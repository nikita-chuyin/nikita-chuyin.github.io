<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="陈楚吟">


    
    


<meta name="description" content="将学习技术点汇总">
<meta name="keywords" content="write myBlog">
<meta property="og:type" content="website">
<meta property="og:title" content="Nikita">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Nikita">
<meta property="og:description" content="将学习技术点汇总">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nikita">
<meta name="twitter:description" content="将学习技术点汇总">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Nikita" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Nikita</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">陈楚吟</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不负韶华</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">陈楚吟</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">陈楚吟</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不负韶华</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-HTML5和CSS3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/09/HTML5和CSS3/" class="article-date">
      <time datetime="2020-05-09T14:12:59.000Z" itemprop="datePublished">2020-05-09</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/09/HTML5和CSS3/">HTML5和CSS3</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li><p>contentEditable设置为true时，该元素就变成了可编辑的，且该元素可继承。</p>
</li>
<li><p>designMode属性用来指定整个页面是否可编辑。<code>document.designMode=&quot;on&quot;</code></p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-爬虫" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/08/爬虫/" class="article-date">
      <time datetime="2020-05-08T12:22:36.000Z" itemprop="datePublished">2020-05-08</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/08/爬虫/">爬虫</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="爬虫基础"><a href="#爬虫基础" class="headerlink" title="爬虫基础"></a>爬虫基础</h4><p>爬虫就是获取网页并提取和保存信息的自动化程序。</p>
<p>Cookies里面保存了登录的凭证，有了它，只需在下次请求携带Cookies发送请求而不必重新输入用户名和密码。因此在爬虫中，有时候需要登录才能访问页面时，我们一般会直接将登录成功后截取的Cookies放在请求头里面直接请求，而不必重新模拟登录。</p>
<h6 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h6><p>Accept：请求报文域，用于指定客户端可接受哪些类型的信息。</p>
<p>Accept-Language：指定客户端可接受的语言类型。</p>
<p>Accept-Encoding：指定客户端可接受的内容编码。</p>
<p>Host：用于指定请求资源的主机IP和端口号，其内容为请求URL的原始服务器或网关的位置。从HTTP1.1版本开始，请求必须包含此内容。</p>
<p>Cookie：也常用复数形式Cookies，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前会话。如：我们输入用户名和密码成功登陆到某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登陆状态，这就是Cookies的功劳。Cookies里面有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上Cookies并将其发送给服务器，服务器通过Cookies识别出是我们自己，并且查出当前状态是登录状态，所以返回的是登陆后才能看到的网页内容。</p>
<p>Referer：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并作相应的处理，如来源统计，防盗链处理等。</p>
<p>User-Agent：简称UA，它是一个特殊的字符串头，可以是服务器识别客户使用的操作系统和版本，浏览器及版本等信息。在做爬虫的时候加上此信息可以伪装为浏览器；如果不加，很可能会被识别为爬虫。</p>
<p>Content-Type：也叫互联网媒体类型或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。如：text/html表示HTML格式，image/gif表示GIF图片，application/json表示JSON类型。</p>
<table>
<thead>
<tr>
<th>Content-Type</th>
<th>提交数据的方式</th>
</tr>
</thead>
<tbody><tr>
<td>application/x-www-form-urlencoded</td>
<td>表单数据</td>
</tr>
<tr>
<td>multipart/form-data</td>
<td>表单文件上传</td>
</tr>
<tr>
<td>application/data</td>
<td>序列化JSON数据</td>
</tr>
<tr>
<td>text/xml</td>
<td>XML数据</td>
</tr>
</tbody></table>
<p>在爬虫中，若要构造POST请求，需要使用正确的Content-Type，并了解各种请求库的各个参数设置时使用的是哪种Content-Type，不然可能导致POST提交后无法正常响应。</p>
<p>请求头是请求的重要组成部分，再写爬虫时大部分情况下都需要设定请求头。</p>
<h6 id="请求主体"><a href="#请求主体" class="headerlink" title="请求主体"></a>请求主体</h6><p>请求体一般承载的内容是POST请求中的表单数据，而对于GET请求，请求体则为空。</p>
<p>响应三部分：响应状态码，响应头，响应体。</p>
<h6 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h6><p>Date：标识响应产生的时间。</p>
<p>Last-Modified：指定资源的最后修改时间。</p>
<p>Content-Encoding：指定响应内容的编码。</p>
<p>Server：包含服务器的信息，比如名称和版本号等。</p>
<p>Content-Type：文档类型，指定返回的数据类型是什么，如text/html代表返回的是HTML文档，application/x-javascript则代表返回JavaScript文件，image/jpeg则代表返回图片。</p>
<p>Set-Cookie：设置Cookies，响应头中的Set-Cookie告诉浏览器需要将此内容放在Cookies中，下次请求携带Cookies请求。</p>
<p>Expires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。</p>
<h6 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h6><p>响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的        HTML代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体。</p>
<h6 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h6><p>在Web中，会话对象用来存储特定用户会话所需的属性及配置信息，这样，当用户在应用程序的Web页之间跳转时，存储在会话对象中的变量将不会丢失，而是在整个用户会话中一直村下去。当用户请求来自应用程序的Web页时，如果该用户还没有会话，则Web服务器将自动创建一个会话对象。当会话过期或放弃后，服务器将终止该会话。</p>
<p><strong>会话维持</strong></p>
<p>当客户端第一次请求服务器时，服务器会返回一个请求头中带有Set-Cookie字段的响应给客户端，用来标记是哪一个用户，客户端浏览器就会把此Cookies放到请求头一起提交给服务器，Cookies携带了会话ID信息，服务器检查该Cookies即可找到对应的会话是什么，然后再判断会话来以此来辨认用户状态。</p>
<p>在成功登录某个网站时，服务器就会告诉客户端设置哪些Cookies信息，在后续访问页面时客户端会把Cookies发送给服务器，服务器再找到对应的会话加以判断。如果会话中某些设置登录状态的变量是有效的，那就证明用户处于登录状态，此时返回登陆之后才可以查看的网页内容，浏览器解析便可以看到了。</p>
<p>反之，如果传给服务器的Cookies是无效的，或者会话已经过期了，我们将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录页面重新登陆。</p>
<p>所以，Cookies和会话需要配合，一个处于客户端，一个处于服务端，两者共同协作就实现会话控制。</p>
<h6 id="会话Cookie与持久Cookie"><a href="#会话Cookie与持久Cookie" class="headerlink" title="会话Cookie与持久Cookie"></a>会话Cookie与持久Cookie</h6><p>从表面意思来说，会话Cookie就是把Cookie放在浏览器内存中，浏览器在关闭之后该Cookie即失效；持久Cookie则会保存到客户端的硬盘中，方便下一次使用，用于长久保持用户登录状态。</p>
<p>因此一些持久化登陆的网站其实就是把Cookie的有效时间和会话有效期设置得较长，下次我们再访问页面时仍然携带之前的Cookie，就可以直接保持登录状态。</p>
<h6 id="会话误区"><a href="#会话误区" class="headerlink" title="会话误区"></a>会话误区</h6><p>在谈论会话机制时，人们认为“只要关闭浏览器，会话就会消失”。可以想象一下会员卡的例子除非顾客主动对店家提出销卡，否则店家绝不会轻易删除顾客的资料。对会话来说，也是一样，除非程序通知服务器删除一个会话，否则服务器会一直保留。比如，程序一般都是在我们做注销操作时才去删除会话。</p>
<p>但是当我们关闭浏览器时，浏览器不会主动在关闭之前通知服务器他将关闭，所以服务器根本不会有机会知道浏览器已经关闭。之所以会有这种错觉是因为大部分会话机制都使用会话Cookie来保存会话ID信息，而关闭浏览器后Cookies就消失了，再次连接服务器时，也就无法找到原来的会话了。如果服务器设置的Cookies保存到硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的Cookies发送给服务器，则再次打开浏览器能找到原来的会话ID，依旧还是可以保持登录状态的。</p>
<p>而恰恰是由于关闭浏览器不会导致会话被删除，这就需要服务器为会话设置一个失效的时间，当距离客户端上一次使用会话的时间时，服务器就可以认为客户端已经停止了活动，才会把会话删除以节省存储空间。</p>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><h6 id="代理的基本原理"><a href="#代理的基本原理" class="headerlink" title="代理的基本原理"></a>代理的基本原理</h6><p>我们在做爬虫时经常会遇到这种情况，最初爬虫正常运行，但过一会就报403Forbidden错误，可能会看到“您的IP访问频率太高”这样的提示，原因是网站采取了反爬虫措施。比如，服务器会检测某个IP在单位时间内的请求次数，如果超过了这个阈值就会直接拒绝服务，返回一些错误信息，这种情况称为封IP。这时就可以采用代理来实现IP伪装。</p>
<p>代理实际是代理服务器，proxy server，功能是代理网络用户去取得网络信息，形象地说是网络信息的中转站，在我们正常请求一个网站时，是发送了请求给Web服务器，WEb服务器把响应传回给我们。如果设置了代理服务器，实际上就是在本机和服务器之间架一座桥，此时本机不是直接向Web服务器发起请求，而是向代理服务器发起请求，请求会发送给代理服务器，然后由代理服务器再发送给Web服务器，接着由代理服务器再把Web服务器返回的响应转发给本机，这样就可正常访问网页了，但这个过程中Web服务器识别出的真实IP就不再是我们本机的IP了，就成功实现了IP伪装，这就是代理的原理。</p>
<p><strong>使用代理隐藏真实的IP，让服务器误以为是代理服务器在请求自己，这样在爬取过程中不断更换代理就不会被封锁，可达到很好的效果</strong>。</p>
<h6 id="代理作用："><a href="#代理作用：" class="headerlink" title="代理作用："></a>代理作用：</h6><ol>
<li><p>突破自身限制，访问一些平时不能访问的站点。</p>
</li>
<li><p>访问一些单位或团体内部资源：比如使用教育网内地址段访问免费代理服务器，就可以实现对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。</p>
</li>
<li><p>提高访问速度：通常代理服务器都设置了一个较大的硬盘缓存区，当有外界的信息通过时，同时也将其保存到缓存区中，当其他用户再访问相同的信息时，则直接由缓存区中取出信息，传给用户，以提高访问速度。</p>
</li>
<li><p>隐藏真实的IP:上网者也可以通过这种方法隐藏自己的IP免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身IP，防止自身的IP被封锁。</p>
</li>
</ol>
<h6 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h6><ol>
<li><p>根据协议区分：</p>
<p>FTP 代理服务器： 主要用于访问 TP 服务器， 般有上传 下载以及 存功能，端口一般为21 212</p>
<p>HTTP 代理服务器： 主要用于访问网页，一般有内容过滤和缓存功能，端口 般为 80  8080 3128</p>
<p>SSL LS 代理： 主要用于访问加密网站， 般有 SSL TLS 加密功能（最高支持 128 位加密强度），端口一般为 443</p>
<p>RTSP 代理： 主要用于访问 Real 流媒体服务器， 般有缓存功能，端口 般为 554</p>
<p>Telnet 代理： 主要用于 telnet 远程控制（黑客人侵计算机时常用于隐藏身份），端口 般为 23</p>
<p>POP3/SMTP 代理： 主要用于 POP3 SMTP 方式收发邮件， 般有缓存功能，端口 般为 110 25</p>
<p>SOCKS 代理： 只是单纯传递数据包，不关心具体协议和用法，所以速度快很 般有存功能，端口一般为 1080  SOCKS 代理协议又分为 SOCKS4 SOCKS5 ，前者只支持 TCP,而后者支持 TC UDP ，还支持各种身份验证机制、服务器端域名解析 简单来说，SOCKS4 能做到的 SOCKS5 都可以做到，但 SOCKS5 能做到的 SOCKS4 定能做到</p>
</li>
<li><p>根据匿名程度区分</p>
<p>高度匿名代理： 会将数据包原封不动地转发，在服务端看来就好像真的是 个普通客户端访问，而记录的 IP 是代理服务器的 IP</p>
<p>普通匿名代理： 会在数据包上做一些改动 服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实 代理服务器通常会加入的 Hπ？头有 HTTP VIA HTTP X FOR DED FOR</p>
<p>透明代理： 不但改动了数据包 还会告诉服务器客户端的真实 IP 这种代理除了能用缓存技术提高浏览速度，能用内容过滤提高安全性之外，并无其他显著作用，最常见的例子是内网的硬件防火墙</p>
<p>间谍代理： 指组织或个人创建的用于记录用户传输的数据，然后进行研究 监控 目的的代理服务器。</p>
</li>
</ol>
<h4 id="基本库"><a href="#基本库" class="headerlink" title="基本库"></a>基本库</h4><h6 id="使用urllib"><a href="#使用urllib" class="headerlink" title="使用urllib"></a>使用urllib</h6><p>urllib库是Python内置的HTTP请求库，不需安装即可使用。包含4个模块：</p>
<ol>
<li>request：它是最基本的 HTTP 请求模块，可以用来模拟发送请求 就像在浏览器里输入网址然后回车一样，只需要给库方法传入 RL 及额外的 数，就可以模拟实现这个过程了</li>
<li>error 异常处理模块，如果出现请求错误 可以捕获这些异常，然后进行重试或作以保证程序不会意外终止</li>
<li>parse 个工具模块，提供了许多 URL 处理方法，比如拆分、解析 合并</li>
<li>robot parser ：主要是用来识别网站的 robots.txt 文件，然后判断哪些网站可以爬，它其实用得 较少。</li>
</ol>
<h6 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h6><p>使用urllib的request模块方便实现请求的发送并得到响应。利用它可模拟浏览器的一个请求发起过程，同时他还带有处理授权验证（authentication），重定向（redirection），浏览器的Cookies以及其他内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">response = urllib.request.urlopen(<span class="string">'https://www.python.org'</span>)</span><br><span class="line">print(response);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>利用最基本的<code>urllib.request.urlopen(url,data=None,[timeout,]*,cafile=None,capath=None,cadefault-False,context=None)</code>方法，可以完成最基本的简单网页的GET请求抓取。</p>
</li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">urllib</span>.<span class="title">request</span>.<span class="title">Request</span><span class="params">(url,data=None,headers=&#123;&#125;,origin_req_host=None,unveriable,method=Node)</span></span></span><br></pre></td></tr></table></figure>

<p>url为必传参数，data要传时必须传bytes（字节流）类型，若为字典，可用<code>urllib.parse</code>模块的<code>urlencode()</code>编码。</p>
<p>headers是一个字典，它是一个请求头，我们可以在构造函数请求时通过headers参数直接构造，也可以通过调用请求实例的add_header()方法添加。添加请求头最常用的方法就是通过修改User-Agent来伪装浏览器，默认的User-Agent是Python-urllib，我们可以通过修改它来伪装浏览器。比如伪装成火狐浏览器，可将它设置为：<code>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:76.0) Gecko/20100101 Firefox/76.0</code>。</p>
<p>origin_req_host指的是请求方的host名称或者IP地址。</p>
<p>unverifiable表示这个请求是否是无法通过验证的，默认是False，意思是说用户没有足够的权限来选择接受这个请求的结果。如：我们请求一个HTML文档中的图片，但是我们没有自动抓取图像的权限，这是unverifiable的值就是true。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,parse</span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:76.0) Gecko/20100101 Firefox/76.0'</span>,</span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'httpbin.org'</span></span><br><span class="line">&#125;</span><br><span class="line">dict = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Germy'</span></span><br><span class="line">&#125;</span><br><span class="line">data = bytes(parse.urlencode(dict),encoding=<span class="string">'utf8'</span>)</span><br><span class="line">req = request.Request(url=url,data=data,headers=headers,method=<span class="string">'POST'</span>)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(<span class="string">'utf8'</span>))</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-python的学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/07/python的学习/" class="article-date">
      <time datetime="2020-05-07T14:00:45.000Z" itemprop="datePublished">2020-05-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/07/python的学习/">python的学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>rmdir    删除目录</p>
<p>ipconfig      查看IP地址</p>
<p>ping         测试网络连接</p>
<p>python       进入python环境</p>
<p>exit()           退出环境</p>
<p>cd   指定目录</p>
<p>dir   浏览目录</p>
<p>mkdir   创建新的目录</p>
<h6 id="pip包管理命令"><a href="#pip包管理命令" class="headerlink" title="pip包管理命令"></a>pip包管理命令</h6><p>pip list     列出匹配管理的包有哪些</p>
<p>pip install   包名      </p>
<p>pip  install  redis == 3.0.2 </p>
<p>pip   uninstall   包名        卸载</p>
<p>pip  -v       查看版本</p>
<p>pip  freeze &gt;  requirements.txt       将项目依赖的包输出到指定的requirements.txt中</p>
<p>pip  install   -r   requirements.txt     使用pip安装requirements.txt中依赖的文件，其中<code>-r</code>指requirements.txt文件</p>
<h6 id="安装requests"><a href="#安装requests" class="headerlink" title="安装requests"></a>安装requests</h6><p>requests是第三方库，python默认不会自带这个库。</p>
<ol>
<li>git clone https ://github.com/kennethreitz/requests</li>
<li>cd  requests</li>
<li>python  setup.py  install</li>
</ol>
<h6 id="安装Selenium"><a href="#安装Selenium" class="headerlink" title="安装Selenium"></a>安装Selenium</h6><p>Selenium是一个自动化测试工具，利用它我们可以驱动浏览器执行特定的动作，如点击，下拉等操作。对于一些js渲染的页面来说，这种抓取方式很有效。</p>
<h6 id="print"><a href="#print" class="headerlink" title="print"></a>print</h6><p>print(value, …, sep=’  ‘，end=’\n’, file=sys.stdout, flush=False)        </p>
<p>sep默认的分隔符是空格</p>
<h4 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h4><h6 id="数与表达式"><a href="#数与表达式" class="headerlink" title="数与表达式"></a>数与表达式</h6><p>乘方运算符的优先级比求负（单目减）高，因此<code>-3**2等价于-（3**2)</code>。如果要计算的是<code>(-3)**2</code>,必须明确指出。</p>
<p>十六进制：0xAF</p>
<p>八进制：010</p>
<p>二进制：0b101011</p>
<p>2 / 4          # 除法，得到一个浮点数</p>
<p>2 // 4          # 除法，得到一个整数</p>
<p>2 ** 5            # 乘方   32</p>
<p>用a + bj,或者complex(a,b)表示复数。</p>
<p><strong>注意</strong></p>
<p>1、Python可以同时为多个变量赋值，如a, b = 1, 2。</p>
<p>2、一个变量可以通过赋值指向不同类型的对象。</p>
<p>3、数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。</p>
<p>4、在混合计算时，Python会把整型转换成为浮点数。</p>
<h6 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h6><ul>
<li>Number数字</li>
<li>String字符串</li>
<li>List列表</li>
<li>Tuple元组</li>
<li>Set集合</li>
<li>Dictionary字典</li>
</ul>
<p>有四种数字类型</p>
<ol>
<li>int整数</li>
<li>bool布尔</li>
<li>float浮点数</li>
<li>complex复数</li>
</ol>
<p><strong>判断类型</strong></p>
<p>type（a） ：判断a的数据类型，不会认为子类是一种父类类型。</p>
<p>isinstance（a,int）：判断a是否为int类型，会认为子类是一种父类类型。</p>
<p>del  val_a, var_b      删除单个或多个对象。</p>
<h6 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h6><p>str=’Runoob’  print(str)                 # 输出字符串 </p>
<p>print(str[0:-1])           # 输出第一个到倒数第二个的所有字符 </p>
<p>print(str[0])              # 输出字符串第一个字符 </p>
<p>print(str[2:5])            # 输出从第三个开始到第五个的字符 </p>
<p>print(str[2:])             # 输出从第三个开始后的所有字符 </p>
<p>print(str * 2)             # 输出字符串两次 </p>
<p>print(str + ‘你好’)        # 连接字符串</p>
<p>print(‘hello\nrunoob’)      # 使用反斜杠()+n转义特殊字符 </p>
<p>print(r’hello\nrunoob’)     # 在字符串前面添加一个 r，表示原始字符串，不会发生转义</p>
<p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 <strong>end=””</strong></p>
<p>print(x)    # 换行输出</p>
<p>print(x,end=” “)        # 不换行输出</p>
<h6 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h6><p>import somemodule         导入整个模块</p>
<p>from somemodule import firstfunc, secondfunc, thirdfunc        从某个模块中导入多个函数</p>
<h6 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h6><p>不可用作任何标识符名称。Python的标准库提供了一个keyword模块，可输出当前版本的所有关键字。</p>
<h6 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h6><p>单行以<code>#</code>开头，多行用三个单或双引号包裹。</p>
<h4 id="urllib库"><a href="#urllib库" class="headerlink" title="urllib库"></a>urllib库</h4><p>python内置的HTTP请求库</p>
<h6 id="request解析库"><a href="#request解析库" class="headerlink" title="request解析库"></a>request解析库</h6><p>urlopen：打开网址</p>
<h6 id="bs4解析库"><a href="#bs4解析库" class="headerlink" title="bs4解析库"></a>bs4解析库</h6><p>bs4: BeautifulSoup</p>
<p>用于解析网页，提取指定数据的。接口简单，较人性化，但bs4只能解析html格式的数据。</p>
<p><strong>BeautifulSoup类</strong></p>
<p>文件解析库：</p>
<p>‘html.parser’：是python自带的一个文件解析库。</p>
<p>‘lxml’：是一个第三方文件解析库，需安装。</p>
<p>根据html标签查找信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content = soup.find(&apos;div&apos;,itemprop=&apos;acticleBody&apos;).text</span><br></pre></td></tr></table></figure>

<p><strong>find()</strong> <strong>方法：返回第一个匹配的内容，为字符串类型</strong></p>
<p>find(name,attrs,recursive,text,**kwargs)</p>
<p>这五个参数都可以<strong>充当过滤器</strong>，提高匹配结果的精确度。</p>
<p><strong>find_all()</strong> <strong>方法：返回所有匹配的项，为一个列表类型</strong></p>
<p>find(name,attrs,recursive, text,<strong>limit</strong>,**kwargs)</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h6 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip install MyQR</span><br><span class="line"></span><br><span class="line">from MyQR Simport myqr</span><br><span class="line">words:  文本，链接地址或字符串</span><br><span class="line">picture：二维码的背景图片</span><br><span class="line">colorized：True，表示生成彩图</span><br><span class="line">save_name: 表示生成的二维码的名字</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from MyQR import myqr</span><br><span class="line">myqr.run(</span><br><span class="line">    words=&quot;https://www.icourse163.org/learn/NHDX-1449955168&quot;,</span><br><span class="line">    picture=&quot;1.png&quot;,</span><br><span class="line">    colorized=True,</span><br><span class="line">    save_name=&quot;ORMooc.png&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h6 id="个人名片"><a href="#个人名片" class="headerlink" title="个人名片"></a>个人名片</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pip install Segno</span><br><span class="line"></span><br><span class="line">from segno import helpers</span><br><span class="line">qr = helpers.make_mecard(</span><br><span class="line">    name=&apos;Erin&apos;,</span><br><span class="line">    city=&apos;湖南省衡阳市南华大学&apos;,</span><br><span class="line">    phone=&apos;1581529632&apos;,</span><br><span class="line">    email=&apos;3511564414@qq.com&apos;</span><br><span class="line">)</span><br><span class="line">qr.save(&apos;Erin名片.png&apos;,scale=10)</span><br></pre></td></tr></table></figure>

<h6 id="爬取小说"><a href="#爬取小说" class="headerlink" title="爬取小说"></a>爬取小说</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(&apos;http://www.39shubao.com/&apos;)</span><br><span class="line">print(response.read().decode(&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure>

<p><strong>报错</strong>：<code>UnicodeDecodeError: &#39;utf-8&#39; codec can&#39;t decode byte 0x8b in position 1: invalid start byte</code></p>
<p>所以去掉解码格式utf-8，<strong>输出的字节码可以看到它是以”b’\x1f\x8b\x08”开头的 ，说明它是gzip压缩过的数据，这也是报错的原因，所以我们需要对我们接收的字节码进行一个解码操作。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line">from io import BytesIO</span><br><span class="line">import gzip</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(&apos;http://www.39shubao.com/&apos;)</span><br><span class="line">buff = BytesIO(response.read())</span><br><span class="line">f = gzip.GzipFile(fileobj=buff)</span><br><span class="line">htmls = f.read().decode(&apos;utf-8&apos;)</span><br><span class="line">print(htmls)</span><br></pre></td></tr></table></figure>

<p><strong>解决乱码问题</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">'http://www.shuquge.com/txt/63542/9645082.html'</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>

<p>通过response.text拿到的数据出现乱码是因为该网页对数据进行加密，所以直接拿到的数据乱码了。</p>
<p>解决：</p>
<p>方法一：使用较老的方法<code>response.encoding=&#39;utf-8&#39;</code>，只能解决utf-8的乱码，其他格式的不能解决。</p>
<p>方法二：<code>response.encoding=response.apparent_encoding</code>，自动解决乱码格式，不仅utf-8格式的可解决，gbk格式的也可解决。</p>
<p>未封装的爬一章小说</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"># 使用parsel来解析网页内容</span><br><span class="line">import parsel</span><br><span class="line">url = &apos;http://www.shuquge.com/txt/63542/9645082.html&apos;</span><br><span class="line">response = requests.get(url)</span><br><span class="line"># 自动解决乱码问题</span><br><span class="line">response.encoding = response.apparent_encoding</span><br><span class="line"># print(response.text)</span><br><span class="line"># 把网页数据结构化</span><br><span class="line">sel = parsel.Selector(response.text)</span><br><span class="line"># 根据css选择器提取标题</span><br><span class="line">title = sel.css(&apos;.content &gt; h1::text&apos;).get()</span><br><span class="line"># 根据css路径提取内容</span><br><span class="line">content = sel.css(&apos;#content::text&apos;).getall()</span><br><span class="line"># 根据xPath提取内容,getall是提取全部的内容，也有re方法，用于匹配正则里面的内容</span><br><span class="line"># print(sel.xpath(&apos;//div[@id=&quot;content&quot;]/text()&apos;).getall())</span><br><span class="line"># 保存数据</span><br><span class="line">with open(title + &apos;.txt&apos;,mode=&apos;w&apos;, encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">    f.write(title)</span><br><span class="line">    # 用切片去掉最后三行</span><br><span class="line">    for con in content[:-3]:</span><br><span class="line">        # str使用replace去除空格</span><br><span class="line">        f.write(con.replace(&apos;\xa0&apos;,&apos;&apos;))</span><br><span class="line">        # f.write(con.strip(&apos;\xa0&apos;))</span><br></pre></td></tr></table></figure>

<h6 id="动态爬取数据"><a href="#动态爬取数据" class="headerlink" title="动态爬取数据"></a>动态爬取数据</h6><p>数据信息不是存放在网页源代码中，它是一个动态更新的网站，需要实时更新的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">url = &apos;https://api.inews.qq.com/newsqa/v1/automation/foreign/country/ranklist&apos;</span><br><span class="line">response = requests.get(url)</span><br><span class="line">content = json.loads(response.text)</span><br><span class="line">print(content[&apos;data&apos;])</span><br><span class="line">df = pd.DataFrame(columns=[&apos;国家及地区&apos;,&apos;确诊人数&apos;,&apos;死亡病例&apos;,&apos;治愈病例&apos;])</span><br><span class="line">for i in range(len(content[&apos;data&apos;])):</span><br><span class="line">    df.loc[i + 1] = [content[&apos;data&apos;][i][&apos;name&apos;],</span><br><span class="line">                     content[&apos;data&apos;][i][&apos;confirm&apos;],</span><br><span class="line">                     content[&apos;data&apos;][i][&apos;dead&apos;],</span><br><span class="line">                     content[&apos;data&apos;][i][&apos;heal&apos;]]</span><br><span class="line">df.to_csv(&apos;F://data.csv&apos;,index=0,encoding=&apos;utf-8&apos;)</span><br><span class="line">print(&apos;爬取完成&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-AJAX学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/30/AJAX学习/" class="article-date">
      <time datetime="2020-04-30T03:04:57.000Z" itemprop="datePublished">2020-04-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/30/AJAX学习/">AJAX学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><h6 id="传统网站存在的问题"><a href="#传统网站存在的问题" class="headerlink" title="传统网站存在的问题"></a>传统网站存在的问题</h6><ol>
<li>网速慢的情况下，页面加载时间长，用户只能等待。</li>
<li>表单提交后，如果一项内容不合格，需要重新填写所有表单内容。</li>
<li>页面跳转，重新加载页面，造成资源浪费，增加用户等待时间。</li>
</ol>
<h6 id="Ajax概述"><a href="#Ajax概述" class="headerlink" title="Ajax概述"></a>Ajax概述</h6><p>它是浏览器提供的一套方法，可以实现页面无刷新更新数据，提高用户浏览网站应用的体验。</p>
<h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><ol>
<li>页面上拉加载更多数据，当下拉到底部并点击加载更多时才会向服务器发起请求并响应给用户。</li>
<li>列表数据无刷新分页，当从第一页切换到第二页时，只有列表中的数据才会变，头部和底部是不会发生变化的。</li>
<li>表单项离开焦点数据验证，当用户输入数据且该表单项失去焦点后，网页会自动将数据传给服务器进行验证，若已有该记录提示给用户。</li>
<li>搜索框提示文字下拉列表。</li>
</ol>
<h6 id="AJAX优缺点"><a href="#AJAX优缺点" class="headerlink" title="AJAX优缺点"></a>AJAX优缺点</h6><p>浏览器可以从服务器同时请求多项内容，利用异步请求可以确保浏览器在后台工作，避免因完全页面刷新而中断用户的工作。</p>
<p>浏览器请求返回的速度会快得多，只是在有些情况下如此而已，请求和响应的速度取决于服务器返回的内容。AJAX页面完全有可能比传统页面的速度更慢。</p>
<p>不能够更真实的渲染颜色，因为颜色渲染由用户监视器控制而不是由用户支配。</p>
<p>只有页面真正改变部分会得到更新。</p>
<p>会减少服务器数据流量，利用AJAX可以建立更小更集中的请求。不过要当心……这也很容易导致建立更多的请求以至于增大数据流量，因为可能要一部建立所有这些请求。</p>
<p>页面的不兼容问题会更严重，由于除了XHTML外，AJAX页面还依赖于其它一些技术，所以使用AJAX后的兼容性问题实际会更严重。</p>
<h6 id="Ajax运行原理及实现"><a href="#Ajax运行原理及实现" class="headerlink" title="Ajax运行原理及实现"></a>Ajax运行原理及实现</h6><p><strong>原理</strong></p>
<p>Ajax相当于浏览器发送请求与接收响应的代理人以实现在不影响用户浏览页面的情况下，局部更新数据，从而提高用户体验。</p>
<p><strong>Ajax实现步骤</strong></p>
<ol>
<li><p>创建Ajax对象</p>
<p><code>var xhr = new XMLHttpRequest();</code></p>
</li>
<li><p>告诉Ajax请求地址以及请求方式</p>
<p><code>xhr.open(&#39;get&#39;,&#39;http://www.example.com&#39;)</code></p>
</li>
<li><p>发送请求</p>
<p><code>xhr.send();</code></p>
</li>
<li><p>获取服务器端给与客户端的响应数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.onload = function()&#123;</span><br><span class="line">	console.log(xhr.responseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>为避免ajax跨域请求，故用express开启一个后端服务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js文件</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用app.use拦截了所有请求，将请求交给express.static处理</span></span><br><span class="line"><span class="comment">// 也就是当网页请求该服务器时，请求全部转向public文件夹进行访问。</span></span><br><span class="line">app.use(express.static(path.join(__dirname,<span class="string">'public'</span>)));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/first'</span>, (req,res) =&gt; &#123;</span><br><span class="line">    res.send(<span class="string">'hello ajax'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'服务器启动成功'</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public/index.html文件</span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">        xhr.open(<span class="string">'GET'</span>,<span class="string">'http://localhost:3000/first'</span>);</span></span><br><span class="line">        xhr.send();</span><br><span class="line"><span class="javascript">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(xhr.responseText);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>服务器端相应的数据格式</strong></p>
<p>在真实的项目中，服务器端大多数情况下会以JSON对象作为响应数据的格式。</p>
<p>在http请求与响应过程中，无论是请求参数还是响应内容，如果是对象类型最终都会被转换为对象字符串进行传输。</p>
<p><code>JSON.parse()   //将json字符串转换为json对象</code></p>
<p><strong>请求参数传递</strong></p>
<p>传统网站表单提交</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"get"</span> <span class="attr">action</span>=<span class="string">"http://www.example.com"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- http://www.example.com?username=zhangsan&amp;passwor=123456 --&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Ajax中的get请求</strong></p>
<p><code>xhr.open(&#39;GET&#39;,&#39;http://www.example.com?name=zhangsan&amp;age=20&#39;);</code></p>
<p><strong>post请求</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.setResquestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;)</span><br><span class="line">xhr.send(&apos;name=zhangsan&amp;age=20&apos;);</span><br></pre></td></tr></table></figure>

<p>application/json</p>
<p>{name:’zhangsan’ , age: ‘20’ ,  sex: ‘男 ‘}</p>
<p>在请求头中指定Content-Type属性的值是application/json，告诉服务器当前请求参数的格式是json。</p>
<p><code>JSON.stringify()</code>    // 将json对象转换为json字符串</p>
<h6 id="Ajax状态码"><a href="#Ajax状态码" class="headerlink" title="Ajax状态码"></a>Ajax状态码</h6><p>在创建ajax对象，配置ajax对象，发送请求以及接受完服务器端响应数据，这个过程中的每一个步骤都会对应一个数值，这个数值就是ajax状态码。</p>
<p>0：请求未初始化，还没调用open（）</p>
<p>1：请求已经建立，但是还没有发送（还没调用send（））</p>
<p>2：请求已经发送</p>
<p>3：请求正在处理中，通常响应中已经有部分数据可以用了。</p>
<p>4：响应已经完成，可以获取并使用服务器的响应了。</p>
<p><code>xhr.readyState    //获取ajax状态码</code></p>
<p><code>onreadystatechange事件</code>，当ajax状态码发生变化时将自动触发该事件。不过推荐使用<code>xhr.onload</code>方法。</p>
<h6 id="Ajax错误处理"><a href="#Ajax错误处理" class="headerlink" title="Ajax错误处理"></a>Ajax错误处理</h6><ol>
<li><p>网络畅通，服务端能接收到请求，服务器返回的结果不是预期的结果。</p>
<p>可以判断服务器端返回的状态码，分别进行处理。xhr.status获取http状态码。</p>
</li>
<li><p>网络畅通，服务器没有接收到请求，返回404状态码。</p>
<p>检查请求地址是否错误。</p>
</li>
<li><p>网络畅通，服务器端能接受收到请求，服务器端返回500状态码。</p>
<p>服务器端错误，找后端程序员进行沟通。</p>
</li>
<li><p>网络中断，请求无法发送到服务器端。（模拟断网，可在浏览器中的network中将offline勾选即可）</p>
<p>会触发xhr对象下面的onerror事件，但不会会触发onload事件，在onerror事件处理函数中对错误进行处理。</p>
</li>
</ol>
<h6 id="封装Ajax函数"><a href="#封装Ajax函数" class="headerlink" title="封装Ajax函数"></a>封装Ajax函数</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 存储的是默认值</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">default</span> = &#123;</span><br><span class="line">        type: <span class="string">'get'</span>,</span><br><span class="line">        url: <span class="string">''</span>,</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        header: &#123;</span><br><span class="line">            <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">                 </span><br><span class="line">&#125;;</span><br><span class="line">	<span class="comment">// 使用options对象中的属性覆盖default对象中的属性</span></span><br><span class="line">	<span class="built_in">Object</span>.assign(<span class="keyword">default</span>,options);</span><br><span class="line">	<span class="comment">// 创建ajax对象</span></span><br><span class="line">	<span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="comment">// 拼接请求参数的变量</span></span><br><span class="line">    <span class="keyword">var</span> params = <span class="string">''</span>;</span><br><span class="line">    <span class="comment">// 循环用户传递进来的对象格式参数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> <span class="keyword">default</span>.data)&#123;</span><br><span class="line">        <span class="comment">// 将参数转换为字符串</span></span><br><span class="line">        params += attr + <span class="string">'='</span> + <span class="keyword">default</span>.data[attr] + <span class="string">'&amp;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将参数最后的&amp;截取掉</span></span><br><span class="line">    <span class="comment">// 将截取的结果重新赋值给params变量</span></span><br><span class="line">    params = params.substr(<span class="number">0</span>,params.length - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断请求方式</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">default</span>.type == <span class="string">'get'</span>)&#123;</span><br><span class="line">        <span class="keyword">default</span>.url = <span class="keyword">default</span>.url + <span class="string">'?'</span> + params;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 配置ajax对象</span></span><br><span class="line">	xhr.open(<span class="keyword">default</span>.type,<span class="keyword">default</span>.url);</span><br><span class="line">    <span class="comment">// 如果是post请求</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">default</span>.type == <span class="string">'post'</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> contentType = <span class="keyword">default</span>.header[<span class="string">'Content-Type'</span>];</span><br><span class="line">          <span class="comment">// 设置请求参数格式的类型</span></span><br><span class="line">        xhr.setRequestHeader(<span class="string">'Content-Type'</span>,contentType);</span><br><span class="line">        <span class="keyword">if</span>(contentType == <span class="string">'application/json'</span>)&#123;</span><br><span class="line">            xhr.send(<span class="built_in">JSON</span>.stringify(<span class="keyword">default</span>.data))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            xhr.send(params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 监听xhr对象上的onload事件</span></span><br><span class="line">	<span class="comment">// 当xhr对象接收完响应数据后触发</span></span><br><span class="line">	xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 获取响应头中的数据</span></span><br><span class="line">        <span class="keyword">var</span> contentType = xhr.getResponseHeader(<span class="string">'Content-Type'</span>);</span><br><span class="line">        <span class="comment">// 服务器端返回的数据</span></span><br><span class="line">        <span class="keyword">var</span> responseText = xhr.responseText;</span><br><span class="line">        <span class="comment">// 如果响应类型中包含application/json</span></span><br><span class="line">        <span class="keyword">if</span>(contentType.includes(<span class="string">'application/json'</span>))&#123;</span><br><span class="line">            responseText = <span class="built_in">JSON</span>.parse(responseText);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">           <span class="keyword">default</span>.success(xhr.responseText,xhr);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">default</span>.error(xhr.responseText,xhr);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(&#123;</span><br><span class="line">	type: <span class="string">'get'</span>,</span><br><span class="line">	url: <span class="string">'http://lcalhost:3000/first'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      name: <span class="string">'zhangsan'</span>,</span><br><span class="line">        age:<span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    header:&#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'json'</span></span><br><span class="line">    &#125;,</span><br><span class="line">	sucess: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(data);</span><br><span class="line">	&#125;,</span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="验证邮箱地址的唯一性"><a href="#验证邮箱地址的唯一性" class="headerlink" title="验证邮箱地址的唯一性"></a>验证邮箱地址的唯一性</h6><ol>
<li>获取文本框并为其添加离开焦点事件</li>
<li>离开焦点时，检测用户输入的邮箱地址是否符合规则。</li>
<li>如果不符合规则，组织程序向下执行并给出提示信息。</li>
<li>向服务端发送请求，检测邮箱地址是否被别人注册。</li>
<li>根据服务端返回值决定客户端显示何种提示信息。</li>
</ol>
<p><strong>常用元字符</strong></p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母或数字或下划线</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的开始或结束</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结束</td>
</tr>
</tbody></table>
<p><strong>常用限定符</strong></p>
<table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody></table>
<p>以此举个例子如邮箱：<a href="mailto:Yuan.Yiuri691@ningmeng.com.cn" target="_blank" rel="noopener">Yuan.Yiuri691@ningmeng.com.cn</a><br> 正则表达式为：<code>^[A-Za-z0-9-._]+@[A-Za-z0-9-]+(\.[A-Za-z0-9]+)\*(\.[A-Za-z]{2,6})$</code></p>
<p>创建过程：</p>
<ol>
<li>开头和结尾：^$;</li>
<li>加入@：^@$;</li>
<li>@前的内容匹配：[A-Za-z0-9-._]  大小写字母，数字,”.”,下划线 随机出现；”+” 号表示当前规则中的字符可以重复；</li>
<li>@后的内容受顶级域名的限制，按点号分割后的规则略有不同：(.[A-Za-z]{2,6}) 必须是字母出现，比如.com，.cn等</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-node进阶" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/30/node进阶/" class="article-date">
      <time datetime="2020-04-30T02:30:22.000Z" itemprop="datePublished">2020-04-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/30/node进阶/">node进阶</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="单线程的弱点"><a href="#单线程的弱点" class="headerlink" title="单线程的弱点"></a>单线程的弱点</h4><ol>
<li>无法利用多核CPU。</li>
<li>错误会引起整个应用退出，应用的健壮性值得考虑。</li>
<li>大量计算占用CPU导致无法继续调用异步I/O。</li>
</ol>
<p>像浏览器中JavaScript与UI共用一个线程一样，JavaScript长时间执行会导致UI渲染和响应被中断。在Node中，长时间的CPU占用也会导致后续异步I/O发不出调用，已完成的异步I/O的回调函数也会得不到及时执行。</p>
<p>Node采用了与Web Workers相同的思路来解决单线程中大计算量的问题：child_process。</p>
<p>子进程的出现，意味着Node可以从容地应对单线程在健壮性和无法利用多核CPU方面的问题。通过计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好的保持应用模型的简单和地低依赖。通过Master-Worker的管理方式，也可以很好地管理各个工作进程，以达到更高的的健壮性。</p>
<h4 id="node简介"><a href="#node简介" class="headerlink" title="node简介"></a>node简介</h4><ul>
<li>Node.js是一个js运行环境，实际上它是对Google v8引擎的封装。V8引擎执行js的速度快，性能好。node.js对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境上运行的更好。</li>
<li>node.js是一个基于chrome javascript运行建立的平台，用于方便的搭建响应速度快，易于拓展的网络应用。node.js使用事件驱动，非阻塞I/O模型得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。</li>
<li>node采用一系列“非阻塞”库来支持事件循环的方式。本质上就是为文件系统，数据库之类的资源提供接口。向文件系统发送一个请求时，无需等待硬盘（寻址并检索文件），硬盘准备好的时候非阻塞接口会通知node。该模型以可拓展的方式简化了对慢资源的访问，直观易懂。</li>
<li>node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理——node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，因此，我们应该要充分的利用这一点——尽可能地避免阻塞操作</li>
</ul>
<h4 id="node-js组成部分"><a href="#node-js组成部分" class="headerlink" title="node.js组成部分"></a>node.js组成部分</h4><ul>
<li>引入required模块：我们可使用required指令载入node.js模块   var http = require(“http”);</li>
<li>创建服务器：服务器可监听客户端请求，类似于Apache，Nginx等http服务器 。使用http.createServer()方法创建服务器，并使用listen方法绑定端口。</li>
<li>接收请求和响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送http请求，服务器接收请求并返回响应数据。使用request和response参数来接收和响应数据。</li>
</ul>
<h4 id="npm包管理器"><a href="#npm包管理器" class="headerlink" title="npm包管理器"></a>npm包管理器</h4><ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用</li>
</ul>
<h4 id="NPM常用命令"><a href="#NPM常用命令" class="headerlink" title="NPM常用命令"></a>NPM常用命令</h4><p>NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。</p>
<ul>
<li><p>NPM提供了很多命令，例如<code>install</code>和<code>publish</code>，使用<code>npm help</code>可查看所有命令。</p>
</li>
<li><p>使用<code>npm help &lt;command&gt;</code>可查看某条命令的详细帮助，例如<code>npm help install</code>。</p>
</li>
<li><p>在<code>package.json</code>所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</p>
</li>
<li><p>使用<code>npm update &lt;package&gt;</code>可以把当前目录下<code>node_modules</code>子目录里边的对应模块更新至最新版本。</p>
</li>
<li><p>使用<code>npm update &lt;package&gt; -g</code>可以把全局安装的对应命令行程序更新至最新版。</p>
</li>
<li><p>使用<code>npm cache clear</code>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</p>
</li>
<li><p>使用<code>npm unpublish &lt;package&gt;@&lt;version&gt;</code>可以撤销发布自己发布过的某个版本代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm -v  						查看版本</span><br><span class="line">npm version  					查看所有模块的版本</span><br><span class="line">npm search 包名/部分包名			 搜索包</span><br><span class="line">npm init   						初始化package.json文件</span><br><span class="line">npm install/i 安装包     </span><br><span class="line">npm remove/r包名					删除包</span><br><span class="line">npm install/i 包名 --save 		安装包并添加到依赖中</span><br><span class="line">npm install 					根据package.json下载当前项目所依赖的包</span><br><span class="line">npm install 包名 -g				全局安装包，用于一些编译根据，比如：gulp，webpack</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>注意：如果想在页面中引入node_module中某个模块，优先从当前目录引入，如果没有，则从上一级目录中找，直到根目录。</li>
</ul>
<h4 id="REPL交互式解释器"><a href="#REPL交互式解释器" class="headerlink" title="REPL交互式解释器"></a>REPL交互式解释器</h4><ul>
<li>REPL(Read Eval Print Loop:交互式解释器)表示一个电脑的环境，类似于终端，可接受系统的响应。node自带了交互式解释器，可执行以下任务<ul>
<li>读取，读取用户输入，解析输入js数据结构并存储于内存中。</li>
<li>执行，执行输入的数据结构。</li>
<li>打印，输出结果。</li>
<li>循环，循环操作以上步骤直到用户两次按下ctrl+c按钮退出。</li>
</ul>
</li>
</ul>
<h4 id="node知识"><a href="#node知识" class="headerlink" title="node知识"></a>node知识</h4><h6 id="node-js与其它语言的区别"><a href="#node-js与其它语言的区别" class="headerlink" title="node.js与其它语言的区别"></a>node.js与其它语言的区别</h6><ul>
<li><p>node.js不是一门独立的语言。php，jsp即使语言，又是平台。node.js用js进行编程，运行平台是封装后的js引擎V8</p>
</li>
<li><p>轻量级架构</p>
<ul>
<li>java，php，net，需要运行在服务器上，apache，tomcat</li>
<li>node.js不用架设在任何服务器软件之上。</li>
<li>用最低的硬件成本，达到更高的开发，更优的处理函数。</li>
</ul>
</li>
<li><p>node.js没有web容器，就是安装配置完成之后，没有根目录（php的根目录是www）</p>
</li>
</ul>
<h6 id="node-js的特点（追求极致性能）"><a href="#node-js的特点（追求极致性能）" class="headerlink" title="node.js的特点（追求极致性能）"></a>node.js的特点（追求极致性能）</h6><ul>
<li>单线程<ul>
<li>优势：减少内存消耗（操作系统不再有创建线程，销毁线程的开销。<ul>
<li>在php，jsp等服务器语言中，会为每个用户创建一个线程，而每个线程大约需要2M内存，每创建一个线程就要占用内存空间。</li>
<li>当有客户链接时，就会触发一个内部事件，通过非阻塞I/O，事件驱动机制，让node.js宏观上是并发的。可同时处理4万用户的请求。即当张三连接着时，李四请求连接，引擎就会停止张三语法的执行，转而将李四加入到时间栈中。</li>
<li>node.js不为每个用户创建一个线程，仅仅使用同一个线程。</li>
</ul>
</li>
<li>劣势：<ul>
<li>如果线程遭遇I/O阻塞，整个线程便阻塞了。</li>
<li>如果有人将node.js搞崩溃了，则会全部奔溃。</li>
</ul>
</li>
</ul>
</li>
<li>非阻塞<ul>
<li>node.js采用非阻塞I/O机制，因此在执行完访问数据库操作后，会立即执行后面的代码（其他非阻塞事件不会，他们会等数据库操作完毕并返回结果才执行后面的代码），把数据库的处理代码放入回调函数中，从而提高效率。</li>
<li>当某个I/O执行完毕后，将以事件的形式通过执行I/O操作的线程，线程执行完这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断检查有没有未处理的事件，并依次予以处理。</li>
<li>阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远执行计算操作，这个线程的CPU核心利用率永远是100%；</li>
</ul>
</li>
<li>事件驱动<ul>
<li>不管用户的请求，还是老用户的I/O完成，都将以事件的形式加入事件环，等待调度。</li>
</ul>
</li>
<li>node.js的iI/O都是异步的，都是回调函数调回调函数</li>
</ul>
<h6 id="node事件触发"><a href="#node事件触发" class="headerlink" title="node事件触发"></a>node事件触发</h6><ul>
<li>继承EventEmitter，大多数情况下不会直接使用EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</li>
<li>原因：<ul>
<li>具有某个实体功能的对象实现时间符合语义，事件的监听和发射应该是一个对象的方法。</li>
<li>js对象是基于原型的，支持多重继承，继承EventEmitter不会打乱对象原有的继承关系。</li>
</ul>
</li>
</ul>
<h6 id="node-js应用方向"><a href="#node-js应用方向" class="headerlink" title="node.js应用方向"></a>node.js应用方向</h6><ol>
<li>特点<ul>
<li>善于I/O，不善于计算。<ul>
<li>因为node.js最擅长任务的调度，如果你的任务有很多CPU计算，实际上相当于这个计算阻塞了这个单线程，就不适合node开发。</li>
<li>当应用程序需要处理大量并发的I/O，而在向客户端发出响应后，应用程序内部并不需要进行复杂的处理时，node也非常适合与websocket配合，开发长连接的实时交互应用程序。</li>
</ul>
</li>
<li>天生异步<ul>
<li>callback，trunk（参数的求值策略），promise，generator（es6的生成器，用于计算），asynac函数</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="node模块化"><a href="#node模块化" class="headerlink" title="node模块化"></a>node模块化</h4><ul>
<li>CommonJS规范为JS能够在任何地方执行，这是一个愿景。</li>
<li>从文件角度看，每个JS文件就是一个个模块，从结构上看，多个JS文件之间可以相互require共同实现一个功能，这整体功能就是一个模块。</li>
<li>在node.js中，一个模块定义的变量只能在该文件中使用，当需要另一文件中的变量时，需使用exports进行暴漏，然后使用require引入。</li>
<li>引入模块时，如果是非核心模块，且在同级目录时，require需要加上<code>./</code>，核心模块则不需要，直接写名字即可</li>
</ul>
<h6 id="node核心模块"><a href="#node核心模块" class="headerlink" title="node核心模块"></a>node核心模块</h6><ul>
<li><p>全局变量是global。</p>
</li>
<li><p>每个node都在外面给我们套了一个函数。</p>
<p><code>function(exports,require,module,_filename,_dirname){//里面是你写的内容}</code></p>
<ul>
<li>exports：该对象用来将函数内部的局部函数暴漏到外部函数中。</li>
<li>require：用来引入外部模块。</li>
<li>module：代表当前模块本身，exports就是module的属性。我们可以使用exports或modile.exports导出。</li>
<li>_filename:当前模块的完整路径</li>
<li>_dirname:当前模块所在的文件的完整路径。</li>
</ul>
</li>
<li><p>exports与module.exports的区别</p>
</li>
<li><p>json文件不能加注释。</p>
</li>
</ul>
<h4 id="Buffer缓存区"><a href="#Buffer缓存区" class="headerlink" title="Buffer缓存区"></a>Buffer缓存区</h4><ul>
<li>可以理解为是一个存放二进制的容器，专门用于数据的存放。</li>
<li>node自带的，不需要引入就可使用。一个字节占8bit</li>
<li>8bit = 1B       1024B  = 1KB      1024KB = 1MKB      1GB=1024KB     1TB=1024GB</li>
<li>Buffer.from(str,编码格式);</li>
<li>Buffer.alloc(size[,fill[,encoding]])<ul>
<li>size:新建的Buffer期望的长度，不能动态改变，溢出的数据不做处理。int值</li>
<li>fill：用来预填充新建的Buffer的值，默认为0.     String   Buffer    int</li>
<li>encoding:如果fill为字符串，则该值就是它的字符编码，默认为“utf-8”</li>
</ul>
</li>
</ul>
<h4 id="fs文件处理"><a href="#fs文件处理" class="headerlink" title="fs文件处理"></a>fs文件处理</h4><ul>
<li><p>fs.open(path,flag[,mode],callback)打开文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//1.引入模块</span><br><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">//2.创建写入流，相当于在it666.txt与服务器之间建立一个通道，使数据可以源源不断从it666.txt中上传至服务器中</span><br><span class="line">let ws = fs.createWriteStream(&quot;it666.txt&quot;);</span><br><span class="line">//3.打开通道，监听打开事件，有on，once等方法，因只需监听一次，故用once</span><br><span class="line">stream.once(&apos;open&apos;,() =&gt; &#123;</span><br><span class="line">    console.log(&apos;通道已经打开&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">stream.once(&apos;close&apos;, ()=&gt; &#123;</span><br><span class="line">    console.log(&apos;通道已经关闭&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">//写入东西</span><br><span class="line">stream.write(&apos;dfsadc&apos;);</span><br><span class="line">stream.write(&apos;dfsadc&apos;);</span><br><span class="line">//关闭通道，当发现还有东西未写入时，不会关闭</span><br><span class="line">stream.end()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">let ws = fs.createWriteStream(&quot;it666.txt&quot;);</span><br><span class="line">let rs = fs.createReadStream(&quot;sp.mp4&quot;);</span><br><span class="line">//创建管道，该语句就会自动将数据存入sp.mp4中，同时监听打开关闭等事件</span><br><span class="line">rs.pipe(ws);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul>
<li>数据库就是按照一定的数据结构来组织，存储和管理数据的仓库。</li>
<li>我们写的程序都是在计算机上运行的，一旦计算机断电或程序运行完毕，程序数据就会全部丢失，所以我们需要将一些程序运行的数据持久性保存到硬盘中，以确保数据的安全性。</li>
<li>选择数据库的原因：<ul>
<li>数据库是有结构的，数据与数据之间可以建立各种关系，类似于网状拓扑图。</li>
<li>数据库提供各种接口，让各种操作（增删改查）变得快捷简单。</li>
<li>给个种语言（php，jsp，java）提供了完善的接口。</li>
</ul>
</li>
<li>数据库分类<ul>
<li>RDBMS(关系型数据库)：MySQL，SQL Server，ORACLE,DB2….</li>
<li>NoSQL（非关系型数据库 Not only SQL）:MongoDB,CouchDB,HBase,Redis…<ul>
<li>没有行列的概念，用JSON来存储数据，集合就相当于“表”，文档就相当于“行”。</li>
<li>非关系型数据库为非标准化的数据库。</li>
<li>特征：键值存储数据库，列存储数据库，文档存储数据库，图形数据库。</li>
</ul>
</li>
<li>两者区别：关系型数据库比较结构化，操作不是很灵活；非关系型数据库操作灵活，但不适合大型数据存储，比较适合微架构….两者相辅相成。</li>
</ul>
</li>
</ul>
<h6 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h6><ul>
<li>MongoDB是为快速开发互联网Web应用而设计的数据库系统。他的数据类型是面向文档的，类似于JSON的结构。</li>
<li>基本组成<ul>
<li>数据库（database）：数据库是一个仓库，在仓库中可以存放集合。</li>
<li>集合（collection）：集合类似于数组，在集合中可以存放文档。</li>
<li>文档（document）：文档数据库中的最小单位，我们存储和操作的内容都是文档。</li>
</ul>
</li>
<li>mongoDB的基本指令:<ul>
<li>show dbs    ：显示当前所有的数据库</li>
<li>use 数据库名        ：进入到指定的数据库中</li>
<li>db     ：显示当前数据库</li>
<li>show  collections        ：显示数据库中的所有集合</li>
</ul>
</li>
<li>命令进行CRUD<ul>
<li>插入：db.<collection>.insert(doc);      如：db.student.insert({id:001,name:’nikita’});</collection></li>
<li>查询：db.<collection>.find();</collection></li>
</ul>
</li>
</ul>
<h4 id="同步与异步，阻塞与非阻塞"><a href="#同步与异步，阻塞与非阻塞" class="headerlink" title="同步与异步，阻塞与非阻塞"></a>同步与异步，阻塞与非阻塞</h4><ul>
<li><p>同步，当发起一个调用时，在没有获取结果前，调用不会返回，直到获取结果。事一件一件做，做完一件在做一件。</p>
</li>
<li><p>异步：当发起一个调用时，在没有获取结果之前，调用就返回了，调用者并不会立即得到结果，而是被调用者通知调用调用者，通过回调函数处理结果。</p>
</li>
<li><p>阻塞，在等待结果时，不能干其他事，线程被挂起，直到结果返回。</p>
</li>
<li><p>非阻塞：在等待结果中，还能干其他事，线程不会被阻塞。</p>
</li>
</ul>
<h4 id="url相关操作"><a href="#url相关操作" class="headerlink" title="url相关操作"></a>url相关操作</h4><ul>
<li>将url解析为一个url对象：url.parse(urlString[,parseQueryString[,slashDenotHost]])</li>
<li>将一个url对象反解析为一个url地址：url.format(urlObject)</li>
<li>将部分url拼接为一个完整url地址url.resolve(from,to)</li>
<li>response对象有一个方法：write可以用来给客户端发送响应数据。write可以使用多次，但最后需要用end来结束响应，否则客户端会一直等待</li>
<li>req.url是地址栏中localhost后面的所有内容，除了hash的内容。</li>
<li>querystring.parse将字符串转为一个对象。</li>
</ul>
<h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><h6 id="使用第三方插件"><a href="#使用第三方插件" class="headerlink" title="使用第三方插件"></a>使用第三方插件</h6><p>需要先安装formidable包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let http = require(&apos;http&apos;);</span><br><span class="line">let url = require(&apos;url&apos;);</span><br><span class="line">let formidable = require(&apos;formidable&apos;);</span><br><span class="line">let util = require(&apos;util&apos;);//用于将object转为字符串</span><br><span class="line"> http.createServer((req,res) =&gt; &#123;</span><br><span class="line"> 	if(req.url === &apos;/postmsg&apos; &amp;&amp; req.methods.tolowerCase() === &quot;post&quot;)&#123;</span><br><span class="line"> 		//实例化对象</span><br><span class="line"> 		let form = new formidable.IncomingForm();</span><br><span class="line"> 		//设置上传文件路径</span><br><span class="line"> 		form.uploadDir = &apos;./uploads&apos;;</span><br><span class="line"> 		//获取表单内容</span><br><span class="line"> 		form.parse(req,(err,fileds,files) =&gt; &#123;</span><br><span class="line"> 			res.writeHead(200,&#123;&quot;content-Type&quot;:&quot;text/plain;charset=UTF-8&quot;&#125;);</span><br><span class="line"> 			res.end(util.inspect(&#123;fields:fields,files:files&#125;));</span><br><span class="line"> 		&#125;)</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;).listen(80,&apos;127.0.0.1&apos;);</span><br></pre></td></tr></table></figure>

<h4 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h4><p>在Node中，每个文件模块都是一个对象，它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Module(id, parent)&#123;</span><br><span class="line">	this.id = id;</span><br><span class="line">	this.exports = &#123;&#125;;</span><br><span class="line">	this.parent = parent;</span><br><span class="line">	if(parent &amp;&amp; parent.children)&#123;</span><br><span class="line">		parent.children.push(this);</span><br><span class="line">	&#125;</span><br><span class="line">	this.filename = null;</span><br><span class="line">	this.loaded = false;</span><br><span class="line">	this.children = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译和执行是引入文件模块的最后一个阶段。定位到具体文件后，Node会新建一个模块对象，然后通过路径载入并编译。对于不同的文件扩展名，其载入的方式也有所不同，具体如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.js文件。通过fs模块同步读取文件后编译执行。</span><br><span class="line"></span><br><span class="line">.node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后的编译生成的文件。</span><br><span class="line"></span><br><span class="line">.json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。</span><br><span class="line"></span><br><span class="line">其余扩展名文件。它们都被当作.js文件解析。(因为node只能解析js文件，其他文件最后都会被转化成js文件，故当其余扩展名文件出现时，node无法识别，故将其认为是默认扩展名进行解析，即.js)</span><br></pre></td></tr></table></figure>

<p>每一个编译成功的模块都会将文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。</p>
<p>根据不同文件扩展名，node会调用不同的读取方式，如：.json文件调用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Module._extensions[&apos;.json&apos;] = function(module,filename)&#123;</span><br><span class="line">	var content = NativeModule.require(&apos;fs&apos;).readFileSync(filename,&apos;utf8&apos;);</span><br><span class="line">	try&#123;</span><br><span class="line">		module.exports = JSON.parse(strinpBOM(cntent));</span><br><span class="line">	&#125;catch(err)&#123;</span><br><span class="line">		err.message = filename + &apos;:&apos; + err.message;</span><br><span class="line">		throw err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，Module._extensions会被赋值给 require() 的extensions属性，所以通过在代码中访问require.extensions可知道系统中已有的加载方式。编写代码测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//新建index.js文件</span><br><span class="line">console.log(require.extensions);</span><br><span class="line">//运行node index.js,输出</span><br><span class="line">//[Object: null prototype] &#123; &apos;.js&apos;: [Function], &apos;.json&apos;: [Function], &apos;.node&apos;: [Function] &#125;</span><br></pre></td></tr></table></figure>

<p>如果想对自定义的扩展名进行特殊的加载，可以通过类似require.extensions[‘.ext’]的方式实现。早期的CoffeeScript文件就是通过添加require.extensions[‘.coffee’]扩展方式来加载的。但是从v0.10.6版本开始，官方不鼓励通过这种方式进行自定义扩展名的加载，而是期望先将其它语言或文件先编译成js文件后再进行加载，这样做的好处是不将繁琐的编译加载等过程引入node的执行过程。</p>
<p>在确定文件的扩展名后，node将调用具体的编译方式来将文件执行后返回给调用者。</p>
<p>注：我们都知道CommonJS模块规范中，每个模块文件都存在<code>require、exports、module、_filename、_dirname</code>这5个变量却不知其从何而来。若是把直接定义模块的过程放在浏览器端，势必会存在污染全局变量的情况，故其不可能。</p>
<p>事实上，在编译过程中，node会对获取的js文件内容进行包装，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function(require、exports、module、_filename、_dirname)&#123;</span><br><span class="line">	var math = require(&apos;math&apos;);</span><br><span class="line">	exports.area = function(radius)&#123;</span><br><span class="line">		return Math.PI * radius * radius;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样每个模块文件之间都进行了作用于隔离。包装之后的代码会通过vm原生模块的runInThisContext() 方法执行，类似于eval，只是具有明确上下文，不污染全局，返回一个体的function对象。最后，将当前模块对象的exports属性，require()方法，module(模块对象本身)，以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。</p>
<p>这就是为什么这些变量并没有在每个模块声明却可以使用的原因。在执行后，模块的exports属性被返回给了调用方。exports属性上的任何方法都可以被外部调用到，但是模块中的其余变量和属性则不可直接被调用。</p>
<p>至此，require、exports、module的流程已经完整，这就是Node对CommonJS模块规范的实现。</p>
<p><strong>JSON文件的编译</strong></p>
<p>json文件的编译是三种编译方式中最简单的。Node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse（）方法得到对象，然后将它赋给模块对象的exports，以供外部调用。</p>
<p>JSON文件在用作项目的配置文件时比较有用。如果你定义了JSON文件作为配置，那就不用调用fs模块去异步读取和解析，直接调用require（）引入即可。此外，你还可以享受到模块缓存的便利，并且二次引入时也没有性能影响。</p>
<p>这里我们提到的模块编译都是指文件编译，即用户自己编写的模块。</p>
<h6 id="内建模块"><a href="#内建模块" class="headerlink" title="内建模块"></a>内建模块</h6><p>内建模块的优势在于：首先，他们本身由C/C++编写，性能上优于脚本语言；其次，其次，在进行文件编译时，他们会被编译进二进制文件。一旦node开始执行，他们会被直接加载进内存中，无需再次坐标识符定位、文件定位、编译等过程，直接就可执行。</p>
<p>Node在启动时，会生成一个全局变量process，并提供Binding()方法来协助加载内建模块。</p>
<p>在加载内建模块时，我们会先创建一个exports空对象，然后调用get_builtin_module（）方法取出内建模块对象，通过执行register_func()填充exports对象，最后将exports对象按模块名缓存，并返回给调用方完成导出。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-http进阶" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/30/http进阶/" class="article-date">
      <time datetime="2020-04-29T23:40:38.000Z" itemprop="datePublished">2020-04-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/30/http进阶/">http进阶</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h6 id="Telnet实例"><a href="#Telnet实例" class="headerlink" title="Telnet实例"></a>Telnet实例</h6><p>由于Http使用的是TCP/IP传输协议，而且它是基于文本的，没有使用哪些难以理解的二进制格式，因此很容易直接1与Web服务器进行对话。</p>
<p>Telnet程序可以将键盘连接到某个目标TCP端口，并将此TCP端口的输出回送到显示屏上。Telnet常用于远程终端会话，但它几乎可以连接所有的TCP服务器，包括HTTP服务器。</p>
<h4 id="Web结构组件"><a href="#Web结构组件" class="headerlink" title="Web结构组件"></a>Web结构组件</h4><ol>
<li>代理：位于客户端和服务器之间的HTTP中间实体。</li>
<li>缓存：HTTP的仓库，是常用页面的副本可以存在离客户端更近的地方。</li>
<li>网关：连接应用程序的特殊Web服务器。</li>
<li>隧道：对HTTP通信报文进行盲转发的特殊代理。</li>
<li>Agent代理：发起自动HTTP请求的半智能Web客户端。</li>
</ol>
<h6 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h6><p>HTTP代理服务器是Web安全，应用集成以及性能优化的重要组成模块。</p>
<p>代理位于客户端与服务器之间，接收所有客户端的HTTP请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。</p>
<p>出于安全考虑，通常会将代理作为转发所有Web流量的可信任中间节点使用。代理还可以对请求和响应进行过滤。比如，在企业中对下载的应用程序进行病毒检测，或者对小学生屏蔽一些成人才能看的内容。</p>
<h6 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h6><p>WEb缓存（Web cache）或代理缓存（proxy cache）是一种特殊的HTTP代理服务器，可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了。</p>
<h6 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h6><p>网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用，通常用于将HTTP流量转换成其他的协议。网关接受时就好像自己是咨议员的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。</p>
<p>如：一个HTTP/FTP网关会通过HTTP请求接受对FTP URI的请求，但通过FTP协议来获取文档。得到的文档会被封装成一条HTTP报文发给客户端。</p>
<h6 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h6><p>隧道（tunnel）是建立起来之后就会在两条连接之间对原始数据进行盲转发的HTTP应用程序。HTTP隧道通常用来在一条或多条HTTP连接上进行转发非HTTP数据，转发时不会窥探数据。</p>
<p>HTTP隧道的一种常见用途是通过HTTP连接承载加密的安全套接字层（SSL,Secure Socket Layout)流量，这样ssl流量就可以穿过只允许Web流量通过的防火墙了。</p>
<p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E9%9A%A7%E9%81%93.png" alt="隧道"></p>
<p>如：HTTP/SSL隧道收到一条HTTP请求，要求建立一条到目的的地址和端口的输出连接，然后在HTTP信道上通过隧道传输加密的SSL流量，这样就可以将其转发到目的服务器上。</p>
<h6 id="Agent代理"><a href="#Agent代理" class="headerlink" title="Agent代理"></a>Agent代理</h6><p>用户代理是代表用户发起HTTP请求的客户端程序。所有发布Web请求的应用程序都是HTTP Agent代理。到目前为止，我们只提过一种HTTP Agent代理：WEb浏览器，但用户Agent代理还有很多类型。</p>
<p>如：有些自己会在Web上闲逛的自动用户Agent代理，可以在无人监视的情况下发布HTTP事务并获取内容。这些自动代理的名字很生动，比如“网络蜘蛛”或“web机器人”。网络蜘蛛会在WEb上闲逛，搜集信息以构建有效的Web内容档案，比如一个搜索引擎的数据库或者为比较购物机器人生成的产品目录。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200430094207000.png" alt="image-20200430094207000"></p>
<h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><p>请求报文格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;method&gt;     &lt;request-URL&gt;  &lt;version&gt;</span><br><span class="line">&lt;headers&gt; </span><br><span class="line">&lt;entrity-body&gt;</span><br></pre></td></tr></table></figure>

<p>响应报文</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;version&gt;   &lt;status&gt;   &lt;response-phrase&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line">&lt;entrity-body&gt;</span><br></pre></td></tr></table></figure>

<h6 id="方法（method）"><a href="#方法（method）" class="headerlink" title="方法（method）"></a>方法（method）</h6><p>客户端希望服务器对资源执行的动作，是一个单独的词，比如GET,HEAD或POST.</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>是否包含主体</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>从服务器获取一份文档</td>
<td>否</td>
</tr>
<tr>
<td>HEAD</td>
<td>只从服务器获取文档的首部</td>
<td>否</td>
</tr>
<tr>
<td>POST</td>
<td>向服务器发送需要处理的数据</td>
<td>是</td>
</tr>
<tr>
<td>PUT</td>
<td>将请求的主体部分存储在服务器上</td>
<td>是</td>
</tr>
<tr>
<td>TRACE</td>
<td>对可能经过代理服务器传送到服务器上去的报文进行追踪</td>
<td>否</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>决定可以在服务器上执行哪些方法</td>
<td>否</td>
</tr>
<tr>
<td>DELETE</td>
<td>从服务器上删除一份文档</td>
<td>否</td>
</tr>
</tbody></table>
<p><strong>扩展方法</strong>：指的是没有在HTTP/1.1规范中定义的方法，服务器会为它所管理的资源实现一些二HTTP服务，这些方法为开发者提供了一种扩展这些HTTP服务能力的手段。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LOCK</td>
<td>允许用户“锁定”资源——比如，可以在编辑某个资源的时候将其锁定，以防别人对其进行修改。</td>
</tr>
<tr>
<td>MKCOL</td>
<td>允许用户创建资源</td>
</tr>
<tr>
<td>COPY</td>
<td>便于在服务器上复制资源</td>
</tr>
<tr>
<td>MOVE</td>
<td>在服务器上移动资源</td>
</tr>
</tbody></table>
<p>惯例：对所发送的内容要求严一点，对接收的内容宽容一些处理扩展方法。</p>
<ol start="2">
<li><p>请求URL(request-URL)</p>
<p>命名了所有请求资源，或者URL路径组件的完整URL。如果直接与服务器进行对话，只要URL的路径组件是资源的绝对路径，通常就不会有什么问题——服务器可以假定自己是URL的主机/端口。</p>
</li>
<li><p>版本（version）</p>
</li>
<li><p>状态码（status-code）</p>
<p>这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般类型（“成功”、“出错”）。</p>
<p><strong>状态码分类</strong></p>
<table>
<thead>
<tr>
<th>整体范围</th>
<th>已定义范围</th>
<th>分类</th>
</tr>
</thead>
<tbody><tr>
<td>100-199</td>
<td>100-101</td>
<td>信息提示</td>
</tr>
<tr>
<td>200-299</td>
<td>200-206</td>
<td>成功</td>
</tr>
<tr>
<td>300-399</td>
<td>300-305</td>
<td>重定向</td>
</tr>
<tr>
<td>400-499</td>
<td>400-415</td>
<td>客户端错误</td>
</tr>
<tr>
<td>500-599</td>
<td>500-505</td>
<td>服务器错误</td>
</tr>
</tbody></table>
<p><strong>常见状态码</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>成功。请求的所有数据都在响应主体中。</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized（未授权）</td>
<td>需要输入用户名和密码</td>
</tr>
<tr>
<td>404</td>
<td>Not Found（未找到）</td>
<td>服务器无法找到所请求URL对应的资源</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented（无法实现）</td>
<td></td>
</tr>
</tbody></table>
<p><strong>信息性状态码</strong>‘</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue</td>
<td>说明受到了请求的初始部分，请客户端继续，发送了这个状态码后，服务器在收到请求后必须进行响应。</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td>说明服务器正在根据客户端的指定，将协议切换成Update’首部所列的协议。</td>
</tr>
</tbody></table>
<p>100 Continue是一种优化，客户端应用程序只有在避免向服务器发送一个服务器无法处理或使用的大实体时才会使用100 Continue。当服务端超时一定时间后，客户端直接将实体发出去。</p>
<p><strong>成功状态码</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>请求没问题，实体的主体部分包含了所请求的资源</td>
<td>OK</td>
</tr>
<tr>
<td>201</td>
<td>用于创建对象的请求（PUT)。响应的主体部分包含各种已创建资源的URL，location首部包含则是最具体的引用。</td>
<td>Created</td>
</tr>
<tr>
<td>202</td>
<td>请求已被接受，但服务器还未对其执行任何动作，不能保证服务器会完成这个请求。</td>
<td>Accepted</td>
</tr>
<tr>
<td>203</td>
<td>实体部分包含的资源不是来自源服务器，而是来自资源的一份副本。如果中间节点上有一份资源副本，但无法对它所发送的与资源有关的元信息（首部）进行验证，就会出现这种情况。</td>
<td>Non-Authoritative-Information</td>
</tr>
<tr>
<td>204</td>
<td>响应报文中包含若干首部和一个状态行，但没有实体部分，主要用于在浏览器不转为显示新文档的情况下，对其将进行更新（如刷新一个表单页面）</td>
<td>No Content</td>
</tr>
<tr>
<td>205</td>
<td>另一个主要用于浏览器的代码，负责告诉浏览器清除当前页面中所有HTML表单元素。</td>
<td>Reset Content</td>
</tr>
<tr>
<td>206</td>
<td>成功执行一部分请求。稍后会看到，客户端可以通过一些特殊的首部来获取部分或某个范围内的文档——这个状态码就说明请求成功了。</td>
<td>Partial Content</td>
</tr>
</tbody></table>
<p><strong>重定向状态码</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>300</td>
<td>Multiple Choices</td>
<td>客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如服务器上有某个HTML文档的英语和法语版本。返回这个代码时会带有一个选项列表，这样用户就可以选择他希望使用的那一项了。有多个版本1可用时，客户端需要沟通解决。</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permananently</td>
<td>在请求的URL已被移除时使用。响应的Location首部中应该包含资源现在所处的URL。</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>与301状态码相似，但是客户端应该使用Location首部给出的URL来临时定位资源。将来的请求仍应使用老的URL。</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的Location首部。其主要目的是允许POST请求的响应将客户端定向到某个资源上去。</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>客户端可以通过所包含的请求首部，使其请求变成有条件的。如果客户端发起一个GET请求，而最近资源未被修改，就可用这个状态码来说明资源未被修改，带有这个状态吗的响应不应该包含实体的主体部分。</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>用来说明必须通过一个代理来访问资源，代理的位置由Location首部给出。很重要一点是，客户端是相对某个特定资源来解析这个响应的，不能假定所有请求，甚至所有对持有所请求资源的服务器的请求都通过这个代理进行。如果客户端错误的让代理介入了某条请求，可能会引发破环性的行为，而且会造成安全漏洞。</td>
</tr>
<tr>
<td>306</td>
<td>（未使用）</td>
<td>当前未使用</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>与301状态码相似，但是客户端应该使用Location首部给出的URL来临时定位资源。将来的请求仍应使用老的URL。</td>
</tr>
</tbody></table>
<p><strong>客户端错误</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>Bad Request</td>
<td>用于告诉客户端他发送了一个错误的请求</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>与适当的首部一同返回，在这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证。</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>现在这个状态码还未使用，但已经被保留，以作未来之用。</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>用以说明请求被服务器拒绝了，如果服务器想说明为什么拒绝请求，可以包含实体的主体部分来对原因进行描述。但这个状态通常是在服务器不想说明拒绝原因的时候使用的。</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>用于说明服务器无法找到所请求的URL。通常会包含一个实体以便客户端应用程序显示给用户看。</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>发起的请求中带所请求的URL不支持的方法时，使用此状态码。应该在响应中包含Allow首部，以告知客户端对请求的资源可以使用哪些方法。</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>客户端可以指定参数来说明他们愿意接受什么类型的实体。服务器没有与客户端可接受的URL相匹配的资源时，使用此代码。通常，服务器会包含一些首部以便客户端弄清楚为什么请求无法满足。</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>与401状态码类似，但用于要求对资源进行认证的代理服务器。</td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout</td>
<td>如果客户端完成请求所花的时间太长，服务器可以回送此状态码，并关闭连接。超时时长随服务器的不同而不同，但通常对所有合法请求来说都是够长的。</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>用于说明请求可能在资源上引发的一些冲突，服务器担心请求会引发冲突时可发送此状态码。响应中应该包含描述冲突的主体。</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>与404相似，只要服务曾经拥有过此资源。主要用于Web站点的维护，这样服务器的管理者就可以在资源被移除的情况下通知客户端了。</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>服务器要求在请求报文中包含Content-Length首部时使用。</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>客户端发起了条件请求且其中一个条件失败时使用。</td>
</tr>
<tr>
<td>413</td>
<td>Request Entrity Too Large</td>
<td>客户端发送实体主体部分比服务器能够或希望处理的要大时发送此状态码。</td>
</tr>
<tr>
<td>414</td>
<td>Request URL Too Long</td>
<td>客户端发送请求中的URL比服务器希望处理的要大时发送此状态码。</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器无法理解或无法支持客户端所发送实体的内容类型时</td>
</tr>
<tr>
<td>416</td>
<td>Unsupported Media Type</td>
<td>请求报文所请求的是指定资源的某个范围，而此范围无效或无法满足时使用此状态码。</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>请求的Expect请求首部包含了一个期望，但服务器无法满足此期望时，使用此状态码。如果代理或其他中间应用程序与确切证据说明源端服务器会为某请求产生一个失败的期望就可发送此状态码。</td>
</tr>
</tbody></table>
<p><strong>服务器错误</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器遇到一个妨碍它为请求提供服务的错误时使用此状态码。</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>客户端发起的请求超出服务器的能力范围。</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应（如，他无法链接到其父网关时）。</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>用来说明服务器现在不能为请求提供服务，但将来可以。如果服务器知道什么时候资源会变为可用的，可在响应中包含一个Retry-After首部。</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout</td>
<td>与状态码408相似，只是这里的响应来自一个网关或代理，他们在等待另一服务器对其请求进行响应时超时了。</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version Not Supported</td>
<td>服务器收到的请求使用了它无法或不愿支持的协议版本。有些服务器应用程序会选择不支持协议的早期版本。</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="5">
<li><p>原因短语（reason-phrase）</p>
<p>数字状态码的可读版本，包含行终止序列的所有文本。</p>
</li>
<li><p>首部（header）</p>
<p>可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号，然后是一个可选的空格，接着是一个值，最后是一个CRLF。首部是由一个空行结束的，表示了首部列表的结束和实体主体部分的开始。</p>
<p><strong>首部分类</strong></p>
<ul>
<li>通用首部：既可以出现在请求报文中，又可以出现在响应报文中。</li>
<li>请求首部：提供更多有关请求的信息。</li>
<li>响应首部：提供更多有关响应的信息。</li>
<li>实体首部：描述主体的长度和内容，或者资源自身。</li>
<li>扩展首部：规范中没有定义的新首部。</li>
</ul>
<p><strong>常见首部实例</strong></p>
<table>
<thead>
<tr>
<th>首部实例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Date：Tue,3 Oct 1997  02:16:03  GMT</td>
<td>服务器产生响应的日期</td>
</tr>
<tr>
<td>Content-length:15040</td>
<td>实体的主体部分包含了</td>
</tr>
<tr>
<td>Content-type:image/gif</td>
<td>实体的主体部分是一个GIF图片</td>
</tr>
<tr>
<td>Accept:image/gif, image/jpeg, text/html</td>
<td>客户端可以接收</td>
</tr>
<tr>
<td>Connection</td>
<td>允许客户端和服务器指定与请求或响应连接有关的选项。</td>
</tr>
<tr>
<td>MIME-Version</td>
<td>给定发送端使用的MIME版本。</td>
</tr>
<tr>
<td>Trailer</td>
<td>如果报文采用了分块传输编码（chunked transfer encoding）方式就可以用这个首部列出位于报文拖挂（trailer）部分的首部集合。</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>告知接收端为了保证报文可靠传输，对报文采取什么编码方式。</td>
</tr>
<tr>
<td>Update</td>
<td>给出了发送端可能想要“升级”使用的新版本或协议。</td>
</tr>
<tr>
<td>Via</td>
<td>显示了报文经过的中间节点（代理，网关）</td>
</tr>
</tbody></table>
</li>
<li><p>实体的主体部分（entrity-body）</p>
<p>实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分。</p>
</li>
</ol>
<h6 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h6><p>通用缓存首部：HTTP/1.0引入了第一个允许HTTP应用程序缓存对象本地副本的首部，这样就不需要总是直接从源端服务器获取了。</p>
<table>
<thead>
<tr>
<th>首部</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>用于随报文传送缓存指示。</td>
</tr>
<tr>
<td>Pragma</td>
<td>另一种随报文传送指示的方式，但并不专用于缓存。</td>
</tr>
</tbody></table>
<p><strong>请求首部</strong>：是只在请求报文中有意义的首部，用于说明是谁或什么在发送请求，请求源自何处，或者客户端的喜好和能力。服务器可以根据请求首部给出的客户端信息，试着为客户端提供更好的响应。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502215359440.png" alt="image-20200502215359440"></p>
<p><strong>Accept首部</strong>为客户端提供一种将其喜好和能力告知服务器的方式，包括它们想要什么，可以使用什么，以及最重要的，他们不想要什么，这样，服务器可以根据这些额外的信息，对要发送的内容做出更明智的决定。Accept首部会使连接的两端都受益。客户端会得到它们想要的内容，服务器则不会浪费时间和带宽来发送客户端无法使用的东西。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502220337984.png" alt="image-20200502220337984"></p>
<p><strong>条件请求首部</strong>：有时客户端希望为请求加上某些限制。比如，如果客户端已经有了一份文件副本就希望只在服务器上的文档与客户端拥有的副本有所区别时才请求服务器传输文档。通过条件请求首部，客户端就可以为请求加上这种限制，要求服务器在对请求进行响应前，确保某个条件为真。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502220845355.png" alt="image-20200502220845355"></p>
<p><strong>安全请求首部</strong></p>
<p>HTTP本身就支持一种简单的机制，可以对请求进行质询/响应认证。这种机制要求客户端在获取特定资源之前，先对自身进行认证，这样就可以使事务稍微安全一些。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502221420633.png" alt="image-20200502221420633"></p>
<p><strong>代理请求首部</strong></p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502221552479.png" alt="image-20200502221552479"></p>
<h6 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h6><p>响应报文有自己的响应首部集。响应首部为客户端提供了一些额外信息，比如谁发送响应，响应者的功能，甚至与响应相关的一些特殊指令，这些首部有助于客户端处理响应，并在将来发起更好的请求。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200503080735091.png" alt="image-20200503080735091"></p>
<p><strong>协商首部</strong></p>
<p>如果资源有多种表示方法——如，若服务器上有某文档的法语和德语译稿，HTTP/1.1可以为服务器和客户端提供对资源进行协商的能力。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200503082210004.png" alt="image-20200503082210004"></p>
<p><strong>安全响应首部</strong></p>
<table>
<thead>
<tr>
<th>首部</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Proxy-Authenticate</td>
<td>来自代理的对客户端的质询列表</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>不是真正的安全首部，但隐含有安全功能，可以在客户端设置一个令牌，以便服务器对客户端进行标识。</td>
</tr>
<tr>
<td>Set-Cookie2</td>
<td>与Set-Cookie类似</td>
</tr>
<tr>
<td>www-Authenticate</td>
<td>来自服务器的对客户端的质询列表</td>
</tr>
</tbody></table>
<h6 id="HTTP事务产生时延的原因"><a href="#HTTP事务产生时延的原因" class="headerlink" title="HTTP事务产生时延的原因"></a>HTTP事务产生时延的原因</h6><ol>
<li>客户端首先需要根据URI确定Web服务器的IP地址和端口号。如果最近没有对URI中的主机名进行访问，通过DNS解析系统将URI中的主机名转换成一个IP地址可能要花费数十秒的时间。</li>
<li>接下来，客户端会向服务器发送一条TCP连接请求，并等待服务器回送一个请求经接受应答。每条新的TCP连接都会有连接建立时延。这个值通常最多只有一两秒钟，但如果有数百个HTTP事务的话，这个值就会快速叠加上去。</li>
<li>一旦连接建立起来，客户端就会通过新建立的TCP管道来发送HTTP请求。数据到达时，Web服务器会从TCP链接中读取请求报文，并对请求进行处理。因特网传输请求报文，以及服务器请求报文都需要时间。</li>
<li>然后，Web服务器会回送HTTP响应，这也需要花费时间。</li>
</ol>
<p>注：大多数HTTP客户端都有一个小的DNS缓存,用来保存近期所访问站点的IP地址。如果已经在本地“缓存”了IP地址，查询就可立即完成，因为大多数Web浏览器浏览的是少数常用站点，所以通常可以很快将主机名解析出来。</p>
<p>TCP网络时延的大小取决于硬件速度，网络和服务器的负载，请求和响应报文的尺寸，以及客户端和服务器之间的距离。</p>
<h6 id="TCP连接握手步骤"><a href="#TCP连接握手步骤" class="headerlink" title="TCP连接握手步骤"></a>TCP连接握手步骤</h6><ol>
<li>请求新的TCP连接时，客户端要向服务器发送一个小的TCP分组（通常是40-60字节）。这个分组中设置了一个特殊的SYN标记，说明这是一个连接请求。</li>
<li>如果服务器接受了连接，就会对连接参数进行计算，并向客户端回送一个TCP分组，这个分组中的SYN和ACK标记都被置位，说明连接请求已被接受。</li>
<li>最后，客户端向服务器回送一条确认消息，通知他连接已成功建立，现代的TCP栈都允许客户端在这个确认分组中发送消息。</li>
</ol>
<p>小的HTTP事务可能会在TCP建立上花费50%，或更多的时间</p>
<h6 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h6><p>由于因特网自身无法确保可靠的分组传输（因特网路由器超负荷的话，可以随意丢弃分组），所以TCP实现了自己的确认机制来确保数据的成功传输。</p>
<p>每个TCP段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段时，都会向发送者回送小的确认分组。如果发送者，欸有在指定的窗口时间内收到确认信息，发送者就会认为分组已被破环或损毁，并重发数据。</p>
<p>由于u企鹅人保温很小，所以TCP允许在发往相同方向的输出数据分组中对其进行“捎带”。TCP将将返回的确认信息与输出的数据分组结合在一起，可以更有效利用网络。为了增加确认报文找到同向传输数据分组的可能性，很多TCP栈都实现了一种延迟确认算法。延迟确认算法会在一个特定的窗口时间内将输出确认缓存放在缓存区中，以寻找能够捎带他的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。</p>
<p>但是，HTTP具有双峰特征的请求——应答行为就降低了捎带信息的可能。当希望有相反方向回传分组的时候，偏偏没有那么多。通常，延迟确认算法会引起相当大的时延。根据所使用的操作系统的不同，可以调整或禁止延迟确认算法。</p>
<p>在对TCP栈的任何参数进行修改之前，一定要对袭击在做什么会有清晰的了解。TCP中引入这些算法的目的是为了防止设计欠佳的应用程序对因特网造成破环。对TCP配置进行任意修改都要绝对确保应用程序不会引发这些i算法所要避免的问题。</p>
<h6 id="TCP慢启动"><a href="#TCP慢启动" class="headerlink" title="TCP慢启动"></a>TCP慢启动</h6><p>TCP数据传输的性能还取决于TCP连接的使用期。TCP连接会随着时间进行自我“调谐”，起初还会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度，这种调谐被称为TCP慢启动，用于防止因特网的突然过载和拥塞。</p>
<p>TCP慢启动限制了一个TCP端点在任意时刻可以传输的分组数。简单来讲是每成功接收一个分组，发送端就有了发送另外两个分组的权限。如果某个HTTP事务有大量的数据要发送，是不能依次将所有分组都发送出去的，必须发送一个分组，确认后才可以再发。这种方式是”打开拥塞窗口“。</p>
<p>由于存在这种拥塞控制特性，所以新连接的传输速度会比已经交换过一定数据量的，“已调谐”连接慢一些。由于已调谐连接要更快一些，所以HTTP中有一些可以重用现存连接的工具。即HTTP“持久连接”。</p>
<h6 id="提高HTTP连接性能的四类方法"><a href="#提高HTTP连接性能的四类方法" class="headerlink" title="提高HTTP连接性能的四类方法"></a>提高HTTP连接性能的四类方法</h6><ol>
<li>并行连接</li>
<li>持久连接</li>
<li>管道化连接</li>
<li>复用连接</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ES6的学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/28/ES6的学习/" class="article-date">
      <time datetime="2020-04-28T06:51:11.000Z" itemprop="datePublished">2020-04-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/ES6的学习/">ES6的学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="ES6变量声明"><a href="#ES6变量声明" class="headerlink" title="ES6变量声明"></a>ES6变量声明</h4><h6 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h6><ul>
<li>声明变量，只在所在的代码块有效，处于暂时性死区</li>
<li><code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</li>
<li>变量不提升，不允许重复声明</li>
<li>允许在块级作用域内声明函数，函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</li>
</ul>
<h6 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h6><ul>
<li><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。且必须立即初始化，不能留到以后赋值。只声明不赋值，就会报错。</li>
<li><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</li>
</ul>
<h6 id="将对象彻底冻结"><a href="#将对象彻底冻结" class="headerlink" title="将对象彻底冻结"></a>将对象彻底冻结</h6><ul>
<li><p>简单冻结 ：const   foo = Object.freeze({});</p>
</li>
<li><p>对象及属性都冻结：</p>
<p>var  constantize = (obj) =&gt; {</p>
<p>Object.freeze(obj);</p>
<p>Object.keys(obj).forEach((key,i) =&gt;{</p>
<p>if( typeof  obj[key] === ‘object’) {</p>
<p>constantize(obj[key]);}</p>
<p>});};</p>
</li>
</ul>
<h6 id="import命令"><a href="#import命令" class="headerlink" title="import命令"></a>import命令</h6><h6 id="class命令"><a href="#class命令" class="headerlink" title="class命令"></a>class命令</h6><h6 id="顶层对象"><a href="#顶层对象" class="headerlink" title="顶层对象"></a>顶层对象</h6><ul>
<li>浏览器环境中的顶层对象指window对象，node指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。<ul>
<li>浏览器里面，顶层对象是<code>window</code>，但 Node 和 Web Worker 没有<code>window</code>。</li>
<li>浏览器和 Web Worker 里面，<code>self</code>也指向顶层对象，但是 Node 没有<code>self</code>。</li>
<li>Node 里面，顶层对象是<code>global</code>，但其他环境都不支持。</li>
</ul>
</li>
<li>一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。</li>
<li>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用<code>this</code>变量，但是有局限性。<ul>
<li>全局环境中，<code>this</code>会返回顶层对象。但是，Node 模块和 ES6 模块中，<code>this</code>返回的是当前模块。</li>
<li>函数里面的<code>this</code>，如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这时<code>this</code>会返回<code>undefined</code>。</li>
<li>不管是严格模式，还是普通模式，<code>new Function(&#39;return this&#39;)()</code>，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么<code>eval</code>、<code>new Function</code>这些方法都可能无法使用。</li>
</ul>
</li>
</ul>
<h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><ul>
<li>只需模式匹配即可用数组方式为各种数据类型赋值</li>
<li>解构赋值允许指定默认值。只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。</li>
</ul>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ul>
<li>全局环境中，this会返回顶层对象（浏览器是window，Node是global）。但是，Node模块和ES6模块中，this返回当前块</li>
<li>函数里面的this，如果函数不是作为对象的方法执行，而是单纯作为函数运行，this会指向顶层对象。但是在严格模式下，这时的this会返回undefined</li>
<li>不管是严格模式还是普通模式，new   Function（‘return  this’）（），总是返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全策略），那么eval，new  Function这些方法都可能不能使用。</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul>
<li><p>字符串的遍历器接口</p>
<ul>
<li><p>for（let   变量名   of  ‘遍历对象’）{}使得字符串如字符串数组般被遍历。</p>
</li>
<li><p>除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点</p>
<blockquote>
<p>let  text = String.fromCodePoint(0x20BB7);</p>
<p>for(let i = 0;i &lt; text.length; i++){</p>
<p>​    console.log(text[i]);  </p>
<p>}</p>
<p>//“ “</p>
<p>// ” “</p>
<p>//for循环认为其包含两个字符</p>
<p>for（let i  of  text）{</p>
<p>​    console.log(text[i]);  </p>
<p>}</p>
<p>//”吉“</p>
<p>//for…of循环会正确识别出这一个字符</p>
</blockquote>
</li>
</ul>
</li>
<li><p>为了确保返回的是合法的 UTF-8 字符，<a href="https://github.com/tc39/proposal-well-formed-stringify" target="_blank" rel="noopener">ES2019</a> 改变了<code>JSON.stringify()</code>的行为。如果遇到<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(&apos;\u&#123;D834&#125;&apos;) // &quot;&quot;\\uD834&quot;&quot;</span><br><span class="line">JSON.stringify(&apos;\uDF06\uD834&apos;) // &quot;&quot;\\udf06\\ud834&quot;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板字符串</p>
<ul>
<li><p>模板字符串（template string）是增强版的字符串，用反引号（~）标识。他可以当作普通字符串使用，也可以用来定义多行字符串，或在字符串中嵌入变量。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; $(<span class="string">'#result'</span>).append(</span><br><span class="line">&gt; <span class="string">'There are &lt;b&gt;'</span> + basket.count + <span class="string">'&lt;/b&gt; '</span> +</span><br><span class="line">&gt; <span class="string">'items in your basket, '</span> +</span><br><span class="line">&gt; <span class="string">'&lt;em&gt;'</span> + basket.onSale +</span><br><span class="line">&gt; <span class="string">'&lt;/em&gt; are on sale!'</span></span><br><span class="line">&gt; );</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// 普通字符串</span></span><br><span class="line">&gt; <span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// 多行字符串</span></span><br><span class="line">&gt; <span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string">&gt; not legal.`</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">&gt; string text line 2`</span>);</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// 字符串中嵌入变量</span></span><br><span class="line">&gt; <span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line">&gt; <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>上面的代码都是用反引号表示，如果在模板字符串中需要使用反引号，则前面要用反斜杠转义</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> greeting = <span class="string">`\`Yo\` World!`</span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>如果使用模板字符串表示多行字符串，所有空格和缩进都会被保留在输出之中。如不想这个换行，可使用trim方法消除他。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; $(<span class="string">'#list'</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&gt; &lt;ul&gt;</span></span><br><span class="line"><span class="string">&gt; &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">&gt; &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&gt; &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&gt; `</span>.trim());</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>模板字符串嵌入变量，需要将变量名写在${}之中。还可以调用函数大括号内部可以放入任意的js表达式，可进行运算，以及引用对象属性。</p>
</li>
<li><p>如果大括号内的值不是字符串，将按照一般规则转为字符串。若是字符串则会调用对象的toString方法。若模板字符串的变量没有声明，将会报错。</p>
</li>
</ul>
</li>
<li><p>标签模板</p>
<ul>
<li><p>它可紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert `123`</span><br><span class="line">//等价于</span><br><span class="line">alert(123);</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板字符串里面如果有变量，就不是简单调用，而是将模板字符串先处理成多个参数，在调用函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = 5;</span><br><span class="line">let b = 10;</span><br><span class="line"></span><br><span class="line">tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;</span><br><span class="line">// 等同于</span><br><span class="line">tag([&apos;Hello &apos;, &apos; world &apos;, &apos;&apos;], 15, 50);</span><br><span class="line">function tag(stringArr, ...values)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="字符串新增方法"><a href="#字符串新增方法" class="headerlink" title="字符串新增方法"></a>字符串新增方法</h4><ul>
<li><p>String.fromCodePoint()</p>
<ul>
<li>可以识别大于<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode()</code>方法的不足。</li>
</ul>
</li>
<li><p>String.raw()</p>
<ul>
<li>该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</li>
</ul>
</li>
<li><p>codePointAt()</p>
</li>
<li><p>normalize()</p>
<ul>
<li>用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</li>
</ul>
</li>
</ul>
<h6 id="确定一个字符串是否包含在另一个字符串中"><a href="#确定一个字符串是否包含在另一个字符串中" class="headerlink" title="确定一个字符串是否包含在另一个字符串中"></a>确定一个字符串是否包含在另一个字符串中</h6><ul>
<li><p><strong>indexof（）</strong></p>
</li>
<li><p><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</p>
</li>
<li><p><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的头部。</p>
</li>
<li><p><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的尾部。</p>
</li>
<li><h6 id="repeat-：返回一个新字符串，表示将原字符串重复n次。"><a href="#repeat-：返回一个新字符串，表示将原字符串重复n次。" class="headerlink" title="repeat()：返回一个新字符串，表示将原字符串重复n次。"></a>repeat()：返回一个新字符串，表示将原字符串重复<code>n</code>次。</h6><ul>
<li>其参数会先进行往0方向取整再代值，如是负数或Infinity会报错。参数<code>NaN</code>等同于 0</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>) <span class="comment">// "xxx"</span></span><br><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">0</span>) <span class="comment">// ""</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。如果某个字符串不够指定长度，会在头部或尾部补全。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>trimStart()</code>和<code>trimEnd()</code>这两个方法。它们的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</li>
<li><code>matchAll()</code>方法返回一个正则表达式在当前字符串的所有匹配</li>
</ul>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><ul>
<li><p>如果正则构造函数的第一个参数是一个正则对象，那么就可以使用第二个参数指定修饰符。且返回的正则表达式会忽略原有的正则表达式修饰符，只使用新指定的修饰符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new RegExp(/abc/ig,&apos;i&apos;).flags</span><br><span class="line">//&quot;i&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串对象共有 4 个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p>
<p>ES6 将这 4 个方法，在语言内部全部调用<code>RegExp</code>的实例方法，从而做到所有与正则相关的方法，全都定义在<code>RegExp</code>对象上。</p>
<ul>
<li><code>String.prototype.match</code> 调用 <code>RegExp.prototype[Symbol.match]</code></li>
<li><code>String.prototype.replace</code> 调用 <code>RegExp.prototype[Symbol.replace]</code></li>
<li><code>String.prototype.search</code> 调用 <code>RegExp.prototype[Symbol.search]</code></li>
<li><code>String.prototype.split</code> 调用 <code>RegExp.prototype[Symbol.split]</code></li>
</ul>
</li>
</ul>
<h6 id="具名组匹配"><a href="#具名组匹配" class="headerlink" title="具名组匹配"></a>具名组匹配</h6><blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> RE_DATE = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line">&gt; <span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line">&gt; <span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line">&gt; <span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>允许为每一个组匹配指定一个名字。模式的头部添加“问号 + 尖括号 + 组名”，然后就可以在<code>exec</code>方法返回结果的<code>groups</code>属性上引用该组名。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> RE_DATE = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line">&gt; <span class="keyword">const</span> year = matchObj.groups.year; <span class="comment">// 1999</span></span><br><span class="line">&gt; <span class="keyword">const</span> month = matchObj.groups.month; <span class="comment">// 12</span></span><br><span class="line">&gt; <span class="keyword">const</span> day = matchObj.groups.day; <span class="comment">// 31</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>RegExp.prototype.flags 属性返回正则表达式的修饰符。</p>
</li>
</ul>
<h6 id="先行断言"><a href="#先行断言" class="headerlink" title="先行断言"></a>先行断言</h6><p>“先行断言”指的是，<code>x</code>只有在<code>y</code>前面才匹配，必须写成<code>/x(?=y)/</code>。比如，只匹配百分号之前的数字，要写成<code>/\d+(?=%)/</code>。“先行否定断言”指的是，<code>x</code>只有不在<code>y</code>前面才匹配，必须写成<code>/x(?!y)/</code>。比如，只匹配不在百分号之前的数字，要写成<code>/\d+(?!%)/</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\d+(?=%)/.exec(&apos;100% of US presidents have been male&apos;)  // [&quot;100&quot;]</span><br><span class="line">/\d+(?!%)/.exec(&apos;that’s all 44 of them&apos;)                 // [&quot;44&quot;]</span><br></pre></td></tr></table></figure>

<h6 id="后行断言"><a href="#后行断言" class="headerlink" title="后行断言"></a>后行断言</h6><p>“后行断言”正好与“先行断言”相反，<code>x</code>只有在<code>y</code>后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。比如，只匹配美元符号之后的数字，要写成<code>/(?&lt;=\$)\d+/</code>。“后行否定断言”则与“先行否定断言”相反，<code>x</code>只有不在<code>y</code>后面才匹配，必须写成<code>/(?&lt;!y)x/</code>。比如，只匹配不在美元符号后面的数字，要写成<code>/(?&lt;!\$)\d+/</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=\$)\d+/.exec(&apos;Benjamin Franklin is on the $100 bill&apos;)  // [&quot;100&quot;]</span><br><span class="line">/(?&lt;!\$)\d+/.exec(&apos;it’s is worth about €90&apos;)                // [&quot;90&quot;]</span><br></pre></td></tr></table></figure>

<h6 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h6><ul>
<li>RegExp.prototype.unicode属性表示是否设置了u修饰符。</li>
<li>y修饰符隐含了头部匹配的标志^</li>
</ul>
<h4 id="函数的拓展"><a href="#函数的拓展" class="headerlink" title="函数的拓展"></a>函数的拓展</h4><ul>
<li><p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面</p>
<blockquote>
<p>function  log(x,y=’world’){</p>
<p>​    console.log(x,y);</p>
<p>}</p>
</blockquote>
<ul>
<li><p>好处：阅读代码的人可立即意识到哪些参数可以省略，不用查看函数体或文档。其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数也不会导致以前的代码无法运行</p>
</li>
<li><p>参数变量是默认声明的，故不能用let和const再次声明。否则会报错</p>
</li>
<li><p>使用参数默认值时，函数不能有同名参数</p>
</li>
<li><p>参数默认值不是传值的，而是每次都重新计算默认值表达式的值，即参数默认值是惰性求值的。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">&gt; <span class="built_in">console</span>.log(p);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; foo() <span class="comment">// 100</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; x = <span class="number">100</span>;</span><br><span class="line">&gt; foo() <span class="comment">// 101</span></span><br><span class="line">&gt; <span class="comment">//参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>函数与解构默认值结合使用</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">&gt; <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; foo(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">&gt; foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line">&gt; foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line">&gt; foo() <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值就可避免这种情况。</p>
<blockquote>
<p>function   foo({x,y=5} = {}){</p>
<p>​    console.log(x,y);</p>
<p>}</p>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// 函数没有参数的情况</span></span><br><span class="line">&gt; m1() <span class="comment">// [0, 0]</span></span><br><span class="line">&gt; m2() <span class="comment">// [0, 0]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// x 和 y 都有值的情况</span></span><br><span class="line">&gt; m1(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line">&gt; m2(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// x 有值，y 无值的情况</span></span><br><span class="line">&gt; m1(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, 0]</span></span><br><span class="line">&gt; m2(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, undefined]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// x 和 y 都无值的情况</span></span><br><span class="line">&gt; m1(&#123;&#125;) <span class="comment">// [0, 0];</span></span><br><span class="line">&gt; m2(&#123;&#125;) <span class="comment">// [undefined, undefined]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; m1(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [0, 0]</span></span><br><span class="line">&gt; m2(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [undefined, undefined]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>参数默认值一般是尾参数。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">5</span>, z</span>) </span>&#123;</span><br><span class="line">&gt; <span class="keyword">return</span> [x, y, z];</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; f() <span class="comment">// [undefined, 5, undefined]</span></span><br><span class="line">&gt; f(<span class="number">1</span>) <span class="comment">// [1, 5, undefined]</span></span><br><span class="line">&gt; f(<span class="number">1</span>, ,<span class="number">2</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt; f(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>) <span class="comment">// [1, 5, 2]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>函数的length属性</p>
<ul>
<li><p>指定了默认值后，函数的length属性将返回没有指定默认值的参数个数。也就是说指定了默认值后，length属性将失真。</p>
</li>
<li><p>length属性的含义是该函数预期传入的参数个数，某个指定了默认之后，预期传入的参数个数就不包括这个参数了。</p>
</li>
<li><p>如果设置默认值的参数不是尾参数，那么length属性将不再计入后面的参数了。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;&#125;).length  <span class="comment">//1</span></span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">a=<span class="number">5</span></span>)</span>&#123;&#125;).length  <span class="comment">//0</span></span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c=<span class="number">9</span></span>)</span>&#123;&#125;).length  <span class="comment">//2</span></span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;&#125;).length   <span class="comment">//0</span></span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">a=<span class="number">0</span>,b,c</span>)</span>&#123;&#125;).length   <span class="comment">//0</span></span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">a,b=<span class="number">2</span>,c</span>)</span>&#123;&#125;).length  <span class="comment">//1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>作用域</p>
<ul>
<li><p>一旦设置了参数默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用于就会消失。这种情况在没有默认参数值是不会出现的。</p>
<blockquote>
<p>var  x = 1;</p>
<p>function   f(x, y = x){</p>
<p>​    console.log(y);</p>
<p>}</p>
<p>f(2)  //2</p>
<p>//上面代码中，参数y的默认值等于变量x。调用函数时，参数会形成一个单独的作用域。在这个作用域里，默认变量x指向第一个参数x，而不是全局变量x，所以输出的是2</p>
</blockquote>
<blockquote>
<p>let  x = 1;</p>
<p>function  f(y=x){</p>
<p>​    let x = 2;</p>
<p>​    console.log(y);</p>
<p>}</p>
<p>f()   //1</p>
<p>//函数<code>f</code>调用时，参数<code>y = x</code>形成一个单独的作用域。这个作用域里面，变量<code>x</code>本身没有定义，所以指向外层的全局变量<code>x</code>。函数调用时，函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code>。若全局变量<code>x</code>不存在，就会报错。</p>
</blockquote>
</li>
<li><p>参数<code>x = x</code>形成一个单独作用域。实际执行的是<code>let x = x</code>，由于暂时性死区的原因，这行代码会报错”x 未定义“。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = x</span>) </span>&#123;</span><br><span class="line">&gt; <span class="comment">// ...</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; foo() <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>函数的参数默认值是一个匿名函数，当函数参数形成的单独作用域里面并没有定义该变量时，该变量就会指向外层的全局变量。若函数外层并无该变量，则会报错。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>) </span>&#123; x = <span class="number">2</span>; &#125;) &#123;</span><br><span class="line">&gt; <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">&gt; y();</span><br><span class="line">&gt; <span class="built_in">console</span>.log(x);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; foo() <span class="comment">// 3</span></span><br><span class="line">&gt; x <span class="comment">// 1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>rest参数</p>
<p>​    function   函数名(…变量名){}</p>
<ul>
<li>rest参数搭配的变量是一个数组，该变量会将多余的参数放入数组中。</li>
<li>与arguments对象不同，arguments对象是一个类数组。</li>
<li>rest参数之后不能有其他参数（及只能是是最后一个参数），否则会报错。当然，函数的length属性也不包括rest参数。</li>
</ul>
</li>
<li><p>严格模式下函数参数不能使用默认值，解构赋值或拓展运算符。两种解决方法：</p>
<ul>
<li><p>设定全局式的严格模式。</p>
<blockquote>
<p>‘use strict’;</p>
<p>function (a,b=a){</p>
<p>//code</p>
<p>}</p>
</blockquote>
</li>
<li><p>把函数包在一个无参数的立即执行函数中。</p>
<blockquote>
<p>const doSomething = (function(){</p>
<p>‘use strict’;</p>
<p>return function(value = 42){</p>
<p>​    return value;</p>
<p>};</p>
<p>}())；</p>
</blockquote>
</li>
</ul>
</li>
<li><p>name属性返回函数的函数名</p>
<ul>
<li><p>如果将一个匿名函数赋值给一个变量，Es5的name属性会返回空字符串，ES6返回实际函数名。</p>
</li>
<li><p>如果将一个具名函数赋值给一个变量，两者都返回这个具名函数原本的名字。</p>
<blockquote>
<p>const  bar = function baz(){};</p>
<p>//ES5</p>
<p>bar.name        //“baz”</p>
<p>//ES6</p>
<p>bar.name     //“baz”</p>
</blockquote>
</li>
<li><p>Function构造函数返回的函数实例，name属性的值为anonymous</p>
<blockquote>
<p>(new Function).name    //“anonymous”</p>
</blockquote>
</li>
<li><p>bind返回的函数，name属性值会加上bound前缀</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&gt; foo.bind(&#123;&#125;).name <span class="comment">// "bound foo"</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name <span class="comment">// "bound "</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
</ul>
<h6 id="箭头函数（-gt-）"><a href="#箭头函数（-gt-）" class="headerlink" title="箭头函数（=&gt;）"></a>箭头函数（=&gt;）</h6><blockquote>
<p>var  f= v =&gt; v;</p>
<p>//等同于</p>
<p>var   f = function(v){</p>
<p>return   v;</p>
<p>};</p>
</blockquote>
<ul>
<li><p>由于大括号被解释为代码块，故如果箭头函数直接返回一个对象会报错，必须在对象外面加上括号；</p>
<blockquote>
<p>//报错</p>
<p>let  gettempItem = id =&gt; { id: id, name: “temp” };</p>
<p>//不报错</p>
<p>let  gettempItem = id =&gt; ({ id: id, name: “temp”})</p>
</blockquote>
</li>
<li><p>使用箭头函数注意点</p>
<ul>
<li>函数体内的this对象，也就是定义时所在的对象，而不是使用是所在的对象。this对象的指向在js中是可变的。但在箭头函数中则是固定的。</li>
<li>不可以当作构造函数，即不可使用new命令，否则会抛出一个错误。</li>
<li>不可使用arguments对象，该对象在函数体内不存在。如果要用，可用rest参数替换。也没有super，new.target</li>
<li>不可使用yield命令，因此箭头函数不能用作Generator函数。</li>
</ul>
</li>
<li><p>this指向的固定化，并不是因为内部有绑定this机制，实际原因是箭头函数没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</p>
</li>
<li><p>箭头函数不适用场景</p>
<ul>
<li><p>定义对象的方法，且该方法内部包含this。调用<code>cat.jumps()</code>时，如果是普通函数，该方法内部的<code>this</code>指向<code>cat</code>；如果写成上面那样的箭头函数，使得<code>this</code>指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致<code>jumps</code>箭头函数定义时的作用域就是全局作用域。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> cat = &#123;</span><br><span class="line">&gt; lives: <span class="number">9</span>,</span><br><span class="line">&gt; jumps: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">&gt;  <span class="keyword">this</span>.lives--;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="comment">//上面的this指向的是全局作用域，不是cat</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>需要动态this时也不应使用箭头函数。下面代码运行时，点击按钮会报错，因为<code>button</code>的监听函数是一个箭头函数，导致里面的<code>this</code>就是全局对象。如果改成普通函数，<code>this</code>就会动态指向被点击的按钮对象。</p>
<blockquote>
<p>var button = document.getElementById(‘press’);</p>
<p>button.addEventListener(‘click’,()=&gt;{</p>
<p>​    this.classList.toggle(‘on’);</p>
<p>});</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h6 id="尾调用（Tail-Call）"><a href="#尾调用（Tail-Call）" class="headerlink" title="尾调用（Tail Call）"></a>尾调用（Tail Call）</h6><ul>
<li><p>尾调用优化只在严格模式下开启，正常模式是无效的，因为正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>
<ul>
<li><p>func.arguments:返回调用时函数的那个参数。</p>
</li>
<li><p>func.caller:返回调用函数当前函数的那个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restricted</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  restricted.caller;    <span class="comment">// 报错</span></span><br><span class="line">  restricted.arguments; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line">restricted();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>尾调用是函数式编程的一个重要概念。指某个函数的最后一步是调用另一个函数。</p>
</li>
<li><p>尾调用之所以与其他调用不同就在于其调用位置。我们知道，函数调用会在内存中形成一个”调用记录“，又称“调用帧”，保存调用的位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方还会形成B的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>
</li>
<li><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
</li>
<li><p>尾调用优化，即只保留内层函数的调用帧。如果所有函数都是尾调用，就可以完全做到每次执行一次时，调用帧只有一项，这将大大节省内存。注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>
</li>
</ul>
<h6 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h6><ul>
<li><p>尾部调用自身即为尾递归。</p>
</li>
<li><p>递归是非常耗内存的，因为需要同时保存成千上万个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<blockquote>
<p>function  factorial(n,total){</p>
<p>​    if(n === 1)    return  total;</p>
<p>​    return factorial(n-1,n*total);</p>
<p>}</p>
</blockquote>
</li>
<li><p>尾调用优化的Fibonacci数列</p>
<blockquote>
<p>function  Fibonacci2(n,ac1 = 1, ac2 = 1){</p>
<p>​    if(n&lt;=1) {return   ac2};</p>
<p>​    return  Fibonacci2(n-1,ac2,ac1+ac2);</p>
<p>}</p>
</blockquote>
</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><p>Array.from()将两类对象（类数组和可便利的对象）转为真正的数组。</p>
<ul>
<li>只要是部署了Iterator接口的数据结构，Array.from就都可以将其转为真正的数组。</li>
<li>扩展运算符背后调用的是遍历器接口（Symbol.iterator),如果一个对象没有部署这个对象就无法转换。</li>
<li>类数组对象本质是有length属性，即只要有length属性的对象都可以通过Array.from方法转为数组。</li>
</ul>
<blockquote>
<p>//es5</p>
<p>var arr1 = [].slice.call(arrayLike);</p>
<p>//es6</p>
<p>let  arr2 = Array.from(arrayLike);</p>
<p>//NodeList对象</p>
<p>let  ps = document.querySelectorAll(‘p’);</p>
<p>Array.from(ps).filter(p =&gt; {</p>
<p>​    return p.textContent.length.length &gt;100;</p>
<p>});</p>
<p>//arguments对象</p>
<p>function  foo(){</p>
<p>var  args = Array.from(arguments);</p>
<p>}</p>
</blockquote>
<ul>
<li><p>对于没有部署该方法的浏览器可使用Array.prototype.slice方法替换。</p>
<blockquote>
<p>const  toArray = ( () =&gt;</p>
<p>​    Array.from ? Array.from : obj =&gt; [].slice.call(obj);</p>
<p>)( );</p>
</blockquote>
</li>
<li><p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<blockquote>
<p>Array.from(arrayLike,x =&gt; x * x);</p>
<p>Array.from(arrayLike).map( x=&gt; x*x);</p>
<p>//两者等价</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Array.of()用于将一组值转换为数组。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line">&gt; <span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line">&gt; <span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>下面代码中，<code>Array</code>方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line">&gt; <span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line">&gt; <span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>Array.prototype.copyWithin(target,stsart=0,end=this.length)</p>
<ul>
<li>数组实例的<code>copyWithin()</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</li>
</ul>
</li>
<li><p>查找</p>
<ul>
<li><p>find（）：用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找到第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。回调函数可接受三个参数，依次为当前的值，当前的位置和原数组。</p>
<blockquote>
<p>[1,2,3,10,15].find(function(value,index,arr){</p>
<p>​    return value &gt; 9;</p>
<p>})    //10</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>findIndex():返回第一个符合条件的数组成员的位置，如果都不符合则返回-1；</p>
</li>
<li><p>这两个方法都可以接受第二个参数，<strong>用于绑定回调函数的this对象。</strong></p>
<blockquote>
<p>function  f(v){</p>
<p>​    return  v &gt; this.age;</p>
<p>}</p>
<p>let  person = {name:’john’,age:20};</p>
<p>[12,15,26,42].find(f,person);     //26</p>
</blockquote>
</li>
<li><p>都可发现NaN，弥补数组中indexOf方法的不足。<code>indexOf</code>方法无法识别数组的<code>NaN</code>成员，但是<code>findIndex</code>方法可以借助<code>Object.is</code>方法做到。</p>
<blockquote>
<p>[NaN].indexOf(NaN)</p>
<p>//-1</p>
<p>[NaN].findIndex(y =&gt; Object.is(NaN,y))</p>
<p>//0</p>
</blockquote>
</li>
</ul>
</li>
<li><p>fill()使用给定值进行数组填充</p>
<ul>
<li>如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</li>
<li>fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</li>
<li>fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</li>
</ul>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>)</span><br><span class="line">&gt; <span class="comment">// [7, 7, 7]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)</span><br><span class="line">&gt; <span class="comment">// [7, 7, 7]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&gt; <span class="comment">// ['a', 7, 'c']</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>遍历数组</p>
<ul>
<li><p><code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对像，可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>
</li>
<li><p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">&gt; <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="comment">// 0 "a"</span></span><br><span class="line">&gt; <span class="comment">// 1 "b"</span></span><br><span class="line">&gt; <span class="keyword">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">&gt; <span class="keyword">let</span> entries = letter.entries();</span><br><span class="line">&gt; <span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, 'a']</span></span><br><span class="line">&gt; <span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, 'b']</span></span><br><span class="line">&gt; <span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, 'c']</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>includes()</p>
<ul>
<li><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似</p>
</li>
<li><p>该方法的第二个参数表示搜索的起始位置，默认为<code>0</code>。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为<code>-4</code>，但数组长度为<code>3</code>），则会重置为从<code>0</code>开始。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>);  <span class="comment">// false</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">-1</span>); <span class="comment">// true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>没有该方法之前，我们通常使用数组的<code>indexOf</code>方法，检查是否包含某个值.</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span> (arr.indexOf(el) !== <span class="number">-1</span>) &#123;</span><br><span class="line">&gt; <span class="comment">// ...</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; [<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line">&gt; <span class="comment">// -1</span></span><br><span class="line">&gt; [<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>)</span><br><span class="line">&gt; <span class="comment">// true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>indexOf</code>方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于<code>-1</code>，表达起来不够直观。二是，它内部使用严格相等运算符（<code>===</code>）进行判断，这会导致对<code>NaN</code>的误判。</li>
</ul>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> contains = <span class="function">(<span class="params">(</span>) =&gt;</span></span><br><span class="line">&gt; <span class="built_in">Array</span>.prototype.includes</span><br><span class="line">&gt;  ? <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.includes(value)</span><br><span class="line">&gt;  : <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.some(<span class="function"><span class="params">el</span> =&gt;</span> el === value)</span><br><span class="line">&gt; )();</span><br><span class="line">&gt; contains([<span class="string">'foo'</span>, <span class="string">'bar'</span>], <span class="string">'baz'</span>); <span class="comment">// =&gt; false</span></span><br><span class="line">&gt; <span class="comment">//简易的替代版本。</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>另外，Map 和 Set 数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p>
<ul>
<li>Map 结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li>
<li>Set 结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>flat()和flatMap（）</p>
<ul>
<li><p>数组的成员有时还是数组，<code>Array.prototype.flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p>
</li>
<li><p><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为</p>
</li>
<li><p>可以用<code>Infinity</code>关键字作为参数。</p>
</li>
<li><p>如果原数组有空位，<code>flat()</code>方法会跳过空位。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].flat()</span><br><span class="line">&gt; <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>)</span><br><span class="line">&gt; <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">&gt; [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="literal">Infinity</span>)</span><br><span class="line">&gt; <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>].flat()</span><br><span class="line">&gt; <span class="comment">// [1, 2, 4, 5]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>flatMap()</code>方法对原数组的每个成员执行一个函数（相当于执行<code>Array.prototype.map()</code>），然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组。<code>flatMap()</code>只能展开一层数组。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">&gt; [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line">&gt; <span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br><span class="line">&gt; <span class="comment">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]])</span><br><span class="line">&gt; <span class="comment">// [[2], [4], [6], [8]]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>flatMap()</code>方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。<code>flatMap()</code>方法还可以有第二个参数，用来绑定遍历函数里面的<code>this</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; arr.flatMap(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>) </span>&#123;</span><br><span class="line">&gt; <span class="comment">// ...</span></span><br><span class="line">&gt; &#125;[, thisArg])</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>数组中的空位</p>
<ul>
<li><p>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p>
</li>
<li><blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>] <span class="comment">// true</span></span><br><span class="line">&gt; <span class="number">0</span> <span class="keyword">in</span> [, , ,] <span class="comment">// false</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位.</p>
<ul>
<li><code>forEach()</code>, <code>filter()</code>, <code>reduce()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位。</li>
<li><code>map()</code>会跳过空位，但会保留这个值</li>
<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li>
</ul>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// forEach方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].forEach(<span class="function">(<span class="params">x,i</span>) =&gt;</span> <span class="built_in">console</span>.log(i)); <span class="comment">// 1</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// filter方法</span></span><br><span class="line">&gt; [<span class="string">'a'</span>,,<span class="string">'b'</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// ['a','b']</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// every方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x===<span class="string">'a'</span>) <span class="comment">// true</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// reduce方法</span></span><br><span class="line">&gt; [<span class="number">1</span>,,<span class="number">2</span>].reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y) <span class="comment">// 3</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// some方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].some(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">'a'</span>) <span class="comment">// false</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// map方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [,1]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// join方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].join(<span class="string">'#'</span>) <span class="comment">// "#a##"</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// toString方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].toString() <span class="comment">// ",a,,"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p>
</li>
<li><p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p>
</li>
<li><p><code>copyWithin()</code>会连空位一起拷贝。</p>
</li>
<li><p><code>fill()</code>会将空位视为正常的数组位置。</p>
</li>
<li><p><code>for...of</code>循环也会遍历空位.</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Array</span>.from([<span class="string">'a'</span>,,<span class="string">'b'</span>])</span><br><span class="line">&gt; <span class="comment">// [ "a", undefined, "b" ]</span></span><br><span class="line">&gt; [...[<span class="string">'a'</span>,,<span class="string">'b'</span>]]</span><br><span class="line">&gt; <span class="comment">// [ "a", undefined, "b" ]</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>,<span class="string">'b'</span>,,].copyWithin(<span class="number">2</span>,<span class="number">0</span>) <span class="comment">// [,"a",,"a"]</span></span><br><span class="line">&gt; <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">'a'</span>) <span class="comment">// ["a","a","a"]</span></span><br><span class="line">&gt; <span class="keyword">let</span> arr = [, ,];</span><br><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">&gt; <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="comment">// 1</span></span><br><span class="line">&gt; <span class="comment">// 1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// entries()</span></span><br><span class="line">&gt; [...[,<span class="string">'a'</span>].entries()] <span class="comment">// [[0,undefined], [1,"a"]]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// keys()</span></span><br><span class="line">&gt; [...[,<span class="string">'a'</span>].keys()] <span class="comment">// [0,1]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// values()</span></span><br><span class="line">&gt; [...[,<span class="string">'a'</span>].values()] <span class="comment">// [undefined,"a"]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// find()</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].find(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// undefined</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// findIndex()</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// 0</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h4><h6 id="属性遍历"><a href="#属性遍历" class="headerlink" title="属性遍历"></a>属性遍历</h6><ul>
<li><p><strong>for…in</strong>:遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
</li>
<li><p><strong>Object.keys(obj)</strong>：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
</li>
<li><p><strong>Object.getOwnPropertyNames(obj)</strong>：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
</li>
<li><p><strong>Object.getOwnPropertySymbols(obj)</strong>：返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
</li>
<li><p><strong>Reflect.ownKeys(obj)</strong>：返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
</li>
<li><p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>
</ul>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Reflect</span>.ownKeys(&#123; [<span class="built_in">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span> &#125;)</span><br><span class="line">&gt; <span class="comment">// ['2', '10', 'b', 'a', Symbol()]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h6 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h6><ul>
<li><p>this关键字总是指向函数所在的当前对象，关键字super则是指向当前对象的原型对象，super只能用在对象的方法中，用在其他地方会报错。</p>
</li>
<li><p>JavaScript 引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。</p>
<blockquote>
<p>const  proto ={foo:’hello’};</p>
<p>const obj = {</p>
<p>​    foo:’world’,</p>
<p>​    find(){</p>
<p>​    return super.foo;</p>
<p>​    }</p>
<p>}</p>
<p>Object.setPrototypeOf(obj,proto);</p>
<p>obj.find();    //“hello”</p>
<p>//报错</p>
<p>const  obj = {foo:super.foo;    //对象的属性}</p>
<p>//只有对象方法的简写式才可以被js引擎确认定义的是对象的方法。</p>
<p>//以下两种都报错报错</p>
<p>const   obj = {</p>
<p>​    foo:() =&gt; super.foo</p>
<p>}</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> obj = &#123;</span><br><span class="line">&gt; foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;  <span class="keyword">return</span> <span class="keyword">super</span>.foo</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  x: <span class="string">'hello'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  x: <span class="string">'world'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// "world"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code>。</p>
<h6 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h6><ul>
<li>扩展运算符的解构赋值，不能复制继承自原型对象的属性。</li>
</ul>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">&gt; <span class="keyword">let</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&gt; o2.__proto__ = o1;</span><br><span class="line">&gt; <span class="keyword">let</span> &#123; ...o3 &#125; = o2;</span><br><span class="line">&gt; o3 <span class="comment">// &#123; b: 2 &#125;</span></span><br><span class="line">&gt; o3.a <span class="comment">// undefined</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="对象新增方法"><a href="#对象新增方法" class="headerlink" title="对象新增方法"></a>对象新增方法</h4><ul>
<li><p>Object.is():在所有环境中，只要两个值是一样的，他们就相等</p>
<ul>
<li><p>与严格相等（===）功能差不多，但是弥补了NaN不等于自身的缺陷。</p>
</li>
<li><p>+0不等于-0</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Object</span>.is(<span class="string">'foo'</span>, <span class="string">'foo'</span>)</span><br><span class="line">&gt; <span class="comment">// true</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)</span><br><span class="line">&gt; <span class="comment">// false</span></span><br><span class="line">&gt; +<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></span><br><span class="line">&gt; <span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>Object.assign()用于对象的合并，将源对象的所有可枚举属性，复制到目标对象。</p>
<ul>
<li><p><code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p>
</li>
<li><p>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
</li>
<li><p>如果只有一个参数，<code>Object.assign</code>会直接返回该参数。</p>
</li>
<li><p>如果该参数不是对象，则会先转成对象，然后返回。由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。</p>
</li>
<li><blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&gt; <span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">&gt; target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(obj) === obj <span class="comment">// true</span></span><br><span class="line">&gt; <span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">2</span>) <span class="comment">// "object"</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(<span class="literal">undefined</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(<span class="literal">null</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。因为只有字符串的包装对象，会产生可枚举属性。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(obj, <span class="literal">undefined</span>) === obj <span class="comment">// true</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(obj, <span class="literal">null</span>) === obj <span class="comment">// true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> v1 = <span class="string">'abc'</span>;</span><br><span class="line">&gt; <span class="keyword">const</span> v2 = <span class="literal">true</span>;</span><br><span class="line">&gt; <span class="keyword">const</span> v3 = <span class="number">10</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">const</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, v2, v3);</span><br><span class="line">&gt; <span class="built_in">console</span>.log(obj); <span class="comment">// &#123; "0": "a", "1": "b", "2": "c" &#125;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="数组中的遍历"><a href="#数组中的遍历" class="headerlink" title="数组中的遍历"></a>数组中的遍历</h4><ul>
<li><p>reduce求和,求平均值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce((tmp,item,index) =&gt; &#123; </span><br><span class="line">	//tmp是一个前一次的总和</span><br><span class="line">	//item是第几个数的值</span><br><span class="line">	//index是下标值，因第一个tmp是第一个arr[0],所以index是从1开始</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>map  映射</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.map((item) =&gt; &#123;</span><br><span class="line">	//item是第几个数的值</span><br><span class="line">	return item*2;</span><br><span class="line">&#125;);</span><br><span class="line">arr.map(item =&gt; item*2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>filter过滤器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr.filter(item =&gt; &#123;</span><br><span class="line">	//返回true者留下，返回false消失</span><br><span class="line">	if(item % 3 == 0)&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">//相当于</span><br><span class="line">arr.filter(item =&gt; item%3 == 0);</span><br></pre></td></tr></table></figure>
</li>
<li><p>forEach   循环迭代</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach( (item,index) =&gt; &#123;</span><br><span class="line">	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="字符串新增方法-1"><a href="#字符串新增方法-1" class="headerlink" title="字符串新增方法"></a>字符串新增方法</h4><ul>
<li>startsWith:检测str是否以某些字符的开头</li>
<li>endsWith：检测str是否以某个字符的结尾</li>
<li>字符串模板 ：${变量}</li>
</ul>
<h4 id="面向对象class类"><a href="#面向对象class类" class="headerlink" title="面向对象class类"></a>面向对象class类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class User&#123;</span><br><span class="line">	constructor(name,pass)&#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.pass = pass;</span><br><span class="line">	&#125;</span><br><span class="line">	showName()&#123;</span><br><span class="line">		alert(this.name);//不可以使用function，不用加逗号，表示属性，而非方法</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>class关键字，构造器和类分开</p>
</li>
<li><p>class里面直接加方法</p>
</li>
</ol>
<h6 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h6><p>老版写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function User(name,pass)&#123;</span><br><span class="line">           this.name = name;</span><br><span class="line">           this.pass = pass;</span><br><span class="line">       &#125; </span><br><span class="line">       User.prototype.showName = function()&#123;</span><br><span class="line">           alert(this.name);</span><br><span class="line">       &#125;</span><br><span class="line">       User.prototype.showPass = function()&#123;</span><br><span class="line">           alert(this.pass);</span><br><span class="line">       &#125;</span><br><span class="line">       function vipUser(name,pass,level)&#123;</span><br><span class="line">           User.call(this,name,pass);</span><br><span class="line">           this.level = level;</span><br><span class="line">       &#125;</span><br><span class="line">      vipUser.prototype = new User();</span><br><span class="line">      vipUser.prototype.constructor = vipUser;</span><br><span class="line">       vipUser.prototype.showlevel = function()&#123;</span><br><span class="line">           alert(this.level);</span><br><span class="line">       &#125;;</span><br><span class="line">       var v1 = new vipUser(&apos;blue&apos;,&apos;12345&apos;,10);</span><br><span class="line">       v1.showName();</span><br><span class="line">       v1.showlevel();</span><br></pre></td></tr></table></figure>

<p>super——超类，就相当于父类</p>
<p>extends——继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class User&#123;</span><br><span class="line">     constructor(name,pass)&#123;</span><br><span class="line">         this.name = name;</span><br><span class="line">         this.pass = pass;</span><br><span class="line">     &#125;</span><br><span class="line">     showName()&#123;</span><br><span class="line">         alert(this.name);</span><br><span class="line">     &#125;</span><br><span class="line">     showPass()&#123;</span><br><span class="line">         alert(this.pass);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> class VipUser extends User&#123;</span><br><span class="line">     constructor(name,pass,level)&#123;</span><br><span class="line">         super(name,pass);</span><br><span class="line">         this.level = level;</span><br><span class="line">     &#125;</span><br><span class="line">     showLevel()&#123;</span><br><span class="line">         alert(this.level);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> var v1 = new VipUser(&apos;nikita&apos;,&apos;15243&apos;,10);</span><br><span class="line"> v1.showName();</span><br><span class="line"> v1.showLevel();</span><br></pre></td></tr></table></figure>

<h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><h6 id="标准写法："><a href="#标准写法：" class="headerlink" title="标准写法："></a>标准写法：</h6><ul>
<li>只能用双引号。</li>
<li>所有名字都必须用引号包起来。</li>
</ul>
<h6 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h6><ul>
<li><p>字符串化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(&#123;&quot;a&quot;:12,&quot;name&quot;:&quot;nikita&quot;&#125;);</span><br><span class="line">//&quot;&#123;&quot;a&quot;:12,&quot;name&quot;:&quot;nikita&quot;&#125;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解析为一个json对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(&#123;&quot;a&quot;:12,&quot;name&quot;:&quot;nikita&quot;&#125;)；</span><br><span class="line">//&#123;name: &quot;nikita&quot;, age: 12&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Promise（消除异步操作）"><a href="#Promise（消除异步操作）" class="headerlink" title="Promise（消除异步操作）"></a>Promise（消除异步操作）</h4><ul>
<li><p>Promise对象只有三种状态：peding(进行中)，fulfilled（已成功），rejected（已失败）。</p>
</li>
<li><p>Promise实例具有then方法，then返回一个新的Promise实例。Promise对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch</code>方法指定的回调函数，处理这个错误。另外，<code>then</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch</code>方法捕获。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))</span><br><span class="line">  .catch((err) =&gt; console.log(&apos;rejected&apos;, err));</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))</span><br><span class="line">  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));</span><br></pre></td></tr></table></figure>
</li>
<li><p>用同步一样的方式来书写异步代码。接收一个含resolve和reject的函数参数。</p>
</li>
<li><p>resolve——解决，即成功    reject——拒绝，即失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise(function(resolve,reject)&#123;</span><br><span class="line">	//异步代码</span><br><span class="line">	$.ajax(&#123;</span><br><span class="line">		url:&apos;arr.txt&apos;,</span><br><span class="line">		dataType:&apos;json&apos;,</span><br><span class="line">		success(arr)&#123;</span><br><span class="line">			resolve(arr);</span><br><span class="line">		&#125;,</span><br><span class="line">		error(err)&#123;</span><br><span class="line">			reject(err);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;);</span><br><span class="line">//then函数有两个参数，一个是成功的回调函数，一个是失败的回调函数</span><br><span class="line">p.then(function()&#123;</span><br><span class="line">	alert(&apos;成功了&apos;);</span><br><span class="line">&#125;,function()&#123;</span><br><span class="line">	alert(&apos;失败了&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//若有两个Promise对象，可使用Promise.all进行全部处理</span><br><span class="line">//其中的arr是p1和p2中的数据</span><br><span class="line">function createPromise(url)&#123;</span><br><span class="line">	return new Promise(function(resolve,reject)&#123;</span><br><span class="line">		$.ajax(&#123;</span><br><span class="line">		url,</span><br><span class="line">		dataType:&apos;json&apos;,</span><br><span class="line">		 success(arr)&#123;</span><br><span class="line">			resolve(arr);</span><br><span class="line">		 &#125;,</span><br><span class="line">		 error(err)&#123;</span><br><span class="line">		 	reject(err);</span><br><span class="line">		 &#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">Promise.all([</span><br><span class="line">	createPromise(&apos;data/arr.txt&apos;),</span><br><span class="line">	createPromise(&apos;data/json.txt&apos;)</span><br><span class="line">]).then(function(arr)&#123;</span><br><span class="line">	//解构赋值</span><br><span class="line">	let [res1,res2] = arr;</span><br><span class="line">	alert(&apos;全部成功&apos;)</span><br><span class="line">&#125;,function()&#123;</span><br><span class="line">	alert(&apos;至少有一个失败&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>高版本jquery也封装了promise对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([</span><br><span class="line">	$.ajax(&#123;url:&apos;data/arr.txt&apos;,dataType:&apos;json&apos;&#125;),</span><br><span class="line">	$.ajax(&#123;url:&apos;data/json.txt&apos;,dataType:&apos;json&apos;&#125;)</span><br><span class="line">]).then(function(results)&#123;</span><br><span class="line">	let [arr,json] = results;</span><br><span class="line">	alert(&apos;成功了&apos;);</span><br><span class="line">&#125;,function(err)&#123;</span><br><span class="line">	alert(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise.race        竞速，即先到先执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Promise.race([</span><br><span class="line">	$.ajax(&#123;url:&apos;http://a2.taobai.com/data/users&apos;&#125;)</span><br><span class="line">	$.ajax(&#123;ur4:&apos;http://a2.taobai.com/data/users&apos;&#125;)</span><br><span class="line">	$.ajax(&#123;ur7:&apos;http://a2.taobai.com/data/users&apos;&#125;)</span><br><span class="line">	$.ajax(&#123;ur2:&apos;http://a2.taobai.com/data/users&apos;&#125;)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h6><ul>
<li>该方法为不管Promise对象最后如何，都会执行的代码。</li>
</ul>
<p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.listen(port)</span><br><span class="line">  .then(function () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure>

<h6 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h6><ul>
<li><p>用于将多个Promise实力包装为一个新的Promise实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>

<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>
<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>
<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 生成一个Promise对象的数组</span><br><span class="line">const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123;</span><br><span class="line">  return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all(promises).then(function (posts) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;).catch(function(reason)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="Fetch-API是js接口"><a href="#Fetch-API是js接口" class="headerlink" title="Fetch API是js接口"></a>Fetch API是js接口</h6><ul>
<li>用于访问和操作HTTP管道的部分，例如请求和响应。</li>
</ul>
<h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><ul>
<li><p>是ES6提供的一种异步编程解决方案，是一个状态机，封装了很多内部状态。执行Generator函数会返回一个遍历器对象，说明Generator函数同时还是一个遍历器对象生成函数，返回的遍历器对象可以一次遍历每个状态。</p>
</li>
<li><p>特征           *             yield</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function* test(value1)&#123;</span><br><span class="line">	let value2 = yield value1;   </span><br><span class="line">	let value3 = yield value2;</span><br><span class="line">	return value3;</span><br><span class="line">&#125;</span><br><span class="line">//第一个yield后的值是传入的参数，第二个是第二个next方法传入的...</span><br><span class="line">var hw = test(1);</span><br><span class="line">hw.next(5);</span><br><span class="line">//第一个next传入的参数无效，不管test有无传参</span><br><span class="line">//&#123;value:1,done:false&#125;</span><br><span class="line">hw.next(7)</span><br><span class="line">//&#123;value:7,done:false&#125;</span><br><span class="line">hw.next(9)</span><br><span class="line">//&#123;value:9,done:true&#125;</span><br></pre></td></tr></table></figure>

<p>调用test函数时，该函数并未执行，而是返回一个指向内部状态的指针对象。而调用该函数的next方法则是将指针移向下一个状态，next有位置记忆功能，故每次调用next方法时，都从上一次停下来的地方执行，直到下一个yield或return为止。return与yield功能相似，但return无位置记忆功能，且每个函数只能有一个return语句。且将return语句后面的表达式作为对象的value属性值，若无return，则返回undefined</p>
<p>当Generator函数运行完毕，但还使用next方法时，返回{value:undefined,done:true},便是遍历已结束。</p>
</li>
<li><p>next的参数表示上一个yield表达式的返回值，所以第一个next传递参数是无效的。</p>
</li>
<li><p>yield表达式若用在另一表达式中，必须放在圆括号内。</p>
</li>
<li><p>yield若用作函数参数或放在赋值表达式的右边，可不加括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;hello&apos; + (yield 123));</span><br><span class="line">function* demo()&#123;</span><br><span class="line">foo(yield &apos;a&apos;,yield &apos;b&apos;);</span><br><span class="line">let input = yield;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="与Symbol-iterator的关系"><a href="#与Symbol-iterator的关系" class="headerlink" title="与Symbol.iterator的关系"></a>与Symbol.iterator的关系</h6><ul>
<li>任意一个对象的Symbol.iterator方法等同于该对象的遍历器生成函数。把Generator赋值给对象的Symbol.iterator属性，可使该对象具有Iterator接口。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var myIterable = &#123;&#125;;</span><br><span class="line">myIterable[Symbol.iterator] = function* ()&#123;</span><br><span class="line">	yield 1;</span><br><span class="line">	yield 2;</span><br><span class="line">&#125;</span><br><span class="line">[...myIterable]   //1,2</span><br></pre></td></tr></table></figure>

<ul>
<li>Generator函数执行后返回一个遍历器对象，该对象本身具有iterator接口，执行后返回自身。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function* gen()&#123;&#125;</span><br><span class="line">var g = gen();</span><br><span class="line">g[Symbol.iterator] === g</span><br><span class="line">//true</span><br></pre></td></tr></table></figure>

<h6 id="原生js对象添加Iterator接口的方法"><a href="#原生js对象添加Iterator接口的方法" class="headerlink" title="原生js对象添加Iterator接口的方法"></a>原生js对象添加Iterator接口的方法</h6><ul>
<li><p>除了<code>for...of</code>循环以外，扩展运算符（<code>...</code>）、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。</p>
</li>
<li><p>原生js对象没有遍历接口，无法使用for…of循环，可通过generator函数为其加上接口便可使用。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function* objectEntries(obj)&#123;</span><br><span class="line">	let propKeys = Reflect.ownKeys(obj);//将obj对象转为数组</span><br><span class="line">	for(let propKey of propKeys)&#123;</span><br><span class="line">		yield [propkey,obj[propKey]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let jane = &#123; first: &apos;Jane&apos;, last: &apos;Doe&apos; &#125;;</span><br><span class="line"></span><br><span class="line">for (let [key, value] of objectEntries(jane)) &#123;</span><br><span class="line">  console.log(`$&#123;key&#125;: $&#123;value&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">// first: Jane</span><br><span class="line">// last: Doe</span><br></pre></td></tr></table></figure>

<ul>
<li>将Generator函数加到对象的symbol.irerator属性上。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* objectEntries() &#123;</span><br><span class="line">  let propKeys = Object.keys(this);</span><br><span class="line"></span><br><span class="line">  for (let propKey of propKeys) &#123;</span><br><span class="line">    yield [propKey, this[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let jane = &#123; first: &apos;Jane&apos;, last: &apos;Doe&apos; &#125;;</span><br><span class="line"></span><br><span class="line">jane[Symbol.iterator] = objectEntries;</span><br><span class="line"></span><br><span class="line">for (let [key, value] of jane) &#123;</span><br><span class="line">  console.log(`$&#123;key&#125;: $&#123;value&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">// first: Jane</span><br><span class="line">// last: Doe</span><br></pre></td></tr></table></figure>

<h6 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw"></a>Generator.prototype.throw</h6><ul>
<li>Generator函数返回的遍历器对象都有一个throw方法，可在函数体外抛出错误，然后在Generator函数体内捕获。</li>
</ul>
<h6 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return"></a>Generator.prototype.return</h6><ul>
<li>Generator 函数返回的遍历器对象，还有一个<code>return</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。</li>
<li>如果 Generator 函数内部有<code>try...finally</code>代码块，且正在执行<code>try</code>代码块，那么<code>return</code>方法会导致立刻进入<code>finally</code>代码块，执行完以后，整个函数才会结束。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* numbers () &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  try &#123;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield 3;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    yield 4;</span><br><span class="line">    yield 5;</span><br><span class="line">  &#125;</span><br><span class="line">  yield 6;</span><br><span class="line">&#125;</span><br><span class="line">var g = numbers();</span><br><span class="line">g.next() // &#123; value: 1, done: false &#125;</span><br><span class="line">g.next() // &#123; value: 2, done: false &#125;</span><br><span class="line">g.return(7) // &#123; value: 4, done: false &#125;</span><br><span class="line">g.next() // &#123; value: 5, done: false &#125;</span><br><span class="line">g.next() // &#123; value: 7, done: true &#125;</span><br></pre></td></tr></table></figure>

<h6 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield*表达式"></a>yield*表达式</h6><ul>
<li><p>yield*表达式返回一个表遍历器对象。</p>
</li>
<li><p>如果Generator函数内部调用另一个Generator函数需要在前者函数体内，利用for..of手动完成遍历。若不想手动，则可利用yield*</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function* bar() &#123;</span><br><span class="line">  yield &apos;x&apos;;</span><br><span class="line">  yield* foo();</span><br><span class="line">  yield &apos;y&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function* bar() &#123;</span><br><span class="line">  yield &apos;x&apos;;</span><br><span class="line">  yield &apos;a&apos;;</span><br><span class="line">  yield &apos;b&apos;;</span><br><span class="line">  yield &apos;y&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function* bar() &#123;</span><br><span class="line">  yield &apos;x&apos;;</span><br><span class="line">  for (let v of foo()) &#123;</span><br><span class="line">    yield v;</span><br><span class="line">  &#125;</span><br><span class="line">  yield &apos;y&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let v of bar())&#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;x&quot;</span><br><span class="line">// &quot;a&quot;</span><br><span class="line">// &quot;b&quot;</span><br><span class="line">// &quot;y&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>yield和yield*都只能放在Generator函数中，不能放在普通函数里。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//遍历嵌套数组</span><br><span class="line">var arr = [1,[[2,3],4],[5,6]];</span><br><span class="line">var flag = function* (a)&#123;</span><br><span class="line">    var length = a.length;</span><br><span class="line">    for(let i = 0;i &lt; length;i++)&#123;</span><br><span class="line">        var item = a[i];</span><br><span class="line">        if(typeof item != &apos;number&apos;)&#123;</span><br><span class="line">            yield* flag(item);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            yield item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(var f of flag(arr))&#123;</span><br><span class="line">    console.log(f);</span><br><span class="line">&#125;</span><br><span class="line">// 1, 2, 3, 4, 5, 6</span><br></pre></td></tr></table></figure>

<h6 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h6><ul>
<li>传统的编程语言早就有异步编程的解决方案，即多任务的解决方案。其中一种就是协程，意思是多个线程相互协作，完成异步操作。<ul>
<li>第一步，协程<code>A</code>开始执行。</li>
<li>第二步，协程<code>A</code>执行到一半，进入暂停，执行权转移到协程<code>B</code>。</li>
<li>第三步，（一段时间后）协程<code>B</code>交还执行权。</li>
<li>第四步，协程<code>A</code>恢复执行。</li>
</ul>
</li>
<li>异步任务的封装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var fetch = require(&apos;node-fetch&apos;);</span><br><span class="line">function* gen()&#123;</span><br><span class="line">    var url = &apos;http://api.github.com/users/github&apos;;</span><br><span class="line">    var result = yield fetch(url);</span><br><span class="line">    console.log(result.bio);</span><br><span class="line">&#125;</span><br><span class="line">var g = gen();</span><br><span class="line">var result = g.next();</span><br><span class="line">result.value.then(function(data)&#123;</span><br><span class="line">  return data.json();</span><br><span class="line">&#125;).then(function(data)&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br><span class="line">//How people build software.</span><br></pre></td></tr></table></figure>

<h6 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h6><ul>
<li>Thunk函数时自动执行Generator函数的一种方法。</li>
<li>参数求值策略有“传值调用”和”传名调用”两种，Thunk函。编译器的“传名调用”实现，往往是将参数放到一个临时函数中，再将这个临时函数传入函数体中，这个函数体即为Thunk函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function f(m)&#123;return m*2;&#125;</span><br><span class="line">f(x+5);</span><br><span class="line">//等同于</span><br><span class="line">vat thunk = function()&#123; return x+5; &#125;</span><br><span class="line">function f(thunk)&#123; return thunk()*2; &#125;</span><br><span class="line"></span><br><span class="line">//Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</span><br><span class="line">// 正常版本的readFile（多参数版本）</span><br><span class="line">fs.readFile(fileName, callback);</span><br><span class="line"></span><br><span class="line">// Thunk版本的readFile（单参数版本）</span><br><span class="line">var Thunk = function (fileName) &#123;</span><br><span class="line">  return function (callback) &#123;</span><br><span class="line">    return fs.readFile(fileName, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var readFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br></pre></td></tr></table></figure>

<h6 id="Thunkify模块"><a href="#Thunkify模块" class="headerlink" title="Thunkify模块"></a>Thunkify模块</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const thunkify = require(&apos;thunkify&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">let read = thunkify(fs.readFile);</span><br><span class="line">read(&apos;package.json&apos;)(function(err,data)&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="co模块"><a href="#co模块" class="headerlink" title="co模块"></a>co模块</h6><ul>
<li><p>co模块让你不用编写Generator函数的执行器，Generator函数只要传入co函数即可执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var co = require(&apos;co&apos;);</span><br><span class="line">co(generator);//返回一个promise对象，故可用then方法添加回调函数</span><br><span class="line">co.then(function()&#123;&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>co模块的原理</strong></p>
<p>为什么 co 可以自动执行 Generator 函数？</p>
<p>前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>
<p>两种方法可以做到这一点。</p>
<p>（1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</p>
<p>（2）Promise 对象。将异步操作包装成 Promise 对象，用<code>then</code>方法交回执行权。</p>
<p>co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的<code>yield</code>命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co。</p>
<p><strong>基于Promise对象的自动执行</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">let readFile = function (fileName)&#123;</span><br><span class="line">    return new Promise(function (resolve,reject)&#123;</span><br><span class="line">        fs.readFile(fileName,function(err,data)&#123;</span><br><span class="line">            if(err) return reject(err);</span><br><span class="line">            return resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">var gen = function* ()&#123;</span><br><span class="line">    let f1 = yield readFile(&apos;1.txt&apos;);</span><br><span class="line">    let f2 = yield readFile(&apos;2.txt&apos;);</span><br><span class="line">    console.log(f1.toString());</span><br><span class="line">    console.log(f2.toString());</span><br><span class="line">&#125;</span><br><span class="line">function run(gen)&#123;</span><br><span class="line">    var g = gen();</span><br><span class="line">    function next(data)&#123;</span><br><span class="line">        var result = g.next(data);</span><br><span class="line">        if(result.done) return result.value;</span><br><span class="line">        result.value.then(function(data)&#123;</span><br><span class="line">            next(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>

<h4 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h4><ul>
<li>引入async函数，使异步操作更方便。跟Generator函数类似，只需将*改为ansyc，yield改为await。</li>
<li><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</li>
</ul>
<h6 id="ansyc较Generator函数的优点"><a href="#ansyc较Generator函数的优点" class="headerlink" title="ansyc较Generator函数的优点"></a>ansyc较Generator函数的优点</h6><ul>
<li>内置执行器。Generator函数的执行必须靠执行器，才co模块，而async函数自带执行器。即async函数的执行与普通函数一样，使用函数名调用即可。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">let readFile = function (fileName)&#123;</span><br><span class="line">    return new Promise(function (resolve,reject)&#123;</span><br><span class="line">        fs.readFile(fileName,function(err,data)&#123;</span><br><span class="line">            if(err) return reject(err);</span><br><span class="line">            return resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//generator函数需要再封装一个run函数自执行</span><br><span class="line">// var gen = function* ()&#123;</span><br><span class="line">//     let f1 = yield readFile(&apos;1.txt&apos;);</span><br><span class="line">//     let f2 = yield readFile(&apos;2.txt&apos;);</span><br><span class="line">//     console.log(f1.toString());</span><br><span class="line">//     console.log(f2.toString());</span><br><span class="line">// &#125;</span><br><span class="line">// function run(gen)&#123;</span><br><span class="line">//     var g = gen();</span><br><span class="line">//     function next(data)&#123;</span><br><span class="line">//         var result = g.next(data);</span><br><span class="line">//         if(result.done) return result.value;</span><br><span class="line">//         result.value.then(function(data)&#123;</span><br><span class="line">//             next(data);</span><br><span class="line">//         &#125;)</span><br><span class="line">//     &#125;</span><br><span class="line">//     next();</span><br><span class="line">// &#125;</span><br><span class="line">// run(gen)</span><br><span class="line"></span><br><span class="line">//async函数有内置执行器</span><br><span class="line">const asyncReadFile = async function()&#123;</span><br><span class="line">    const f1 = await readFile(&apos;1.txt&apos;);</span><br><span class="line">    const f2 = await readFile(&apos;2.txt&apos;);</span><br><span class="line">    console.log(f1.toString());</span><br><span class="line">    console.log(f2.toString());</span><br><span class="line">&#125;</span><br><span class="line">asyncReadFile()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>更好的语义    </p>
<ul>
<li>async：异步</li>
<li>await表示紧跟在后面的表达式需要等待结果</li>
</ul>
</li>
<li><p>更广的适应性。</p>
<ul>
<li>co模块约定，yield命令后面只能是Thunk函数或Promise’对象，而async函数的await命令后面可以是Promise对象和原始类型的值（number，string，boolean，但这时会转为立即resolved的promise对象）。</li>
</ul>
</li>
<li><p>返回值是 Promise。</p>
<p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>
<p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p>
</li>
</ul>
<h6 id="async使用形式"><a href="#async使用形式" class="headerlink" title="async使用形式"></a>async使用形式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">async function foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">const foo = async function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 对象的方法</span><br><span class="line">let obj = &#123; async foo() &#123;&#125; &#125;;</span><br><span class="line">obj.foo().then(...)</span><br><span class="line"></span><br><span class="line">// Class 的方法</span><br><span class="line">class Storage &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.cachePromise = caches.open(&apos;avatars&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async getAvatar(name) &#123;</span><br><span class="line">    const cache = await this.cachePromise;</span><br><span class="line">    return cache.match(`/avatars/$&#123;name&#125;.jpg`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const storage = new Storage();</span><br><span class="line">storage.getAvatar(&apos;jake&apos;).then(…);</span><br><span class="line"></span><br><span class="line">// 箭头函数</span><br><span class="line">const foo = async () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>async函数内部return语句返回的值会成为then方法回调函数的参数。</strong></p>
<p><strong>async函数抛出的错误会导致返回的Promise对象变为reject状态。抛出的错误会被catch方法回调函数接收到。</strong>‘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function f(flag)&#123;</span><br><span class="line">    if(flag) throw new Error(&apos;出错了&apos;);</span><br><span class="line">    return &apos;hello&apos;;</span><br><span class="line">&#125;</span><br><span class="line">f(false).then(</span><br><span class="line">    v =&gt; console.log(v),</span><br><span class="line">    e =&gt; console.log(e)</span><br><span class="line">)</span><br><span class="line">//hello</span><br><span class="line">//当flag为true时，返回’出错了‘</span><br></pre></td></tr></table></figure>

<ul>
<li>async函数返回的Promise对象必须等到内部所有await命令后面的Promise对象执行完毕才会发生状态改变，除非遇到return语句或抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</li>
</ul>
<h6 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h6><ul>
<li><p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p>
</li>
<li><p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p>
</li>
<li><p>任何一个await语句后面的Promise对象变为reject状态，那么整个async函数就都会中断执行。</p>
<ul>
<li>要想不中断，可将其放入try…catch结构中。</li>
<li>或者在await后面的Promise对象再跟一个catch方法，处理前面可能出现的错误。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">async function f()&#123;</span><br><span class="line">	try&#123;</span><br><span class="line">		await Promise.reject(&apos;出错了&apos;);</span><br><span class="line">	&#125;catch(e)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	return await Promise.resolve(&apos;hello&apos;);</span><br><span class="line">&#125;</span><br><span class="line">f().then(v =&gt; &#123; console.log(v)&#125;);//hello</span><br><span class="line"></span><br><span class="line">async function f()&#123;</span><br><span class="line">	await Promise.reject(&apos;出错了&apos;)</span><br><span class="line">	.catch(e =&gt; &#123;console.log(e);&#125;);</span><br><span class="line">	return await Promise.resolve(&apos;hello&apos;)</span><br><span class="line">&#125;</span><br><span class="line">f().then(v =&gt; &#123; console.log(v)&#125;);</span><br><span class="line">//出错了</span><br><span class="line">//hello</span><br><span class="line"></span><br><span class="line">async function f() &#123;</span><br><span class="line">  await new Promise(function (resolve, reject) &#123;</span><br><span class="line">    throw new Error(&apos;出错了&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(v =&gt; console.log(v))</span><br><span class="line">.catch(e =&gt; console.log(e))</span><br><span class="line">// Error：出错了</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h4><ul>
<li>生成实例对象的传统方法是通过构造函数，引入class类概念，利用constructor构造方法创建实例，类中方法不需要加function，毗邻方法间不许用逗号相隔，加了会报错。在类实例上调用方法其实就是调用原型上的方法。</li>
<li>prototype对象的constructor属性，直接指向类本身，与ES5相似。constructor是类的默认方法，无显式指定时会模认自动生成。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class B&#123;</span><br><span class="line">	constructor()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">let b = new B();</span><br><span class="line">b.constructor === B.prototype.constructor  //true</span><br><span class="line">B.prototype.constructor === B    //true</span><br></pre></td></tr></table></figure>

<ul>
<li>由于类的方法都定义在prototype对象上，故类的新方法可添加在prototype对象上。Object.assign可一次添加多个方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(Point.prototype,&#123;</span><br><span class="line">	toString()&#123;&#125;,</span><br><span class="line">	toValue()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>类内部定义的方法都不可枚举。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(Point.prototype)</span><br><span class="line">//Object.keys()返回可枚举的键名</span><br><span class="line">//[]  </span><br><span class="line">Object.getOwnPropertyNames(Point.prototype)</span><br><span class="line">//[&quot;constructor&quot;,&quot;toString&quot;]</span><br><span class="line">//返回自身全部属性方法名（包括不可枚举属性）</span><br></pre></td></tr></table></figure>

<ul>
<li>constructor方法默认返回实例对象（即this），可指定返回另外一个对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">	constructor()&#123; return Object.create(null); &#125;</span><br><span class="line">&#125;</span><br><span class="line">new Foo() instanceof Foo</span><br></pre></td></tr></table></figure>

<h6 id="类的几种表示法"><a href="#类的几种表示法" class="headerlink" title="类的几种表示法"></a>类的几种表示法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class B&#123;&#125;</span><br><span class="line">let b = new B();</span><br><span class="line"></span><br><span class="line">const MyClass = class Me&#123;&#125;; //Me可省略，只能在内部使用</span><br><span class="line">let inst = new MyClass();//外部使用类只能用MyClass</span><br><span class="line"> </span><br><span class="line">//立即执行的类</span><br><span class="line">let person = new class&#123;</span><br><span class="line">	constructor(name)&#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	sayName()&#123;</span><br><span class="line">		console.log(this.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;(&apos;张三&apos;)</span><br><span class="line">person.sayName(); //“张三”</span><br></pre></td></tr></table></figure>

<h6 id="noticePoint"><a href="#noticePoint" class="headerlink" title="noticePoint"></a>noticePoint</h6><ul>
<li><p>类和模块默认就是严格模式。</p>
</li>
<li><p>类不存在变量提升，类使用在前，定义在后会报错。</p>
</li>
<li><p>name属性。ES6的类只是ES5的构造函数的一层包装，故函数的许多特性都被Class继承，包括name属性，name属性总是返回紧跟在class关键字后面的类名。</p>
</li>
<li><p>如果类的Symbol.iterator方法前有一星号，就是Generator方法。该方法会返回类的默认遍历器，for…of循环自动调用这个遍历器。</p>
</li>
<li><p>类内部如果有this默认指向类的实例。<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是<code>undefined</code>），从而导致找不到<code>print</code>方法而报错。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">  printName(name = &apos;there&apos;) &#123;</span><br><span class="line">    this.print(`Hello $&#123;name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print(text) &#123;</span><br><span class="line">    console.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const logger = new Logger();</span><br><span class="line">const &#123; printName &#125; = logger;</span><br><span class="line">printName(); // TypeError: Cannot read property &apos;print&apos; of undefined</span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//1.给构造函数绑定this</span><br><span class="line">class Logger&#123;</span><br><span class="line">	constructor()&#123;</span><br><span class="line">		this.printName = this.printName.bind(this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2.使用箭头函数</span><br><span class="line">class Obj&#123;</span><br><span class="line">	constructor()&#123;</span><br><span class="line">		this.getThis = () =&gt; this;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">const myObj = new Obj();</span><br><span class="line">myObj.getThis() === myobj  //true</span><br><span class="line"></span><br><span class="line">//3.使用Proxy，获取方法时自动绑定this</span><br><span class="line">function selfish(target)&#123;</span><br><span class="line">	const cache = new WeakMap();</span><br><span class="line">	const handler = &#123;</span><br><span class="line">		get(target,key)&#123;</span><br><span class="line">			const value = Reflect.get(target,key);</span><br><span class="line">			if(typeof value !== &apos;function&apos;)&#123;</span><br><span class="line">				return value;</span><br><span class="line">			&#125;</span><br><span class="line">			if(!cache.has(value))&#123;</span><br><span class="line">				cache.set(value,value.bind(target));</span><br><span class="line">			&#125;</span><br><span class="line">			return cache.get(value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	const proxy = new Proxy(target,handle);</span><br><span class="line">	return proxy;</span><br><span class="line">&#125;</span><br><span class="line">const logger = selfish(new Logger());</span><br></pre></td></tr></table></figure>

<ul>
<li>类中的方法前加上static关键字，该不会被实例继承，调用只能通过累来调用，称为静态方法。如果静态方法上包含this关键字，这个this指的是类，而不是实例。故静态方法可与非静态方法重名。</li>
<li>父类的静态方法可被子类继承，并可通过super对象屌用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">	static bar()&#123;this.baz();&#125;</span><br><span class="line">	static baz()&#123;console.log(&apos;helloBar&apos;);&#125;</span><br><span class="line">	static classMethod()&#123;return &apos;hello&apos;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.classMethod()  //‘hello&apos;</span><br><span class="line">Foo.bar()    //&apos;helloBar&apos;</span><br><span class="line">var foo = new Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line">//TypeError:foo.classMethod is not a function</span><br><span class="line"></span><br><span class="line">class Bar extends Foo&#123;</span><br><span class="line">	static sonMethod()&#123;</span><br><span class="line">		return super.classMethod() + &apos;,too&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Bar.classMethod()   //&apos;hello&apos;</span><br><span class="line">Bar.sonMethods()      //&apos;hello,too&apos;</span><br></pre></td></tr></table></figure>

<ul>
<li>实例属性<code>this._count</code>定义在<code>constructor()</code>方法里面，可将属性也可以定义在类的最顶层，其他都不变。实例属性<code>_count</code>与取值函数<code>value()</code>和<code>increment()</code>方法，处于同一个层级。这时，不需要在实例属性前面加上<code>this</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class IncreasingCounter &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this._count = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  get value() &#123;</span><br><span class="line">    console.log(&apos;Getting the current value!&apos;);</span><br><span class="line">    return this._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    this._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class IncreasingCounter &#123;</span><br><span class="line">  _count = 0;</span><br><span class="line">  get value() &#123;</span><br><span class="line">    console.log(&apos;Getting the current value!&apos;);</span><br><span class="line">    return this._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    this._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态属性即Class本身属性，必须在前面加上static关键字。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">calss Foo&#123;</span><br><span class="line">	static prop = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>子类继承父类，除了使用extends外，必须在子类的constructor上调用super对象，否则new实例时会报错。这是因为子类自己的this对象必须经过父类的构造函数完成塑造，得到与父类同样的实例属性和方法再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。如果在调用super之前使用this会报错。</p>
</li>
<li><p>Object.getPrototypeOf()用于在子类中获取父类，可用该方法判断一个类是否继承了另一个类。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(ColorPoint) === Point</span><br><span class="line">//true</span><br></pre></td></tr></table></figure>

<h6 id="super"><a href="#super" class="headerlink" title="super"></a>super</h6><ul>
<li>既可当函数调用，也可当对象使用。</li>
<li>super作为函数调用时，代表父类的构造函数。ES6规定，子类的constructor函数必须执行一次super()，且super()函数只能用在子类的构造函数内，用在其他地方会报错。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">	constructor()&#123;</span><br><span class="line">		console.log(new.target.name);//new.target指向当前正在执行的函数</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">	constructor()&#123;</span><br><span class="line">		super();   //等价于A.prototype.constructor.call(this)</span><br><span class="line">		//super内部的this指向子类的实例</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">new A() //A</span><br><span class="line">new B() //B</span><br></pre></td></tr></table></figure>

<ul>
<li>super作为对象时，在普通方法中，指向父类的原型对象；静态方法中，指向父类。这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.p = 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.x = 3;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  get m() &#123;</span><br><span class="line">    return super.p;</span><br><span class="line">  &#125;</span><br><span class="line">  get x()&#123;</span><br><span class="line">  	return super.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B();</span><br><span class="line">b.m // undefined</span><br><span class="line">b.x //3</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.x = 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x = 2;</span><br><span class="line">    super.x = 3;</span><br><span class="line">    console.log(super.x); // undefined</span><br><span class="line">    console.log(this.x); // 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p>
<ul>
<li>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</li>
<li>在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">  	this.x = &apos;实例的x&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  static print()&#123;</span><br><span class="line">  	console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">  static myMethod(msg) &#123;</span><br><span class="line">    console.log(&apos;static&apos;, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    console.log(&apos;instance&apos;, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">  static m()&#123;</span><br><span class="line">  	super.print();</span><br><span class="line">  &#125;</span><br><span class="line">  static myMethod(msg) &#123;</span><br><span class="line">    super.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    super.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.myMethod(1); // static 1</span><br><span class="line"></span><br><span class="line">var child = new Child();</span><br><span class="line">child.myMethod(2); // instance 2</span><br><span class="line"></span><br><span class="line">Child.x = &apos;这是类的x&apos;;</span><br><span class="line">Child.m() //&apos;这是类的x&apos;</span><br></pre></td></tr></table></figure>

<h6 id="类的prototype属性和-proto-属性"><a href="#类的prototype属性和-proto-属性" class="headerlink" title="类的prototype属性和__proto__属性"></a>类的prototype属性和<code>__proto__</code>属性</h6><ul>
<li>每个对象都有<code>__proto__</code>属性，指向对应的构造函数的prototype属性。</li>
<li><strong>子类的<code>__proto__</code>属性表示构造函数的继承，总是指向父类。</strong></li>
<li><strong>子类的prototype属性的<code>__proto__</code>属性表示方法的继承，总是指向父类的prototype属性。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">class B extends A&#123;&#125;</span><br><span class="line">B.__proto__ === A  //true</span><br><span class="line">B.prototype.__proto__  === A.prototype  //true</span><br><span class="line"></span><br><span class="line">//B的实例继承A的实例</span><br><span class="line">Object.setPrototypeOf(B.prototype,A.prototype);</span><br><span class="line">//B继承A的静态属性</span><br><span class="line">Object.setPrototypeOf(B,A);</span><br><span class="line"></span><br><span class="line">//Object.setPrototypeOf方法实现</span><br><span class="line">Object.setPrototypeOf = function(obj,proto)&#123;</span><br><span class="line">	obj.__proto__ = proto;</span><br><span class="line">	return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</p>
<p>上面代码的<code>A</code>，只要是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p>
<p>以下两种特殊情况</p>
<ul>
<li>子类继承Object类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A extends Object&#123;&#125;</span><br><span class="line">A.__proto__ === Object  //true</span><br><span class="line">A.prototype.__proto__ === Object.prototype  //true</span><br><span class="line">//A其实就是构造函数Object的复制，A的实例就是Object的实例</span><br></pre></td></tr></table></figure>

<ul>
<li>不存在任何继承</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">A.__proto__ === Function.prototype   //true</span><br><span class="line">A.prototype.__proto__ === Object.prototype   //true</span><br></pre></td></tr></table></figure>

<p>A作为一个基类，即不存在任何继承，就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象即object实例，所以<code>A.prototype.__proto__</code>指向构造函数Object的prototype属性。</p>
<h4 id="module模块"><a href="#module模块" class="headerlink" title="module模块"></a>module模块</h4><ul>
<li>ES6之前，社区制定了一些模块加载方案。主要是CommonJS——服务器，AMD——浏览器。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// CommonJS模块,运行时加载，无法做到“运行时加载”</span><br><span class="line">let &#123; stat, exists, readFile &#125; = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">let _fs = require(&apos;fs&apos;);</span><br><span class="line">let stat = _fs.stat;</span><br><span class="line">let exists = _fs.exists;</span><br><span class="line">let readfile = _fs.readfile;</span><br></pre></td></tr></table></figure>

<ul>
<li>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ES6模块</span><br><span class="line">import &#123; stat, exists, readFile &#125; from &apos;fs&apos;;</span><br></pre></td></tr></table></figure>

<p>上面代码的实质是从<code>fs</code>模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>
<p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p>
<ul>
<li>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li>
<li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li>
<li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li>
</ul>
<p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p>
<h6 id="严格模式主要有以下限制。"><a href="#严格模式主要有以下限制。" class="headerlink" title="严格模式主要有以下限制。"></a>严格模式主要有以下限制。</h6><ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用<code>with</code>语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀 0 表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li>
<li><code>eval</code>不会在它的外层作用域引入变量</li>
<li><code>eval</code>和<code>arguments</code>不能被重新赋值</li>
<li><code>arguments</code>不会自动反映函数参数的变化</li>
<li>不能使用<code>arguments.callee</code></li>
<li>不能使用<code>arguments.caller</code></li>
<li>禁止<code>this</code>指向全局对象</li>
<li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li>
<li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li>
</ul>
<p>其中，尤其需要注意<code>this</code>的限制。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code></p>
<h6 id="exprot与import"><a href="#exprot与import" class="headerlink" title="exprot与import"></a>exprot与import</h6><ul>
<li>export写法：必须提供对外的接口。实质是在接口名与模块内部变量之间建立一一对应的关系。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">export 1;</span><br><span class="line">// 报错</span><br><span class="line">var m = 1; </span><br><span class="line">export m;</span><br><span class="line"></span><br><span class="line">// 写法一</span><br><span class="line">export var m = 1;</span><br><span class="line">// 写法二</span><br><span class="line">var m = 1;</span><br><span class="line">export &#123;m&#125;;</span><br><span class="line">// 写法三</span><br><span class="line">var n = 1;</span><br><span class="line">export &#123;n as m&#125;;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">export f;</span><br><span class="line">// 正确</span><br><span class="line">export function f() &#123;&#125;;</span><br><span class="line">// 正确</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">export &#123;f&#125;;</span><br></pre></td></tr></table></figure>

<p><code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p>
<ul>
<li><code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。<code>import</code>命令是编译阶段执行的，在代码运行之前。</li>
<li>使用export  default 时，对应的import语句不需要使用大括号；使用export时，对应的import语句需要使用大括号。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default function crc32()&#123;&#125;</span><br><span class="line">import crc32 from &apos;crc32&apos;;</span><br><span class="line"></span><br><span class="line">export function crc32()&#123;&#125;</span><br><span class="line">import &#123;crc32&#125; from &apos;crc32&apos;;</span><br></pre></td></tr></table></figure>

<p>export  default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export  default命令只能使用一次。故import后面才不用加大括号，因为只可能唯一对应export  default命令。</p>
<p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// modules.js</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x * y;</span><br><span class="line">&#125;</span><br><span class="line">export &#123;add as default&#125;;</span><br><span class="line">// 等同于</span><br><span class="line">// export default add;</span><br><span class="line"></span><br><span class="line">// app.js</span><br><span class="line">import &#123; default as foo &#125; from &apos;modules&apos;;</span><br><span class="line">// 等同于</span><br><span class="line">// import foo from &apos;modules&apos;;</span><br></pre></td></tr></table></figure>

<h6 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h6><ul>
<li>浏览器异步加载js脚本的方法。<code>&lt;script&gt;</code>标签遇到defer或async属性，脚本就会异步加载，渲染引擎遇到这一命令就会开始下载外部脚本，但不会等他下载和执行，而是直接执行后面的命令。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;&quot;  defer&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;&quot;  async&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>defer与async的区别</strong></p>
<p>defer要等到整个页面在内存中正常渲染结束（DOM结构完全生成，以及脚本执行），才会执行。<strong>渲染完再执行</strong>，若有多个defer脚本，则按顺序加载。</p>
<p>async是<strong>下载后执行</strong>，即一旦下载完成，渲染引擎就会中断渲染执行这个脚本后再继续渲染。故不能保证加载顺序。</p>
<ul>
<li>加载ES6模块,对于带有<code>type=&quot;module&quot;</code>的脚本都是异步加载，相当于默认是defer属性，<strong>渲染完再加载</strong>，可设为async属性。</li>
</ul>
<p><code>&lt;script type=&quot;module&quot; src=&quot;&quot;&gt;&lt;/script&gt;</code></p>
<ul>
<li>外部脚本注意事项：<ul>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>
<li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li>
<li>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li>
<li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li>
<li>同一个模块如果加载多次，将只执行一次。</li>
</ul>
</li>
</ul>
<h6 id="ES6模块与CommonJS模块的差异"><a href="#ES6模块与CommonJS模块的差异" class="headerlink" title="ES6模块与CommonJS模块的差异"></a>ES6模块与CommonJS模块的差异</h6><ul>
<li>commonJS模块输出的是一个值的拷贝，且运行时加载。<ul>
<li>值拷贝表明一旦输出后，内部值的改变不影响这个值。</li>
</ul>
</li>
<li>ES6模块输出的是值的引用，编译时输出接口。<ul>
<li>JS引擎对脚本静态分析时，遇到模块加载命令import就会生成一个只读引用，等到脚本真正执行时再根据这个只读引用到被加载模块取值。</li>
</ul>
</li>
</ul>
<h6 id="CommonJS加载原理"><a href="#CommonJS加载原理" class="headerlink" title="CommonJS加载原理"></a>CommonJS加载原理</h6><ul>
<li>CommonJS（加载时执行）的一个模块就是一个脚本文件，require命令第一次加载该脚本就会执行整个脚本，然后在内存生成一个对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	//node内部加载模块完成后生成的对象</span><br><span class="line">	id:&apos;...&apos;,	//模块名</span><br><span class="line">	exports:&#123;...&#125;,	//模块输出的各个接口</span><br><span class="line">	loaded:true,	//该模块脚本是否执行完毕</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以后用到这个模块时就回到exports属性上取值，即使再执行require也不会再次执行该模块而是到缓存中取值，即CommonJS无论加载多少次都只在第一次加载时运行一次，以后再加载只会返回第一次加载的结果，除非手动清除缓存。</p>
<h6 id="ES6模块转码"><a href="#ES6模块转码" class="headerlink" title="ES6模块转码"></a>ES6模块转码</h6><ul>
<li>Babel</li>
<li>转码器：ES6 module transpiler（将es6转为CommonJS或AMD模块）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm i -g es6-module-transpiler</span><br><span class="line">//转码</span><br><span class="line">compile-modules convert file1.js file2.js</span><br><span class="line">//-o指定转码后的文件名</span><br><span class="line">compile-modules convert -o out.js file1.js</span><br></pre></td></tr></table></figure>

<ul>
<li>在网页中导入system.js文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;system.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	//使用System.import加载模块文件,返回Promise对象</span><br><span class="line">	System.import(&apos;./模块文件&apos;).then(function()&#123;&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h4><ul>
<li>注意区分Object与Map，只有模拟现实世界的实体对象时才使用Object。如果只是需要key：value的数据结构，使用Map结构，因其有内建的遍历机制。</li>
<li>总是用class代替prototype操作。使用extends实现继承，不会破环instanceof运算的危险。</li>
<li>模块默认输出一个函数，函数名首字母应该小写，默认输出对象时，对象名首字母大写。</li>
</ul>
<h4 id="异步遍历器"><a href="#异步遍历器" class="headerlink" title="异步遍历器"></a>异步遍历器</h4><ul>
<li>Iterator接口是一种数据遍历的协议，只要调用遍历器对象的next方法就会得到一个对象，表示当前遍历指针所在的那个位置的信息。next方法必须是同步的，返回value和done两个属性值。</li>
<li>若next方法是一个异步操作，可将异步操作包装成Thunk函数或Promise对象，即next方法的返回值的value属性是一个Thunk函数或Promise对象，等待以后返回真正的值，而done则还是同步操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function idMaker()&#123;</span><br><span class="line">	let index = 0;</span><br><span class="line">	return &#123;</span><br><span class="line">		next:function()&#123;</span><br><span class="line">			return&#123;</span><br><span class="line">				value:new Promise(resolve =&gt; setTimeOut(() =&gt; resolve(index++),1000)),</span><br><span class="line">				done:false</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">const it = idMaker();</span><br><span class="line">it.next().value.then(o =&gt; console.log(o))  //1</span><br><span class="line">it.next().value.then(o =&gt; console.log(o))  //2</span><br></pre></td></tr></table></figure>

<ul>
<li>一个对象的同步遍历器的接口部署在Symbol.iterator属性上。</li>
<li>for…of遍历同步的iterator接口，<code>for await...of</code>循环遍历异步的Iterator接口。createAsyncIterable()返回一个拥有一部遍历器接口的对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function f()&#123;</span><br><span class="line">	for await (const x of createAsyncIterable([&apos;a&apos;,&apos;b&apos;]))&#123;</span><br><span class="line">		console.log(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//a   b</span><br></pre></td></tr></table></figure>

<ul>
<li>异步Generator函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async function* map()&#123; yield &apos;hello&apos;; &#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-vue学习中的问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/28/vue学习中的问题/" class="article-date">
      <time datetime="2020-04-28T04:47:51.000Z" itemprop="datePublished">2020-04-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/vue学习中的问题/">vue学习中的问题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h6 id="登陆切换input复用问题"><a href="#登陆切换input复用问题" class="headerlink" title="登陆切换input复用问题"></a>登陆切换input复用问题</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;span v-if=&quot;isUser&quot;&gt;</span><br><span class="line">            &lt;label for=&quot;userName&quot;&gt;用户账号&lt;/label&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; id=&quot;userName&quot; placeholder=&quot;用户账号&quot; key=&quot;name&quot;&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &lt;span v-else&gt;</span><br><span class="line">            &lt;label for=&quot;email&quot;&gt;用户账号&lt;/label&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; id=&quot;email&quot; placeholder=&quot;用户邮箱&quot; key=&quot;email&quot;&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &lt;button @click=&quot;isUser = !isUser&quot;&gt;切换&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>如果我们在输入内容的情况下切换了类型，我们会发现文字依然显示之前的输入内容。按道理来讲，我们应该切换到另外一个input元素中，在另外这个元素中，我们并没有输入内容，所以应该是空的才对？</p>
<p>这是因为Vue在进行DOM渲染时，出于性能考虑，会尽可能的复用已经存在的元素，而不是重新创建新的元素。</p>
<p>解决：</p>
<p>给对应的input添加不同的key，当进行DOM渲染时，就会识别为不同的元素。</p>
<h6 id="vue管道机制部署"><a href="#vue管道机制部署" class="headerlink" title="vue管道机制部署"></a>vue管道机制部署</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 即前一个函数的输出是后一个函数的输入</span><br><span class="line">const pipeline = (...func) =&gt; val =&gt; func.reduce((a,b) =&gt; b(a),val);</span><br></pre></td></tr></table></figure>

<h6 id="尾调用解决递归"><a href="#尾调用解决递归" class="headerlink" title="尾调用解决递归"></a>尾调用解决递归</h6><p>函数调用自身称为递归。若尾调用自己就称为尾递归。</p>
<p>递归非常耗内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误，但对于尾调用则不会。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 递归</span><br><span class="line">function factorial(n)&#123;</span><br><span class="line">	if(n === 1)  return 1;</span><br><span class="line">	return n*factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 尾调用</span><br><span class="line">function factorial(n,total)&#123;</span><br><span class="line">	if(n === 1)  return total;</span><br><span class="line">	return factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归复杂度为O(n),尾递归的复杂度为O(1)。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-计算机网络" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/27/计算机网络/" class="article-date">
      <time datetime="2020-04-27T12:38:05.000Z" itemprop="datePublished">2020-04-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/27/计算机网络/">计算机网络</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><p><img src="https://iknow-pic.cdn.bcebos.com/c75c10385343fbf2012331c4be7eca8064388fce?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" alt="https://iknow-pic.cdn.bcebos.com/c75c10385343fbf2012331c4be7eca8064388fce?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1"></p>
<h4 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h4><p>一个搭建好的网络往往需要先进行一个简单的测试来验证网络是否畅通；但是IP协议并不能提供可靠传输，如果丢包了，IP协议并不能通知传输层是否丢包以及丢包的原因，所以就需要一种协议来完成这样的功能——ICMP。</p>
<h6 id="ICMP功能"><a href="#ICMP功能" class="headerlink" title="ICMP功能"></a>ICMP功能</h6><ol>
<li>确认IP包是否成功到达目标地址。</li>
<li>通知在发送过程中的IP包被丢弃的原因。</li>
</ol>
<p><img src="https://img-blog.csdn.net/20180530175416942?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM3OTY0MDcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>我们需要注意几点： </p>
<ol>
<li><p>ICMP是基于IP协议工作的，但是它并不是传输层的功能，因此仍然把它归结为网络层协议 </p>
</li>
<li><p>ICMP只能搭配IPv4使用，如果是IPv6的情况下, 需要是用ICMPv6。</p>
</li>
</ol>
<h6 id="ICMP的报文格式"><a href="#ICMP的报文格式" class="headerlink" title="ICMP的报文格式"></a>ICMP的报文格式</h6><p>ICMP报文包含在IP数据报中，IP报头在ICMP报文的最前面。一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）和ICMP报文（属于ICMP报文的数据部分）。当IP报头中的协议字段值为1时，就说明这是一个ICMP报文。ICMP报头如下图所示。 </p>
<p><img src="https://img-blog.csdn.net/201805301801365?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM3OTY0MDcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>占一字节，标识ICMP报文的类型，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文</td>
</tr>
<tr>
<td>代码</td>
<td>占一字节，标识对应ICMP报文的代码。它与类型字段一起共同标识了ICMP报文的详细类型</td>
</tr>
<tr>
<td>校验和</td>
<td>这是对包括ICMP报文数据部分在内的整个ICMP数据报的校验和，以检验报文在传输过程中是否出现了差错（其计算方法与在我们介绍IP报头中的校验和计算方法是一样的）</td>
</tr>
</tbody></table>
<p>ICMP大概分为两类报文：<br> 一类是通知出错原因 ；一类是用于诊断查询<br> 类型及含义如下：</p>
<table>
<thead>
<tr>
<th>类型（十进制）</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>回送应答</td>
</tr>
<tr>
<td>3</td>
<td>目标不可达</td>
</tr>
<tr>
<td>4</td>
<td>原点抑制</td>
</tr>
<tr>
<td>5</td>
<td>重定向或改变路由</td>
</tr>
<tr>
<td>8</td>
<td>回送请求</td>
</tr>
<tr>
<td>9</td>
<td>路由器公告</td>
</tr>
<tr>
<td>10</td>
<td>路由器请求</td>
</tr>
<tr>
<td>11</td>
<td>超时</td>
</tr>
<tr>
<td>17</td>
<td>地址子网请求</td>
</tr>
<tr>
<td>18</td>
<td>地址子网应答</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h6 id="常见的ICMP报文"><a href="#常见的ICMP报文" class="headerlink" title="常见的ICMP报文"></a>常见的ICMP报文</h6><p><strong>响应请求</strong></p>
<p>我们用的ping操作中就包括了响应请求（类型字段值为8）和应答（类型字段值为0）ICMP报文。</p>
<p>一台主机向一个节点发送一个类型字段值为8的ICMP报文，如果途中没有异常（如果没有被路由丢弃，目标不回应ICMP或者传输失败），则目标返回类型字段值为0的ICMP报文，说明这台主机存在。</p>
<p><strong>目标不可达，源抑制和超时报文</strong></p>
<p>这三种报文的格式是一样的。<br> （1）目标不可到达报文（类型值为3）在路由器或者主机不能传递数据时使用。<br> 例如：我们要连接对方一个不存在的系统端口（端口号小于1024）时，将返回类型字段值3、代码字段值为3的ICMP报文。<br> <strong>常见的不可到达类型还有网络不可到达（代码字段值为0）、主机不可达到（代码字段值为1）、协议不可到达（代码字段值为2）等等。</strong><br> （2）源抑制报文（类型字段值为4，代码字段值为0）则充当一个控制流量的角色，通知主机减少数据报流量。由于ICMP没有回复传输的报文，所以只要停止该报文，主机就会逐渐恢复传输速率。<br> （3）无连接方式网络的问题就是数据报会丢失，或者长时间在网络游荡而找不到目标，或者拥塞导致主机在规定的时间内无法重组数据报分段，这时就要触发ICMP超时报文的产生。<br> <strong>超时报文（类型字段值为11）的代码域有两种取值：代码字段值为0表示传输超时，代码字段值为1表示分段重组超时。</strong></p>
<p><strong>时间戳请求</strong></p>
<p>时间戳请求报文（类型值字段13）和时间戳应答报文（类型值字段14）用于测试两台主机之间数据报来回一次的传输时间。<br> 传输时，主机填充原始时间戳，接受方收到请求后填充接受时间戳后以类型值字段14的报文格式返回，发送方计算这个时间差。<br> (有些系统不响应这种报文)</p>
<hr>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><h6 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h6><p>应用层：所有能产生网络流量的程序，如qq，需要联网才能正常操作，是网络服务与用户的一个接口。</p>
<p>协议有：HTTP   FTP   TFTP   SMTP    SNMP    DNS   TELNET   HTTPS    POP3     DHCP。</p>
<p>应用层安全</p>
<ol>
<li>开发的应用程序没有漏洞。</li>
</ol>
<h6 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h6><p>表示层：在传输之前是否进行加密或压缩处理，以及数据在传输的时候是以ASCII码形式传输还是二进制形式传输。一般如果编码格式不对，页面就不能正常加载，会出现乱码现象。（如我传输过来的是utf-8，却以unicode格式来解析网页，势必会出现乱码现象）。</p>
<p>格式有： JPEG       ASCII     EBCDIC       加密格式等。</p>
<h6 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h6><p>cmd命令行中运行netstat -n可查看会话连接情况，状态为<code>ESTABISHED</code>表示已经建立的会话，<code>TIME_WAIT</code>表示这些会话快释放了。</p>
<p>会话层可用于查木马（盗号木马，如qq被盗，别人就可以给你邮箱发一些东西。远程登录木马，就可以远程登录你的电脑），因为木马总是要和外面建立会话，故可以通过<code>netstat -nb</code>查看建立会话的程序是谁，如果是木马就可以发现了。</p>
<p>建立，管理，终止会话，在五层模型中已经合并到应用层。</p>
<p>对应主机进程，指本地主机与远程主机正在进行会话。</p>
<h6 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h6><p>传输层可进行可靠或不可靠的传输，以及流量控制。定义传输数据的协议端口号，以及流控和差错校验。</p>
<p>协议有：TCP,UDP，数据包一旦离开网卡即进入网络传输层。</p>
<h6 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h6><p>网络层负责选择最佳路径以及规划IP地址（IPv4变为IPv6，只改变网络层）。划分局域段，这是网络层的升级。进行逻辑地址寻址，实现不同网络之间的路径选择。</p>
<p>协议有：ICMP  IGMP  IP(IPv4   IPv4)。</p>
<p>网络层故障：</p>
<ol>
<li>配置错误的IP地址，子网掩码。</li>
<li>配置错误的网关（网关是网络的出口）。</li>
<li>路由器没有配置到达目标网络的路由。</li>
</ol>
<p>网络层安全</p>
<ol>
<li>在路由器上使用ACL控制数据包流量。</li>
</ol>
<h6 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h6><p>数据链路层可以标识帧的开始和结尾（特殊符号标识开始和结尾），透明传输（如果中间内容有与标识结尾的标识符相同，会在该内容前加上某些字符告知交换机此处不是结尾），差错校验（会在后面加上一些字符作为校验位）。交换机中将光纤由百兆升级为千兆，这是数据链路层的知识。</p>
<p>建立逻辑连接，进行硬件地址寻址，差错校验等功能，由底层网络定义协议。将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</p>
<p>数据链路层故障：</p>
<ol>
<li>MAC地址冲突，我们知道一般MAC地址都是唯一的，电脑生产时就已经定义好每台电脑对应的MAC地址，但是我们设置电脑的MAC地址为某台电脑的MAC地址，这样就可能造成MAC地址冲突。</li>
<li>当ADSL欠费，电信就会阻断通信。</li>
<li>网速没办法协商也会出现，服务器规定网速为千兆，而电脑网速为百兆。</li>
<li>计算机连接到错误的VLAN。</li>
</ol>
<p>网络安全</p>
<ol>
<li>ADSL需要输入账号密码。</li>
<li>VLAN交换机端口绑定MAC地址。</li>
</ol>
<h6 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h6><p>规范了一些接口标准（比如各个公司生产的网卡固定了几根线），电器标准（例如0V代表低电平0，5V代表高电平1）以及规定如何在物理链路上传输更快的速度。更换通信介质，更换通信设备是物理层。</p>
<p>建立，维护，断开物理连接，由底层网络定义协议。</p>
<p>物理层故障，在控制面板——&gt; 所有控制面板项——&gt; 网络和共享中心——&gt; 找到已连接网络，点击查看WLAN状态，如果数据包发送不为0，但接收为0，表示是物理层故障，需要检查线是否完好，或重新接好线。</p>
<h4 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h4><p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E6%A8%A1%E5%9E%8B.png" alt="模型"></p>
<p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E4%BC%A0%E8%BE%93.PNG" alt="传输"></p>
<p>FCS:校验位。</p>
<h6 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h6><p>TCP提供了</p>
<ol>
<li>无差错的数据传输。</li>
<li>按序传输（数据总是会按照发送的顺序到达）。</li>
<li>未分段数据流（可以在任意时刻以任意尺寸将数据发送出去）。</li>
<li></li>
</ol>
<h4 id="网络的性能"><a href="#网络的性能" class="headerlink" title="网络的性能"></a>网络的性能</h4><h6 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h6><p>连接在计算机网络上的主机在数字信道上传送数据位数的速率，也称为data rate或bit rate。单位是b/s,  kb/s,  Mb/s,  Gb/s。</p>
<h6 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h6><p>数据通信领域中，数字信道所能传送的最高数据率。</p>
<h6 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h6><p>在单位时间内通过某个网络的数据量。</p>
<h6 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h6><ol>
<li><p>发送时延</p>
<p>发送时延 = 数据块长度（比特）/ 信道带宽（比特/秒）</p>
</li>
<li><p>传播时延</p>
</li>
<li><p>处理时延</p>
</li>
<li><p>排队时延</p>
</li>
</ol>
<h6 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h6><h6 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h6><h6 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h6><ol>
<li>信道利用率：有数据通过时间 / （有+无）数据通过时间</li>
<li>网络利用率：信道利用率加权平均值</li>
</ol>
<p>D = D0 / 1-U</p>
<p>D0 :表示网络空闲时的时延</p>
<p>D：表示信道利用率</p>
<p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1.PNG" alt="数据通信"></p>
<h4 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h4><h6 id="数据通信的术语"><a href="#数据通信的术语" class="headerlink" title="数据通信的术语"></a>数据通信的术语</h6><p>通信的目的是传送消息。</p>
<p>数据（data）—— 运送消息的实体。</p>
<p>信号（signal）——数据的消息或电磁的表现。</p>
<p>“模拟信号” —— 代表消息的参数的取值是连续的。</p>
<p>“数字信号” —— 代表消息的参数的取值是离散的。</p>
<p>码元（code）—— 在使用时间域的波形表示数字信号时，则代表不同离散数值的基本波形就成为码元。</p>
<p>在数字通信中常常使用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元。而这个间隔被称为码元长度。1码元可以携带nbit的信息量。</p>
<h6 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h6><p>信道一般表示向一个方向传送信息的媒体，所以我们说平常的通信线路往往包含一条发送信息的信道和一条接收信息的通道。</p>
<p><strong>单向通信</strong>（单工通信）——只能有一个方向的通信而没有反方向的交互。</p>
<p><strong>双向交替通信</strong>（半双工通信）——通信双方都可以发送信息，但不能双方同时发送/接收。</p>
<p><strong>双向同时通信</strong>（全双工通信）——通信双方可以同时发送或接收信息。</p>
<h6 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h6><p><strong>基带信号</strong>（即基本频带信号）——来自信源的信号。像计算机输出的表示各种文字或图像文件的数据信号都属于基带信号，比如我们说话的声带就是基带信号。</p>
<p><strong>带通信号</strong>——把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。</p>
<p>因此在传输距离较近时，计算机网络都采用基带传输方式，由于近距离范围内基带信号的衰减不大，从而信号内容不会发生变化，因此在传输距离较近时，计算机网络采用基带传输方式。如从计算机到监视器，打印机等外设的信号就是基带传输的。</p>
<p><strong>调幅（AM）</strong>：载波的振幅随基带数字信号而变化。</p>
<p><strong>调频（FM)</strong>：载波的频率随基带数字信号而变化。</p>
<p><strong>调相（PM)</strong>:载波的初始相位随基带数字信号而变化。</p>
<p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E8%B0%83%E9%A2%91.PNG" alt="调频"></p>
<h6 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h6><p>物理层设备集线器的工作特点是在网络中只起到信号放大和重发作用，其目的是扩大网络的传输范围，而不具备信号的定向传送能力。它是一个大的冲突域，因为当一台电脑发送给集线器后，集线器会把该内容转发给连接在集线器上的其他电脑，当其他电脑接收到内容后先对比该内容的MAC地址与自己电脑的MAC地址，相同则进行处理，不同者不做处理，但是我们可以把数据爬出来。</p>
<h6 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h6><p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8.PNG" alt="信道复用">**</p>
<p><strong>频分复用技术FDM(Frequency  Division  Multiplexing)</strong>：用户在分配到一定的频带后在通信过程中自始自终都占用这个频带。频分复用的所有用户在相同时间内占用不同的带宽资源，请注意，这里的“带宽”是频率带宽而不是数据的发送速率。</p>
<p><strong>时分复用技术TDM(Time Division Multiplexing)</strong>是将时间划分为一段段等长的时分复用帧，每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，在不同时间内占用相同的频带宽度。<img src="C:%5CUsers%5CCCY%5CDesktop%5C%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8.PNG" alt="时分复用"></p>
<p>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</p>
<p><strong>统计时分复用</strong>：通过标记是哪个VLAN。</p>
<h6 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h6><p>xDSL(用数字技术对现有的模拟电话用户线进行改造)</p>
<p>标准模拟电话信号的频带被限制在300<del>3400Hz的范围内，但用户线本身实际可通过的信号频率仍然超过1MHz。xDSL技术把0</del>4kHz低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。</p>
<h4 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>数据链路层使用的信道主要有以下两种类型：</p>
<ol>
<li>点对点信道。这种信道使用一对一的点对点通信方式。</li>
<li>广播通信。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。</li>
</ol>
<h6 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h6><p>链路（link）是一条点到点的物理路线，中间没有任何其他的交换结点，一条链路只是一条通路的组成部分。</p>
<p>数据链路（data  link）除了物理线路外，还必须有通信协议来控制这些数据的传输，若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p>
<p>现最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。</p>
<p>一般的适配器都包括了数据链路层和物理层这两层的功能。</p>
<h6 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h6><p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93.PNG" alt="透明传输"></p>
<h6 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h6><p>传输过程中可能会产生比特差错，1可能变成0而0也可能变成1.在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER(Bit  Error  Rate)。</p>
<p>误码率与信噪比有很大的关系，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采取各种差错检测措施。</p>
<h6 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h6><p>现在全世界使用最多的数据链路层协议是点对点协议PPP(Point-to-Point Protocol)。</p>
<p>用户使用拨号电话线接入因特网时一般都是使用PPP协议。</p>
<p>PPP协议应该满足的要求：</p>
<ol>
<li>简单——这是首要的要求</li>
<li>封装成帧。</li>
<li>透明性。</li>
<li>多种网络层协议。</li>
<li>差错检测。</li>
<li>检测连接状态。</li>
<li>最大传送单元。</li>
<li>网络层地址协商。</li>
<li>数据压缩协商。</li>
</ol>
<p>PPP协议不满足的要求：</p>
<ol>
<li>纠错。</li>
<li>流量控制。</li>
<li>序号。</li>
<li>多点线路。</li>
<li>半双工或单工链路。</li>
</ol>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200429135924281.png" alt="image-20200429135924281"></p>
<p>7E是结束和开头标志，FCS用于差错校验。</p>
<p><strong>PPP协议工作状态</strong>：当用户拨号接入ISP时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。PC机向路由器发送一系列的LCP分组（封装成多个PPP帧），这些分组及其响应选择一些PPP参数，和进行网络层配置，NCP给新接入的PC机分配一个临时的IP地址，使PC机成为因特网上的一个主机。通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。接着，LCP释放数据链路层连接，最后释放的是物理层的连接。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-数据结构与算法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/27/数据结构与算法/" class="article-date">
      <time datetime="2020-04-27T12:36:59.000Z" itemprop="datePublished">2020-04-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/27/数据结构与算法/">数据结构与算法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><img src="https://user-gold-cdn.xitu.io/2019/8/28/16cd6d6deb3a6f8f?imageView2/0/w/1280/h/960/ignore-error/1" alt="数组方法大全"></p>
<h6 id="数组解构赋值应用"><a href="#数组解构赋值应用" class="headerlink" title="数组解构赋值应用"></a>数组解构赋值应用</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 交换变量</span><br><span class="line">[a, b] = [b, a]</span><br><span class="line">[o.a, o.b] = [o.b, o.a]</span><br><span class="line">// 生成剩余数组</span><br><span class="line">const [a, ...rest] = [...&apos;asdf&apos;] // a：&apos;a&apos;，rest: [&quot;s&quot;, &quot;d&quot;, &quot;f&quot;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h6 id="数组浅拷贝"><a href="#数组浅拷贝" class="headerlink" title="数组浅拷贝"></a>数组浅拷贝</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3]</span><br><span class="line">const arrClone = [...arr]</span><br><span class="line">// 对象也可以这样浅拷贝</span><br><span class="line">const obj = &#123; a: 1 &#125;</span><br><span class="line">const objClone = &#123; ...obj &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>浅拷贝方法有很多如<code>arr.slice(0, arr.length)/Arror.from(arr)</code>等，但是用了<code>...</code>操作符之后就不会再想用其他的了~</p>
<h6 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [1, 2, 3]</span><br><span class="line">const arr2 = [4, 5, 6]</span><br><span class="line">const arr3 = [7, 8, 9]</span><br><span class="line">const arr = [...arr1, ...arr2, ...arr3]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>arr1.concat(arr2, arr3)</code>同样可以实现合并，但是用了<code>...</code>操作符之后就不会再想用其他的了~</p>
<h6 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 1, 2, 2, 3, 4, 5, 5]</span><br><span class="line">const newArr = [...new Set(arr)]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>new Set(arr)</code>接受一个数组参数并生成一个set结构的数据类型。set数据类型的元素不会重复且是<code>Array Iterator</code>，所以可以利用这个特性来去重。</p>
<h6 id="数组取交集"><a href="#数组取交集" class="headerlink" title="数组取交集"></a>数组取交集</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a = [0, 1, 2, 3, 4, 5]</span><br><span class="line">const b = [3, 4, 5, 6, 7, 8]</span><br><span class="line">const duplicatedValues = [...new Set(a)].filter(item =&gt; b.includes(item))</span><br><span class="line">duplicatedValues // [3, 4, 5]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h6 id="数组取差集"><a href="#数组取差集" class="headerlink" title="数组取差集"></a>数组取差集</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = [0, 1, 2, 3, 4, 5]</span><br><span class="line">const b = [3, 4, 5, 6, 7, 8]</span><br><span class="line">const diffValues = [...new Set([...a, ...b])].filter(item =&gt; !b.includes(item) || !a.includes(item)) // [0, 1, 2, 6, 7, 8]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h6 id="数组转对象"><a href="#数组转对象" class="headerlink" title="数组转对象"></a>数组转对象</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4]</span><br><span class="line">const newObj = &#123;...arr&#125; // &#123;0: 1, 1: 2, 2: 3, 3: 4&#125;</span><br><span class="line">const obj = &#123;0: 0, 1: 1, 2: 2, length: 3&#125;</span><br><span class="line">// 对象转数组不能用展开操作符，因为展开操作符必须用在可迭代对象上</span><br><span class="line">let newArr = [...obj] // Uncaught TypeError: object is not iterable...</span><br><span class="line">// 可以使用Array.form()将类数组对象转为数组</span><br><span class="line">let newArr = Array.from(obj) // [0, 1, 2]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h6 id="数组摊平"><a href="#数组摊平" class="headerlink" title="数组摊平"></a>数组摊平</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;a: &apos;群主&apos;, b: &apos;男群友&apos;, c: &apos;女裙友&apos;, d: &apos;未知性别&apos;&#125;</span><br><span class="line">const getName = function (item) &#123; return item.includes(&apos;群&apos;)&#125;</span><br><span class="line">// 方法1</span><br><span class="line">const flatArr = Object.values(obj).flat().filter(item =&gt; getName(item))</span><br><span class="line">// 经大佬指点，更加简化（发现自己的抽象能力真的差~）</span><br><span class="line">const flatArr = Object.values(obj).flat().filter(getName)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>二维数组用<code>array.flat()</code>，三维及以上用<code>array.flatMap()</code>。</p>
<h6 id="数组常用遍历"><a href="#数组常用遍历" class="headerlink" title="数组常用遍历"></a>数组常用遍历</h6><p>数组常用遍历有 <code>forEach、every、some、filter、map、reduce、reduceRight、find、findIndex</code> 等方法，很多方法都可以达到同样的效果。数组方法不仅要会用，而且要用好。要用好就要知道什么时候用什么方法。</p>
<h6 id="遍历的混合使用"><a href="#遍历的混合使用" class="headerlink" title="遍历的混合使用"></a>遍历的混合使用</h6><p><code>filter</code>、<code>map</code>方法返回值仍旧是一个数组，所以可以搭配其他数组遍历方法混合使用。注意遍历越多效率越低~</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> value = arr</span><br><span class="line">    .map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">3</span>)</span><br><span class="line">    .filter(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">item</span> =&gt;</span> item + <span class="number">1</span>)</span><br><span class="line">    .reduce(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> prev + curr, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h6 id="检测数组所有元素是否都符合判断条件"><a href="#检测数组所有元素是否都符合判断条件" class="headerlink" title="检测数组所有元素是否都符合判断条件"></a>检测数组所有元素是否都符合判断条件</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> isAllNum = arr.every(<span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">typeof</span> item === <span class="string">'number'</span>)</span><br></pre></td></tr></table></figure>

<h6 id="检测数组是否有元素符合判断条件"><a href="#检测数组是否有元素符合判断条件" class="headerlink" title="检测数组是否有元素符合判断条件"></a>检测数组是否有元素符合判断条件</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> hasNum = arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">typeof</span> item === <span class="string">'number'</span>)</span><br></pre></td></tr></table></figure>

<h6 id="找到第一个符合条件的元素-下标"><a href="#找到第一个符合条件的元素-下标" class="headerlink" title="找到第一个符合条件的元素/下标"></a>找到第一个符合条件的元素/下标</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> findItem = arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="number">3</span>) <span class="comment">// 返回子项</span></span><br><span class="line"><span class="keyword">const</span> findIndex = arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="number">3</span>) <span class="comment">// 返回子项的下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> findIndex</span><br><span class="line">arr.find(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item === <span class="number">3</span>) &#123;</span><br><span class="line">        findIndex = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="数组使用误区"><a href="#数组使用误区" class="headerlink" title="数组使用误区"></a>数组使用误区</h6><p>数组的方法很多，很多方法都可以达到同样的效果，所以在使用时要根据需求使用合适的方法。</p>
<p>垃圾代码产生的很大原因就是数组常用方法使用不当，这里有以下需要注意的点：</p>
<p><strong>array.includes() 和 array.indexOf()</strong></p>
<p><code>array.includes()</code> 返回布尔值，<code>array.indexOf()</code> 返回数组子项的索引。<code>indexOf</code> 一定要在需要索引值的情况下使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用indexOf，需要用到索引值</span></span><br><span class="line"><span class="keyword">const</span> index = arr.indexOf(<span class="number">1</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">if</span> (~index) &#123; <span class="comment">// 若index === -1，~index得到0，判断不成立；若index不为-1，则~index得到非0，判断成立。</span></span><br><span class="line">    arr.spilce(index, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用includes，不需要用到索引值</span></span><br><span class="line"><span class="comment">// 此时若用indexOf会造成上下文上的阅读负担：到底其他地方有没有用到这个index?</span></span><br><span class="line"><span class="keyword">const</span> isExist = arr.includes(<span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (!isExist) &#123;</span><br><span class="line">    arr.push(<span class="number">6</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外评论区大佬指出，<code>array.indexOf()</code>找 <code>NaN</code> 会找不到，返回<code>-1</code>，<code>array.includes()</code>能找到，返回<code>true</code>~</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p><strong>array.find() 、 array.findIndex() 和 array.some()</strong></p>
<p><code>array.find()</code>返回值是第一个符合条件的数组子项，<code>array.findIndex()</code> 返回第一个符合条件的数组子项的下标，<code>array.some()</code> 返回有无复合条件的子项，如有返回<code>true</code>，若无返回<code>false</code>。注意这三个都是短路操作，即找到符合条件的之后就不在继续遍历。</p>
<p>在需要数组的子项的时候使用<code>array.find()</code> ；需要子项的索引值的时候使用 <code>array.findIndex()</code> ；而若只需要知道有无符合条件的子项，则用 <code>array.some()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [&#123;<span class="attr">label</span>: <span class="string">'男'</span>, <span class="attr">value</span>: <span class="number">0</span>&#125;, &#123;<span class="attr">label</span>: <span class="string">'女'</span>, <span class="attr">value</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">label</span>: <span class="string">'不男不女'</span>, <span class="attr">value</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用some</span></span><br><span class="line"><span class="keyword">const</span> isExist = arr.some(<span class="function"><span class="params">item</span> =&gt;</span> item.value === <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> (isExist) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'哈哈哈找到了'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用find</span></span><br><span class="line"><span class="keyword">const</span> item = arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item.value === <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> (item) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item.label)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用findIndex</span></span><br><span class="line"><span class="keyword">const</span> index = arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item.value === <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> (~index) &#123;</span><br><span class="line">    <span class="keyword">const</span> delItem = arr[index]</span><br><span class="line">    arr.splice(index, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`你删除了<span class="subst">$&#123;delItem.label&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议在只需要布尔值的时候和数组子项是字符串或数字的时候使用 <code>array.some()</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当子包含数字0的时候可能出错</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> isExist = arr.some(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (isExist) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'存在要找的子项，很舒服~'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">const</span> isExist = arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (isExist) &#123; <span class="comment">// isExist此时是0，隐式转换为布尔值后是false</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行不到这里~'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当子项包含空字符串的时候也可能出错</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">''</span>, <span class="string">'asdf'</span>, <span class="string">'qwer'</span>, <span class="string">'...'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> isExist = arr.some(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="string">''</span>)</span><br><span class="line"><span class="keyword">if</span> (isExist) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'存在要找的子项，很舒服~'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">const</span> isExist = arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="string">''</span>)</span><br><span class="line"><span class="keyword">if</span> (isExist) &#123; <span class="comment">// isExist此时是''，隐式转换为布尔值后是false</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行不到这里~'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>array.find() 和 array.filter()</strong></p>
<p>只需要知道 <code>array.filter()</code> 返回的是所有符合条件的子项组成的数组，会遍历所有数组；而 <code>array.find()</code> 只返回第一个符合条件的子项，是短路操作。</p>
<h6 id="合理使用-Set-数据结构"><a href="#合理使用-Set-数据结构" class="headerlink" title="合理使用 Set 数据结构"></a>合理使用 Set 数据结构</h6><p>由于 es6 原生提供了 <code>Set</code> 数据结构，而 <code>Set</code> 可以保证子项不重复，且和数组转换十分方便，所以在一些可能会涉及重复添加的场景下可以直接使用 <code>Set</code> 代替 <code>Array</code>，避免了多个地方重复判断是否已经存在该子项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"><span class="keyword">set</span>.add(1)</span><br><span class="line"><span class="keyword">set</span>.add(1)</span><br><span class="line"><span class="keyword">set</span>.add(1)</span><br><span class="line"><span class="keyword">set</span>.size // 1</span><br><span class="line">const arr = [...<span class="keyword">set</span>] // arr: [1]</span><br></pre></td></tr></table></figure>

<h6 id="强大的reduce"><a href="#强大的reduce" class="headerlink" title="强大的reduce"></a>强大的reduce</h6><p><code>array.reduce</code> 遍历并将当前次回调函数的返回值作为下一次回调函数执行的第一个参数。</p>
<p>利用 <code>array.reduce</code> 替代一些需要多次遍历的场景，可以极大提高代码运行效率。</p>
<ol>
<li>利用<code>reduce</code> 输出一个数字/字符串</li>
</ol>
<p>假如有如下每个元素都由字母’s’加数字组成的数组<code>arr</code>，现在找出其中最大的数字：（<code>arr</code>不为空）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'s0'</span>, <span class="string">'s4'</span>, <span class="string">'s1'</span>, <span class="string">'s2'</span>, <span class="string">'s8'</span>, <span class="string">'s3'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1  进行了多次遍历，低效</span></span><br><span class="line"><span class="keyword">const</span> newArr = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item.substring(<span class="number">1</span>)).map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Number</span>(item))</span><br><span class="line"><span class="keyword">const</span> maxS = <span class="built_in">Math</span>.max(...newArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2  一次遍历</span></span><br><span class="line"><span class="keyword">const</span> maxS = arr.reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> curIndex = <span class="built_in">Number</span>(cur.replace(<span class="string">'s'</span>, <span class="string">''</span>))</span><br><span class="line">  <span class="keyword">return</span> curIndex &gt; prev ? curIndex : prev</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>利用<code>reduce</code> 输出一个数组/对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 方法1  遍历了两次，效率低</span></span><br><span class="line"><span class="keyword">const</span> value = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> (&#123; <span class="attr">value</span>: item &#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1  一次遍历，效率高</span></span><br><span class="line"><span class="keyword">const</span> value = arr.reduce(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> curr % <span class="number">2</span> === <span class="number">0</span> ? [...prev, curr] : prev</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>

<p>掌握了上面两种用法，结合实际需要，就可以用 <code>reduce/reduceRight</code> 实现各种奇巧淫技了。</p>
<p>实例：利用 <code>reduce</code> 做下面这样的处理来生成想要的 html 字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后端返回数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  <span class="string">'if _ then s9'</span>: [</span><br><span class="line">    <span class="string">'作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生'</span>,</span><br><span class="line">    <span class="string">'作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生'</span>,</span><br><span class="line">    <span class="string">'作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生'</span></span><br><span class="line">    ],</span><br><span class="line">  <span class="string">'if C then s4'</span>: [</span><br><span class="line">    <span class="string">'当有条件时时,结构构件满足要求,要求属于安全性、适用性和耐久性'</span>,</span><br><span class="line">    <span class="string">'当有条件时时,住宅结构满足要求,要求属于安全性、适用性和耐久性'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ifthens = <span class="built_in">Object</span>.entries(data).reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> values = cur[<span class="number">1</span>].reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;prev&#125;</span>&lt;p&gt;<span class="subst">$&#123;cur&#125;</span>&lt;/p&gt;`</span>, <span class="string">''</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;prev&#125;</span></span></span><br><span class="line"><span class="string">    &lt;li&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;<span class="subst">$&#123;cur[<span class="number">0</span>]&#125;</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;values&#125;</span></span></span><br><span class="line"><span class="string">    &lt;/li&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;ul class="nlp-notify-body"&gt;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;ifthens&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>生成的 html 结构如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">"nlp-notify-body"</span>&gt;            </span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;p&gt;<span class="keyword">if</span> _ then s9&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生&lt;/</span>p&gt;</span><br><span class="line">    &lt;p&gt;作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生&lt;/</span>p&gt;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;if C then s4&lt;/</span>p&gt;</span><br><span class="line">    &lt;p&gt;当有条件时时,结构构件满足要求,要求属于安全性、适用性和耐久性&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;当有条件时时,住宅结构满足要求,要求属于安全性、适用性和耐久性&lt;/</span>p&gt;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>

<p>这里还有一个替代 <code>reverse</code> 函数的技巧</p>
<p>由于 <code>array.reverse()</code> 函数会改变原数组自身，这样就限制了一些使用场景。如果我想要一个不会改变数组自身的 <code>reverse</code> 函数呢？拿走！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myReverse = <span class="function">(<span class="params">arr = []</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>  arr.reduceRight(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> [...prev, cur], []) <span class="comment">// 也可以返回逗号表达式 (prev.push(cur), prev)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><h6 id="用JavaScript封装栈"><a href="#用JavaScript封装栈" class="headerlink" title="用JavaScript封装栈"></a>用JavaScript封装栈</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 封装栈</span><br><span class="line">   function Stack()&#123;</span><br><span class="line">       // 栈中的属性</span><br><span class="line">       this.items = [];</span><br><span class="line">       // 栈中的相关操作</span><br><span class="line">       // 1.将元素压入栈中</span><br><span class="line">       Stack.prototype.push = function(element)&#123;</span><br><span class="line">		this.items.push(element);</span><br><span class="line">       &#125;;</span><br><span class="line">       // 2.将元素弹出栈中</span><br><span class="line">       Stack.prototype.pop = function()&#123;</span><br><span class="line">		return	this.items.pop();</span><br><span class="line">       &#125;;</span><br><span class="line">       // 3.查看一下栈顶元素</span><br><span class="line">       Stack.prototype.check = function()&#123;</span><br><span class="line">		return this.items[this.items.length - 1];</span><br><span class="line">       &#125;;</span><br><span class="line">       // 4.判断栈中是否有元素</span><br><span class="line">       Stack.prototype.isEmpty = function()&#123;</span><br><span class="line">		return this.items.length == 0;</span><br><span class="line">       &#125;;</span><br><span class="line">       // 5.获取栈中的元素的个数</span><br><span class="line">       Stack.prototype.size = function()&#123;</span><br><span class="line">		return this.items.length;</span><br><span class="line">       &#125;;</span><br><span class="line">       // 6.toString方法</span><br><span class="line">       Stack.prototype.toString = function()&#123;</span><br><span class="line">           // 方法一：</span><br><span class="line">           // var resultString = &apos;&apos;;</span><br><span class="line">           // for(var i = 0; i &lt; this.items.length; i ++)&#123;</span><br><span class="line">           // 	resultString += this.items[i] + &apos; &apos;;</span><br><span class="line">           // &#125;</span><br><span class="line">           // return resultString;</span><br><span class="line">           // 方法二：</span><br><span class="line">           return this.items.join(&apos; &apos;);</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>之所以不使用<code>this.push=function(){}</code>，而是采用原型的方法，是因为通过prototype原型的方法相当于给整个类添加了方法，而this.push方式则仅是给某个实例添加方法。</p>
<h6 id="用栈将十进制转为二进制"><a href="#用栈将十进制转为二进制" class="headerlink" title="用栈将十进制转为二进制"></a>用栈将十进制转为二进制</h6><ul>
<li>因为我们习惯使用十进制，而计算机里面的所有内容都是用二进制数字表示的（0和1）</li>
<li>可采用对十进制的数字进行除二取余法，将十进制转为二进制。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//函数：将十进制转为二进制</span><br><span class="line">function dec2bin(decNumber)&#123;</span><br><span class="line">    // 1.定义栈对象</span><br><span class="line">    var stack = new Stack();</span><br><span class="line">    while(decNumber &gt; 0)&#123;</span><br><span class="line">        stack.push(decNumber % 2);</span><br><span class="line">        decNumber = Math.floor(decNumber / 2);</span><br><span class="line">        console.log(decNumber)</span><br><span class="line">    &#125;</span><br><span class="line">    var binaryString = &apos;&apos;;</span><br><span class="line">    while(!stack.isEmpty())&#123;</span><br><span class="line">        binaryString += stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return binaryString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h6 id="队列结构"><a href="#队列结构" class="headerlink" title="队列结构"></a>队列结构</h6><ul>
<li><p>队列是一种受限的数据结构，可解决某些特定的问题。它的受限之处在于他只允许在表的前端（font）进行删除操作，而在表的后端（rear）进行插入操作。</p>
</li>
<li><p>队列的实现和栈一样有两种方案：</p>
<ul>
<li>基于数组实现</li>
<li>基于链表实现</li>
</ul>
</li>
<li><p>队列常见的操作</p>
<ul>
<li>enqueue(element)：向队列尾部添加一个或多个新的项。</li>
<li>dequeue（）：移除队列的第一（即排在队列最前面的）项，并返回移除的元素；</li>
<li>front（）：返回队列中第一个元素。</li>
<li>isEmpty（）：判断队列中是否含有元素。</li>
<li>size（）：返回队列中的元素个数。</li>
<li>toString（）：将队列中的内容转为字符串形式</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 用数组封装队列</span><br><span class="line">function Queue()&#123;</span><br><span class="line">this.item = [];</span><br><span class="line"></span><br><span class="line">// 1.添加元素</span><br><span class="line">Queue.prototype.enqueue = function(element)&#123;</span><br><span class="line">    this.item.push(element);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">// 2.移除元素</span><br><span class="line">Queue.prototype.dequeue = function()&#123;</span><br><span class="line">    return this.item.shift();</span><br><span class="line">&#125;;</span><br><span class="line">// 3.查看队列中第一个元素</span><br><span class="line">Queue.prototype.front = function()&#123;</span><br><span class="line">    return this.item[0];</span><br><span class="line">&#125;;</span><br><span class="line">// 4.判断元素是否为空</span><br><span class="line">Queue.prototype.isEmpty = function()&#123;</span><br><span class="line">    return this.item.length == 0;</span><br><span class="line">&#125;;</span><br><span class="line">// 5.队列中的元素个数</span><br><span class="line">Queue.prototype.size = function()&#123;</span><br><span class="line">    return this.item.length;</span><br><span class="line">&#125;;</span><br><span class="line">// 6.将队列中的内容转为字符串</span><br><span class="line">Queue.prototype.toString = function()&#123;</span><br><span class="line">    return this.item.join(&apos; &apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="队列击鼓传花"><a href="#队列击鼓传花" class="headerlink" title="队列击鼓传花"></a>队列击鼓传花</h6><ul>
<li>参数：所有参与人的性名，基于此的数字</li>
<li>结果：最终剩下的一人的姓名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> // 击鼓传花</span><br><span class="line">    function passGame(nameList, num) &#123;</span><br><span class="line">        //创建一个队列</span><br><span class="line">        var queue = new Queue();</span><br><span class="line">        // 将所有人加入队列中</span><br><span class="line">        for(var i = 0; i &lt; nameList.length; i++)&#123;</span><br><span class="line">            queue.enqueue(nameList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        // 不是num，重新加入队列末尾</span><br><span class="line">        // 是num时，从队列中删除并把不是num的值重新放入队列中</span><br><span class="line">        // 当队列中只剩下一人退出循环</span><br><span class="line">        while (queue.size() &gt; 1) &#123;</span><br><span class="line">            for (var i = 0; i &lt; num - 1; i++) &#123;</span><br><span class="line">                queue.enqueue(queue.dequeue());</span><br><span class="line">            &#125;</span><br><span class="line">            queue.dequeue();</span><br><span class="line">        &#125;</span><br><span class="line">        var index = nameList.indexOf(queue.front());</span><br><span class="line">        return queue.front();</span><br><span class="line">    &#125;// 击鼓传花</span><br><span class="line">function passGame(nameList, num) &#123;</span><br><span class="line">    //创建一个队列</span><br><span class="line">    var queue = new Queue();</span><br><span class="line">    // 将所有人加入队列中</span><br><span class="line">    for(var i = 0; i &lt; nameList.length; i++)&#123;</span><br><span class="line">        queue.enqueue(nameList[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    // 不是num，重新加入队列末尾</span><br><span class="line">    // 是num时，从队列中删除并把不是num的值重新放入队列中</span><br><span class="line">    // 当队列中只剩下一人退出循环</span><br><span class="line">    while (queue.size() &gt; 1) &#123;</span><br><span class="line">        for (var i = 0; i &lt; num - 1; i++) &#123;</span><br><span class="line">            queue.enqueue(queue.dequeue());</span><br><span class="line">        &#125;</span><br><span class="line">        queue.dequeue();</span><br><span class="line">    &#125;</span><br><span class="line">    var index = nameList.indexOf(queue.front());</span><br><span class="line">    return queue.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h6><ul>
<li>普通的队列插入一个元素，数据就会被放入后端，并且需要前面的所有元素处理完后才会处理前面的数据。但是优先级队列，在插入一个元素的的时候会考虑该数据的优先级。</li>
<li>和其他数据优先级进行比较，比较完成后可得出这个元素在队列中正确的位置。</li>
<li>优先级队列主要考虑的问题：<ul>
<li>每个元素不再只是一个数据，且包含数据的优先级。</li>
<li>在添加方式中，根据优先级放入正确的位置。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// 封装优先级队列</span><br><span class="line">function PriorityQueue() &#123;</span><br><span class="line">    // 内部类</span><br><span class="line">    function QueueElement(element, priority) &#123;</span><br><span class="line">        this.element = element;</span><br><span class="line">        this.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    // 封装属性</span><br><span class="line">    this.item = [];</span><br><span class="line">    // 实现插入方法</span><br><span class="line">    PriorityQueue.prototype.enqueue = function (element, priority) &#123;</span><br><span class="line">        // 创建QueueElement对象</span><br><span class="line">        var queueElement = new QueueElement(element, priority);</span><br><span class="line">        if (this.item.length == 0) &#123;</span><br><span class="line">            this.item.push(queueElement);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            let flag = false;</span><br><span class="line">            for (let i = 0; i &lt; this.item.length; i++) &#123;</span><br><span class="line">                if (queueElement.priority &lt; this.item[i].priority) &#123;</span><br><span class="line">                    this.item.splice(i, 0, queueElement);</span><br><span class="line">                    flag = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!flag) &#123;</span><br><span class="line">                this.item.push(queueElement);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.移除元素</span><br><span class="line">    PriorityQueue.prototype.dequeue = function () &#123;</span><br><span class="line">        return this.item.shift();</span><br><span class="line">    &#125;;</span><br><span class="line">    // 3.查看队列中第一个元素</span><br><span class="line">    PriorityQueue.prototype.front = function () &#123;</span><br><span class="line">        return this.item[0];</span><br><span class="line">    &#125;;</span><br><span class="line">    // 4.判断元素是否为空</span><br><span class="line">    PriorityQueue.prototype.isEmpty = function () &#123;</span><br><span class="line">        return this.item.length == 0;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 5.队列中的元素个数</span><br><span class="line">    PriorityQueue.prototype.size = function () &#123;</span><br><span class="line">        return this.item.length;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 6.将队列中的内容转为字符串</span><br><span class="line">    PriorityQueue.prototype.toString = function () &#123;</span><br><span class="line">       let result = &apos;&apos;;</span><br><span class="line">       for(let i = 0; i &lt; this.item.length; i++)&#123;</span><br><span class="line">           result += this.item[i].priority + &apos; &apos; + this.item[i].element + &apos; &apos;;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var priorityQueue = new PriorityQueue();</span><br><span class="line">priorityQueue.enqueue(&apos;nikita&apos;,10);</span><br><span class="line">priorityQueue.enqueue(&apos;nikita1&apos;,110);</span><br><span class="line">priorityQueue.enqueue(&apos;nikit2a&apos;,101);</span><br><span class="line">priorityQueue.enqueue(&apos;nikitak&apos;,210);</span><br><span class="line">console.log(priorityQueue.toString());</span><br></pre></td></tr></table></figure>

<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h6 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h6><p>要存储多个元素，有两个选择：数组和链表。</p>
<p>但不同于数组，链表中的元素在内存中不必是连续的空间，链表的每一个元素由一个存储元素本身的节点和指向下一个元素的引用（即指针）组成。</p>
<p>相对于数组，链表优势：</p>
<ol>
<li>内存不必连续，可充分利用计算机的内存，实现灵活的内存动态管理。</li>
<li>链表不必在创建时就确定大小，并且大小可以无限的延伸下去。</li>
<li>链表在插入和删除操作时，时间复杂度可达O（1），相对数组效率高很多。</li>
</ol>
<p>劣势：</p>
<ol>
<li>链表访问任何一个位置的元素都必须从头开始。（无法跳过第一个元素访问任何一个元素）。</li>
<li>无法通过下标直接访问元素，必须从头开始，直到找到元素。</li>
</ol>
<p>![1 (3)](C:\Users\CCY\Desktop\1 (3).png)</p>
<p>常见操作：</p>
<ol>
<li>append（element）：向链表尾部添加一个新的项。</li>
<li>insert（position,element）：向特定位置添加一个项</li>
<li>get（position）</li>
<li>indexOf（element）</li>
<li>update（position）：修改某个位置的元素</li>
<li>removeAt（position）</li>
<li>remove（element）</li>
<li>isEmpty()</li>
<li>size()</li>
<li>toString()</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">![4](C:\Users\CCY\Desktop\4.png)// 封装单向链表</span><br><span class="line">function LinkedList()&#123;</span><br><span class="line">    // 内部类，节点类</span><br><span class="line">    function Node(data)&#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.next = null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 定义属性</span><br><span class="line">    this.head = null;</span><br><span class="line">    this.length = 0;</span><br><span class="line"></span><br><span class="line">    // 追加append方法</span><br><span class="line">    LinkedList.prototype.append = function(data)&#123;</span><br><span class="line">        let newNode = new Node(data);</span><br><span class="line">        if(this.length == 0)&#123;</span><br><span class="line">            this.head = newNode;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let current = this.head;</span><br><span class="line">            while(current.next)&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        this.length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // toString方法</span><br><span class="line">    LinkedList.prototype.toString = function()&#123;</span><br><span class="line">        let resultString = &apos;&apos;;</span><br><span class="line">        let current = this.head;</span><br><span class="line">        while(current)&#123;</span><br><span class="line">            resultString += current.data + &apos; &apos;;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在任意位置加元素</span><br><span class="line">    LinkedList.prototype.insert = function(position,data)&#123;</span><br><span class="line">        // 对position进行边界判断</span><br><span class="line">        if(position &lt; 0 || position &gt; this.length)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let newNode = new Node(data);</span><br><span class="line">            let index = 0;</span><br><span class="line">            let previous = null;</span><br><span class="line">            let current = this.head;</span><br><span class="line">            while(index++ &lt; position)&#123;</span><br><span class="line">                previous = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            previous.next = newNode;</span><br><span class="line">            newNode.next = current;</span><br><span class="line">        &#125;</span><br><span class="line">        this.length++;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取对应位置的值</span><br><span class="line">    LinkedList.prototype.get = function(position)&#123;</span><br><span class="line">        // 对position边界判断</span><br><span class="line">        if(position &lt; 0 || position &gt;= this.length)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let current = this.head;</span><br><span class="line">            let index = 0;</span><br><span class="line">            while(index++ &lt; position)&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return current.data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回元素索引值indexOf，没有返回-1</span><br><span class="line">    LinkedList.prototype.indexOf = function(value)&#123;</span><br><span class="line">        let current = this.head;</span><br><span class="line">        let index = 0;</span><br><span class="line">        while(current)&#123;</span><br><span class="line">            if(current.data == value)&#123;</span><br><span class="line">                return index;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // update方法</span><br><span class="line">    LinkedList.prototype.update = function(position,value)&#123;</span><br><span class="line">        // 对position边界判断</span><br><span class="line">        if(position &lt; 0 || position &gt;= this.length)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let current = this.head;</span><br><span class="line">            let index = 0;</span><br><span class="line">            while(index++ &lt; position)&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.data = value;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在特定位置删除数据</span><br><span class="line">    LinkedList.prototype.removeAt = function(position)&#123;</span><br><span class="line">        // 方便后续返回里面的值</span><br><span class="line">        let current = this.head;</span><br><span class="line">        // 对position边界判断</span><br><span class="line">        if(position &lt; 0 || position &gt;= this.length)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let index = 0;</span><br><span class="line">            let previous = null;</span><br><span class="line">            while(index++ &lt; position)&#123;</span><br><span class="line">                previous = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = previous.next;</span><br><span class="line">        &#125;</span><br><span class="line">        this.length -= 1;</span><br><span class="line">        return current.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在列表中删除某个值</span><br><span class="line">    LinkedList.prototype.remove = function(value)&#123;</span><br><span class="line">        // 获取data在列表中的位置</span><br><span class="line">        let position = this.indexOf(value);</span><br><span class="line"></span><br><span class="line">        return this.removeAt(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 是否为空</span><br><span class="line">    LinkedList.prototype.isEmpty = function()&#123;</span><br><span class="line">        return !this.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 元素个数</span><br><span class="line">    LinkedList.prototype.size = function()&#123;</span><br><span class="line">        return this.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h6><p>既可以从头遍历到尾，又可以从尾遍历到头。</p>
<p>实现原理是：一个节点既有向前连接的引用，也有一个向后连接的引用。</p>
<p>但有以下缺点：</p>
<p>每次插入删除某个节点时，需要处理四个引用，而不是两个，也就是实现起来更困难一些。并且相当于单向链表，必然占用内存空间更大些。<img src="C:%5CUsers%5CCCY%5CDesktop%5C4.png" alt="4"></p>
<p>特点：</p>
<ol>
<li>可以使用一个head和一个tail分别指向头部和尾部的节点。</li>
<li>每个节点由三部分组成：前一个节点的指针（prev）/保存的元素（item）/后一个节点的指针（next）。</li>
<li>双向链表的第一个节点的prev是null，最后一个节点的next为null。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">// 封装双向链表</span><br><span class="line">function DoubleLinkedList()&#123;</span><br><span class="line">    // 内部节点类</span><br><span class="line">    function Node(data)&#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.prev = null;</span><br><span class="line">        this.next = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 内部属性</span><br><span class="line">    this.head = null;</span><br><span class="line">    this.tail = null;</span><br><span class="line">    this.length = 0;</span><br><span class="line"></span><br><span class="line">    // append追加方法</span><br><span class="line">    DoubleLinkedList.prototype.append = function(data)&#123;</span><br><span class="line">        let newNode = new Node(data);</span><br><span class="line">        if(this.length == 0)&#123;</span><br><span class="line">            this.head = newNode;</span><br><span class="line">            this.tail = newNode;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            newNode.prev = this.tail;</span><br><span class="line">            this.tail.next = newNode;</span><br><span class="line">            this.tail = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        this.length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 任意位置插入值</span><br><span class="line">    DoubleLinkedList.prototype.insert = function(position,value)&#123;</span><br><span class="line">        if(position &lt; 0 || position &gt;= this.length) return false;</span><br><span class="line">        let newNode = new Node(value);</span><br><span class="line">        // 原链表为空</span><br><span class="line">        if(this.length == 0)&#123;</span><br><span class="line">            this.prev = newNode;</span><br><span class="line">            this.tail = newNode;</span><br><span class="line">        &#125;else if(position == 0)&#123;</span><br><span class="line">            this.head.prev = newNode;</span><br><span class="line">            newNode.next = this.head;</span><br><span class="line">            this.head = newNode;</span><br><span class="line">        &#125;else if(position == this.length)&#123;</span><br><span class="line">            newNode.prev = this.tail;</span><br><span class="line">            this.tail.next = newNode;</span><br><span class="line">            this.tail = newNode;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let index = 0;</span><br><span class="line">            let current = this.head;</span><br><span class="line">            while(index++ &lt; position)&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            newNode.next = current;</span><br><span class="line">            newNode.prev = current.prev;</span><br><span class="line">            current.prev.next = newNode;</span><br><span class="line">            current.prev = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // get方法</span><br><span class="line">    DoubleLinkedList.prototype.get = function(position)&#123;</span><br><span class="line">        if(position &lt; 0 || position &gt;= this.length) return null;</span><br><span class="line">        let index = 0;</span><br><span class="line">        let current = this.head;</span><br><span class="line">        while(index++ &lt; position)&#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return current.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // indexOf方法</span><br><span class="line">    DoubleLinkedList.prototype.indexOf = function(value)&#123;</span><br><span class="line">        let index = 0;</span><br><span class="line">        let current = this.head;</span><br><span class="line">        while(current)&#123;</span><br><span class="line">            if(current.data == value)&#123;</span><br><span class="line">                return index;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // update方法</span><br><span class="line">    DoubleLinkedList.prototype.update = function(position,newValue)&#123;</span><br><span class="line">        if(position &lt; 0 || position &gt;= this.length) return false;</span><br><span class="line">        let current = this.head;</span><br><span class="line">        let index = 0;</span><br><span class="line">        while(index++ &lt; position)&#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.data = newValue;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 移除数据</span><br><span class="line">    DoubleLinkedList.prototype.removeAt = function(position)&#123;</span><br><span class="line">        if(position &lt; 0 || position &gt;= this.length) return null;</span><br><span class="line">        let current = this.head;</span><br><span class="line">        if(position == 0)&#123;</span><br><span class="line">            this.head.next.prev = null;</span><br><span class="line">            this.head = this.head.next;</span><br><span class="line">        &#125;else if(position == this.length - 1)&#123;</span><br><span class="line">            current = this.tail;</span><br><span class="line">            this.tail.prev.next = null;</span><br><span class="line">            this.tail = this.tail.prev;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let index = 0;</span><br><span class="line">            while(index++ &lt; position)&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.prev.next = current.next;</span><br><span class="line">            current.next.prev = current.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        this.length -= 1;</span><br><span class="line">        return current.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // remove方法</span><br><span class="line">    DoubleLinkedList.prototype.remove = function(value)&#123;</span><br><span class="line">        let position = this.indexOf(value);</span><br><span class="line">        return this.removeAt(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // isEmpty方法</span><br><span class="line">    DoubleLinkedList.prototype.isEmpty = function()&#123;</span><br><span class="line">        return !this.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // size方法</span><br><span class="line">    DoubleLinkedList.prototype.size = function()&#123;</span><br><span class="line">        return this.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DoubleLinkedList.prototype.getHead = function()&#123;</span><br><span class="line">        return this.head.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DoubleLinkedList.prototype.getTail = function()&#123;</span><br><span class="line">        return this.tail.data;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将链表转成字符串</span><br><span class="line">    DoubleLinkedList.prototype.toString = function()&#123;</span><br><span class="line">        return this.backwardString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DoubleLinkedList.prototype.forwardString = function()&#123;</span><br><span class="line">        let current = this.tail;</span><br><span class="line">        let resultString = &apos;&apos;;</span><br><span class="line">        while(current)&#123;</span><br><span class="line">            resultString += current.data + &apos; &apos;;</span><br><span class="line">            current = current.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从前向后遍历</span><br><span class="line">    DoubleLinkedList.prototype.backwardString = function()&#123;</span><br><span class="line">        let current = this.head;</span><br><span class="line">        let resultString = &apos;&apos;;</span><br><span class="line">        while(current)&#123;</span><br><span class="line">            resultString += current.data + &apos; &apos;;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>几乎每种编程语言中，都有集合结构，比较常见的实现方式是哈希表。</p>
<p>集合通常是由一组<strong>无序的，不能重复的</strong>元素组成与数学中的集合不同，计算机中的集合表示的结构中元素是不允许重复的。ES6中的Set类就是一种集合类。</p>
<h6 id="集合常见操作："><a href="#集合常见操作：" class="headerlink" title="集合常见操作："></a>集合常见操作：</h6><ol>
<li>add（value）向集合添加一个新的项。</li>
<li>remove（value）：从集合中一个数</li>
<li>has（value）：值是否在集合中，有返回true，没有返回false</li>
<li>clear（）：移除集合所有项。</li>
<li>size（）：length属性</li>
<li>values（）：返回所有值的数组。</li>
</ol>
<h6 id="集合间的操作"><a href="#集合间的操作" class="headerlink" title="集合间的操作"></a>集合间的操作</h6><p><strong>并集</strong></p>
<p><strong>交集</strong></p>
<p><strong>差集</strong></p>
<p><strong>子集</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">// 封装集合</span><br><span class="line">function Set()&#123;</span><br><span class="line">    // 属性</span><br><span class="line">    this.item = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // add方法</span><br><span class="line">    Set.prototype.add = function(value)&#123;</span><br><span class="line">        // 先判断是否有该值</span><br><span class="line">        if(this.has(value))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.item[value] = value;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set.prototype.has = function(value)&#123;</span><br><span class="line">        return this.item.hasOwnProperty(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set.prototype.remove = function(value)&#123;</span><br><span class="line">        // 判断有无该值</span><br><span class="line">        if(!this.has(value))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        delete this.item[value];</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set.prototype.clear = function()&#123;</span><br><span class="line">        this.item = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set.prototype.size = function()&#123;</span><br><span class="line">        return Object.keys(this.item).length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set.prototype.values = function()&#123;</span><br><span class="line">        return Object.keys(this.item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 并集</span><br><span class="line">    Set.prototype.union = function(otherSet)&#123;</span><br><span class="line">        // this: 集合对象A</span><br><span class="line">        // otherSet：集合对象B</span><br><span class="line">        let unionSet = new Set();</span><br><span class="line">        let value = this.values();</span><br><span class="line">        for(let i = 0; i &lt; value.length;i++)&#123;</span><br><span class="line">            unionSet.add(value[i])</span><br><span class="line">        &#125;</span><br><span class="line">        // 去除B集合中的元素，判断是否需要添加到新的集合</span><br><span class="line">        value = otherSet.values();</span><br><span class="line">        for(let i = 0; i &lt; value.length;i++)&#123;</span><br><span class="line">            unionSet.add(value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return unionSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 交集</span><br><span class="line">    Set.prototype.intersection = function(otherSet)&#123;</span><br><span class="line">        let intersection = new Set();</span><br><span class="line">        let value = this.values();</span><br><span class="line">        for(let i = 0; i &lt; value.length;i++)&#123;</span><br><span class="line">            if(otherSet.has(value[i]))&#123;</span><br><span class="line">                intersection.add(value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return intersection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 差集</span><br><span class="line">    Set.prototype.differce = function(otherSet)&#123;</span><br><span class="line">        let differce = new Set();</span><br><span class="line">        let value = this.values();</span><br><span class="line">        for(let i = 0; i &lt; value.length;i++)&#123;</span><br><span class="line">            if(!otherSet.has(value[i]))&#123;</span><br><span class="line">                differce.add(value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return differce;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 子集：集合A是否为集合B的子集</span><br><span class="line">    Set.prototype.subSet = function(otherSet)&#123;</span><br><span class="line">        let value = this.values();</span><br><span class="line">        for(let i = 0; i &lt; value.length;i++)&#123;</span><br><span class="line">            if(!otherSet.has(value[i]))&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表无论多少条数据，插入删除值需要接近常量的时间：即O（1）的时间级。实际上，只需要几个机器指令即可完成。</p>
<p>哈希表的速度比树快，基本可在瞬间找到想要的元素，且哈希表相对于树来说编码要容易得多。哈希表基于数组，但效率比数组高。</p>
<p>哈希表相对于数组：</p>
<ol>
<li>哈希表中的数据没有顺序，所以不能以一种固定的方式，比如从小到大来遍历其中的元素。</li>
<li>哈希表中的key不允许重复，不能放置相同的key用于保存不同的元素。</li>
</ol>
<h6 id="字母转数字"><a href="#字母转数字" class="headerlink" title="字母转数字"></a>字母转数字</h6><p>方案一：把数字相加求和产生的数组下标太少。</p>
<p>方案二：与27的幂相乘求和产生的数组下标又太多。</p>
<h6 id="哈希化"><a href="#哈希化" class="headerlink" title="哈希化"></a>哈希化</h6><p><strong>哈希化</strong>：将大数字转化为数组范围内下标的过程，我们称之为哈希化。</p>
<p><strong>哈希函数</strong>：通常我们将单词转为大数字，大数字在进行哈希化的代码实现放在一个函数中，这就是哈希函数。</p>
<p><strong>哈希表</strong>：最终将数据插入到这个数组，对整个结构的封装，我们就称之为哈希表。</p>
<p>哈希化后的下标值仍可能会重复，解决方案有二：</p>
<h6 id="1-链地址法"><a href="#1-链地址法" class="headerlink" title="1.链地址法"></a>1.链地址法</h6><p>链地址解决冲突的办法是每个数组单元中存放的不再是单个数据，而是一个链条（数组和链表），当发现重复时，便把重复的元素插入到链表的首端或末端即可。当查询时，先根据哈希化后的下标值找到对应的位置，再取出链表，依次查询寻找的数据。</p>
<p>一般哈希化的index找出这个链表或数组时，通常就会使用线性查找，这时数组和链表的效率是差不多的。</p>
<p>但若是需要将新插入的数据放在数组或链表的最前面，因为觉得新插入的数据用于取出的可能性更大，这种情况最好采用链表，因为数组在首位插入数据时需要其他项后移，链表则没有此问题。<img src="C:%5CUsers%5CCCY%5CDesktop%5C5.png" alt="5"></p>
<h6 id="2-开放地址法"><a href="#2-开放地址法" class="headerlink" title="2.开放地址法"></a>2.开放地址法</h6><p>开放地址法的主要工作方式是寻找空白的单元格来添加重复的数据。</p>
<p><img src="C:%5CUsers%5CCCY%5CDesktop%5C6.png" alt="6"></p>
<h6 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a><strong>线性探测</strong></h6><p>线性的查找空白的单元。</p>
<p>插值：当我们通过哈希化找到下标值时，发现该位置已经有值了，下标值就自加1开始一点一点查找合适的位置（空的位置）</p>
<p>查询：首先经过哈希化得到下标值，比较该下标值的结果与查询的数值是否相同，相同则返回，不同则线性查找（下标值加1），查到空位置即停止。因为插值时不可能跳过空位置去其他位置。</p>
<p>删除：删除一个数据项时，不可以将这个位置下标的内容设置为null，因为将它设置为null可能影响我们之后查询其他操作，所以通常删除一个位置的数据项时，需将其进行特殊处理（比如设置为-1）。</p>
<p>当我们之后看到-1位置的数据项时就知道查询时要继续查询，但是插入该位置可放置数据。</p>
<p>线性探测有一个较严重的问题就是聚集（连续填充单位），它会影响哈希表的性能，无论删除/插入/删除都会影响。</p>
<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><ol>
<li>节点的度（degree）：节点的子树个数。</li>
<li>树的度：树的所有节点中最大的度数。</li>
<li>叶节点（leaf）：度为0的节点（也称为叶子节点）。</li>
<li>父节点（parent）：有子树的节点是其树的根节点的父节点。</li>
<li>子节点（child）</li>
<li>兄弟节点路径和路径长度：一个节点序列的父节点，路径所包含的边的个数为路径的长度。</li>
<li>节点的层次（level）：规定根节点在1层，其他节点的层数是其父节点的层数加1.</li>
<li>树的深度（depth）：树中所有节点中的最大层次是这棵树的深度。</li>
</ol>
<h6 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h6><ol>
<li>一个二叉树第i层的最大节点数为<code>2^(i-1),i&gt;=1</code>;</li>
<li>深度为k的二叉树有最大的节点总数为：<code>2^k-1,k&gt;=1</code>;</li>
<li>对任何非空二叉树T，若n0表示叶结点的个数，n2是度为2的非叶节点个数，则两者关系n0 = n2 + 1。</li>
</ol>
<h6 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h6><p>二叉搜索树（BST ,Binary Search Tree)，也称二叉排序树或二叉查找树。二叉搜索树是一颗二叉树，可以为空；二分查找法其实就是利用的二叉搜索树。</p>
<p>如果不为空，满足以下性质：</p>
<ol>
<li>非空左子树的所有键值小于其根节点的键值。</li>
<li>非空右节点的所有键值大于其根节点的键值。</li>
<li>左，右子树本身也都是二叉树。</li>
</ol>
<p>常见操作：</p>
<ol>
<li><p>insert（key）：向树中插入一个新的键</p>
</li>
<li><p>search（key）：树中查找键</p>
</li>
<li><p>inOrderTraverse：通过中序遍历所有节点。</p>
</li>
<li><p>preOrderTraverse：先序</p>
</li>
<li><p>postOrderTraverse：后序</p>
</li>
<li><p>min</p>
</li>
<li><p>max</p>
</li>
<li><p>remove（key）</p>
<p>如果我们要删除的节点current有两个子节点，甚至子节点还有子节点，这种情况下就需要从current下面所有节点中找到一个最接近current的节点来替换current。</p>
<p>最接近curren的节点必定是比current小一点点的节点（它必是current左子树中的最大值，叫做<strong>前驱</strong>）和比current大一点点的节点（current右子树的最小值，叫做<strong>后继</strong>）</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line">function BinarySearchTree() &#123;</span><br><span class="line">    function Node(key) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.left = null;</span><br><span class="line">        this.right = null;</span><br><span class="line">    &#125;</span><br><span class="line">    this.root = null;</span><br><span class="line">    // insert方法:对外给用户调用的方法</span><br><span class="line">    BinarySearchTree.prototype.insert = function (key) &#123;</span><br><span class="line">        // 根据key值创建节点</span><br><span class="line">        let newNode = new Node(key);</span><br><span class="line">        // 判断根节点是否为空，空节点直接将新节点赋给根节点</span><br><span class="line">        // 非空节点则调用内部insertNode方法</span><br><span class="line">        if (this.root == null) &#123;</span><br><span class="line">            this.root = newNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.insertNode(this.root, newNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BinarySearchTree.prototype.insertNode = function (node, newNode) &#123;</span><br><span class="line">        if (newNode.key &lt; node.key) &#123; //向左查找</span><br><span class="line">            if (node.left == null) &#123;</span><br><span class="line">                node.left = newNode;</span><br><span class="line">            &#125; else &#123; //向右查找</span><br><span class="line">                this.insertNode(node.left, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (node.right == null) &#123;</span><br><span class="line">                node.right = newNode;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.insertNode(node.right, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 树的遍历</span><br><span class="line">    // 1.先序遍历</span><br><span class="line">    BinarySearchTree.prototype.preOrderTraversal = function (handler) &#123;</span><br><span class="line">        this.preOrderTraversalNode(this.root, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    BinarySearchTree.prototype.preOrderTraversalNode = function (node, handler) &#123;</span><br><span class="line">        if (node != null) &#123;</span><br><span class="line">            // 先序就是先处理遍历来的数</span><br><span class="line">            handler(node.key);</span><br><span class="line">            // 处理经过节点的左子节点</span><br><span class="line">            this.preOrderTraversalNode(node.left, handler);</span><br><span class="line">            // 处理经过节点的右子节点</span><br><span class="line">            this.preOrderTraversalNode(node.right, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 中序遍历</span><br><span class="line">    BinarySearchTree.prototype.midOrderTraversal = function (handler) &#123;</span><br><span class="line">        this.midOrderTraversalNode(this.root, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    BinarySearchTree.prototype.midOrderTraversalNode = function (node, handler) &#123;</span><br><span class="line">        if (node != null) &#123;</span><br><span class="line">            this.midOrderTraversalNode(node.left, handler);</span><br><span class="line">            handler(node.key);</span><br><span class="line">            this.midOrderTraversalNode(node.right, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 右序遍历</span><br><span class="line">    BinarySearchTree.prototype.postOrderTraversal = function (handler) &#123;</span><br><span class="line">        this.postOrderTraversalNode(this.root, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    BinarySearchTree.prototype.postOrderTraversalNode = function (node, handler) &#123;</span><br><span class="line">        if (node != null) &#123;</span><br><span class="line">            this.postOrderTraversalNode(node.left);</span><br><span class="line">            this.postOrderTraversalNode(node.right);</span><br><span class="line">            handler(node.key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     //层序遍历</span><br><span class="line">    BinarySearchTree.prototype.levelOrderTraversal = function()&#123;</span><br><span class="line">        if(!this.root) return false;   //头节点为空返回false</span><br><span class="line">        let result = [];   //创建一个数组存放结果</span><br><span class="line">        let tree = [];    //创建一个数组存放二叉树</span><br><span class="line">        tree.push(this.root);    //先传入头节点</span><br><span class="line">        while(tree.length)&#123;       //当tree数组长度不为空</span><br><span class="line">            let node = tree.shift();     //将数组中的第一个节点放到node中</span><br><span class="line">            result.push(node.key);         // 将node节点的值放入result中</span><br><span class="line">            if(node.left)&#123;                 //如果node的左节点不为空，就将左节点压入tree数组中</span><br><span class="line">                tree.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if(node.right)&#123;                //如果node的右节点不为空，就将左节点压入tree数组中</span><br><span class="line">                tree.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 找最小值，在最左边位置</span><br><span class="line">    BinarySearchTree.prototype.min = function () &#123;</span><br><span class="line">        let node = this.root;</span><br><span class="line">        while (node.left) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        return node.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // max</span><br><span class="line">    BinarySearchTree.prototype.max = function () &#123;</span><br><span class="line">        let node = this.root;</span><br><span class="line">        while (node.right) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return node.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // search搜索特定的值</span><br><span class="line">    // 递归搜索</span><br><span class="line">    // BinarySearchTree.prototype.search = function (key) &#123;</span><br><span class="line">    //     return this.searchNode(this.root, key);</span><br><span class="line">    // &#125;</span><br><span class="line">    // BinarySearchTree.prototype.searchNode = function (node, key) &#123;</span><br><span class="line">    //     if (node == null) &#123;</span><br><span class="line">    //         return false;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     if (key &lt; node.key) &#123;</span><br><span class="line">    //        return this.searchNode(node.left, key);</span><br><span class="line">    //     &#125; else if (key &gt; node.key) &#123;</span><br><span class="line">    //         return this.searchNode(node.right, key);</span><br><span class="line">    //     &#125; else &#123;</span><br><span class="line">    //         return true;</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;</span><br><span class="line">    // 循环搜索</span><br><span class="line">    BinarySearchTree.prototype.search = function(key)&#123;</span><br><span class="line">        let node = this.root;</span><br><span class="line">        while(node)&#123;</span><br><span class="line">            if(key &lt; node.key)&#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;else if(key &gt; node.key)&#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除节点</span><br><span class="line">    BinarySearchTree.prototype.remove = function(key)&#123;</span><br><span class="line">        // 寻找要删除的节点，定义变量，保存一些信息</span><br><span class="line">        let parent = null;</span><br><span class="line">        let current = this.root;</span><br><span class="line">        let isLeftChild = true;</span><br><span class="line"></span><br><span class="line">        // 开始寻找删除的节点</span><br><span class="line">        while(current.key != key)&#123;</span><br><span class="line">            parent = current;</span><br><span class="line">            if(key &lt; current.key)&#123;</span><br><span class="line">                isLeftChild = true;</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                isLeftChild = false;</span><br><span class="line">                current = current.right;</span><br><span class="line">            &#125;</span><br><span class="line">            // 若已经找到最后的节点，依然没找到等于key的节点</span><br><span class="line">            if(current == null)   return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 找到了要删除的节点</span><br><span class="line">        // 1.是一个叶节点</span><br><span class="line">        if(current.left == null &amp;&amp; current.right == null)&#123;</span><br><span class="line">            if(isLeftChild)&#123;</span><br><span class="line">                parent.left = null;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                parent.right = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.删除节点有一个子节点</span><br><span class="line">        else if(current.right == null)&#123;</span><br><span class="line">            if(current == this.root)&#123;</span><br><span class="line">                this.root = current.left;</span><br><span class="line">            &#125;else if(isLeftChild)&#123;</span><br><span class="line">                parent.left = current.left;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                parent.right = current.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(current.left == null)&#123;</span><br><span class="line">            if(current == this.root)&#123;</span><br><span class="line">                this.root = current.right;</span><br><span class="line">            &#125;else if(isLeftChild)&#123;</span><br><span class="line">                parent.left = current.right;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                parent.right = current.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 3.删除的节点上有两个节点</span><br><span class="line">        else&#123;</span><br><span class="line">            // 找到后继</span><br><span class="line">            let successor = this.getSuccessor(current);</span><br><span class="line">            if(current == this.root)&#123;</span><br><span class="line">                this.root = successor;</span><br><span class="line">            &#125;else if(isLeftChild)&#123;</span><br><span class="line">                parent.left = successor;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                parent.right = successor;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 将删除节点的左子树</span><br><span class="line">            successor.left = current.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 找后继的方法</span><br><span class="line">    BinarySearchTree.prototype.getSuccessor = function(delNode)&#123;</span><br><span class="line">        // 定义变量，保存找到的后继</span><br><span class="line">        let successor = delNode;</span><br><span class="line">        let current = delNode.right;</span><br><span class="line">        let successorParent = delNode.parent;</span><br><span class="line"></span><br><span class="line">        // 循环查找</span><br><span class="line">        while(current != null)&#123;</span><br><span class="line">            successorParent = successor;</span><br><span class="line">            successor = current;</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        // 判断寻找的后继节点是否直接就是delNode的right节点</span><br><span class="line">        if(successor != delNode.right)&#123;</span><br><span class="line">            successorParent.left = successor.right;</span><br><span class="line">            successor.right = delNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return successor;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let bst = new BinarySearchTree();</span><br><span class="line">bst.insert(11);</span><br><span class="line">bst.insert(7);</span><br><span class="line">bst.insert(15);</span><br><span class="line">bst.insert(42);</span><br><span class="line">bst.insert(5);</span><br><span class="line">bst.insert(8);</span><br><span class="line">let resultStr = &apos;&apos;;</span><br><span class="line">bst.preOrderTraversal(function (key) &#123;</span><br><span class="line">    resultStr += key + &apos; &apos;;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(resultStr);</span><br><span class="line">bst.remove(11);</span><br><span class="line">resultStr = &apos;&apos;;</span><br><span class="line">bst.midOrderTraversal(function (key) &#123;</span><br><span class="line">    resultStr += key + &apos; &apos;;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(resultStr);</span><br></pre></td></tr></table></figure>

<p>我们发现删除操作很棘手。实际上，因为它复杂，所以我们尽量避免删除操作。做法是在Node类中添加一个boolean的字段，比如isDeleted。要删除一个节点时就将该字段设为true。进行其他操作时，比如find（），在查找前会先判断这个节点是不是被标记为删除。这样比较简单，不会删除原来的树结构，但在二叉树存储中仍保留着本该被删除的节点，造成了很大的空间浪费。</p>
<p>二叉搜索树可快速找到给定关键字的数据项，并且可快速插入和删除数据项。但是当插入的数据是有序的数据时，树的深度就会变得很大，变成非平衡二叉树。</p>
<p>非平衡树：</p>
<ol>
<li>比较好的二叉搜索树数据项应该是左右分布均匀的，但是插入连续数据后，分布的不均匀即为非平衡树。</li>
<li>对于一颗平衡二叉树来说，查找和插入等操作的效率是O（logN）。</li>
<li>非平衡二叉树相当于编写了一个链表，查找效率变成了O（N）。</li>
</ol>
<p><strong>AVL树</strong></p>
<p>AVL树是最早的一种平衡树，他有办法保持树的平衡（每个节点多存储了一个额外的数据），时间复杂度为O（logN），但每次删除插入操作不及红黑树，所以整体效率不如红黑树。</p>
<h6 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h6><p>红黑树除了满足二叉搜索树的基本规则外，还有以下特性：</p>
<ol>
<li>节点都是黑色或红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点都是黑色的空节点（Null节点）。</li>
<li>每个红色节点的两个子节点都是黑色。（从每个叶子到根所有路径上不能有两个连续的红色节点）。</li>
<li>从任意节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
</ol>
<p>以上约束确保了红黑树的关键特性：</p>
<ol>
<li>从根到叶子的最长可能路径不会超过最短可能路径的两倍长。最短者的可能路径是都是黑色节点，最长的可能路径是红色和黑色交替。</li>
<li>红黑树基本是平衡的，虽然没有做到绝对的平衡，但是可以保证在最坏的情况下依然是高效的。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 陈楚吟
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
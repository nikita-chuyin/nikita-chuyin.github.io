<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="陈楚吟">


    
    


<meta name="description" content="将学习技术点汇总">
<meta name="keywords" content="write myBlog">
<meta property="og:type" content="website">
<meta property="og:title" content="Nikita">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Nikita">
<meta property="og:description" content="将学习技术点汇总">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nikita">
<meta name="twitter:description" content="将学习技术点汇总">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Nikita" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Nikita</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">陈楚吟</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不负韶华</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">陈楚吟</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">陈楚吟</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不负韶华</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-http进阶" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/30/http进阶/" class="article-date">
      <time datetime="2020-04-29T23:40:38.000Z" itemprop="datePublished">2020-04-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/30/http进阶/">http进阶</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h6 id="Telnet实例"><a href="#Telnet实例" class="headerlink" title="Telnet实例"></a>Telnet实例</h6><p>由于Http使用的是TCP/IP传输协议，而且它是基于文本的，没有使用哪些难以理解的二进制格式，因此很容易直接1与Web服务器进行对话。</p>
<p>Telnet程序可以将键盘连接到某个目标TCP端口，并将此TCP端口的输出回送到显示屏上。Telnet常用于远程终端会话，但它几乎可以连接所有的TCP服务器，包括HTTP服务器。</p>
<h4 id="Web结构组件"><a href="#Web结构组件" class="headerlink" title="Web结构组件"></a>Web结构组件</h4><ol>
<li>代理：位于客户端和服务器之间的HTTP中间实体。</li>
<li>缓存：HTTP的仓库，是常用页面的副本可以存在离客户端更近的地方。</li>
<li>网关：连接应用程序的特殊Web服务器。</li>
<li>隧道：对HTTP通信报文进行盲转发的特殊代理。</li>
<li>Agent代理：发起自动HTTP请求的半智能Web客户端。</li>
</ol>
<h6 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h6><p>HTTP代理服务器是Web安全，应用集成以及性能优化的重要组成模块。</p>
<p>代理位于客户端与服务器之间，接收所有客户端的HTTP请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。</p>
<p>出于安全考虑，通常会将代理作为转发所有Web流量的可信任中间节点使用。代理还可以对请求和响应进行过滤。比如，在企业中对下载的应用程序进行病毒检测，或者对小学生屏蔽一些成人才能看的内容。</p>
<h6 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h6><p>WEb缓存（Web cache）或代理缓存（proxy cache）是一种特殊的HTTP代理服务器，可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了。</p>
<h6 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h6><p>网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用，通常用于将HTTP流量转换成其他的协议。网关接受时就好像自己是咨议员的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。</p>
<p>如：一个HTTP/FTP网关会通过HTTP请求接受对FTP URI的请求，但通过FTP协议来获取文档。得到的文档会被封装成一条HTTP报文发给客户端。</p>
<h6 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h6><p>隧道（tunnel）是建立起来之后就会在两条连接之间对原始数据进行盲转发的HTTP应用程序。HTTP隧道通常用来在一条或多条HTTP连接上进行转发非HTTP数据，转发时不会窥探数据。</p>
<p>HTTP隧道的一种常见用途是通过HTTP连接承载加密的安全套接字层（SSL,Secure Socket Layout)流量，这样ssl流量就可以穿过只允许Web流量通过的防火墙了。</p>
<p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E9%9A%A7%E9%81%93.png" alt="隧道"></p>
<p>如：HTTP/SSL隧道收到一条HTTP请求，要求建立一条到目的的地址和端口的输出连接，然后在HTTP信道上通过隧道传输加密的SSL流量，这样就可以将其转发到目的服务器上。</p>
<h6 id="Agent代理"><a href="#Agent代理" class="headerlink" title="Agent代理"></a>Agent代理</h6><p>用户代理是代表用户发起HTTP请求的客户端程序。所有发布Web请求的应用程序都是HTTP Agent代理。到目前为止，我们只提过一种HTTP Agent代理：WEb浏览器，但用户Agent代理还有很多类型。</p>
<p>如：有些自己会在Web上闲逛的自动用户Agent代理，可以在无人监视的情况下发布HTTP事务并获取内容。这些自动代理的名字很生动，比如“网络蜘蛛”或“web机器人”。网络蜘蛛会在WEb上闲逛，搜集信息以构建有效的Web内容档案，比如一个搜索引擎的数据库或者为比较购物机器人生成的产品目录。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200430094207000.png" alt="image-20200430094207000"></p>
<h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><p>请求报文格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;method&gt;     &lt;request-URL&gt;  &lt;version&gt;</span><br><span class="line">&lt;headers&gt; </span><br><span class="line">&lt;entrity-body&gt;</span><br></pre></td></tr></table></figure>

<p>响应报文</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;version&gt;   &lt;status&gt;   &lt;response-phrase&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line">&lt;entrity-body&gt;</span><br></pre></td></tr></table></figure>

<h6 id="方法（method）"><a href="#方法（method）" class="headerlink" title="方法（method）"></a>方法（method）</h6><p>客户端希望服务器对资源执行的动作，是一个单独的词，比如GET,HEAD或POST.</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>是否包含主体</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>从服务器获取一份文档</td>
<td>否</td>
</tr>
<tr>
<td>HEAD</td>
<td>只从服务器获取文档的首部</td>
<td>否</td>
</tr>
<tr>
<td>POST</td>
<td>向服务器发送需要处理的数据</td>
<td>是</td>
</tr>
<tr>
<td>PUT</td>
<td>将请求的主体部分存储在服务器上</td>
<td>是</td>
</tr>
<tr>
<td>TRACE</td>
<td>对可能经过代理服务器传送到服务器上去的报文进行追踪</td>
<td>否</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>决定可以在服务器上执行哪些方法</td>
<td>否</td>
</tr>
<tr>
<td>DELETE</td>
<td>从服务器上删除一份文档</td>
<td>否</td>
</tr>
</tbody></table>
<p><strong>扩展方法</strong>：指的是没有在HTTP/1.1规范中定义的方法，服务器会为它所管理的资源实现一些二HTTP服务，这些方法为开发者提供了一种扩展这些HTTP服务能力的手段。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LOCK</td>
<td>允许用户“锁定”资源——比如，可以在编辑某个资源的时候将其锁定，以防别人对其进行修改。</td>
</tr>
<tr>
<td>MKCOL</td>
<td>允许用户创建资源</td>
</tr>
<tr>
<td>COPY</td>
<td>便于在服务器上复制资源</td>
</tr>
<tr>
<td>MOVE</td>
<td>在服务器上移动资源</td>
</tr>
</tbody></table>
<p>惯例：对所发送的内容要求严一点，对接收的内容宽容一些处理扩展方法。</p>
<ol start="2">
<li><p>请求URL(request-URL)</p>
<p>命名了所有请求资源，或者URL路径组件的完整URL。如果直接与服务器进行对话，只要URL的路径组件是资源的绝对路径，通常就不会有什么问题——服务器可以假定自己是URL的主机/端口。</p>
</li>
<li><p>版本（version）</p>
</li>
<li><p>状态码（status-code）</p>
<p>这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般类型（“成功”、“出错”）。</p>
<p><strong>状态码分类</strong></p>
<table>
<thead>
<tr>
<th>整体范围</th>
<th>已定义范围</th>
<th>分类</th>
</tr>
</thead>
<tbody><tr>
<td>100-199</td>
<td>100-101</td>
<td>信息提示</td>
</tr>
<tr>
<td>200-299</td>
<td>200-206</td>
<td>成功</td>
</tr>
<tr>
<td>300-399</td>
<td>300-305</td>
<td>重定向</td>
</tr>
<tr>
<td>400-499</td>
<td>400-415</td>
<td>客户端错误</td>
</tr>
<tr>
<td>500-599</td>
<td>500-505</td>
<td>服务器错误</td>
</tr>
</tbody></table>
<p><strong>常见状态码</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>成功。请求的所有数据都在响应主体中。</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized（未授权）</td>
<td>需要输入用户名和密码</td>
</tr>
<tr>
<td>404</td>
<td>Not Found（未找到）</td>
<td>服务器无法找到所请求URL对应的资源</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented（无法实现）</td>
<td></td>
</tr>
</tbody></table>
<p><strong>信息性状态码</strong>‘</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue</td>
<td>说明受到了请求的初始部分，请客户端继续，发送了这个状态码后，服务器在收到请求后必须进行响应。</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td>说明服务器正在根据客户端的指定，将协议切换成Update’首部所列的协议。</td>
</tr>
</tbody></table>
<p>100 Continue是一种优化，客户端应用程序只有在避免向服务器发送一个服务器无法处理或使用的大实体时才会使用100 Continue。当服务端超时一定时间后，客户端直接将实体发出去。</p>
<p><strong>成功状态码</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>请求没问题，实体的主体部分包含了所请求的资源</td>
<td>OK</td>
</tr>
<tr>
<td>201</td>
<td>用于创建对象的请求（PUT)。响应的主体部分包含各种已创建资源的URL，location首部包含则是最具体的引用。</td>
<td>Created</td>
</tr>
<tr>
<td>202</td>
<td>请求已被接受，但服务器还未对其执行任何动作，不能保证服务器会完成这个请求。</td>
<td>Accepted</td>
</tr>
<tr>
<td>203</td>
<td>实体部分包含的资源不是来自源服务器，而是来自资源的一份副本。如果中间节点上有一份资源副本，但无法对它所发送的与资源有关的元信息（首部）进行验证，就会出现这种情况。</td>
<td>Non-Authoritative-Information</td>
</tr>
<tr>
<td>204</td>
<td>响应报文中包含若干首部和一个状态行，但没有实体部分，主要用于在浏览器不转为显示新文档的情况下，对其将进行更新（如刷新一个表单页面）</td>
<td>No Content</td>
</tr>
<tr>
<td>205</td>
<td>另一个主要用于浏览器的代码，负责告诉浏览器清除当前页面中所有HTML表单元素。</td>
<td>Reset Content</td>
</tr>
<tr>
<td>206</td>
<td>成功执行一部分请求。稍后会看到，客户端可以通过一些特殊的首部来获取部分或某个范围内的文档——这个状态码就说明请求成功了。</td>
<td>Partial Content</td>
</tr>
</tbody></table>
<p><strong>重定向状态码</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>300</td>
<td>Multiple Choices</td>
<td>客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如服务器上有某个HTML文档的英语和法语版本。返回这个代码时会带有一个选项列表，这样用户就可以选择他希望使用的那一项了。有多个版本1可用时，客户端需要沟通解决。</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permananently</td>
<td>在请求的URL已被移除时使用。响应的Location首部中应该包含资源现在所处的URL。</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>与301状态码相似，但是客户端应该使用Location首部给出的URL来临时定位资源。将来的请求仍应使用老的URL。</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的Location首部。其主要目的是允许POST请求的响应将客户端定向到某个资源上去。</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>客户端可以通过所包含的请求首部，使其请求变成有条件的。如果客户端发起一个GET请求，而最近资源未被修改，就可用这个状态码来说明资源未被修改，带有这个状态吗的响应不应该包含实体的主体部分。</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>用来说明必须通过一个代理来访问资源，代理的位置由Location首部给出。很重要一点是，客户端是相对某个特定资源来解析这个响应的，不能假定所有请求，甚至所有对持有所请求资源的服务器的请求都通过这个代理进行。如果客户端错误的让代理介入了某条请求，可能会引发破环性的行为，而且会造成安全漏洞。</td>
</tr>
<tr>
<td>306</td>
<td>（未使用）</td>
<td>当前未使用</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>与301状态码相似，但是客户端应该使用Location首部给出的URL来临时定位资源。将来的请求仍应使用老的URL。</td>
</tr>
</tbody></table>
<p><strong>客户端错误</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>Bad Request</td>
<td>用于告诉客户端他发送了一个错误的请求</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>与适当的首部一同返回，在这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证。</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>现在这个状态码还未使用，但已经被保留，以作未来之用。</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>用以说明请求被服务器拒绝了，如果服务器想说明为什么拒绝请求，可以包含实体的主体部分来对原因进行描述。但这个状态通常是在服务器不想说明拒绝原因的时候使用的。</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>用于说明服务器无法找到所请求的URL。通常会包含一个实体以便客户端应用程序显示给用户看。</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>发起的请求中带所请求的URL不支持的方法时，使用此状态码。应该在响应中包含Allow首部，以告知客户端对请求的资源可以使用哪些方法。</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>客户端可以指定参数来说明他们愿意接受什么类型的实体。服务器没有与客户端可接受的URL相匹配的资源时，使用此代码。通常，服务器会包含一些首部以便客户端弄清楚为什么请求无法满足。</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>与401状态码类似，但用于要求对资源进行认证的代理服务器。</td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout</td>
<td>如果客户端完成请求所花的时间太长，服务器可以回送此状态码，并关闭连接。超时时长随服务器的不同而不同，但通常对所有合法请求来说都是够长的。</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>用于说明请求可能在资源上引发的一些冲突，服务器担心请求会引发冲突时可发送此状态码。响应中应该包含描述冲突的主体。</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>与404相似，只要服务曾经拥有过此资源。主要用于Web站点的维护，这样服务器的管理者就可以在资源被移除的情况下通知客户端了。</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>服务器要求在请求报文中包含Content-Length首部时使用。</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>客户端发起了条件请求且其中一个条件失败时使用。</td>
</tr>
<tr>
<td>413</td>
<td>Request Entrity Too Large</td>
<td>客户端发送实体主体部分比服务器能够或希望处理的要大时发送此状态码。</td>
</tr>
<tr>
<td>414</td>
<td>Request URL Too Long</td>
<td>客户端发送请求中的URL比服务器希望处理的要大时发送此状态码。</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器无法理解或无法支持客户端所发送实体的内容类型时</td>
</tr>
<tr>
<td>416</td>
<td>Unsupported Media Type</td>
<td>请求报文所请求的是指定资源的某个范围，而此范围无效或无法满足时使用此状态码。</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>请求的Expect请求首部包含了一个期望，但服务器无法满足此期望时，使用此状态码。如果代理或其他中间应用程序与确切证据说明源端服务器会为某请求产生一个失败的期望就可发送此状态码。</td>
</tr>
</tbody></table>
<p><strong>服务器错误</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器遇到一个妨碍它为请求提供服务的错误时使用此状态码。</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>客户端发起的请求超出服务器的能力范围。</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应（如，他无法链接到其父网关时）。</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>用来说明服务器现在不能为请求提供服务，但将来可以。如果服务器知道什么时候资源会变为可用的，可在响应中包含一个Retry-After首部。</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout</td>
<td>与状态码408相似，只是这里的响应来自一个网关或代理，他们在等待另一服务器对其请求进行响应时超时了。</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version Not Supported</td>
<td>服务器收到的请求使用了它无法或不愿支持的协议版本。有些服务器应用程序会选择不支持协议的早期版本。</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="5">
<li><p>原因短语（reason-phrase）</p>
<p>数字状态码的可读版本，包含行终止序列的所有文本。</p>
</li>
<li><p>首部（header）</p>
<p>可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号，然后是一个可选的空格，接着是一个值，最后是一个CRLF。首部是由一个空行结束的，表示了首部列表的结束和实体主体部分的开始。</p>
<p><strong>首部分类</strong></p>
<ul>
<li>通用首部：既可以出现在请求报文中，又可以出现在响应报文中。</li>
<li>请求首部：提供更多有关请求的信息。</li>
<li>响应首部：提供更多有关响应的信息。</li>
<li>实体首部：描述主体的长度和内容，或者资源自身。</li>
<li>扩展首部：规范中没有定义的新首部。</li>
</ul>
<p><strong>常见首部实例</strong></p>
<table>
<thead>
<tr>
<th>首部实例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Date：Tue,3 Oct 1997  02:16:03  GMT</td>
<td>服务器产生响应的日期</td>
</tr>
<tr>
<td>Content-length:15040</td>
<td>实体的主体部分包含了</td>
</tr>
<tr>
<td>Content-type:image/gif</td>
<td>实体的主体部分是一个GIF图片</td>
</tr>
<tr>
<td>Accept:image/gif, image/jpeg, text/html</td>
<td>客户端可以接收</td>
</tr>
<tr>
<td>Connection</td>
<td>允许客户端和服务器指定与请求或响应连接有关的选项。</td>
</tr>
<tr>
<td>MIME-Version</td>
<td>给定发送端使用的MIME版本。</td>
</tr>
<tr>
<td>Trailer</td>
<td>如果报文采用了分块传输编码（chunked transfer encoding）方式就可以用这个首部列出位于报文拖挂（trailer）部分的首部集合。</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>告知接收端为了保证报文可靠传输，对报文采取什么编码方式。</td>
</tr>
<tr>
<td>Update</td>
<td>给出了发送端可能想要“升级”使用的新版本或协议。</td>
</tr>
<tr>
<td>Via</td>
<td>显示了报文经过的中间节点（代理，网关）</td>
</tr>
</tbody></table>
</li>
<li><p>实体的主体部分（entrity-body）</p>
<p>实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分。</p>
</li>
</ol>
<h6 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h6><p>通用缓存首部：HTTP/1.0引入了第一个允许HTTP应用程序缓存对象本地副本的首部，这样就不需要总是直接从源端服务器获取了。</p>
<table>
<thead>
<tr>
<th>首部</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>用于随报文传送缓存指示。</td>
</tr>
<tr>
<td>Pragma</td>
<td>另一种随报文传送指示的方式，但并不专用于缓存。</td>
</tr>
</tbody></table>
<p><strong>请求首部</strong>：是只在请求报文中有意义的首部，用于说明是谁或什么在发送请求，请求源自何处，或者客户端的喜好和能力。服务器可以根据请求首部给出的客户端信息，试着为客户端提供更好的响应。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502215359440.png" alt="image-20200502215359440"></p>
<p><strong>Accept首部</strong>为客户端提供一种将其喜好和能力告知服务器的方式，包括它们想要什么，可以使用什么，以及最重要的，他们不想要什么，这样，服务器可以根据这些额外的信息，对要发送的内容做出更明智的决定。Accept首部会使连接的两端都受益。客户端会得到它们想要的内容，服务器则不会浪费时间和带宽来发送客户端无法使用的东西。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502220337984.png" alt="image-20200502220337984"></p>
<p><strong>条件请求首部</strong>：有时客户端希望为请求加上某些限制。比如，如果客户端已经有了一份文件副本就希望只在服务器上的文档与客户端拥有的副本有所区别时才请求服务器传输文档。通过条件请求首部，客户端就可以为请求加上这种限制，要求服务器在对请求进行响应前，确保某个条件为真。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502220845355.png" alt="image-20200502220845355"></p>
<p><strong>安全请求首部</strong></p>
<p>HTTP本身就支持一种简单的机制，可以对请求进行质询/响应认证。这种机制要求客户端在获取特定资源之前，先对自身进行认证，这样就可以使事务稍微安全一些。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502221420633.png" alt="image-20200502221420633"></p>
<p><strong>代理请求首部</strong></p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502221552479.png" alt="image-20200502221552479"></p>
<h6 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h6><p>响应报文有自己的响应首部集。响应首部为客户端提供了一些额外信息，比如谁发送响应，响应者的功能，甚至与响应相关的一些特殊指令，这些首部有助于客户端处理响应，并在将来发起更好的请求。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200503080735091.png" alt="image-20200503080735091"></p>
<p><strong>协商首部</strong></p>
<p>如果资源有多种表示方法——如，若服务器上有某文档的法语和德语译稿，HTTP/1.1可以为服务器和客户端提供对资源进行协商的能力。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200503082210004.png" alt="image-20200503082210004"></p>
<p><strong>安全响应首部</strong></p>
<table>
<thead>
<tr>
<th>首部</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Proxy-Authenticate</td>
<td>来自代理的对客户端的质询列表</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>不是真正的安全首部，但隐含有安全功能，可以在客户端设置一个令牌，以便服务器对客户端进行标识。</td>
</tr>
<tr>
<td>Set-Cookie2</td>
<td>与Set-Cookie类似</td>
</tr>
<tr>
<td>www-Authenticate</td>
<td>来自服务器的对客户端的质询列表</td>
</tr>
</tbody></table>
<h6 id="HTTP事务产生时延的原因"><a href="#HTTP事务产生时延的原因" class="headerlink" title="HTTP事务产生时延的原因"></a>HTTP事务产生时延的原因</h6><ol>
<li>客户端首先需要根据URI确定Web服务器的IP地址和端口号。如果最近没有对URI中的主机名进行访问，通过DNS解析系统将URI中的主机名转换成一个IP地址可能要花费数十秒的时间。</li>
<li>接下来，客户端会向服务器发送一条TCP连接请求，并等待服务器回送一个请求经接受应答。每条新的TCP连接都会有连接建立时延。这个值通常最多只有一两秒钟，但如果有数百个HTTP事务的话，这个值就会快速叠加上去。</li>
<li>一旦连接建立起来，客户端就会通过新建立的TCP管道来发送HTTP请求。数据到达时，Web服务器会从TCP链接中读取请求报文，并对请求进行处理。因特网传输请求报文，以及服务器请求报文都需要时间。</li>
<li>然后，Web服务器会回送HTTP响应，这也需要花费时间。</li>
</ol>
<p>注：大多数HTTP客户端都有一个小的DNS缓存,用来保存近期所访问站点的IP地址。如果已经在本地“缓存”了IP地址，查询就可立即完成，因为大多数Web浏览器浏览的是少数常用站点，所以通常可以很快将主机名解析出来。</p>
<p>TCP网络时延的大小取决于硬件速度，网络和服务器的负载，请求和响应报文的尺寸，以及客户端和服务器之间的距离。</p>
<h6 id="TCP连接握手步骤"><a href="#TCP连接握手步骤" class="headerlink" title="TCP连接握手步骤"></a>TCP连接握手步骤</h6><ol>
<li>请求新的TCP连接时，客户端要向服务器发送一个小的TCP分组（通常是40-60字节）。这个分组中设置了一个特殊的SYN标记，说明这是一个连接请求。</li>
<li>如果服务器接受了连接，就会对连接参数进行计算，并向客户端回送一个TCP分组，这个分组中的SYN和ACK标记都被置位，说明连接请求已被接受。</li>
<li>最后，客户端向服务器回送一条确认消息，通知他连接已成功建立，现代的TCP栈都允许客户端在这个确认分组中发送消息。</li>
</ol>
<p>小的HTTP事务可能会在TCP建立上花费50%，或更多的时间</p>
<h6 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h6><p>由于因特网自身无法确保可靠的分组传输（因特网路由器超负荷的话，可以随意丢弃分组），所以TCP实现了自己的确认机制来确保数据的成功传输。</p>
<p>每个TCP段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段时，都会向发送者回送小的确认分组。如果发送者，欸有在指定的窗口时间内收到确认信息，发送者就会认为分组已被破环或损毁，并重发数据。</p>
<p>由于u企鹅人保温很小，所以TCP允许在发往相同方向的输出数据分组中对其进行“捎带”。TCP将将返回的确认信息与输出的数据分组结合在一起，可以更有效利用网络。为了增加确认报文找到同向传输数据分组的可能性，很多TCP栈都实现了一种延迟确认算法。延迟确认算法会在一个特定的窗口时间内将输出确认缓存放在缓存区中，以寻找能够捎带他的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。</p>
<p>但是，HTTP具有双峰特征的请求——应答行为就降低了捎带信息的可能。当希望有相反方向回传分组的时候，偏偏没有那么多。通常，延迟确认算法会引起相当大的时延。根据所使用的操作系统的不同，可以调整或禁止延迟确认算法。</p>
<p>在对TCP栈的任何参数进行修改之前，一定要对袭击在做什么会有清晰的了解。TCP中引入这些算法的目的是为了防止设计欠佳的应用程序对因特网造成破环。对TCP配置进行任意修改都要绝对确保应用程序不会引发这些i算法所要避免的问题。</p>
<h6 id="TCP慢启动"><a href="#TCP慢启动" class="headerlink" title="TCP慢启动"></a>TCP慢启动</h6><p>TCP数据传输的性能还取决于TCP连接的使用期。TCP连接会随着时间进行自我“调谐”，起初还会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度，这种调谐被称为TCP慢启动，用于防止因特网的突然过载和拥塞。</p>
<p>TCP慢启动限制了一个TCP端点在任意时刻可以传输的分组数。简单来讲是每成功接收一个分组，发送端就有了发送另外两个分组的权限。如果某个HTTP事务有大量的数据要发送，是不能依次将所有分组都发送出去的，必须发送一个分组，确认后才可以再发。这种方式是”打开拥塞窗口“。</p>
<p>由于存在这种拥塞控制特性，所以新连接的传输速度会比已经交换过一定数据量的，“已调谐”连接慢一些。由于已调谐连接要更快一些，所以HTTP中有一些可以重用现存连接的工具。即HTTP“持久连接”。</p>
<h6 id="提高HTTP连接性能的四类方法"><a href="#提高HTTP连接性能的四类方法" class="headerlink" title="提高HTTP连接性能的四类方法"></a>提高HTTP连接性能的四类方法</h6><ol>
<li>并行连接</li>
<li>持久连接</li>
<li>管道化连接</li>
<li>复用连接</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ES6的学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/28/ES6的学习/" class="article-date">
      <time datetime="2020-04-28T06:51:11.000Z" itemprop="datePublished">2020-04-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/ES6的学习/">ES6的学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-vue学习中的问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/28/vue学习中的问题/" class="article-date">
      <time datetime="2020-04-28T04:47:51.000Z" itemprop="datePublished">2020-04-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/vue学习中的问题/">vue学习中的问题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h6 id="登陆切换input复用问题"><a href="#登陆切换input复用问题" class="headerlink" title="登陆切换input复用问题"></a>登陆切换input复用问题</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;span v-if=&quot;isUser&quot;&gt;</span><br><span class="line">            &lt;label for=&quot;userName&quot;&gt;用户账号&lt;/label&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; id=&quot;userName&quot; placeholder=&quot;用户账号&quot; key=&quot;name&quot;&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &lt;span v-else&gt;</span><br><span class="line">            &lt;label for=&quot;email&quot;&gt;用户账号&lt;/label&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; id=&quot;email&quot; placeholder=&quot;用户邮箱&quot; key=&quot;email&quot;&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &lt;button @click=&quot;isUser = !isUser&quot;&gt;切换&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>如果我们在输入内容的情况下切换了类型，我们会发现文字依然显示之前的输入内容。按道理来讲，我们应该切换到另外一个input元素中，在另外这个元素中，我们并没有输入内容，所以应该是空的才对？</p>
<p>这是因为Vue在进行DOM渲染时，出于性能考虑，会尽可能的复用已经存在的元素，而不是重新创建新的元素。</p>
<p>解决：</p>
<p>给对应的input添加不同的key，当进行DOM渲染时，就会识别为不同的元素。</p>
<h6 id="vue管道机制部署"><a href="#vue管道机制部署" class="headerlink" title="vue管道机制部署"></a>vue管道机制部署</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 即前一个函数的输出是后一个函数的输入</span><br><span class="line">const pipeline = (...func) =&gt; val =&gt; func.reduce((a,b) =&gt; b(a),val);</span><br></pre></td></tr></table></figure>

<h6 id="尾调用解决递归"><a href="#尾调用解决递归" class="headerlink" title="尾调用解决递归"></a>尾调用解决递归</h6><p>函数调用自身称为递归。若尾调用自己就称为尾递归。</p>
<p>递归非常耗内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误，但对于尾调用则不会。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 递归</span><br><span class="line">function factorial(n)&#123;</span><br><span class="line">	if(n === 1)  return 1;</span><br><span class="line">	return n*factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 尾调用</span><br><span class="line">function factorial(n,total)&#123;</span><br><span class="line">	if(n === 1)  return total;</span><br><span class="line">	return factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归复杂度为O(n),尾递归的复杂度为O(1)。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-计算机网络" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/27/计算机网络/" class="article-date">
      <time datetime="2020-04-27T12:38:05.000Z" itemprop="datePublished">2020-04-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/27/计算机网络/">计算机网络</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><h6 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h6><p>应用层：所有能产生网络流量的程序，如qq，需要联网才能正常操作，是网络服务与用户的一个接口。</p>
<p>协议有：HTTP   FTP   TFTP   SMTP    SNMP    DNS   TELNET   HTTPS    POP3     DHCP。</p>
<p>应用层安全</p>
<ol>
<li>开发的应用程序没有漏洞。</li>
</ol>
<h6 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h6><p>表示层：在传输之前是否进行加密或压缩处理，以及数据在传输的时候是以ASCII码形式传输还是二进制形式传输。一般如果编码格式不对，页面就不能正常加载，会出现乱码现象。（如我传输过来的是utf-8，却以unicode格式来解析网页，势必会出现乱码现象）。</p>
<p>格式有： JPEG       ASCII     EBCDIC       加密格式等。</p>
<h6 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h6><p>cmd命令行中运行netstat -n可查看会话连接情况，状态为<code>ESTABISHED</code>表示已经建立的会话，<code>TIME_WAIT</code>表示这些会话快释放了。</p>
<p>会话层可用于查木马（盗号木马，如qq被盗，别人就可以给你邮箱发一些东西。远程登录木马，就可以远程登录你的电脑），因为木马总是要和外面建立会话，故可以通过<code>netstat -nb</code>查看建立会话的程序是谁，如果是木马就可以发现了。</p>
<p>建立，管理，终止会话，在五层模型中已经合并到应用层。</p>
<p>对应主机进程，指本地主机与远程主机正在进行会话。</p>
<h6 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h6><p>传输层可进行可靠或不可靠的传输，以及流量控制。定义传输数据的协议端口号，以及流控和差错校验。</p>
<p>协议有：TCP,UDP，数据包一旦离开网卡即进入网络传输层。</p>
<h6 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h6><p>网络层负责选择最佳路径以及规划IP地址（IPv4变为IPv6，只改变网络层）。划分局域段，这是网络层的升级。进行逻辑地址寻址，实现不同网络之间的路径选择。</p>
<p>协议有：ICMP  IGMP  IP(IPv4   IPv4)。</p>
<p>网络层故障：</p>
<ol>
<li>配置错误的IP地址，子网掩码。</li>
<li>配置错误的网关（网关是网络的出口）。</li>
<li>路由器没有配置到达目标网络的路由。</li>
</ol>
<p>网络层安全</p>
<ol>
<li>在路由器上使用ACL控制数据包流量。</li>
</ol>
<h6 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h6><p>数据链路层可以标识帧的开始和结尾（特殊符号标识开始和结尾），透明传输（如果中间内容有与标识结尾的标识符相同，会在该内容前加上某些字符告知交换机此处不是结尾），差错校验（会在后面加上一些字符作为校验位）。交换机中将光纤由百兆升级为千兆，这是数据链路层的知识。</p>
<p>建立逻辑连接，进行硬件地址寻址，差错校验等功能，由底层网络定义协议。将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</p>
<p>数据链路层故障：</p>
<ol>
<li>MAC地址冲突，我们知道一般MAC地址都是唯一的，电脑生产时就已经定义好每台电脑对应的MAC地址，但是我们设置电脑的MAC地址为某台电脑的MAC地址，这样就可能造成MAC地址冲突。</li>
<li>当ADSL欠费，电信就会阻断通信。</li>
<li>网速没办法协商也会出现，服务器规定网速为千兆，而电脑网速为百兆。</li>
<li>计算机连接到错误的VLAN。</li>
</ol>
<p>网络安全</p>
<ol>
<li>ADSL需要输入账号密码。</li>
<li>VLAN交换机端口绑定MAC地址。</li>
</ol>
<h6 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h6><p>规范了一些接口标准（比如各个公司生产的网卡固定了几根线），电器标准（例如0V代表低电平0，5V代表高电平1）以及规定如何在物理链路上传输更快的速度。更换通信介质，更换通信设备是物理层。</p>
<p>建立，维护，断开物理连接，由底层网络定义协议。</p>
<p>物理层故障，在控制面板——&gt; 所有控制面板项——&gt; 网络和共享中心——&gt; 找到已连接网络，点击查看WLAN状态，如果数据包发送不为0，但接收为0，表示是物理层故障，需要检查线是否完好，或重新接好线。</p>
<h4 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h4><p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E6%A8%A1%E5%9E%8B.png" alt="模型"></p>
<p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E4%BC%A0%E8%BE%93.PNG" alt="传输"></p>
<p>FCS:校验位。</p>
<h6 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h6><p>TCP提供了</p>
<ol>
<li>无差错的数据传输。</li>
<li>按序传输（数据总是会按照发送的顺序到达）。</li>
<li>未分段数据流（可以在任意时刻以任意尺寸将数据发送出去）。</li>
<li></li>
</ol>
<h4 id="网络的性能"><a href="#网络的性能" class="headerlink" title="网络的性能"></a>网络的性能</h4><h6 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h6><p>连接在计算机网络上的主机在数字信道上传送数据位数的速率，也称为data rate或bit rate。单位是b/s,  kb/s,  Mb/s,  Gb/s。</p>
<h6 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h6><p>数据通信领域中，数字信道所能传送的最高数据率。</p>
<h6 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h6><p>在单位时间内通过某个网络的数据量。</p>
<h6 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h6><ol>
<li><p>发送时延</p>
<p>发送时延 = 数据块长度（比特）/ 信道带宽（比特/秒）</p>
</li>
<li><p>传播时延</p>
</li>
<li><p>处理时延</p>
</li>
<li><p>排队时延</p>
</li>
</ol>
<h6 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h6><h6 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h6><h6 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h6><ol>
<li>信道利用率：有数据通过时间 / （有+无）数据通过时间</li>
<li>网络利用率：信道利用率加权平均值</li>
</ol>
<p>D = D0 / 1-U</p>
<p>D0 :表示网络空闲时的时延</p>
<p>D：表示信道利用率</p>
<p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1.PNG" alt="数据通信"></p>
<h4 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h4><h6 id="数据通信的术语"><a href="#数据通信的术语" class="headerlink" title="数据通信的术语"></a>数据通信的术语</h6><p>通信的目的是传送消息。</p>
<p>数据（data）—— 运送消息的实体。</p>
<p>信号（signal）——数据的消息或电磁的表现。</p>
<p>“模拟信号” —— 代表消息的参数的取值是连续的。</p>
<p>“数字信号” —— 代表消息的参数的取值是离散的。</p>
<p>码元（code）—— 在使用时间域的波形表示数字信号时，则代表不同离散数值的基本波形就成为码元。</p>
<p>在数字通信中常常使用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元。而这个间隔被称为码元长度。1码元可以携带nbit的信息量。</p>
<h6 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h6><p>信道一般表示向一个方向传送信息的媒体，所以我们说平常的通信线路往往包含一条发送信息的信道和一条接收信息的通道。</p>
<p><strong>单向通信</strong>（单工通信）——只能有一个方向的通信而没有反方向的交互。</p>
<p><strong>双向交替通信</strong>（半双工通信）——通信双方都可以发送信息，但不能双方同时发送/接收。</p>
<p><strong>双向同时通信</strong>（全双工通信）——通信双方可以同时发送或接收信息。</p>
<h6 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h6><p><strong>基带信号</strong>（即基本频带信号）——来自信源的信号。像计算机输出的表示各种文字或图像文件的数据信号都属于基带信号，比如我们说话的声带就是基带信号。</p>
<p><strong>带通信号</strong>——把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。</p>
<p>因此在传输距离较近时，计算机网络都采用基带传输方式，由于近距离范围内基带信号的衰减不大，从而信号内容不会发生变化，因此在传输距离较近时，计算机网络采用基带传输方式。如从计算机到监视器，打印机等外设的信号就是基带传输的。</p>
<p><strong>调幅（AM）</strong>：载波的振幅随基带数字信号而变化。</p>
<p><strong>调频（FM)</strong>：载波的频率随基带数字信号而变化。</p>
<p><strong>调相（PM)</strong>:载波的初始相位随基带数字信号而变化。</p>
<p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E8%B0%83%E9%A2%91.PNG" alt="调频"></p>
<h6 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h6><p>物理层设备集线器的工作特点是在网络中只起到信号放大和重发作用，其目的是扩大网络的传输范围，而不具备信号的定向传送能力。它是一个大的冲突域，因为当一台电脑发送给集线器后，集线器会把该内容转发给连接在集线器上的其他电脑，当其他电脑接收到内容后先对比该内容的MAC地址与自己电脑的MAC地址，相同则进行处理，不同者不做处理，但是我们可以把数据爬出来。</p>
<h6 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h6><p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8.PNG" alt="信道复用">**</p>
<p><strong>频分复用技术FDM(Frequency  Division  Multiplexing)</strong>：用户在分配到一定的频带后在通信过程中自始自终都占用这个频带。频分复用的所有用户在相同时间内占用不同的带宽资源，请注意，这里的“带宽”是频率带宽而不是数据的发送速率。</p>
<p><strong>时分复用技术TDM(Time Division Multiplexing)</strong>是将时间划分为一段段等长的时分复用帧，每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，在不同时间内占用相同的频带宽度。<img src="C:%5CUsers%5CCCY%5CDesktop%5C%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8.PNG" alt="时分复用"></p>
<p>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</p>
<p><strong>统计时分复用</strong>：通过标记是哪个VLAN。</p>
<h6 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h6><p>xDSL(用数字技术对现有的模拟电话用户线进行改造)</p>
<p>标准模拟电话信号的频带被限制在300<del>3400Hz的范围内，但用户线本身实际可通过的信号频率仍然超过1MHz。xDSL技术把0</del>4kHz低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。</p>
<h4 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>数据链路层使用的信道主要有以下两种类型：</p>
<ol>
<li>点对点信道。这种信道使用一对一的点对点通信方式。</li>
<li>广播通信。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。</li>
</ol>
<h6 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h6><p>链路（link）是一条点到点的物理路线，中间没有任何其他的交换结点，一条链路只是一条通路的组成部分。</p>
<p>数据链路（data  link）除了物理线路外，还必须有通信协议来控制这些数据的传输，若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p>
<p>现最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。</p>
<p>一般的适配器都包括了数据链路层和物理层这两层的功能。</p>
<h6 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h6><p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93.PNG" alt="透明传输"></p>
<h6 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h6><p>传输过程中可能会产生比特差错，1可能变成0而0也可能变成1.在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER(Bit  Error  Rate)。</p>
<p>误码率与信噪比有很大的关系，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采取各种差错检测措施。</p>
<h6 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h6><p>现在全世界使用最多的数据链路层协议是点对点协议PPP(Point-to-Point Protocol)。</p>
<p>用户使用拨号电话线接入因特网时一般都是使用PPP协议。</p>
<p>PPP协议应该满足的要求：</p>
<ol>
<li>简单——这是首要的要求</li>
<li>封装成帧。</li>
<li>透明性。</li>
<li>多种网络层协议。</li>
<li>差错检测。</li>
<li>检测连接状态。</li>
<li>最大传送单元。</li>
<li>网络层地址协商。</li>
<li>数据压缩协商。</li>
</ol>
<p>PPP协议不满足的要求：</p>
<ol>
<li>纠错。</li>
<li>流量控制。</li>
<li>序号。</li>
<li>多点线路。</li>
<li>半双工或单工链路。</li>
</ol>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200429135924281.png" alt="image-20200429135924281"></p>
<p>7E是结束和开头标志，FCS用于差错校验。</p>
<p><strong>PPP协议工作状态</strong>：当用户拨号接入ISP时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。PC机向路由器发送一系列的LCP分组（封装成多个PPP帧），这些分组及其响应选择一些PPP参数，和进行网络层配置，NCP给新接入的PC机分配一个临时的IP地址，使PC机成为因特网上的一个主机。通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。接着，LCP释放数据链路层连接，最后释放的是物理层的连接。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-数据结构与算法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/27/数据结构与算法/" class="article-date">
      <time datetime="2020-04-27T12:36:59.000Z" itemprop="datePublished">2020-04-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/27/数据结构与算法/">数据结构与算法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-前端面试" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/07/前端面试/" class="article-date">
      <time datetime="2020-04-07T14:26:30.000Z" itemprop="datePublished">2020-04-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/07/前端面试/">前端面试</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><ul>
<li>是一套包含HTMML,CSS,JS在内的技术组合，它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务。</li>
</ul>
<h3 id="优"><a href="#优" class="headerlink" title="优"></a>优</h3><ul>
<li><ol>
<li>网络标准统一，HTML5本身是由W3C推荐出来的。</li>
</ol>
</li>
<li><ol start="2">
<li>多设备，跨平台，即时更新。</li>
</ol>
</li>
<li><ol start="3">
<li>提高可用性和改进用户的友好体验。</li>
</ol>
</li>
<li><ol start="4">
<li>有几个新的标签将有利于开发者定义重要的内容。</li>
</ol>
</li>
<li><ol start="5">
<li>可以给站点带来更多的多媒体元素。</li>
</ol>
</li>
<li><ol start="6">
<li>可以很好的替代Flash和Silverlight。</li>
</ol>
</li>
<li><ol start="7">
<li>涉及到网站的抓取和索引时，对于SEO很友好。</li>
</ol>
</li>
<li><ol start="8">
<li>被大量应用于移动应用程序和游戏。</li>
</ol>
</li>
</ul>
<h3 id="缺"><a href="#缺" class="headerlink" title="缺"></a>缺</h3><ul>
<li><ol>
<li>安全性：websocket和透明代理的实现有严重安全问题，webstorage和websocket这样的功能很容易被黑客利用来盗取用户的信息与资料。</li>
</ol>
</li>
<li><ol start="2">
<li>完善性：许多特性浏览器的支持程度不一样。</li>
</ol>
</li>
<li><ol start="3">
<li>技术门槛：HTML5简化了开发者学习，像web worker、web socket、web storage等新特性，后台甚至浏览器原理的知识。</li>
</ol>
</li>
<li><ol start="4">
<li>性能：某些平台上的引擎问题导致HTML5性能低下。</li>
</ol>
</li>
<li><ol start="5">
<li>浏览器兼容性：最大缺点，IE9以下浏览器几乎全军覆没。</li>
</ol>
</li>
</ul>
<h3 id="Doctype作用"><a href="#Doctype作用" class="headerlink" title="Doctype作用"></a>Doctype作用</h3><ul>
<li><ol>
<li>声明位于文档最前面，处于标签之前，告知浏览器的解析器以何种方式解析文档。</li>
</ol>
</li>
<li><ol start="2">
<li>严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。</li>
</ol>
</li>
<li><ol start="3">
<li>在混杂模式中，页面以宽松的方式向后兼容的方式显示。模拟老式浏览器的行为防止站点无法工作。</li>
</ol>
</li>
<li><ol start="4">
<li>Doctype不存在或格式不正确会导致文档以混杂模式呈现。</li>
</ol>
</li>
</ul>
<h3 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h3><ul>
<li><ol>
<li>去掉或样式丢失的时候能让页面呈现清晰的结构</li>
</ol>
<ul>
<li>：html本身是没有表现的，我们看到例如h1是粗体，字体大小2em，加粗；strong是加粗的，不要认为这是html的表现，这些其实html默认的css样式在起作用，所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语义化的HTML结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达html的语义，可以说浏览器的默认样式和语义化的HTML结构是不可分割的。</li>
</ul>
</li>
<li><ol start="2">
<li>屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页.</li>
</ol>
<ul>
<li>例如,如果你使用的含语义的标记,屏幕阅读器就会“逐个拼出”你的单词,而不是试着去对它完整发音.</li>
</ul>
</li>
<li><ol start="3">
<li>PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）.使用语义标记可以确保这些设备以一种有意义的方式来渲染网页.理想情况下,观看设备的任务是符合设备本身的条件来渲染网页.语义标记为设备提供了所需的相关信息,就省去了你自己去考虑所有可能的显示情况（包括现有的或者将来新的设备）.</li>
</ol>
<ul>
<li>例如,一部手机可以选择使一段标记了标题的文字以粗体显示.而掌上电脑可能会以比较大的字体来显示.无论哪种方式一旦你对文本标记为标题,您就可以确信读取设备将根据其自身的条件来合适地显示页面.</li>
</ul>
</li>
<li><ol start="4">
<li>搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重.</li>
</ol>
<ul>
<li><ol start="5">
<li>你的页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记,而只注重语义标记.因此,如果页面文件的标题被标记,而不是,那么这个页面在搜索结果的位置可能会比较靠后.除了提升易用性外,语义标记有利于正确使用CSS和JavaScript,因为其本身提供了许多“钩钩”来应用页面的样式与行为.SEO主要还是靠你网站的内容和外部链接的。</li>
</ol>
</li>
</ul>
</li>
<li><ol start="6">
<li>便于团队开发和维护</li>
</ol>
</li>
<li><p>W3C给我们定了一个很好的标准，在团队中大家都遵循这个标准，可以减少很多差异化的东西，方便开发和维护，提高开发效率，甚至实现模块化开发。</p>
</li>
</ul>
<h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><ul>
<li><p>媒体查询</p>
</li>
<li><p>百分比</p>
<ul>
<li>%单位是依赖于元素的祖先元素。</li>
</ul>
</li>
<li><p>rem</p>
<ul>
<li><p>rem与em区别</p>
<ul>
<li>rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。</li>
<li>作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值设置font-size的值实现当屏幕分辨率变化时让元素也变化，以前的天猫tmall就使用这种办法</li>
<li>em是文本相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)</li>
<li>em（font size of the element）是指相对于父元素的字体大小的单位。它与rem之间其实很相似，区别在。（相对是的HTML元素的字体大，默认16px）</li>
<li><strong>em与rem的重要区别：</strong> 它们计算的规则一个是依赖父元素另一个是依赖根元素计算</li>
</ul>
</li>
<li><p>通过 rem 单位来实现适配，需要内嵌一段脚本去动态计算根元素大小。</p>
</li>
</ul>
</li>
<li><p>vw/vh</p>
<ul>
<li><p>使用纯CSS视口单位来自行自适应，虽然现在的兼容性还没法完全能够接受</p>
</li>
<li><p>依赖于视口的尺寸，根据视口尺寸的百分比来定义的</p>
<ul>
<li>vw : 1vw 等于视口宽度的1%</li>
<li>vh : 1vh 等于视口高度的1%</li>
<li>vmin : 选取 vw 和 vh 中最小的那个</li>
<li>vmax : 选取 vw 和 vh 中最大的那个</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="出现css阻塞地方"><a href="#出现css阻塞地方" class="headerlink" title="出现css阻塞地方"></a>出现css阻塞地方</h3><ul>
<li><ol>
<li>当css后面跟着嵌入的js时，该css就会出现阻塞后面资源下载的情况，而当把嵌入JS放到css前面就不会出现阻塞。</li>
</ol>
</li>
<li><ol start="2">
<li>根本原因是浏览器会维持html中css与js的顺序，样式表必须在嵌入的js执行前先加载解析完。但嵌入的js会阻塞后面资源的下载，所以就会出现上面CSS阻塞下载的情况。</li>
</ol>
</li>
</ul>
<h3 id="优化css性能"><a href="#优化css性能" class="headerlink" title="优化css性能"></a>优化css性能</h3><ul>
<li><ul>
<li>减少首次有效绘制时间，只将渲染首屏内容的关键css内联到HTML中（Github上有一个项目Critical CSS可确定哪些内容是首屏关键样式），但内联css不会进行缓存，每次需重新下载。</li>
</ul>
</li>
<li><ul>
<li>剩下的css由外部异步加载导入并启动缓存。异步加载方式：</li>
</ul>
<ul>
<li><ul>
<li>使用js动态动态创建样式表link并插入到DOM中</li>
</ul>
</li>
<li><ul>
<li>将link元素的media属性设置为用户浏览器不匹配的媒体类型。因为对浏览器来说，如果样式表不适合当前媒体类型，其优先级会被放低，会在不阻塞页面渲染情况下再进行下载，但在文件加载完成后将media的值设为screen或all  <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;mystyle.css&quot; media=&quot;noexist&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>文件压缩，只会去除无用的空格。</li>
</ul>
</li>
<li><ul>
<li>去除无用的css。编写代码时，尽量提取公共类，减少重复。</li>
</ul>
</li>
<li><ul>
<li>有选择的使用选择器</li>
</ul>
<ul>
<li>保持简单，不要嵌套过多过于复杂的选择器。</li>
<li><ul>
<li>通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。</li>
</ul>
</li>
</ul>
</li>
<li><p>减少重排和重绘</p>
<ul>
<li><ul>
<li>触发重排：font-size、font-family、元素内外边距，通过js改变css类，通过js获取DOM元素位置的相关属性、css伪类激活，滚动滚动条或改变窗口大小。   <strong>优先使用flex弹性布局</strong>。</li>
</ul>
</li>
<li><ul>
<li>触发重绘：改变元素的外观（如color，background，visibility等属性）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="css预处理"><a href="#css预处理" class="headerlink" title="css预处理"></a>css预处理</h3><ul>
<li><ul>
<li>css预处理器是一种专门的编程语言，用来为css增加一些变成特性（css本身不是编程语言）不需要考虑浏览器兼容问题，因为css预处理器最终编译和输出的仍是标准的css样式。</li>
</ul>
</li>
<li><ul>
<li>可在css预处理器中使用变量，简单逻辑判断，函数等基本编程技巧。有合理的样式复用机制。</li>
</ul>
</li>
<li>less，sass</li>
</ul>
<h3 id="浮动的原理和工作方式"><a href="#浮动的原理和工作方式" class="headerlink" title="浮动的原理和工作方式"></a>浮动的原理和工作方式</h3><ul>
<li><ul>
<li>浮动元素是脱离文档流的，不占据空间。浮动元素碰到包含他的元素的边框或其他浮动元素的边框会停下来。</li>
</ul>
</li>
<li><ul>
<li>引发问题：</li>
</ul>
<ul>
<li><ul>
<li>父元素的高度无法撑开，影响与父元素同级的元素。</li>
</ul>
</li>
<li><ul>
<li>与浮动元素同级的非浮动元素紧跟其后。</li>
</ul>
</li>
<li><ul>
<li>若非第一个元素浮动，则该元素之前的元素也需要紧跟其后，否则会影响页面的显示的结构。</li>
</ul>
</li>
</ul>
</li>
<li><p>清除浮动：</p>
<ul>
<li><ul>
<li>在所有浮动标签后面使用<strong>空标签</strong>清除浮动，定义css clear：both；弊端是增加无意义的标签。</li>
</ul>
</li>
<li><ul>
<li>给浮动元素的<strong>父标签</strong>添加css属性，overflow：auto；</li>
</ul>
</li>
<li><ul>
<li>非IE浏览器者使用<strong>伪元素</strong>清除浮动，不过要设置伪对象height：0；否则该元素高度要比实际高出若干像素。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="link与-import区别"><a href="#link与-import区别" class="headerlink" title="link与@import区别"></a>link与@import区别</h3><ul>
<li><ul>
<li>link是HTML标签无兼容问题，页面被加载时，link会同时被加载。</li>
</ul>
</li>
<li><ul>
<li>@import由css提供，但只在IE5以上才能识别，且引用的css会等到页面被加载完再加载。</li>
</ul>
</li>
</ul>
<h3 id="absolute与fixed区别"><a href="#absolute与fixed区别" class="headerlink" title="absolute与fixed区别"></a>absolute与fixed区别</h3><ul>
<li><p>共同点：</p>
<ul>
<li><ol>
<li>改变行内元素的呈现方式，display被置为inline-block；</li>
</ol>
</li>
<li><ol start="2">
<li>让元素脱离普通流，不占据空间；</li>
</ol>
</li>
<li><ol start="3">
<li>默认会覆盖到非定位元素上。</li>
</ol>
</li>
</ul>
</li>
<li><p>不同点：</p>
<ul>
<li><ol>
<li>absolute的根元素是可以设置的，而fixed的根元素固定为浏览器。</li>
</ol>
</li>
<li><ol start="2">
<li>当你滚动网页时，fixed元素与浏览器窗口之间的距离是不变的。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="src与href区别"><a href="#src与href区别" class="headerlink" title="src与href区别"></a>src与href区别</h3><ul>
<li>src用于替换当前元素，href用于在当前文档和引用资源间确立联系。</li>
<li>src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在的位置，请求src资源时会将其指向的资源下载并应用到文档中。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也是如此，类似于将所指资源嵌入当前标签内，这也是为啥要将js脚本放在底部而不是头部。</li>
<li>href指向网络资源所在的位置，建立和当前元素之间的链接，如果我们在文档中添加<code>&lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot; /&gt;</code>，那浏览器就会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css而不是使用@import方式。</li>
</ul>
<h3 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap"></a>bootstrap</h3><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="js继承及对象共享"><a href="#js继承及对象共享" class="headerlink" title="js继承及对象共享"></a>js继承及对象共享</h3><ul>
<li>1.利用原型来继承,通过增加一个空的函数来避免原型链上的对象共享</li>
<li>1.利用原型来继承,通过增加一个空的函数来避免原型链上的对象共享<pre><code>var a = {name：“小明”}；
    var b = cloneObj(a);
     function cloneObj(obj){
            var f = function(){};
            f.prototype = obj;
            return new f();
    }</code></pre></li>
</ul>
<p>2.使用extend，多用于插件封装</p>
<p>示例：</p>
<p>Var item={name:”olive”,age:23};</p>
<p>Var item1={name:”Momo”,sex:”gril”};</p>
<p>Var result=$.extend({},item,item1);</p>
<p>结果：</p>
<p>Result={name:”Momo”,age:23,sex:”gril”};</p>
<h3 id="js阻塞"><a href="#js阻塞" class="headerlink" title="js阻塞"></a>js阻塞</h3><ul>
<li><p>why</p>
<ul>
<li><ul>
<li>所有浏览器在下载JS时会阻塞一切其他活动，比如资源的下载，内容的呈现等等。直到JS下载，解析，执行完才开始继续并行下载其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载JS，但是JS下载仍会阻塞其他资源的下载，如图片或css文件。</li>
</ul>
</li>
<li><ul>
<li>由于浏览器为了防止JS修改DOM树，需要重新构建DOM树的情况，所以就会阻塞其他的下载和呈现。</li>
</ul>
</li>
<li><ul>
<li>同时嵌入的脚本会阻塞所有内容的呈现，而由外引入的脚本只会阻塞其后内容的呈现，2种方式都会阻塞其后资源的下载，但是外部引入的脚本可将引入标签写在页面最后就可避免此种情况。</li>
</ul>
</li>
</ul>
</li>
<li><p>how to do</p>
<ul>
<li><p>嵌入脚本</p>
<ul>
<li><ol>
<li>放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。</li>
</ol>
</li>
<li><ol start="2">
<li>如果嵌入JS放在head中，请把嵌入JS放在CSS头部。</li>
</ol>
</li>
<li><ol start="3">
<li>使用 defer（只支持IE）</li>
</ol>
</li>
<li><ol start="4">
<li>不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用 setTimeout 来调用</li>
</ol>
</li>
</ul>
</li>
<li><ol>
<li>将脚本放在底部。<link>还是放在head中，用以保证在js加载前，能加载出正常显示的页面。<script>标签放在</body>前。</li>
</ol>
</li>
<li><ol start="2">
<li>阻塞脚本：由于每个<script>标签下载时阻塞页面解析过程，所以限制页面的<script>总数也可以改善性能。适用于内联脚本和外部脚本。</li>
</ol>
</li>
<li><ol start="3">
<li>非阻塞脚本：等页面完成加载后，再加载js代码。也就是，在 window.onload 事件发出后开始下载代码。</li>
</ol>
</li>
<li><ol start="4">
<li>defer属性：支持IE4和fierfox3.5更高版本浏览器</li>
</ol>
</li>
<li><ol start="5">
<li>动态脚本元素：文档对象模型（DOM）允许你使用js动态创建HTML的几乎全部文档内容。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li><ul>
<li>what：闭包是可以读取其他函数内部变量的函数，本质是将函数内部和外部连接起来的一座桥梁。</li>
</ul>
</li>
<li><ul>
<li>advantage：可读取函数内部的变量，可让这些变量的值始终保持在内存中。</li>
</ul>
</li>
<li><ul>
<li>disadvantage：内存消耗大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。故在退出函数之前，将不使用的局部变量全部删除。闭包会在父函数外部改变父函数内部变量的值。</li>
</ul>
</li>
</ul>
<h3 id="AJAX（同源策略）"><a href="#AJAX（同源策略）" class="headerlink" title="AJAX（同源策略）"></a>AJAX（同源策略）</h3><ul>
<li><p>Ajax与Flash的优缺点</p>
<ul>
<li><p>AJAX</p>
<ul>
<li>优：<br>1.可搜索性 2.开放性 3.费用 4.易用性 5.易于开发。</li>
<li>缺：<br>它可能破坏浏览器的后退功能 2.使用动态页面更新使得用户难于将某个特定的状态保存到收藏夹中 ，不过这些都有相关方法解决。</li>
</ul>
</li>
<li><p>flash</p>
<ul>
<li>优势：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>1.多媒体处理 2.兼容性 3.矢量图形 4.客户端资源调度<br>        - 劣势：</p>
<p>1.二进制格式 2.格式私有 3.flash 文件经常会很大，用户第一次使用的时候需要忍耐较长的等待时间 4.性能问题</p>
<ul>
<li><p>ajax请求的过程</p>
<ul>
<li><ol>
<li>创建XMLHttpRequest对象，也就是创建一个异步调用对象。</li>
</ol>
</li>
<li><ol start="2">
<li>创建一个新的HTTP请求，并指定该HTTP请求的方法，URL及验证信息。</li>
</ol>
</li>
<li><ol start="3">
<li>设置响应HTTP请求状态变化的函数.</li>
</ol>
</li>
<li><ol start="4">
<li>发送HTTP请求。</li>
</ol>
</li>
<li><ol start="5">
<li>获取异步调用返回的数据。</li>
</ol>
</li>
<li><ol start="6">
<li>使用 JS 和 DOM 实现局部刷新。</li>
</ol>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><ol>
<li>通过异步模式提升用户体验。</li>
</ol>
</li>
<li><ol start="2">
<li>优化了浏览器与服务器之间的传输，减少不必要的数据往返，减少了带宽占用。</li>
</ol>
</li>
<li><ol start="3">
<li>Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</li>
</ol>
</li>
<li><ol start="4">
<li>Ajax可实现局部刷新，即动态不刷新。</li>
</ol>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><ol>
<li>Ajax不支持浏览器back按钮。</li>
</ol>
</li>
<li><ol start="2">
<li>安全问题：Ajax暴漏了与服务器间交互的细节。</li>
</ol>
</li>
<li><ol start="3">
<li>对搜索引擎的支持比较弱。</li>
</ol>
</li>
<li><ol start="4">
<li>破坏程序的异常机制。</li>
</ol>
</li>
<li><ol start="5">
<li>不容易调试。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h3><h3 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h3><ul>
<li><p>使用场景</p>
<ul>
<li><ol>
<li>实时应用：如在线聊天，实时通知推送等（socket.io);</li>
</ol>
</li>
<li><ol start="2">
<li>分布式应用：通过高效的并行I/O使用已有的数据；</li>
</ol>
</li>
<li><ol start="3">
<li>工具类应用：海量的工具，小到前端压缩部署（如grunt），大到桌面应用程序。</li>
</ol>
</li>
<li><ol start="4">
<li>游戏类应用：游戏对实时和并发有很高的要求；</li>
</ol>
</li>
<li><ol start="5">
<li>利用稳定接口提升web渲染能力；</li>
</ol>
</li>
<li><ol start="6">
<li>前后后端编程语言环境统一：前端人员可快速切入到服务器端的开发；</li>
</ol>
</li>
</ul>
</li>
<li><p>what</p>
<ul>
<li>NodeJS是基于Event Loop（事件循环）和Callback（回调）把单线程的效率发挥到极致（会让人感觉实现了多线程），使有限的资源（CPU,内存，网络资源）利用最大化。</li>
</ul>
</li>
<li><p>优</p>
<ul>
<li><ol>
<li>因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在node上的代理服务器相比其他技术实现的服务器表现要好得多。</li>
</ol>
</li>
<li><ol start="2">
<li>与node代理服务器交互的客户端代码是由js语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的。</li>
</ol>
</li>
</ul>
</li>
<li><p>缺</p>
<ul>
<li><ol>
<li>Node是单线程，处理CPU密集型吃力，不过可将密集拆分。</li>
</ol>
</li>
<li><ol start="2">
<li>只支持单核CPU,不能充分利用CPU。</li>
</ol>
</li>
<li><ol start="3">
<li>可靠性低，一旦代码某个环节崩溃，整个系统都崩溃。</li>
</ol>
</li>
<li><ol start="4">
<li>开源组件库质量参差不齐，更新快，向下不兼容。</li>
</ol>
</li>
<li><ol start="5">
<li>Debbug不方便，错误没有stack trace。</li>
</ol>
</li>
</ul>
</li>
<li><p>事件循环eventloop</p>
<ul>
<li>　1）所有同步任务都在主线程上执行，形成一个执行栈</li>
<li>　2）当主线程中的执行栈为空时，检查事件队列是否为空，如果为空，则继续检查；如不为空，则执行3</li>
<li>　3）取出任务队列的首部，加入执行栈</li>
<li>　4）执行任务</li>
<li>　5）检查执行栈，如果执行栈为空，则跳回第 2 步；如不为空，则继续检查</li>
</ul>
</li>
<li><p>node怎么跟MongoDB建立连接</p>
<ul>
<li>1）引入mongoose</li>
<li>2）使用mongoose.connect()方法连接到MongoDB数据库</li>
<li>3）监听连接是否成功</li>
<li>4）然后通过node，书写接口，对数据库进行增删改查</li>
</ul>
</li>
</ul>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><ul>
<li><p>增</p>
<ul>
<li>arr.unshift('字符')：向数组开头添加一个或多个元素，并返回新的长度。</li>
<li>arr.concat(arr1,arr2,...)：连接两个或更多的数组，并返回结果</li>
<li>arr.push('字符')：向数组的末尾添加一个或多个元素，并返回新的长度。</li>
<li>arr.splice(index,howmany,item1,item2,...itemX)：向数组添加或删除元素。</li>
</ul>
</li>
<li><p>删</p>
<ul>
<li>arr.pop()：删除数组中最后一个元素并返回删除的元素。</li>
<li>arr.shift()：删除数组中的第一个元素。</li>
</ul>
</li>
<li><p>改</p>
<ul>
<li>arr.sort(fn)：对数组元素进行排序。</li>
<li>arr.reverse()：翻转数组的元素的顺序。</li>
<li>arr.map(fn)：通过指定函数处理的每个数组，并返回处理后的数组。</li>
<li>arr.join('连字符')：把数组中元素放入一个字符串中。</li>
<li>arr.toString()：把数组转为字符串，并返回结果。</li>
</ul>
</li>
<li><p>查</p>
<ul>
<li><p>filter()：检测数组元素，并返回符合条件所有元素的数组。</p>
</li>
<li><p>arr.every(fn)：检测数组元素是否都符合条件，返回布尔值。</p>
</li>
<li><p>arr.slice(n1,n2)：返回n1到n2之间的数组元素，不包括n2上的元素。</p>
</li>
<li><p>arr.lastIndexOf('字符')：返回指定字符最后出现的位置的下标。</p>
</li>
<li><p>arr.indexOf(‘字符’)：搜索数组中元素，并返回它首次出现的下标。</p>
</li>
<li><p>arr.some(fn)：检测数组元素中是否有元素符合指定条件。</p>
</li>
<li><p>遍历元素</p>
<ul>
<li>array.forEach(function(currentValue, index, arr), thisValue)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul>
<li>length：字符串的长度</li>
<li>str.charAt(num)：返回在指定位置的字符。</li>
<li>str.charCodeAt(num)：返回在指定位置的Unicode编码。</li>
<li>str.concat(str1,str2)：连接两个或多个字符串，并返回新的字符串。</li>
<li>String.fromCharCode(num)：将Unicode编码转为字符。</li>
<li>str.indexOf('字符串')：返回指定字符串值在字符串中首次出现的位置的下标。</li>
<li>str.lastIndexOf('字符串')：从后向前搜索字符串</li>
<li>str.match(/ain/g)：在字符串中检索指定的值，查找一或多个正则表达式的匹配。返回包含所有结果的数组。</li>
<li>str.replace(searchValue,newValue)：在字符串中用一些字符替换另一些字符。</li>
<li>str.search('字符或正则表达式')：检索字符串中指定子字符串。返回下标值。</li>
<li>str.slice(start,end)：提取字符串的某个部分，并以新的字符串返回被提取的部分</li>
<li>str.split()：将字符串分割成字符串数组。</li>
<li>str.substr(start,length)：从start开始截length个字符，返回截取的字符串。</li>
<li>str.substring(n1,n2)：返回n1到n2的字符串，不包括n2.</li>
<li>str.toLowerCase()<br>str.toUpperCase()</li>
<li>str.trim():去掉字符串两边空白。</li>
</ul>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><ul>
<li><p>变量声明</p>
<ul>
<li><p>let</p>
<ul>
<li>暂时性死区</li>
<li>变量不提升</li>
<li>不可重复声明</li>
</ul>
</li>
<li><p>const</p>
<ul>
<li>let的所有特性</li>
<li>值不可变</li>
<li>本质：const保证的不是变量的值不可改变，而是变量指向的那个内存地址不可改变。对于简单数据，值就保存在变量指向的那个内存地址，因此等同于常量。</li>
</ul>
</li>
<li><p>var</p>
</li>
<li><p>function</p>
</li>
<li><p>class</p>
<ul>
<li>ES6的class可以看作是一个语法糖，它的绝大部分功能ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法</li>
</ul>
</li>
<li><p>import</p>
</li>
</ul>
</li>
<li><p>解构赋值（模式匹配）</p>
<ul>
<li><p>规则：只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构，都会报错。let { prop: x } = undefined或null;  //TypeError</p>
</li>
<li><p>允许指定默认值，但如果一个数组成员不严格等于undefined，默认值无效。</p>
<ul>
<li>默认值是表达式，，那这个表达式是惰性求值，只在用到时才求值。</li>
</ul>
</li>
<li><p>本质：只要数据结构具有Iterator接口，都可以采用数组形式的解构赋值。let [a,b,c] = [1,2,3]</p>
</li>
<li><p>字符串</p>
<ul>
<li>字符串被转换成一个类似数组的对象。</li>
</ul>
</li>
<li><p>对象</p>
<ul>
<li>解构失败，变量的值为undefined。let {foo} = {bar: 'baz'};  foo  //undefined</li>
<li>对象解构赋值可以很方便将现有对象的方法赋值到某个变量中。let { log, sin, cos } = Math;</li>
<li>对象解构赋值的内部机制是先找到同名属性，然后再赋给对应的变量，真正被赋值的是后者，而非前者。let {foo:baz} = {foo: 123};    //baz为123，foo会报错，foo is not defined</li>
<li>数组解构的元素是按次序排列的，变量的取值由他的位置决定；而对象的属性没有次序，变量必须与属性同名才能取到正确的值。</li>
</ul>
</li>
<li><p>数值和布尔值</p>
<ul>
<li>解构赋值时会先转为对象。</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li>function add([x,y]){}<br>函数的参数表面上是一个数组，但在传入参数时，数组参数就被解构成变量x和y。</li>
</ul>
</li>
<li><p>用途</p>
<ul>
<li><p>交换变量的值 [x,y] = [y,x]</p>
</li>
<li><p>函数返回多个值</p>
<ul>
<li>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象返回。有了解构赋值便可轻松取出这些值。function example(){return [1,2,3];}  let [a,b,c] = example();</li>
</ul>
</li>
<li><p>函数参数的定义</p>
<ul>
<li>但参数无序时，可将参数与变量名对应起来。<br>function f({x,y,z}){}  f({z: 3, y: 2, x: 1});</li>
</ul>
</li>
<li><p>提取JSON数据</p>
</li>
<li><p>函数参数的默认值</p>
</li>
<li><p>遍历Map结构</p>
<ul>
<li>任何部署了Iterator接口的对象都可以用for...of循环遍历。</li>
<li>const map = new Map();<br>map.set('first','hello');<br>map.set('last','world');<br>for(let [key,value] of map){}</li>
</ul>
</li>
<li><p>输入模块的指定方法</p>
<ul>
<li>加载模块时，指定输入哪些方法</li>
<li>const { SourceMapConsumer, SourceNode } = require("source-map");</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>babel命令行转码</p>
<ul>
<li>将es6语法转为es5</li>
</ul>
</li>
<li><p>数组</p>
<ul>
<li><p>复制</p>
<ul>
<li>[].concat(...arr)</li>
</ul>
</li>
<li><p>array.forEach((item,index,arr) =>{})</p>
</li>
<li><p>扩展运算符</p>
<ul>
<li><p>三点(...)将数组转为用逗号分隔的参数序列</p>
<ul>
<li><p>替代数组的apply方法</p>
<ul>
<li>获取数组最大值:Math.max(...arr)</li>
</ul>
</li>
</ul>
</li>
<li><p>子主题 2</p>
</li>
</ul>
</li>
<li><p>Array上的</p>
<ul>
<li><p>Array.from(likeArr,fn)</p>
<ul>
<li>用于将类数组转为数组</li>
<li>参数一：类数组<br>二：类似于map方法，对每个元素遍历处理</li>
<li>如果map函数使用了this关键值，Array.from的第三个参数用于绑定this。</li>
</ul>
</li>
<li><p>Array.of()</p>
<ul>
<li>用于将一组值转为数组</li>
</ul>
</li>
</ul>
</li>
<li><p>数组实例</p>
<ul>
<li><p>copyWithin(target，start，end)</p>
<ul>
<li>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原来成员），然后返回当前数组。（会改变原数组）</li>
<li>target（必需）：从该位置开始替换数据）。<br>start（可选）：从该位置开始读取数据，默认为0。若为0，表示负数。<br>end（可选）：到该位置停止读取数据，默认等于数组长度，若为负值，表示倒数。<br>参数都是数值，若不是，先转为数值。</li>
</ul>
</li>
<li><p>find((value,index,arr) => {})</p>
<ul>
<li>遍历数组，找出第一个为true的成员，返回该成员，若无，返回undefined</li>
<li>可接受第二个参数，用于绑定回调函数的this对象</li>
</ul>
</li>
<li><p>findIndex((value,index,arr) => {})</p>
<ul>
<li>与find相同，但返回的是下标值，无返回-1</li>
<li>可发现NaN，弥补indexOf的不足</li>
</ul>
</li>
<li><p>fill(value,start,end)</p>
<ul>
<li>用value值填充或覆盖数组成员</li>
</ul>
</li>
<li><p>entries(),keys(),values()</p>
<ul>
<li><p>for(let index of ['a',b'].keys(){}<br>for(let [index,elem]  of  ['a','b'].entries(){}</p>
</li>
<li><p>遍历数组，keys对键名的遍历，values（）对键值遍历，entries（）对键值对的遍历</p>
</li>
<li><p>如果不使用 for...of 循环，可以手动调用遍历器对象的 next 方法，进行遍历。</p>
<ul>
<li>let letter = ['a', 'b', 'c'];</li>
<li>let entries = letter.entries();</li>
<li>console.log(entries.next().value); // [0, 'a']</li>
<li>console.log(entries.next().value); // [1, 'b']</li>
<li>console.log(entries.next().value); // [2, 'c']</li>
</ul>
</li>
</ul>
</li>
<li><p>includes(value，start)</p>
<ul>
<li>返回boolean值，表示数组中是否包含value值</li>
<li>start为负值，从倒数开始，大于数组长度，重置为0</li>
</ul>
</li>
<li><p>空位</p>
<ul>
<li><p>ES5中的空位</p>
<ul>
<li><p>空位不是 undefined ，一个位置的值等于 undefined ，依然是有值的。空位是没有任何值， in 运算符可以说明这一点。</p>
<ul>
<li>0 in [undefined, undefined, undefined] // true</li>
<li>0 in [, , ,] // false</li>
<li>forEach() , filter() , every() 和 some() 都会跳过空位。</li>
<li>map() 会跳过空位，但会保留这个值</li>
<li>join() 和 toString() 会将空位视为 undefined ，而 undefined 和 null 会被处理成空字符串。</li>
</ul>
</li>
</ul>
</li>
<li><p>ES6不会忽略空位，会将空位转为undefined</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串</p>
<ul>
<li><p>字符Unicode表示法</p>
<ul>
<li><p>js提供的\uxxxx形式表示一个字符，超出\uffff的字符，必须用两个双字节表示。“\uD842\uDFB7"    "吉"</p>
</li>
<li><p>ES6只需将码点放入大括号即可正确解读该字符串。“\u{20BB7}"   "吉”</p>
</li>
<li><p>at()方法</p>
<ul>
<li>ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。‘abc'.charAt(0)  //'a'     '吉'.charAt(0)   //’\uD842'</li>
<li>at()可识别码点大于0xFFFF的字符。<br>‘abc'.at(0)     //"a"<br>'吉'.at(0)    //“吉”</li>
</ul>
</li>
</ul>
</li>
<li><p>有遍历器接口，可用for...of遍历</p>
</li>
<li><p>字符查找</p>
<ul>
<li><p>ES5(返回-1）</p>
<ul>
<li>indexOf()</li>
</ul>
</li>
<li><p>ES6（返回布尔值，第二个参数表示开始搜素位置））</p>
<ul>
<li>includes(’字符‘，num)</li>
<li>startsWith(’字符‘，num)</li>
<li>endWith(’字符‘，num)</li>
</ul>
</li>
</ul>
</li>
<li><p>增加</p>
<ul>
<li><p>repeat（）</p>
<ul>
<li><p>返回新字符串，表示将原字符串重复n次<br>'x'.repeat(3)   //"xxx"</p>
</li>
<li><p>参数</p>
<ul>
<li>参数是小数时取整。<br>参数是负数或Infinity会报错。<br>参数是0到-1之间的小数，则等同于0。‘na'.repeat(-0.9)  //""<br>参数NaN等同于0    'na'.repeat(NaN)   //""<br>参数是字符串，则先转为数字。</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串补全长度</p>
<ul>
<li><p>头部补全padStart()，<br>尾部补全padEnd()     ’xxx'.padEnd(5,'ab')   //xxxab </p>
</li>
<li><p>参数</p>
<ul>
<li><p>第一个参数用来指定字符串的最小长度（如果原字符串的长度大于或等于指定最小长度，返回原字符串），'xxx'.padStart(2,'ab')     //'xxx'</p>
<ul>
<li>补全的 + 原字符串 》 指定的最小长度，截去超出位数的补全字符串。</li>
</ul>
</li>
<li><p>第二个参数是用来补全的字符串，省略就使用空格补全长度</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>模板字符串(反引号``）标识</p>
<ul>
<li><p>变量名写在${}中</p>
</li>
<li><p>调用函数 function fn(){ return 'hello world";}<br><code>foo ${ fn() } bar</code> //foo Hello World bar</p>
</li>
<li><p>不做处理raw()方法</p>
<ul>
<li>String.raw()方法往往用来充当模板字符串的处理函数，返回一个斜杆都被转义的字符串，对应于替换变量后的模板字符串。  String.raw<code>Hi\n${2+3}!</code>;    //"Hi\n5!"</li>
<li>若斜杠已转义则不做处理<br>String.raw<code>Hi\\n${2+3}!</code>;    //"Hi\n5!"</li>
</ul>
</li>
<li><p>标签模板<br>alert `123'  =><br>alert(123)</p>
<ul>
<li>标签指的是函数，紧跟其后的模板字符串就是它的参数。该参数实际是一个数组，该数组有一个raw属性，保存的是转义后的原字符串。<br>console.lof'123'     //   ["123", raw: Array[1]];</li>
<li>应用：过滤HTML字符串，防止用户输入恶意内容。</li>
</ul>
</li>
<li><p>限制：因默认会将字符串转义，故无法嵌入其他语言。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>正则</p>
<ul>
<li><p>ES5</p>
<ul>
<li>var regex = new RegExp('xyz','i');<br>等价于 var regex = /xyz/i;<br>等价于 var  regex = new RegExp(/xyz/i);<br> //不允许使用第二个参数添加修饰符，否则报错。<br>var regex = new RegExp(/xyz/,'i');  报错</li>
</ul>
</li>
<li><p>ES6</p>
<ul>
<li><p>若RegExp构造函数第一个参数是正则对象，第二个参数指定修饰符，且返回的修饰符会覆盖原来的修饰符。<br>new RegExp(/abc/ig,'i').flags    //“i”</p>
</li>
<li><p>字符串的正则方法,做到所有与正则相关的方法，全部定义在RegExp对象上。</p>
<ul>
<li>String.prototype.match调用RegExp.prototype[Symbol.match]</li>
<li>String.prototype.replace调用RegExp.prototype[Symbol.replace]</li>
<li>String.prototype.search调用RegExp.prototype[Symbol.search]</li>
<li>String.prototype.split调用RegExp.prototype[Symbol.split]</li>
</ul>
</li>
<li><p>修饰符</p>
<ul>
<li>i：忽略大小写</li>
<li>u:用来处理大于\uFFFF的Unicode字符</li>
<li>y： 全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配即可，而y修饰符确保匹配必须从剩余的第一个位置开始。</li>
</ul>
</li>
<li><p>具名组匹配</p>
<ul>
<li><p>const  RE_DATE=  /(?<year>\d{4}-(?<month>\d{2}-(?<day>\d{2})/;<br>const matchObj = RE_DTAE.exec('1999-12-31');<br>const year = matchObj.groups.yeat;   //1999<br>const  month = matchObj.groups.month;   //12<br>const   day = matchObj.groups.day;    //31</p>
<ul>
<li>"具名组匹配“在圆括号内部，模式的头部添加”问号+尖括号+组名“（？<year>),然后就可以在exec方法返回结果的groups属性上引用该组名。若具名组as没找到匹配，则matchObj.groups.as属性值就是undefined，并且as这个键名在groups始终存在。</li>
</ul>
</li>
<li><p>字符串替换时，使用$<组名>引用具名组</p>
<ul>
<li>let re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/u;<br>'2015-01-02'.replace(re,'$<day>/$<month>/$<year>')<br>//'02/01/2015'</li>
</ul>
</li>
<li><p>正则表达式内部引用某个”具名组匹配“，可使用\k<组名>。数字引用（\1）依然有效。</p>
<ul>
<li>const  RE_TWICE = /^(?<word>[a-z]+!\k<word>$/;<br>RE_TWICE.test('abc!abc')      //true<br>RE_TWICE.test('abc!ab')    //false</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数值扩展</p>
<ul>
<li><p>Number</p>
<ul>
<li><p>Number.isFinite()</p>
<ul>
<li>只对数值有效，非数值一律返回false，它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值转为数值再进行判断。</li>
</ul>
</li>
<li><p>Number.isNaN()</p>
</li>
<li><p>将全局parseInt()和parseFloat()转移到Number上面，使语言逐渐模块化。</p>
</li>
<li><p>Number.isInteger():判断一个值是否为整数（js中浮点数与整数相同存储方式）。</p>
</li>
<li><p>Number.EPSILON：表示极小的常量</p>
</li>
</ul>
</li>
<li><p>Math</p>
<ul>
<li><p>Math.trunc():去除一个数的小数部分，<br>非数值的话会先将其转为数值，<br>控制和无法截取整数的值，返回NaN</p>
</li>
<li><p>Math.sign():判断一个数是正数，负数还是0.非数值的先转为数值。</p>
<ul>
<li>参数为正数，返回+1</li>
<li>负数，返回-1</li>
<li>0，返回0</li>
<li>-0，返回-0</li>
<li>其他值，返回NaN</li>
</ul>
</li>
<li><p>Math.cbrt():计算一个数的立方根，非数值先转为数值</p>
</li>
<li><p>Math.fround()：返回一个数的单精度浮点数形式。</p>
</li>
<li><p>Math.hypot():返回所有参数的平方和的平方根<br>Math.hypot(3,4);      //5</p>
</li>
<li><p>对数方法</p>
<ul>
<li>Math.expm1():返回e的x次方减1</li>
<li>Math.log1p(x):返回 1+x 的自然对数，即Math.log(1+x)</li>
<li>Math.log10(x):返回以10为底的x的对数，若x<0,返回NaN。</li>
<li>Math.log2(x):返回以2为底的x的对数。</li>
</ul>
</li>
<li><p>双曲函数</p>
<ul>
<li>Math.sinh(x)<br>Math.cosh(x)<br>Math.tanh(x)<br>Math.asinh(x)<br>Math.acosh(x)<br>Math.atanh(x)</li>
</ul>
</li>
<li><p>Math.signbit():判断数的正负</p>
<ul>
<li>参数是NaN,返回false，<br>-0，返回true<br>负数，返回true<br>其他情况，返回false</li>
</ul>
</li>
<li><p>指数运算符（**）</p>
<ul>
<li>2 ** 2   //4<br>a  **= 2;<br>//等价于a = a * a</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>函数扩展</p>
<ul>
<li><p>函数参数的默认值</p>
<ul>
<li>function   m1({x=0,y=0}={}){return [x,y];}<br>function   m2({x,y} = { x : 0, y: 0}){return  [x,y];}</li>
<li>位置：必须是函数的尾参数，非尾参数不可设置默认值。</li>
<li>函数的length属性，将返回没有指定默认值的参数个数。（length指该函数预期传入的参数个数，指定默认值后，预期传入的参数个数就不包括这个参数了。同理，rest参数也不会计入length属性中。）</li>
<li>作用域：一旦参数设置了默认值，函数进行生命初始化时，参数会形成一个单独的作用域，等初始化结束，这个作用域就会消失。这种语法行为在不设置参数默认值时是不会出现的。</li>
</ul>
</li>
<li><p>rest函数</p>
<ul>
<li>function  add(...values){}</li>
<li>引入rest参数，用于获取函数的多于参数，这样就不用arguments对象了。且是一个数组对象。</li>
</ul>
</li>
<li><p>严格模式</p>
<ul>
<li>ES5开始，函数内部可设定为严格模式。<br>ES6规定，只要函数参数使用默认值，解构赋值或扩展运算符，那函数内部就不能显式设定为严格模式。</li>
</ul>
</li>
<li><p>name属性</p>
<ul>
<li>返回该函数的函数名，若将一个匿名函数赋值给一个变量，ES5的name属性会返回空字符串，而ES6则返回实际的函数名。</li>
<li>Function构造函数返回的函数实例，name属性值为anonymous。<br>(new  Function).name     //"anonymous"</li>
<li>bind返回的函数，name属性值加上bound前缀。<br>（function(){}).bind({}).name   //"bound   "</li>
</ul>
</li>
<li><p>箭头函数</p>
<ul>
<li><p>注意点</p>
<ul>
<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>不可使用arguments对象，该对象在函数体内不存在。要用时可用rest替代。</li>
<li>不可用yield命令，因此箭头函数不能用作Generator函数。</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><p>无参数或多个参数，用圆括号代替参数部分</p>
</li>
<li><p>返回一个对象，必须在对象外面加上括号，否则报错。</p>
</li>
<li><p>与变量解构结合使用</p>
<ul>
<li>const full = ({first,last}) => first + last;</li>
</ul>
</li>
<li><p>与rest参数结合</p>
<ul>
<li>const  h = (head,...tail) => [head,tail];<br>h(1,2,3,4,5);<br>//[1,[2,3,4,5]]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>双冒号运算符</p>
</li>
<li><p>尾调用优化</p>
</li>
<li><p>函数参数的尾逗号</p>
</li>
<li><p>catch语句的参数</p>
</li>
</ul>
</li>
<li><p>对象的扩展</p>
<ul>
<li>属性的简写。ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。</li>
<li>方法的简写。省略冒号与function关键字。</li>
<li>Object.keys()方法，获取对象的所有属性名或方法名（不包括原形的内容），返回一个数组。</li>
<li>Object.assign ()，assign方法将多个原对象的属性和方法都合并到了目标对象上面。可以接收多个参数，第一个参数是目标对象，后面的都是源对象。</li>
</ul>
</li>
<li><p>for...of  循环</p>
</li>
<li><p>import和export</p>
<ul>
<li>import和export命令只能在模块的顶部，不能在代码块之中。</li>
</ul>
</li>
<li><p>新增数据结构</p>
<ul>
<li><p>map（数据存储）</p>
<ul>
<li>本质上是健值对的集合，类似集合</li>
<li>可以遍历，可以跟各种数据格式转换</li>
</ul>
</li>
<li><p>set（数据重组）</p>
<ul>
<li>Set数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数。</li>
<li>属性和方法：<br>size 数据的长度<br>add() 添加某个值，返回 Set 结构本身。<br>delete() 删除某个值，返回一个布尔值，表示删除是否成功。<br>has() 查找某条数据，返回一个布尔值。<br>clear() 清除所有成员，没有返回值。<br>应用：数组去重。</li>
</ul>
</li>
</ul>
</li>
<li><p>promise</p>
<ul>
<li><p>它有三种状态，分别是pending-进行中、resolved-已完成、rejected-已失败。</p>
</li>
<li><p>三个状态：</p>
<ul>
<li>pending</li>
<li>fulfilled</li>
<li>reject</li>
</ul>
</li>
<li><p>两个过程：</p>
<ul>
<li>pending -> fulfilled</li>
<li>pending -> rejectd</li>
</ul>
</li>
<li><p>当pending为rejectd时，promise会进入catch</p>
</li>
<li><p>Promise是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p>
</li>
<li><p>Promise 构造函数包含一个参数和一个带有 resolve（解析）和 reject（拒绝）两个参数的回调。在回调中执行一些操作（例如异步），如果一切都正常，则调用 resolve，否则调用 reject。对于已经实例化过的 promise 对象可以调用 promise.then() 方法，传递 resolve 和 reject 方法作为回调。then()方法接收两个参数：onResolve和onReject，分别代表当前 promise 对象在成功或失败时。</p>
</li>
<li><p>promise构造函数是同步执行的，then方法是异步执行的</p>
</li>
</ul>
</li>
<li><p>Symbol</p>
<ul>
<li>Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的</li>
</ul>
</li>
<li><p>proxy代理</p>
<ul>
<li>Proxy代理使用代理（Proxy）监听对象的操作，然后可以做一些相应事情</li>
</ul>
</li>
</ul>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h3 id="优化前端性能"><a href="#优化前端性能" class="headerlink" title="优化前端性能"></a>优化前端性能</h3><ul>
<li>用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。</li>
<li><ul>
<li>压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css</li>
</ul>
</li>
<li><ul>
<li>利用<a href="https://cloud.tencent.com/product/cdn?from=10680">CDN</a>加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径</li>
</ul>
</li>
<li><ul>
<li>删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现</li>
</ul>
</li>
<li><ul>
<li>提取公共代码。</li>
</ul>
</li>
</ul>
<h3 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h3><ul>
<li>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</li>
<li><ol>
<li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li>
</ol>
</li>
<li><ol start="2">
<li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li>
</ol>
</li>
<li><ol start="3">
<li>确定入口：根据配置中的 entry 找出所有的入口文件；</li>
</ol>
</li>
<li><ol start="4">
<li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li>
</ol>
</li>
<li><ol start="5">
<li>完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li>
</ol>
</li>
<li><ol start="6">
<li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li>
</ol>
</li>
<li><ol start="7">
<li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li>
</ol>
</li>
<li>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</li>
</ul>
<h3 id="webpack-config-js配置文件"><a href="#webpack-config-js配置文件" class="headerlink" title="webpack.config.js配置文件"></a>webpack.config.js配置文件</h3><ul>
<li><p>webpack-dev-server：webpack实时打包构建</p>
</li>
<li><p>html-webpack-plugin插件配置启动页面</p>
</li>
<li><p>热更新</p>
<ul>
<li>“dev":"webpack-dev-server  --hot  --port  端口号   --open"</li>
</ul>
</li>
<li><p>打包css，less，scss文件</p>
</li>
<li><p>使用url-loader和file-loader处理css中的路径</p>
</li>
<li><p>使用babel处理高级JS语法</p>
</li>
<li><p>配置vue组件页面的解析。</p>
</li>
</ul>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="对MVVM理解"><a href="#对MVVM理解" class="headerlink" title="对MVVM理解"></a>对MVVM理解</h3><ul>
<li><p>MVVM 是 Model-View-ViewModel 的缩写。</p>
</li>
<li><p><strong>Model</strong>代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。</p>
</li>
<li><p><strong>View</strong> 代表UI 组件，它负责将数据模型转化成UI 展现出来。</p>
</li>
<li><p><strong>ViewModel</strong> 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。</p>
</li>
<li><p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p>
</li>
<li><p><strong>ViewModel</strong> 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
</li>
<li><p>与MVC区别</p>
<ul>
<li>mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到 View 。</li>
</ul>
</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li>Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。</li>
<li><strong>beforeCreate</strong>（创建前） 在数据观测和初始化事件还未开始</li>
<li><strong>created</strong>（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来</li>
<li><strong>beforeMount</strong>（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。</li>
<li><strong>mounted</strong>（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。</li>
<li><strong>beforeUpdate</strong>（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</li>
<li><strong>updated</strong>（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li>
<li><strong>beforeDestroy</strong>（销毁前） 在实例销毁之前调用。实例仍然完全可用。</li>
<li><strong>destroyed</strong>（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</li>
</ul>
<h3 id="数据绑定原理"><a href="#数据绑定原理" class="headerlink" title="数据绑定原理"></a>数据绑定原理</h3><ul>
<li>vue实现数据双向绑定主要是：采<strong>用数据劫持结合发布者-订阅者模式</strong>的方式，通过<strong>Object.defineProperty（）</strong>来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</li>
<li>vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 ），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —>视图更新；视图交互变化（input）—>数据model变更双向绑定效果。</li>
</ul>
<h3 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h3><ul>
<li><p>父组件与子组件传值</p>
<ul>
<li>父组件传给子组件：子组件通过props方法接受数据;</li>
<li>子组件传给父组件：$emit方法传递参数</li>
</ul>
</li>
<li><p>非父子组件间的数据传递，兄弟组件传值</p>
<ul>
<li>使用vuex。</li>
</ul>
</li>
</ul>
<h3 id="路由实现"><a href="#路由实现" class="headerlink" title="路由实现"></a>路由实现</h3><ul>
<li><p>模式</p>
<ul>
<li><p>history模式</p>
<ul>
<li><strong>history模式：</strong>history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。</li>
</ul>
</li>
<li><p>hash模式</p>
<ul>
<li><strong>hash模式：</strong>在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；</li>
<li>特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。</li>
<li>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。</li>
</ul>
</li>
</ul>
</li>
<li><p>vue-router</p>
<ul>
<li><p>路由嵌套</p>
<ul>
<li>在 VueRouter 的参数中使用 children 配置，这样就可以很好的实现路由嵌套。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><ul>
<li>低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的"View"上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</li>
</ul>
</li>
<li><ul>
<li>可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。</li>
</ul>
</li>
<li><ul>
<li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用 Expression Blend 可以很容易设计界面并生成 xml 代码。</li>
</ul>
</li>
<li><ul>
<li>可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li>
</ul>
</li>
</ul>
<h3 id="vue中的data必须是函数"><a href="#vue中的data必须是函数" class="headerlink" title="vue中的data必须是函数"></a>vue中的data必须是函数</h3><ul>
<li>对象为引用类型，当重用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。</li>
</ul>
<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><ul>
<li><p>vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车<br>有 5 种属性，分别是 state、getter、mutation、action、module</p>
</li>
<li><p>store 特性</p>
<ul>
<li><p>vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 datastate 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</p>
</li>
<li><p>使用 Vuex 只需执行 Vue.use(Vuex)，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？</p>
<ul>
<li>Vue.use(Vuex) 方法执行的是 install 方法，它实现了 Vue 实例对象的 init 方法封装和注入，使传入的 store 对象被设置到 Vue 上下文环境的store中。因此在VueComponent任意地方都能够通过this.store 访问到该 store。</li>
</ul>
</li>
</ul>
</li>
<li><p>getter特性</p>
<ul>
<li>getter 可以对 state 进行计算操作，它就是 store 的计算属性虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用如果一个状态只在一个组件内使用，是可以不用 getters</li>
</ul>
</li>
<li><p>mutation特性</p>
<ul>
<li>action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态action 可以包含任意异步操作</li>
</ul>
</li>
<li><p>原理</p>
<ul>
<li>vuex 仅仅是作为 vue 的一个插件而存在，不像 Redux,MobX 等库可以应用于所有框架，vuex 只能使用在 vue 上，很大的程度是因为其高度依赖于 vue 的 computed 依赖检测系统以及其插件系统，vuex 整体思想诞生于 flux,可其的实现方式完完全全的使用了 vue 自身的响应式设计，依赖监听、依赖收集都属于 vue 对对象 Property set get 方法的代理劫持。</li>
<li>最后一句话结束 vuex 工作原理，vuex 中的 store 本质就是没有 template 的隐藏着的 vue 组件；</li>
</ul>
</li>
</ul>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li><p>vue指令</p>
<ul>
<li><p>v-cloak</p>
<ul>
<li><p v-cloak></p>
</li>
<li><p>解决插值表达式闪烁问题（即网速慢时，只显示）</p>
</li>
</ul>
</li>
<li><p>v-text</p>
<ul>
<li><p><code>&lt;h2 v-text=&quot;msg&quot;&gt;*****&lt;/h2&gt;</code></p>
</li>
<li><p>会覆盖掉****，无闪烁问题</p>
</li>
</ul>
</li>
<li><p>v-html</p>
<ul>
<li><p><code>&lt;p  v-html=&quot;msg&quot;&gt;&lt;/p&gt;</code></p>
</li>
<li><p>会解析html格式的代码</p>
</li>
</ul>
</li>
<li><p>v-bind（  :  )</p>
<ul>
<li>绑定属性</li>
</ul>
</li>
<li><p>v-on (  @  )</p>
<ul>
<li>绑定事件</li>
</ul>
</li>
<li><p>v-model</p>
<ul>
<li>双向数据绑定</li>
</ul>
</li>
<li><p>v-for：遍历属性</p>
<ul>
<li>组件中使用v-for时，key是必须的。</li>
</ul>
</li>
<li><p>v-if</p>
<ul>
<li>高切换消耗。</li>
</ul>
</li>
<li><p>v-show</p>
<ul>
<li>高初始渲染消耗。</li>
</ul>
</li>
</ul>
</li>
<li><p>事件修饰符</p>
<ul>
<li><p>.stop</p>
<ul>
<li>阻止冒泡</li>
</ul>
</li>
<li><p>.prevent</p>
<ul>
<li>阻止默认事件</li>
</ul>
</li>
<li><p>.capture</p>
<ul>
<li>阻止事件捕获</li>
</ul>
</li>
<li><p>.self</p>
<ul>
<li>只阻止该元素自身事件</li>
</ul>
</li>
<li><p>.once</p>
<ul>
<li>事件只触发一次</li>
</ul>
</li>
</ul>
</li>
<li><p>过滤器</p>
<ul>
<li><p>只能用于mustach插值和v-bind表达式</p>
</li>
<li><p>私有过滤器</p>
<ul>
<li>filters: {dataFormat(data){}}</li>
</ul>
</li>
<li><p>全局过滤器</p>
<ul>
<li>Vue.filter('dataFormat',function(data){})</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义键盘修饰符</p>
<ul>
<li>Vue.config.keyCodes.名称 = 按键值</li>
</ul>
</li>
<li><p>自定义指令</p>
<ul>
<li><p>Vue.directive('focus',{<br>bind:function(el,binding){}<br>inserted:function(el){}<br>update:function(el){}})</p>
<ul>
<li><p>注意：在每个函数中，第一个参数永远是el，表示被绑定了指令的那个元素，这个el参数是一个原生的JS对象。</p>
</li>
<li><p>bind:每当指令绑定到元素上时会立即执行这个bind函数，只执行一次。</p>
<ul>
<li>和样式相关的操作一般放在bind函数中。</li>
<li>bind函数中有binding对象（包括name，value。。。属性）</li>
<li>子主题 3</li>
</ul>
</li>
<li><p>inserted表示元素插入到DOM中的时候会执行inserted函数，只触发一次。</p>
<ul>
<li>和JS行为有关的操作最好在inserted中执行放置。</li>
</ul>
</li>
<li><p>update:当VNode更新时会执行updates，可能会触发多次。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>请求地址</p>
<ul>
<li><p>vue-resource</p>
<ul>
<li><p>实现get,post,jsonp请求</p>
</li>
<li><p>在this.$http.get/post/jsonp().then()</p>
</li>
<li><p>form表单发起post请求，默认使用application/x-www-form-urlencoded表单格式。而vue-resource则是手动发起的post请求，默认没有表单格式，所以，有的服务器处理不了。</p>
</li>
<li><p>this.$http.post()中接受三个参数：</p>
<ul>
<li>第一个参数是要请求的URL地址。</li>
<li>第二个是要提交给服务器的数据，要以对象形式提交给服务器</li>
<li>第三个是一个配置对象，要以哪种表单数据类型提交过去。{emulateJSON: true},以普通表单格式将数据提交给服务器。</li>
</ul>
</li>
<li><p>指定数据接口根域名</p>
<ul>
<li>Vue.http.options.root = 'http://***/'<br>this.$http.get('add').then()</li>
<li>如果我们通过全局配置了请求的数据接口的根域名，则在每次单独发起http请求的时候，请求的 url 路径，必须以相对路径开头，前面不能带  / ，否则不会启用根路径做拼接。</li>
</ul>
</li>
<li><p>全局启用emulateJSON选项</p>
<ul>
<li>Vue.http.options.emulateJSON = true;<br>this.$http.post(url,参数）</li>
</ul>
</li>
</ul>
</li>
<li><p>JSONP的实现原理</p>
<ul>
<li><p>由于浏览器的安全限制，不允许AJAX访问跨域请求的数据接口，浏览器认为这种访问不安全。</p>
</li>
<li><p>可以通过动态创建script标签的形式，把script标签的src属性指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式称为JSONP（注意：根据JSONP的实现原理知晓，JSONP只支持GET请求。</p>
</li>
<li><p>具体实现过程</p>
<ul>
<li>先在客户端定义一个回调方法，预定义对数据的操作；</li>
<li>再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口。</li>
<li>服务端数据接口组织好要发送给客户端的数据，再拿着客户端传过来的回调方法名称，拼接出一个回调这个方法的字符串发送给客户端去解析执行。</li>
<li>客户端拿到服务器返回的字符串后，当作script脚本去解析执行，这样就能够拿到JSONP的数据了。</li>
</ul>
</li>
</ul>
</li>
<li><p>请求方法axios</p>
<ul>
<li><p>ajax</p>
<ul>
<li>【优点：局部更新；原生支持】</li>
<li>【缺点：可能破坏浏览器后退功能；嵌套回调】</li>
</ul>
</li>
<li><p>jqueryAjax：</p>
<ul>
<li>【在原生的ajax的基础上进行了封装；支持jsonp】</li>
</ul>
</li>
<li><p>fetch：</p>
<ul>
<li>【优点：解决回调地狱】</li>
<li>【缺点：API 偏底层，需要封装;默认不带Cookie，需要手动添加; 浏览器支持情况不是很友好，需要第三方的ployfill】</li>
</ul>
</li>
<li><p>axios</p>
<ul>
<li>支持浏览器和node.js</li>
<li>支持promise</li>
<li>能拦截请求和响应</li>
<li>能转换请求和响应数据</li>
<li>能取消请求</li>
<li>自动转换JSON数据</li>
<li>浏览器端支持防止CSRF(跨站请求伪造)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用<transition name="***"  mode="out-in">包裹</p>
<ul>
<li><p>name属性指定使用对象；<br>mode属性指定模式</p>
</li>
<li><p>有v-enter-active，v-leave-active和v-enter，v-leave的样式类名。</p>
</li>
<li><p>引入animate.css动画类库</p>
<ul>
<li>注意每个类中都得加animated这个基本类，效果才会出现。</li>
</ul>
</li>
<li><p>动画钩子函数</p>
<ul>
<li><p>第一个参数都是el，表示要执行动画的那个DOM元素，是个原生的JS DOM对象，大家可以认为el是通过document.getElementById获得的。</p>
</li>
<li><p>beforeEnter(el){}</p>
<ul>
<li>表示动画入场之前，此时动画尚未开始，可在函数中设置动画起始样式。</li>
</ul>
</li>
<li><p>enter(el，done){<br>el.offsetWidth<br>el.style.transform = ''<br>done()<br>}</p>
<ul>
<li>enter表示动画开始之后的样式，这里可以设置动画完成之后的结束状态。</li>
<li>el.offsetWidth这句话没实际作用，但是不写，出不来动画效果，可认为el.offsetWidth会强制动画刷新。</li>
<li>done():done是afterEnter()函数的引用，写上即可解决需要等一下才会出现afterEnter中设置的样式。因为它被同步调用。</li>
</ul>
</li>
<li><p>afterEnetr(el){}</p>
</li>
</ul>
</li>
<li><p>transition-group</p>
<ul>
<li>要使元素都很平滑过渡，使用固定模式：<br>.v-move{ transition: all  0.6s  ease; }<br>.v-leave-active{  position: absolute;  }<br>它会在元素的改变定位过程中应用。</li>
<li>在实现列表过渡的时候，如果需要过渡的元素是通过v-for循环创建的元素不能使用transition包裹，而应该使用transition-group，其中每个v-for出来的元素需要加上：key属性。</li>
<li>给transition-group添加appear属性，实现页面刚渲染出来时有入场的效果。</li>
<li>设置tag属性指定transition-group渲染为指定为元素，如不指定，默认为span标签。</li>
</ul>
</li>
</ul>
</li>
<li><p>数据监听</p>
<ul>
<li>watch属性监听data中属性/路由对象的改变</li>
<li>computed计算属性</li>
</ul>
</li>
</ul>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ul>
<li><p>cookie</p>
<ul>
<li><p>优点：</p>
<ul>
<li><ol>
<li>通过良好的编程习惯，控制保存在cookie中的session对象的大小。</li>
</ol>
</li>
<li><ol start="2">
<li>通过加密和安全传输技术，减少cookie被破解的可能性。</li>
</ol>
</li>
<li><ol start="3">
<li>只在cookie中存放不敏感数据，即使被盗也不会有重大损失。</li>
</ol>
</li>
<li><ol start="4">
<li>控制cookie的生命周期，使之不会永远有效。偷盗者可能拿到一个过期的cookie。</li>
</ol>
</li>
<li>5.解决无状态问题。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><ol>
<li>cookie数量和长度的限制。每个域名最多有20条cookie，每个cookie长度不超过4KB，否则会被截掉。</li>
</ol>
</li>
<li><ol start="2">
<li>安全性问题。如果cookie被人拦截，那人就可以获取session信息。即使加密也于事无补，因为拦截者并不需要知道cookie的信息，他只要原样转发cookie就可达到目的。</li>
</ol>
</li>
<li><ol start="3">
<li>有些状态不可能保存在客户端。如，为了防止重复提交表单，我们需要在服务器保存一个计数器。如果我们把这个计数器保存在客户端就起不到任何作用。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>浏览器本地存储</p>
<ul>
<li><ul>
<li>在较高版本的浏览器中，js提供sessionStorage和globalStorage。而HTML5使用localStorage代替globalStorage。</li>
</ul>
</li>
<li><ul>
<li>seesionStorage用于存储一个会话（session）中的数据，这些数据只在同一个会话中的页面才能访问并当会话结束后数据也随之销毁。因此，sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。</li>
</ul>
</li>
<li><ul>
<li>而localStorage用于持久化的本地存储，除非用户主动删除，否则数据永远不会过期。</li>
</ul>
</li>
</ul>
</li>
<li><p>web storage与cookie的区别</p>
<ul>
<li><ul>
<li>webStorage的概念与cookie相似，区别是他是为了更大存储设计的。cookie的大小是受限的，并且每次你请求一个新的页面时cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需指定作用域，不可跨域调用。</li>
</ul>
</li>
<li><ul>
<li>除此以外，Web Storage拥有setitem，getitem，removeitem，clear等方法，不像cookie需要前端开发者自己封装setCookie和getCookie。</li>
</ul>
</li>
<li><ul>
<li>但Cookie却是不可或缺的，cookie的作用是与服务器交互，作为http规范的一部分存在，而Web Storage仅仅是为了在本地存储数据而生。</li>
</ul>
</li>
</ul>
</li>
<li><p>cookie与session区别</p>
<ul>
<li><ol>
<li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>
</ol>
</li>
<li><ol start="2">
<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。考虑到安全应当使用session。</li>
</ol>
</li>
<li><ol start="3">
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</li>
</ol>
</li>
<li>考虑到减轻服务器性能方面，应当使用COOKIE。</li>
<li><ol start="4">
<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul>
<li><p>同步加载</p>
<ul>
<li>请求提交 -> 等待服务器处理 -> 处理完毕返回，这个期间客户端浏览器不能干任何事</li>
<li>又称阻塞模式，会阻塞到未加载的css，html的加载和渲染。</li>
<li>流览器之所以会采用同步模式，是因为加载的js文件中有对dom的操作，重定向，输出document等默认行为，所以同步才是最安全的。通常会把要加载的js放到body结束标签之前，使得js可在页面最后加载，尽量减少阻塞页面的渲染。这样可以先让页面显示出来</li>
</ul>
</li>
<li><p>异步加载</p>
<ul>
<li>请求通过事件触发 -> 服务器·处理（这时浏览器可以做其他事） -> 处理完毕</li>
<li><ol>
<li>也叫非阻塞模式加载，浏览器在下载js的同时，同时还会执行后续的页面处理。</li>
</ol>
</li>
<li><ol start="2">
<li>异步加载的方案有：动态插入js标签；通过ajax去获取js代码，通过eval执行；添加defer或async属性；创建并插入ifram，让它异步执行js。</li>
</ol>
</li>
</ul>
</li>
<li><p>延迟加载（懒加载）</p>
<ul>
<li><ol>
<li>有些js代码并不是页面初始化时就立刻需要，而稍后才需要。</li>
</ol>
</li>
<li><ol start="2">
<li>延迟加载就是一开始并不加载这些暂时不用的js，而是在需要的时候或稍后再通过js 的控制来异步加载。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul>
<li><p>同源策略及其限制</p>
<ul>
<li>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。它的存在可以保护用户隐私信息，防止身份伪造等(读取Cookie)。</li>
<li>同源策略限制内容有：Cookie、LocalStorage、IndexedDB 等存储性内容</li>
<li>img，link，script这三个标签允许跨域</li>
</ul>
</li>
<li><p>处理跨域方法</p>
<ul>
<li><p>JSONP</p>
<ul>
<li>原理：利用script元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</li>
<li>JSONP优点：是兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性。</li>
<li>JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。</li>
<li>流程：<br>1.声明一个回调函数，其函数名(如fn)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据。<br>2.服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串。<br>3.最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（fn），对返回的数据进行操作。</li>
</ul>
</li>
<li><p>CORS</p>
<ul>
<li>原理：整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</li>
<li>优点在于功能更加强大支持各种HTTP Method，缺点是兼容性不如JSONP。</li>
</ul>
</li>
<li><p>WebSocket</p>
<ul>
<li>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</li>
<li>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</li>
</ul>
</li>
<li><p>PostMessage</p>
<ul>
<li>如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即"协议 + 域名 + 端口"。也可以设为*，表示不限制域名，向所有窗口发送。</li>
</ul>
</li>
<li><p>服务器上设置代理页面</p>
</li>
</ul>
</li>
</ul>
<h3 id="输入url。。。"><a href="#输入url。。。" class="headerlink" title="输入url。。。"></a>输入url。。。</h3><ul>
<li>输入url后，首先需要找到这个url域名的服务器ip,为了寻找这个ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存-》路由器缓存，缓存中没有则查找系统的hosts文件中是否有记录，如果没有则查询DNS服务器，得到服务器的ip地址后，浏览器根据这个ip以及相应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个http请求封装在一个tcp包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的html给浏览器，因为html是一个树形结构，浏览器根据这个html来构建DOM树，在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐JS代码应该放在html代码的后面，之后根据外部央视，内部央视，内联样式构建一个CSS对象模型树CSS树，构建完成后和DOM树合并为渲染树，这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为html文件中会含有图片，视频，音频等资源，在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。 Cache-Control和Expires的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用Cache-Control，在请求这些有设置了缓存的数据时，会先 查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了ETag值会在这次请求的时候作为If-None-Match的值交给服务器校验，如果一致，继续校验 Last-Modified，没有设置ETag则直接验证Last-Modified，再决定是否返回304。</li>
</ul>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul>
<li><ol>
<li>减少http请求次数：CSS Sprites，JS、CSS源码压缩，图片大小控制合适；网页Gzip，CDN托管，data缓存，图片服务器。</li>
</ol>
</li>
<li><ol start="2">
<li>前端模板JS + 数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数。</li>
</ol>
</li>
<li><ol start="3">
<li>用innerHTML代替DOM操作，减少DOM操作的次数，优化js性能。</li>
</ol>
</li>
<li><ol start="4">
<li>当需要设置的样式很多时设置className而不是直接操作style。</li>
</ol>
</li>
<li><ol start="5">
<li>少用全局变量，缓存DOM节点查找的结果。减少IO读取操作。</li>
</ol>
</li>
<li><ol start="6">
<li>避免使用动态属性。</li>
</ol>
</li>
<li><ol start="7">
<li>图片预加载，将样式表放在顶部，将脚本放在底部，加上时间戳。</li>
</ol>
</li>
<li>8.利用webpack优化</li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul>
<li><p>XSS</p>
<ul>
<li>XSS跨站脚本攻击指恶意攻击者往web页面插入恶意代码，当用户浏览该页时，嵌入其中的html代码会被执行，从而达到恶意用户的目的。</li>
<li>防范：XSS攻击的核心是利用脚本注入。因此我们解决方法很简单，不信任用户的输入，对特殊字符进行如 “<”，“>" 转义。</li>
</ul>
</li>
<li><p>CSRF</p>
<ul>
<li><p>CSRF跨站请求伪造核心是请求伪造，通过伪造身份提交POST和GET请求来进行跨域的攻击。常见操作如转账。</p>
</li>
<li><p>完成跨站请求伪造需要两个步骤：</p>
<ul>
<li><ol>
<li>登陆受信任的网站A，在本地生成cookie。</li>
</ol>
</li>
<li><ol start="2">
<li>在不登出网站A或cookie未过期时，访问危险网站B。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SQL注入</p>
<ul>
<li><p>SQL注入攻击指应用程序在向后台数据库传递数据时，攻击者将SQL语句插入到表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意代码的SQL命令。</p>
</li>
<li><p>防范：</p>
<ul>
<li>1、增加黑名单或者白名单验证<br>白名单验证一般指，检查用户输入是否是符合预期的类型、长度、数值范围或者其他格式标准。黑名单验证是指，若在用户输入中，包含明显的恶意内容则拒绝该条用户请求。在使用白名单验证时，一般会配合黑名单验证。</li>
<li>2、安全检测<br>在项目完成的时候，始终坚持安全检测</li>
<li>3、防止系统敏感信息泄露<br>对数据表的访问权限进行严格控制，尽量限制用户不必要的访问权限。</li>
</ul>
</li>
</ul>
</li>
<li><p>文件上传漏洞</p>
<ul>
<li><p>原理：由于文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，导致允许攻击者向某个可通过 Web 访问的目录上传任意后台文件，并能够将这些文件传递给解释器，就可以在远程服务器上执行任意后台脚本。</p>
</li>
<li><p>防范：</p>
<ul>
<li>1、检查服务器是否判断了上传文件类型及后缀。</li>
<li>2、定义上传文件类型白名单，即只允许白名单里面类型的文件上传。</li>
<li>3、文件上传目录禁止执行脚本解析，避免攻击者进行二次攻击。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><ul>
<li><p>状态码</p>
<ul>
<li>1   --   继续，一般在发送post请求，已发送了http header之后，服务器将返回此信息，表示确认，之后发送具体参数信息。</li>
<li>2   --      请求成功。</li>
<li>3   --    重定向</li>
<li>4   --    客户端错误。</li>
<li>5   --    服务端错误。</li>
</ul>
</li>
<li><p>http与https区别</p>
<ul>
<li>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。</li>
<li>主要的区别如下：</li>
<li>Https协议需要ca证书，费用较高。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
<li>在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层</li>
</ul>
</li>
<li><p>https</p>
<ul>
<li><p>工作原理</p>
<ul>
<li>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</li>
<li>客户使用https url访问服务器，则要求web 服务器建立ssl链接。</li>
<li>web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。</li>
<li>客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。</li>
<li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>
<li>web服务器通过自己的私钥解密出会话密钥。</li>
<li>web服务器通过会话密钥加密与客户端之间的通信。</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>
<li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。</li>
<li>https缓存不如http高效，会增加数据开销。</li>
<li>SSL证书也需要钱，功能越强大的证书费用越高。</li>
<li>SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。</li>
</ul>
</li>
</ul>
</li>
<li><p>http2.0</p>
<ul>
<li><ol>
<li>提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比http1.0）</li>
</ol>
</li>
<li><ol start="2">
<li>允许多路复用：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了：在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。</li>
</ol>
</li>
<li><ol start="3">
<li>二进制分帧：HTTP2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码</li>
</ol>
</li>
<li><ol start="4">
<li>首部压缩</li>
</ol>
</li>
<li><ol start="5">
<li>服务器端推送</li>
</ol>
</li>
</ul>
</li>
<li><p>http协议无状态协议</p>
<ul>
<li><p>无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，需要重传，这样可能导致每次连接传送的数据量增大。</p>
<ul>
<li>HTTP无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持HTTP连接状态的技术就应运而生了，一个是Cookie，而另一个则是Session。HTTP本身是一个无状态的连接协议，为了支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是Cookie和Session了。</li>
<li>也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。</li>
</ul>
</li>
<li><p>可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。</p>
</li>
</ul>
</li>
</ul>
<h3 id="对前端的认识和看法"><a href="#对前端的认识和看法" class="headerlink" title="对前端的认识和看法"></a>对前端的认识和看法</h3><ul>
<li><ol>
<li>前端他是一个工作，他的工作领域是浏览器，它既要与美工，设计打交道又要懂点后台代码，知道ajax怎么从后台拿数据，接口怎么调用，最主要的是把美工的图合成完成的网页呈现给用户，需要实现网页的交互效果。</li>
</ol>
</li>
<li><ol start="2">
<li>前端处于设计和后台的中间领域，起到承上启下的作用，这就要求前端工程师的知识面在横向上必须要广。服务器技术要懂，产品与交互也要懂</li>
</ol>
</li>
<li><ol start="3">
<li>它需要掌握三个基本的技能：HTML，CSS， javascript。另外还需要懂点PHP或者其他应用在Web上的编程语言。</li>
</ol>
</li>
<li>前端的未来则是：有越来越多的软件开始在浏览器里运行，随着google和火狐的webos的发展，甚至在不久的将来，浏览器的api，会替代操作系统的sdk成为软件开发的标准。随着html5的发展，浏览器里运行的早已不是简单的页面，而是复杂的web应用。前端工程师也早已不是页面制作，而是web应用工程师。而未来究竟是web时代还是app时代仍是一个难以回答的问题。</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>逻辑结构</p>
<ul>
<li><p>集合结构</p>
</li>
<li><p>线性结构</p>
<ul>
<li>栈</li>
<li>队列</li>
<li>链表</li>
</ul>
</li>
<li><p>树形结构</p>
</li>
<li><p>图形结构</p>
</li>
</ul>
</li>
<li><p>物理结构</p>
<ul>
<li>顺序存储结构</li>
<li>链式存储结构</li>
</ul>
</li>
</ul>
<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>底部导航条采用uni-app自带的的tabbar，可在pages.json配置。因为顶部导航条的样式不想采用默认样式，所以取消顶部导航栏的默认样式，使用自己写的导航条，并使用固定定位display为flexed将导航条固定在顶部，设置z-index为99，使所有内容都处于导航条下面。</p>
<h3 id="尽量使用字体图标代替图片"><a href="#尽量使用字体图标代替图片" class="headerlink" title="尽量使用字体图标代替图片"></a>尽量使用字体图标代替图片</h3><ul>
<li><ol>
<li>轻量级：一个字体图标要比一系列的图像小，一旦字体加载了，图标就会马上渲染出来，不需要下载一个个图像，这样可减少HTTP请求，而且和HTML5的离线存储配合，可以对性能做出优化。</li>
</ol>
</li>
<li><ol start="2">
<li>灵活性：不调字体可以像页面中的文字一样通过font-size属性来对其进行大小的设置，且可添加各种文字效果，如color、hover、filter、text-shadow、transform等效果。灵活的很。</li>
</ol>
</li>
<li><ol start="3">
<li>兼容性：图标字体支持现代浏览器甚至低版本的IE浏览器，可放心使用。</li>
</ol>
</li>
<li><ol start="4">
<li>相对于位图放大图片会失真，缩小会浪费像素点，图标字体不会出现这种情况。</li>
</ol>
</li>
</ul>
<p>另外，点击导航栏进行页面切换部分采用uni-app官方为我们提供的scroll-view来实现横向或竖向的滚动。其特点是可以无缝滚动，且不会出现滚动条，当想使用滚动动画时可使用scroll-with-animation，感觉比较方便。</p>
<p>图片轮播图中出现在开发者工具显示正常，在手机上右半部分出现一部分空白，只需加上一个div将其包裹起来，最后一张图片切换到第一张时给人感觉不正常，只需将两套一样的图片拼接在一起即可。还有就是</p>
<p>页面整体采用flex布局，把重复的地方抽离出来并以组件形式呈现，把字体文件和公共样式文件单独存放。</p>
<h3 id="使用swiper组件"><a href="#使用swiper组件" class="headerlink" title="使用swiper组件"></a>使用swiper组件</h3><ul>
<li><ul>
<li>决定轮播图真正的高度是swiper，在其上设置高度才有效。swiper-item宽高自动是100%；</li>
</ul>
</li>
<li><ul>
<li>最好在swiper组件外面用view包裹，不然在手机端看时，图片无法全部铺满屏宽，右边有留白。</li>
</ul>
</li>
</ul>
</script></li></ol></li></ul></li></ul>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-http的学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/06/http的学习/" class="article-date">
      <time datetime="2020-04-06T02:47:35.000Z" itemprop="datePublished">2020-04-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/http的学习/">http的学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="HTTP无状态协议"><a href="#HTTP无状态协议" class="headerlink" title="HTTP无状态协议"></a>HTTP无状态协议</h4><p>HTTP无状态协议，是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<p>客户端与服务器进行动态交互的Web应用程序出现之后，HTTP无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持HTTP连接状态的技术就应运而生了，一个是<a href="https://baike.baidu.com/item/Cookie" target="_blank" rel="noopener">Cookie</a>，而另一个则是<a href="https://baike.baidu.com/item/Session" target="_blank" rel="noopener">Session</a>。HTTP本身是一个无状态的<a href="https://baike.baidu.com/item/连接协议" target="_blank" rel="noopener">连接协议</a>，为了支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是Cookie和Session了。</p>
<p>Cookie是通过客户端保持状态的<a href="https://baike.baidu.com/item/解决/32786" target="_blank" rel="noopener">解决</a>方案。从定义上来说，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。让我们说得更具体一些：当用户使用浏览器访问一个支持<a href="https://baike.baidu.com/item/Cookie/1119" target="_blank" rel="noopener">Cookie</a>的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的<a href="https://baike.baidu.com/item/超文本" target="_blank" rel="noopener">超文本</a>的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体（Response Body）中的，而是存放于HTTP响应头（Response Header）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置，对于<a href="https://baike.baidu.com/item/Windows操作系统/852149" target="_blank" rel="noopener">Windows操作系统</a>而言，我们可以从： [<a href="https://baike.baidu.com/item/系统盘" target="_blank" rel="noopener">系统盘</a>]:\Documents and Settings[用户名]\Cookies目录中找到存储的Cookie；自此，客户端再向服务器发送请求的时候，都会把相应的<a href="https://baike.baidu.com/item/Cookie/1119" target="_blank" rel="noopener">Cookie</a>再次发回至服务器。而这次，Cookie信息则存放在<a href="https://baike.baidu.com/item/HTTP请求头/6623287" target="_blank" rel="noopener">HTTP请求头</a>（Request Header）了。</p>
<p>有了Cookie这样的技术实现，服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。通常，我们可以从很多网站的登录界面中看到“请记住我”这样的选项，如果你勾选了它之后再登录，那么在下一次访问该网站的时候就不需要进行重复而繁琐的登录动作了，而这个功能就是通过Cookie实现的。</p>
<p>与Cookie相对的一个解决方案是Session，它是通过服务器来保持状态的。由于<a href="https://baike.baidu.com/item/Session/479100" target="_blank" rel="noopener">Session</a>这个词汇包含的语义很多，因此需要在这里明确一下 Session的含义。首先，我们通常都会把Session翻译成会话，因此我们可以把客户端浏览器与服务器之间一系列交互的动作称为一个  Session。从这个语义出发，我们会提到Session持续的时间，会提到在Session过程中进行了什么操作等等；其次，Session指的是服务器端为客户端所开辟的存储空间，在其中保存的信息就是用于保持状态。从这个语义出发，我们则会提到往Session中存放什么内容，如何根据键值从 Session中获取匹配的内容等。</p>
<p>要使用Session，第一步当然是创建Session了。那么Session在何时创建呢？当然还是在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同创建Session的方法，而在<a href="https://baike.baidu.com/item/Java/85979" target="_blank" rel="noopener">Java</a>中是通过调用HttpServletRequest的getSession方法（使用true作为参数）创建的。在创建了<a href="https://baike.baidu.com/item/Session/479100" target="_blank" rel="noopener">Session</a>的同时，服务器会为该Session生成唯一的Session id，而这个Session  id在随后的请求中会被用来重新获得已经创建的Session；在Session被创建之后，就可以调用Session相关的方法往Session中增加内容了，而这些内容只会保存在服务器中，发到客户端的只有Session id；当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session  id找到相应的Session，从而再次使用之。正是这样一个过程，用户的状态也就得以保持了。</p>
<p>综上所述，HTTP本身是一个无状态的<a href="https://baike.baidu.com/item/连接协议/7768217" target="_blank" rel="noopener">连接协议</a>，为了支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是<a href="https://baike.baidu.com/item/Cookie/1119" target="_blank" rel="noopener">Cookie</a>和Session了。</p>
<h4 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h4><p>​    1. cookie数据存放在客户的浏览器上，session数据放在服务器上。<br>​    2. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。考虑到安全应当使用session。<br>​    3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>​       考虑到减轻服务器性能方面，应当使用COOKIE。<br>​    4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
<h4 id="cookie的优缺点"><a href="#cookie的优缺点" class="headerlink" title="cookie的优缺点"></a>cookie的优缺点</h4><h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><p>​        1. 通过良好的编程习惯，控制保存在cookie中的session对象的大小。<br>​        2. 通过加密和安全传输技术，减少cookie被破解的可能性。<br>​        3. 只在cookie中存放不敏感数据，即使被盗也不会有重大损失。<br>​        4. 控制cookie的生命周期，使之不会永远有效。偷盗者可能拿到一个过期的cookie。<br>​        5.解决无状态问题。</p>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><p>​        1. cookie数量和长度的限制。每个域名最多有20条cookie，每个cookie长度不超过4KB，否则会被截掉。<br>​        2. 安全性问题。如果cookie被人拦截，那人就可以获取session信息。即使加密也于事无补，因为拦截者并不需要知道cookie的信息，他只要原样转发cookie就可达到目的。<br>​        3. 有些状态不可能保存在客户端。如，为了防止重复提交表单，我们需要在服务器保存一个计数器。如果我们把这个计数器保存在客户端就起不到任何作用。</p>
<h4 id="常用的HTTP方法"><a href="#常用的HTTP方法" class="headerlink" title="常用的HTTP方法"></a>常用的HTTP方法</h4><ul>
<li>GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li>
<li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</li>
<li>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。</li>
<li>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</li>
<li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。</li>
<li>OPTIONS：查询相应URI支持的HTTP方法。</li>
</ul>
<h4 id="URL和URI区别"><a href="#URL和URI区别" class="headerlink" title="URL和URI区别"></a>URL和URI区别</h4><p><strong>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。</strong></p>
<ul>
<li>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的</li>
<li>URI一般由三部组成：</li>
<li>①访问资源的命名机制</li>
<li>②存放资源的主机名</li>
<li>③资源自身的名称，由路径表示，着重强调于资源。</li>
</ul>
<p><strong>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</strong></p>
<ul>
<li>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。</li>
<li>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：</li>
<li>①协议(或称为服务方式)</li>
<li>②存有该资源的主机IP地址(有时也包括端口号)</li>
<li>③主机资源的具体地址。如目录和文件名等</li>
</ul>
<h4 id="HTTP请求报文与响应报文格式"><a href="#HTTP请求报文与响应报文格式" class="headerlink" title="HTTP请求报文与响应报文格式"></a>HTTP请求报文与响应报文格式</h4><h6 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h6><p><img src="https://img-blog.csdn.net/20180213114347309" alt="img"></p>
<ul>
<li>a、请求行：包含请求方法、URI、HTTP版本信息</li>
<li>b、请求首部字段</li>
<li>c、请求内容实体</li>
<li>d、空行</li>
</ul>
<h6 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h6><h6 id><a href="#" class="headerlink" title></a><img src="https://img-blog.csdn.net/20180213114358760" alt="img"></h6><ul>
<li>a、状态行：包含HTTP版本、状态码、状态码的原因短语</li>
<li>b、响应首部字段</li>
<li>c、响应内容实体</li>
<li>d、空行</li>
</ul>
<h6 id="常见的首部"><a href="#常见的首部" class="headerlink" title="常见的首部"></a>常见的首部</h6><ul>
<li><strong>通用首部字段（请求报文与响应报文都会使用的首部字段）</strong><ul>
<li>Date：创建报文时间</li>
<li>Connection：连接的管理</li>
<li>Cache-Control：缓存的控制</li>
<li>Transfer-Encoding：报文主体的传输编码方式</li>
</ul>
</li>
<li><strong>请求首部字段（请求报文会使用的首部字段）</strong><ul>
<li>Host：请求资源所在服务器</li>
<li>Accept：可处理的媒体类型</li>
<li>Accept-Charset：可接收的字符集</li>
<li>Accept-Encoding：可接受的内容编码</li>
<li>Accept-Language：可接受的自然语言</li>
</ul>
</li>
<li><strong>响应首部字段（响应报文会使用的首部字段）</strong><ul>
<li>Accept-Ranges：可接受的字节范围</li>
<li>Location：令客户端重新定向到的URI</li>
<li>Server：HTTP服务器的安装信息</li>
</ul>
</li>
<li><strong>实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）</strong><ul>
<li>Allow：资源可支持的HTTP方法</li>
<li>Content-Type：实体主类的类型</li>
<li>Content-Encoding：实体主体适用的编码方式</li>
<li>Content-Language：实体主体的自然语言</li>
<li>Content-Length：实体主体的的字节数</li>
<li>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</li>
</ul>
</li>
</ul>
<h4 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h4><ul>
<li>首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；</li>
<li>客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；</li>
<li>消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；</li>
<li>发送给服务端，此时只有服务端（RSA私钥）能解密。</li>
<li>解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。</li>
</ul>
<h4 id="一次完整的HTTP请求所经历的7个步骤"><a href="#一次完整的HTTP请求所经历的7个步骤" class="headerlink" title="一次完整的HTTP请求所经历的7个步骤"></a>一次完整的HTTP请求所经历的7个步骤</h4><p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p>
<ul>
<li>建立TCP连接</li>
</ul>
<p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。<strong>HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</strong></p>
<ul>
<li>Web浏览器向Web服务器发送请求行</li>
</ul>
<p>一旦建立了TCP连接，<strong>Web浏览器就会向Web服务器发送请求命令</strong>。例如：GET /sample/hello.js HTTP/1.1。</p>
<ul>
<li>Web浏览器发送请求头<ul>
<li>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，<strong>之后浏览器发送了一空白行来通知服务器</strong>，它已经结束了该头信息的发送。</li>
</ul>
</li>
<li>Web服务器应答<ul>
<li>客户机向服务器发出请求后，服务器会客户机回送应答， <strong>HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</strong></li>
</ul>
</li>
<li>Web服务器发送应答头<ul>
<li>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</li>
</ul>
</li>
<li>Web服务器向浏览器发送数据<ul>
<li>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，<strong>它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据</strong>。</li>
</ul>
</li>
<li>Web服务器关闭TCP连接<ul>
<li>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>

<p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>
<p>建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接</p>
<h4 id="常见的HTTP相应状态码"><a href="#常见的HTTP相应状态码" class="headerlink" title="常见的HTTP相应状态码"></a>常见的HTTP相应状态码</h4><ul>
<li>200：请求被正常处理</li>
<li>204：请求被受理但没有资源可以返回</li>
<li>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</li>
<li>301：永久性重定向</li>
<li>302：临时重定向</li>
<li>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</li>
<li>304：发送附带条件的请求时，条件不满足时返回，与重定向无关</li>
<li>307：临时重定向，与302类似，只是强制要求使用POST方法</li>
<li>400：请求报文语法有误，服务器无法识别</li>
<li>401：请求需要认证</li>
<li>403：请求的对应资源禁止被访问</li>
<li>404：服务器无法找到对应资源</li>
<li>500：服务器内部错误</li>
<li>503：服务器正忙</li>
</ul>
<h4 id="HTTP1-1版本新特性"><a href="#HTTP1-1版本新特性" class="headerlink" title="HTTP1.1版本新特性"></a>HTTP1.1版本新特性</h4><ul>
<li>a、<strong>默认持久连接节省通信量</strong>，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</li>
<li>b、<strong>管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应</strong></li>
<li>c、<strong>断点续传</strong><ul>
<li><strong>实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输。</strong></li>
</ul>
</li>
</ul>
<h6 id="HTTP优化方案"><a href="#HTTP优化方案" class="headerlink" title="HTTP优化方案"></a>HTTP优化方案</h6><ul>
<li><strong>TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持。</strong></li>
<li><strong>内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。</strong></li>
<li><strong>压缩：将文本数据进行压缩，减少带宽</strong></li>
<li><strong>SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速</strong></li>
<li><strong>TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。</strong></li>
</ul>
<h4 id="Cache-control缓存控制"><a href="#Cache-control缓存控制" class="headerlink" title="Cache-control缓存控制"></a>Cache-control缓存控制</h4><p>网页的缓存是由HTTP消息头中的“Cache-control”来控制的，常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。<br>其作用根据不同的重新浏览方式分为以下几种情况：<br>（1）  打开新窗口如果指定cache-control的值为private、no-cache、must-revalidate，那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值，那么在此值内的时间里就不会重新访问服务器，例如： Cache-control: max-age=5 表示当访问此网页后的5秒内再次访问不会去服务器。<br>（2） 在地址栏回车如果值为private或must-revalidate（和网上说的不一样），则只有第一次访问时会访问服务器，以后就不再访问。如果值为no-cache，那么每次都会访问。如果值为max-age，则在过期之前不会重复访问。<br>（3） 按后退按扭如果值为private、must-revalidate、max-age，则不会重访问，而如果为no-cache，则每次都重复访问。<br>（4） 按刷新按扭无论为何值，都会重复访问  当指定Cache-control值为“no-cache”时，访问此页面不会在Internet临时文章夹留下页面备份。另外，通过指定“Expires”值也会影响到缓存。例如，指定Expires值为一个早已过去的时间，那么访问此网时若重复在地址栏按回车，那么每次都会重复访问： Expires: Fri, 31 Dec 1999 16:00:00 GMT  在ASP中，可以通过Response对象的Expires、ExpiresAbsolute属性控制Expires值；通过Response对象的CacheControl属性控制Cache-control的值，例如： Response.ExpiresAbsolute = #2000-1-1# ‘  指定绝对的过期时间，这个时间用的是服务器当地时间，会被自动转换为GMT时间 Response.Expires = 20 ‘  指定相对的过期时间，以分钟为单位，表示从当前时间起过多少分钟过期。 Response.CacheControl = “no-cache”  Expires值是可以通过在Internet临时文件夹中查看临时文件的属性看到的。                                    </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-课程表制作" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/29/课程表制作/" class="article-date">
      <time datetime="2020-03-29T00:09:28.000Z" itemprop="datePublished">2020-03-29</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/29/课程表制作/">课程表制作</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h5 id="课程表制作"><a href="#课程表制作" class="headerlink" title="课程表制作"></a>课程表制作</h5><p>使用微信小程序制作的课程表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//index.wxml文件</span><br><span class="line"></span><br><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;view class=&quot;top&quot;&gt;</span><br><span class="line">    &lt;view wx:for=&quot;&#123;&#123;[&apos;一&apos;,&apos;二&apos;,&apos;三&apos;,&apos;四&apos;,&apos;五&apos;,&apos;六&apos;,&apos;日&apos;]&#125;&#125;&quot; class=&quot;top-text&quot;&gt;</span><br><span class="line">      周&#123;&#123;item&#125;&#125;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view style=&quot;display:flex;flex-direction:row;background:#D2E6B3&quot;&gt;</span><br><span class="line">  &lt;view style=&quot;color:#7cba23;&quot;&gt;</span><br><span class="line">    &lt;view wx:for=&quot;&#123;&#123;[1,2,3,4,5,6,7,8,9,10]&#125;&#125;&quot; class=&quot;left&quot;&gt;</span><br><span class="line">      &#123;&#123;item&#125;&#125;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;!-- &lt;view wx:for=&quot;&#123;&#123;[1,2,3,4,5,6,7,8,9,10]&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;view style=&quot;width:750rpx;margin-top:&#123;&#123;(index+1)*100&#125;&#125;rpx;  position: absolute;border-bottom:1rpx solid &#123;&#123;index==3?&apos;red&apos;:&apos;lightgray&apos;&#125;&#125;;&quot;&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt; --&gt;</span><br><span class="line">  &lt;view wx:for=&quot;&#123;&#123;wlist&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;view class=&quot;flex-item kcb-item&quot; bindtap=&quot;showCardView&quot; data-statu=&quot;open&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; style=&quot;margin-left:&#123;&#123;(item.xqj-1)*100&#125;&#125;rpx;margin-top:&#123;&#123;(item.skjc-1)*100+10&#125;&#125;rpx;height:&#123;&#123;item.skcd*100-5&#125;&#125;rpx;background-color:&#123;&#123;colorArrays[index%9]&#125;&#125;&quot;&gt;</span><br><span class="line">      &lt;view class=&quot;smalltext&quot;&gt;&#123;&#123;item.kcmc&#125;&#125;&lt;/view&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<p>index.wxss</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">.top &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: row;</span><br><span class="line">  margin-left: 35rpx;</span><br><span class="line">  background-color: #d2e6b3;</span><br><span class="line">  color: #7cba23;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.top-text &#123;</span><br><span class="line">  width: 100rpx;</span><br><span class="line">  height: 35rpx;</span><br><span class="line">  font-size: 9pt;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">  border: 1px solid gray;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">  width: 35rpx;</span><br><span class="line">  height: 100rpx;</span><br><span class="line">  font-size: 9pt;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">  border: 1px solid gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.flex-item &#123;</span><br><span class="line">  width: 95rpx;</span><br><span class="line">  height: 100px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.kcb-item &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.smalltext &#123;</span><br><span class="line">  font-size: 8pt;</span><br><span class="line">  color: #fff;</span><br><span class="line">  padding-left: 2px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.scroll &#123;</span><br><span class="line">  height: 1170rpx;</span><br><span class="line">  z-index: 101;</span><br><span class="line">  position: fixed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.js文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">//获取应用实例</span><br><span class="line">const app = getApp()</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    colorArrays: [&quot;#85B8CF&quot;, &quot;#C0C652&quot;, &quot;#D8AA5A&quot;, &quot;#FC9F9D&quot;, &quot;#0A9A84&quot;, &quot;#61BC69&quot;, &quot;#12AEF3&quot;, &quot;#E29AAD&quot;], </span><br><span class="line">    wlist: [</span><br><span class="line">      &#123; &quot;xqj&quot;: 1, &quot;skjc&quot;: 1, &quot;skcd&quot;: 3, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 1, &quot;skjc&quot;: 5, &quot;skcd&quot;: 3, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 2, &quot;skjc&quot;: 1, &quot;skcd&quot;: 2, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 2, &quot;skjc&quot;: 8, &quot;skcd&quot;: 2, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 3, &quot;skjc&quot;: 4, &quot;skcd&quot;: 1, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 3, &quot;skjc&quot;: 8, &quot;skcd&quot;: 1, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 3, &quot;skjc&quot;: 5, &quot;skcd&quot;: 2, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 4, &quot;skjc&quot;: 2, &quot;skcd&quot;: 3, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 4, &quot;skjc&quot;: 8, &quot;skcd&quot;: 2, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 5, &quot;skjc&quot;: 1, &quot;skcd&quot;: 2, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 6, &quot;skjc&quot;: 3, &quot;skcd&quot;: 2, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 7, &quot;skjc&quot;: 5, &quot;skcd&quot;: 3, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">    ],</span><br><span class="line">    motto: &apos;Hello World&apos;,</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">    hasUserInfo: false,</span><br><span class="line">    canIUse: wx.canIUse(&apos;button.open-type.getUserInfo&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  //事件处理函数</span><br><span class="line">  bindViewTap: function() &#123;</span><br><span class="line">    wx.navigateTo(&#123;</span><br><span class="line">      url: &apos;../logs/logs&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: function () &#123;</span><br><span class="line">    if (app.globalData.userInfo) &#123;</span><br><span class="line">      this.setData(&#123;</span><br><span class="line">        userInfo: app.globalData.userInfo,</span><br><span class="line">        hasUserInfo: true</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else if (this.data.canIUse)&#123;</span><br><span class="line">      // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span><br><span class="line">      // 所以此处加入 callback 以防止这种情况</span><br><span class="line">      app.userInfoReadyCallback = res =&gt; &#123;</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">          userInfo: res.userInfo,</span><br><span class="line">          hasUserInfo: true</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 在没有 open-type=getUserInfo 版本的兼容处理</span><br><span class="line">      wx.getUserInfo(&#123;</span><br><span class="line">        success: res =&gt; &#123;</span><br><span class="line">          app.globalData.userInfo = res.userInfo</span><br><span class="line">          this.setData(&#123;</span><br><span class="line">            userInfo: res.userInfo,</span><br><span class="line">            hasUserInfo: true</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getUserInfo: function(e) &#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">    app.globalData.userInfo = e.detail.userInfo</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      userInfo: e.detail.userInfo,</span><br><span class="line">      hasUserInfo: true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5CCCY%5CDesktop%5C3.png" alt="3"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-CSS3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/26/CSS3/" class="article-date">
      <time datetime="2020-03-26T03:48:03.000Z" itemprop="datePublished">2020-03-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/CSS3/">CSS3</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>CSS知识点</p>
<h2 id="一-解决老的浏览器支持问题"><a href="#一-解决老的浏览器支持问题" class="headerlink" title="一 . 解决老的浏览器支持问题"></a>一 . 解决老的浏览器支持问题</h2><h5 id="1-加上相应的前缀即可"><a href="#1-加上相应的前缀即可" class="headerlink" title="1.加上相应的前缀即可"></a>1.加上相应的前缀即可</h5><table>
<thead>
<tr>
<th>Chorme</th>
<th>IE</th>
<th>Firefox</th>
<th>Safari</th>
<th>Opera</th>
</tr>
</thead>
<tbody><tr>
<td>-webkit-</td>
<td>-ms-</td>
<td>-moz-</td>
<td>-webkit-</td>
<td>-o-或者-xv-</td>
</tr>
</tbody></table>
<h4 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h4><ul>
<li>CSS3弹性盒子：<ul>
<li>是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式；引入弹性布局的目的是提供更有效的方式来对一个容器中的子元素进行排列，对齐和分配空白空间。</li>
<li>弹性容器通过设置display属性为flex或inline-flex将其定义为弹性盒子，弹性容器内包含了一个或多个弹性子元素； 弹性容器外及弹性子元素内是正常渲染的。弹性盒子只定义了弹性子元素如何在弹性容器内布局。</li>
<li>弹性子元素通常在弹性盒子内一行显示。默认情况每个容器只有一行。</li>
</ul>
</li>
</ul>
<h4 id="3-选择器"><a href="#3-选择器" class="headerlink" title="3.选择器"></a>3.选择器</h4><table>
<thead>
<tr>
<th>.intro</th>
<th>选择所有class=”intro”的元素</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-id.html" target="_blank" rel="noopener">#<em>id</em></a></td>
<td>#firstname</td>
<td>选择所有id=”firstname”的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-all.html" target="_blank" rel="noopener">*</a></td>
<td>*</td>
<td>选择所有元素</td>
</tr>
<tr>
<td><em>element</em></td>
<td>p</td>
<td>选择所有p元素</td>
</tr>
<tr>
<td><em>element,element</em></td>
<td>div,p</td>
<td>选择所有元素和元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-element-element.html" target="_blank" rel="noopener"><em>element element</em></a></td>
<td>div p</td>
<td>选择元素内的所有元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-element-gt.html" target="_blank" rel="noopener"><em>element</em>&gt;<em>element</em></a></td>
<td>div&gt;p</td>
<td>选择所有父级是div元素的p元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-element-pluss.html" target="_blank" rel="noopener"><em>element</em>+<em>element</em></a></td>
<td>div+p</td>
<td>选择所有紧接着元素之后的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-attribute.html" target="_blank" rel="noopener">[<em>attribute</em>]</a></td>
<td>[target]</td>
<td>选择所有带有target属性元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-attribute-value.html" target="_blank" rel="noopener">[<em>attribute</em>=<em>value</em>]</a></td>
<td>[target=-blank]</td>
<td>选择所有使用target=”-blank”的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-attribute-value-contains.html" target="_blank" rel="noopener">[<em>attribute</em>~=<em>value</em>]</a></td>
<td>[title~=flower]</td>
<td>选择标题属性包含单词”flower”的所有元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-attribute-value-lang.html" target="_blank" rel="noopener">[<em>attribute</em>|=<em>language</em>]</a></td>
<td>[lang|=en]</td>
<td>选择一个lang属性的起始值=”EN”的所有元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-link.html" target="_blank" rel="noopener">:link</a></td>
<td>a:link</td>
<td>选择所有未访问链接</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-visited.html" target="_blank" rel="noopener">:visited</a></td>
<td>a:visited</td>
<td>选择所有访问过的链接</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-active.html" target="_blank" rel="noopener">:active</a></td>
<td>a:active</td>
<td>选择活动链接</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-hover.html" target="_blank" rel="noopener">:hover</a></td>
<td>a:hover</td>
<td>选择鼠标在链接上面时</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-focus.html" target="_blank" rel="noopener">:focus</a></td>
<td>input:focus</td>
<td>选择具有焦点的输入元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-firstletter.html" target="_blank" rel="noopener">:first-letter</a></td>
<td>p:first-letter</td>
<td>选择每一个元素的第一个字母</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-firstline.html" target="_blank" rel="noopener">:first-line</a></td>
<td>p:first-line</td>
<td>选择每一个元素的第一行</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-firstchild.html" target="_blank" rel="noopener">:first-child</a></td>
<td>p:first-child</td>
<td>指定只有当元素是其父级的第一个子级的样式。</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-before.html" target="_blank" rel="noopener">:before</a></td>
<td>p:before</td>
<td>在每个元素之前插入内容</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-after.html" target="_blank" rel="noopener">:after</a></td>
<td>p:after</td>
<td>在每个元素之后插入内容</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-lang.html" target="_blank" rel="noopener">:lang(<em>language</em>)</a></td>
<td>p:lang(it)</td>
<td>选择一个lang属性的起始值=”it”的所有元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-gen-sibling.html" target="_blank" rel="noopener"><em>element1</em>~<em>element2</em></a></td>
<td>p~ul</td>
<td>选择p元素之后的每一个ul元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-attr-begin.html" target="_blank" rel="noopener">[<em>attribute</em>^=<em>value</em>]</a></td>
<td>a[src^=”https”]</td>
<td>选择每一个src属性的值以”https”开头的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-attr-end.html" target="_blank" rel="noopener">[<em>attribute</em>$=<em>value</em>]</a></td>
<td>a[src$=”.pdf”]</td>
<td>选择每一个src属性的值以”.pdf”结尾的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-attr-contain.html" target="_blank" rel="noopener">[<em>attribute*</em>=<em>value</em>]</a></td>
<td>a[src*=”44lan”]</td>
<td>选择每一个src属性的值包含子字符串”44lan”的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-first-of-type.html" target="_blank" rel="noopener">:first-of-type</a></td>
<td>p:first-of-type</td>
<td>选择每个p元素是其父级的第一个p元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-last-of-type.html" target="_blank" rel="noopener">:last-of-type</a></td>
<td>p:last-of-type</td>
<td>选择每个p元素是其父级的最后一个p元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-only-of-type.html" target="_blank" rel="noopener">:only-of-type</a></td>
<td>p:only-of-type</td>
<td>选择每个p元素是其父级的唯一p元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-only-child.html" target="_blank" rel="noopener">:only-child</a></td>
<td>p:only-child</td>
<td>选择每个p元素是其父级的唯一子元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-nth-child.html" target="_blank" rel="noopener">:nth-child(<em>n</em>)</a></td>
<td>p:nth-child(2)</td>
<td>选择每个p元素是其父级的第二个子元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-nth-last-child.html" target="_blank" rel="noopener">:nth-last-child(<em>n</em>)</a></td>
<td>p:nth-last-child(2)</td>
<td>选择每个p元素的是其父级的第二个子元素，从最后一个子项计数</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-nth-of-type.html" target="_blank" rel="noopener">:nth-of-type(<em>n</em>)</a></td>
<td>p:nth-of-type(2)</td>
<td>选择每个p元素是其父级的第二个p元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-nth-last-of-type.html" target="_blank" rel="noopener">:nth-last-of-type(<em>n</em>)</a></td>
<td>p:nth-last-of-type(2)</td>
<td>选择每个p元素的是其父级的第二个p元素，从最后一个子项计数</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-last-child.html" target="_blank" rel="noopener">:last-child</a></td>
<td>p:last-child</td>
<td>选择每个p元素是其父级的最后一个子级。</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-root.html" target="_blank" rel="noopener">:root</a></td>
<td>:root</td>
<td>选择文档的根元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-empty.html" target="_blank" rel="noopener">:empty</a></td>
<td>p:empty</td>
<td>选择每个没有任何子级的p元素（包括文本节点）</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-target.html" target="_blank" rel="noopener">:target</a></td>
<td>#news:target</td>
<td>选择当前活动的#news元素（包含该锚名称的点击的URL）</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-enabled.html" target="_blank" rel="noopener">:enabled</a></td>
<td>input:enabled</td>
<td>选择每一个已启用的输入元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-disabled.html" target="_blank" rel="noopener">:disabled</a></td>
<td>input:disabled</td>
<td>选择每一个禁用的输入元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-checked.html" target="_blank" rel="noopener">:checked</a></td>
<td>input:checked</td>
<td>选择每个选中的输入元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-not.html" target="_blank" rel="noopener">:not(<em>selector</em>)</a></td>
<td>:not(p)</td>
<td>选择每个并非p元素的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-selection.html" target="_blank" rel="noopener">::selection</a></td>
<td>::selection</td>
<td>匹配元素中被用户选中或处于高亮状态的部分</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-out-of-range.html" target="_blank" rel="noopener">:out-of-range</a></td>
<td>:out-of-range</td>
<td>匹配值在指定区间之外的input元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-in-range.html" target="_blank" rel="noopener">:in-range</a></td>
<td>:in-range</td>
<td>匹配值在指定区间之内的input元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-read-write.html" target="_blank" rel="noopener">:read-write</a></td>
<td>:read-write</td>
<td>用于匹配可读及可写的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-read-only.html" target="_blank" rel="noopener">:read-only</a></td>
<td>:read-only</td>
<td>用于匹配设置 “readonly”（只读） 属性的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-optional.html" target="_blank" rel="noopener">:optional</a></td>
<td>:optional</td>
<td>用于匹配可选的输入元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-required.html" target="_blank" rel="noopener">:required</a></td>
<td>:required</td>
<td>用于匹配设置了 “required” 属性的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-valid.html" target="_blank" rel="noopener">:valid</a></td>
<td>:valid</td>
<td>用于匹配输入值为合法的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-invalid.html" target="_blank" rel="noopener">:invalid</a></td>
<td>:invalid</td>
<td>用于匹配输入值为非法的元素</td>
</tr>
</tbody></table>
<h2 id="二-多重样式优先级深入概念"><a href="#二-多重样式优先级深入概念" class="headerlink" title="二 . 多重样式优先级深入概念"></a>二 . 多重样式优先级深入概念</h2><p>优先级是浏览器是通过判断哪些属性值与元素最相关以决定并应用到该元素上的。优先级仅由选择器组成的匹配规则决定的。</p>
<p>优先级就是分配给指定的CSS声明的一个权重，它由匹配的选择器中的每一种选择器类型的数值决定。</p>
<h3 id="优先级顺序"><a href="#优先级顺序" class="headerlink" title="优先级顺序"></a>优先级顺序</h3><p>下列是一份优先级逐级增加的选择器列表：</p>
<ul>
<li>通用选择器（*）</li>
<li>元素(类型)选择器</li>
<li>类选择器</li>
<li>属性选择器</li>
<li>伪类</li>
<li>ID 选择器</li>
<li>内联样式</li>
</ul>
<h3 id="important-规则例外"><a href="#important-规则例外" class="headerlink" title="!important 规则例外"></a>!important 规则例外</h3><p>当 !important 规则被应用在一个样式声明中时,该样式声明会覆盖CSS中任何其他的声明, 无论它处在声明列表中的哪里. 尽管如此, !important规则还是与优先级毫无关系.使用 !important 不是一个好习惯，因为它改变了你样式表本来的级联规则，从而使其难以调试。</p>
<p>一些经验法则：</p>
<ul>
<li><strong>Always</strong> 要优化考虑使用样式规则的优先级来解决问题而不是 <code>!important</code></li>
<li><strong>Only</strong> 只在需要覆盖全站或外部 css（例如引用的 ExtJs 或者 YUI ）的特定页面中使用 <code>!important</code></li>
<li><strong>Never</strong> 永远不要在全站范围的 css 上使用<code>!important</code></li>
<li><strong>Never</strong> 永远不要在你的插件中使用 <code>!important</code></li>
<li><ul>
<li>内联样式表的权值最高 1000；</li>
<li>ID 选择器的权值为 100</li>
<li>Class 类选择器的权值为 10</li>
<li>HTML 标签选择器的权值为 1</li>
</ul>
</li>
<li>id属性不要以数字开头，数字开头的id在Mozilla/Firefox浏览器不起作用</li>
<li>创建样式表<ul>
<li>外部样式表</li>
<li>内部样式表</li>
<li>内联样式表</li>
<li>多重样式表</li>
</ul>
</li>
</ul>
<h3 id="CSS-优先级法则："><a href="#CSS-优先级法则：" class="headerlink" title="CSS 优先级法则："></a>CSS 优先级法则：</h3><ul>
<li>A 选择器都有一个权值，权值越大越优先；</li>
<li>B 当权值相等时，后出现的样式表设置要优于先出现的样式表设置；</li>
<li>C 创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；</li>
<li>D 继承的CSS 样式不如后来指定的CSS 样式；</li>
<li>E 在同一组属性设置中标有“!important”规则的优先级最大；</li>
</ul>
<h4 id="目标选择器"><a href="#目标选择器" class="headerlink" title="目标选择器"></a>目标选择器</h4><ul>
<li>：target{ }当目标被选中时就会执行该样式</li>
</ul>
<h2 id="三-CSS属性"><a href="#三-CSS属性" class="headerlink" title="三 . CSS属性"></a>三 . CSS属性</h2><h4 id="1-align-content"><a href="#1-align-content" class="headerlink" title="1.align-content"></a>1.align-content</h4><ul>
<li><p>align-content属性在弹性容器内的各项没有占用交叉轴上所有可用的空间时对齐容器内的各项（垂直）</p>
</li>
<li><p><strong>提示：</strong>使用 justify-content 属性对齐主轴上的各项（水平）</p>
<p><strong>注意：</strong>容器内必须有多行的项目，该属性才能渲染出效果。</p>
<h2 id="CSS-语法"><a href="#CSS-语法" class="headerlink" title="CSS 语法"></a>CSS 语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-content: stretch|center|flex-start|flex-end|space-between|space-around|initial|inherit;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性值</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>stretch</td>
<td>默认值。项目被拉伸以适应容器</td>
</tr>
<tr>
<td>center</td>
<td>项目位于容器的中心。</td>
</tr>
<tr>
<td>flex-start</td>
<td>项目位于容器的开头。</td>
</tr>
<tr>
<td>flex-end</td>
<td>项目位于容器的结尾。</td>
</tr>
<tr>
<td>space-between</td>
<td>项目位于各行之间留有空白的容器内。</td>
</tr>
<tr>
<td>space-around</td>
<td>项目位于各行之前、之间、之后都留有空白的容器内。</td>
</tr>
<tr>
<td>initial</td>
<td>设置该属性为它的默认值。</td>
</tr>
<tr>
<td>inherit</td>
<td>从父元素继承该属性。</td>
</tr>
</tbody></table>
<p>#main { width: 70px; height: 300px; border: 1px solid #c3c3c3; display: -webkit-flex; display: flex; -webkit-flex-wrap: wrap; flex-wrap: wrap; -webkit-align-content: center; align-content: center;}</p>
</li>
</ul>
<h4 id="2-align-items属性"><a href="#2-align-items属性" class="headerlink" title="2.align-items属性"></a>2.align-items属性</h4><ul>
<li>设置flex容器的对齐方式，使用每个flex对象元素的 align-self 属性可重写 align-items 属性。</li>
<li>语法<ul>
<li>align-items: stretch|center|flex-start|flex-end|baseline（位置元素在容器的基线）|initial（设为默认值）|inherit;</li>
</ul>
</li>
</ul>
<h5 id="3-背景属性background"><a href="#3-背景属性background" class="headerlink" title="3.背景属性background"></a>3.背景属性background</h5><ul>
<li>当使用简写属性时，属性值的顺序为：:<ul>
<li>background-color</li>
<li>background-image</li>
<li>background-repeat</li>
<li>background-attachment</li>
<li>background-position</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Property</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>background</td>
<td>简写属性，作用是将背景属性设置在一个声明中。</td>
</tr>
<tr>
<td>background-attachment</td>
<td>背景图像是否固定或者随着页面的其余部分滚动。</td>
</tr>
<tr>
<td>background-color</td>
<td>设置元素的背景颜色。</td>
</tr>
<tr>
<td>background-image</td>
<td>把图像设置为背景。</td>
</tr>
<tr>
<td>background-position</td>
<td>设置背景图像的起始位置。</td>
</tr>
<tr>
<td>background-repeat</td>
<td>设置背景图像是否及如何重复。</td>
</tr>
</tbody></table>
<h5 id="四-文本格式"><a href="#四-文本格式" class="headerlink" title="四 . 文本格式"></a>四 . 文本格式</h5><ul>
<li>文本颜色color</li>
<li>文本对齐方式：text-align</li>
<li>文本修饰：text-decoration</li>
<li>文本转换：text-transform</li>
<li>文本缩进（指定第一行缩进）：text-indent</li>
<li>指定字符间的距离：letter-spacing（可正可负）</li>
<li>指定一个段落中行之间的空间：line-height</li>
<li>指定单词间的间距：word-spacing</li>
</ul>
<h2 id="一-CSS3的基本概念"><a href="#一-CSS3的基本概念" class="headerlink" title="一 . CSS3的基本概念"></a>一 . CSS3的基本概念</h2><ul>
<li>CSS 用于控制网页的样式和布局。而CSS3是CSS技术的升级版本，CSS3语言开发是朝着模块化发展的。</li>
<li>CSS3使用了层叠样式表技术，可以对网页布局、字体、颜色、背景灯效果做出控制。css3作为css的进阶版，拆分和增加了盒子模型、列表模块、语言模块 、背景边框 、文字特效 、多栏布局等等。CSS3的改变有很多，增加了文字特效，丰富了下划线样式，加入了圈重点的功能。在边框方面，有了更多的灵活性，可以更加轻松地操控渐变效果和动态效果等等。在文字效果方面，特意增加了投影。CSS3在兼容上做了很大的功夫，并且网络浏览器也还将继续支持CSS2，因此原来的代码不需要做太多的改变，只会变得更加地轻松。</li>
<li>css是指层叠样式表，解决内容与表现分离的问题</li>
<li>id选择器可为特有的id的html元素指定特定的样式，ID属性不要以数字开头，数字开头的ID在 Mozilla/Firefox 浏览器中不起作用。</li>
<li><em>不要在属性值与单位之间留有空格（如：”margin-left: 20 px” ），正确的写法是 “margin-left: 20px” 。</em></li>
</ul>
<h2 id="二-CSS3的新属性"><a href="#二-CSS3的新属性" class="headerlink" title="二 . CSS3的新属性"></a>二 . CSS3的新属性</h2><h4 id="1-边框border"><a href="#1-边框border" class="headerlink" title="1.边框border"></a>1.边框border</h4><ul>
<li>圆角边框：border-radius<ul>
<li>border-radius：左上 右上 右下 左下；</li>
</ul>
</li>
<li>阴影边框：border-shadow<ul>
<li>box-shadow: 右偏移量 下偏移量 模糊距离 阴影尺寸  颜色 内外阴影；(可同时加多个)</li>
<li><ul>
<li>h-shadow：必需，水平阴影的位置。允许负值</li>
<li>v-shadow：必需。垂直阴影的位置。允许负值。</li>
<li>blur：可选，模糊距离</li>
<li>spread：可选，阴影尺寸</li>
<li>color：颜色</li>
<li>insert：可选，将外部阴影（outset）改为内部阴影，外部阴影是默认值（不允许写）</li>
</ul>
</li>
</ul>
</li>
<li>图像边框（IE浏览器不支持）：border-image</li>
<li>对于 border-image，Safari 5 以及更老的版本需要前缀 -webkit-。Opera 支持 border-radius 和 box-shadow 属性，但是对于 border-image 需要前缀 -o-。</li>
</ul>
<h4 id="2-图片滤镜filter属性"><a href="#2-图片滤镜filter属性" class="headerlink" title="2.图片滤镜filter属性"></a>2.图片滤镜filter属性</h4><ul>
<li>为元素添加可视效果（如饱和度与模糊度）</li>
<li>img{ filter:grayscale(100%); //修改所有图片的颜色为100%灰度}</li>
<li>常用属性值<ul>
<li>filter:none | biur() | brightness() | contrast() | drop-shadow() | grayscale() | hue-rotate() | invert() | opacity()| saturate() | sepia() | url();</li>
</ul>
</li>
</ul>
<p><strong>提示:</strong> 使用空格分隔多个滤镜。</p>
<h2 id="Filter-函数"><a href="#Filter-函数" class="headerlink" title="Filter 函数"></a>Filter 函数</h2><p><strong>注意:</strong> 滤镜通常使用百分比 (如：75%), 当然也可以使用小数来表示 (如：0.75)。</p>
<table>
<thead>
<tr>
<th>Filter</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>默认值，没有效果。</td>
</tr>
<tr>
<td>blur(<em>px</em>)</td>
<td>给图像设置高斯模糊。”radius”一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起， 所以值越大越模糊； 如果没有设定值，则默认是0；这个参数可设置css长度值，但不接受百分比值。</td>
</tr>
<tr>
<td>brightness(<em>%</em>)</td>
<td>给图片应用一种线性乘法，使其看起来更亮或更暗。如果值是0%，图像会全黑。值是100%，则图像无变化。其他的值对应线性乘数效果。值超过100%也是可以的，图像会比原来更亮。如果没有设定值，默认是1。</td>
</tr>
<tr>
<td>contrast(<em>%</em>)</td>
<td>调整图像的对比度。值是0%的话，图像会全黑。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。</td>
</tr>
<tr>
<td>drop-shadow(<em>h-shadow v-shadow blur spread color</em>)</td>
<td>给图像设置一个阴影效果。阴影是合成在图像下面，可以有模糊度的，可以以特定颜色画出的遮罩图的偏移版本。 函数接受<shadow>(在CSS3背景中定义)类型的值，除了”inset”关键字是不允许的。该函数与已有的box-shadow box-shadow属性很相似；不同之处在于，通过滤镜，一些浏览器为了更好的性能会提供硬件加速。<code>&lt;shadow&gt;参数如下：```**&lt;offset-x&gt; &lt;offset-y&gt;** (必须)这是设置阴影偏移量的两个 &lt;length&gt;值. **&lt;offset-x&gt;** 设定水平方向距离. 负值会使阴影出现在元素左边. **&lt;offset-y&gt;**设定垂直距离.负值会使阴影出现在元素上方。查看**&lt;length&gt;**可能的单位. **如果两个值都是0**, 则阴影出现在元素正后面 (如果设置了</code><blur-radius> and/or <spread-radius>，会有模糊效果).``<strong><blur-radius></blur-radius></strong> (可选)这是第三个code&gt;<length>值. 值越大，越模糊，则阴影会变得更大更淡.不允许负值 若未设定，默认是0 (则阴影的边界很锐利).<strong><spread-radius></spread-radius></strong> (可选)这是第四个 <length>值. 正值会使阴影扩张和变大，负值会是阴影缩小.若未设定，默认是0 (阴影会与元素一样大小). 注意: Webkit, 以及一些其他浏览器 不支持第四个长度，如果加了也不会渲染。 <strong><color></color></strong> (可选)查看 <color>该值可能的关键字和标记。若未设定，颜色值基于浏览器。在Gecko (Firefox), Presto (Opera)和Trident (Internet Explorer)中， 会应用color<strong>color</strong>属性的值。另外, 如果颜色值省略，WebKit中阴影是透明的。`</color></length></length></spread-radius></blur-radius></shadow></td>
</tr>
<tr>
<td>grayscale(<em>%</em>)</td>
<td>将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0；</td>
</tr>
<tr>
<td>hue-rotate(<em>deg</em>)</td>
<td>给图像应用色相旋转。”angle”一值设定图像会被调整的色环角度值。值为0deg，则图像无变化。若值未设置，默认值是0deg。该值虽然没有最大值，超过360deg的值相当于又绕一圈。</td>
</tr>
<tr>
<td>invert(<em>%</em>)</td>
<td>反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。值在0%和100%之间，则是效果的线性乘子。 若值未设置，值默认是0。</td>
</tr>
<tr>
<td>opacity(<em>%</em>)</td>
<td>转化图像的透明程度。值定义转换的比例。值为0%则是完全透明，值为100%则图像无变化。值在0%和100%之间，则是效果的线性乘子，也相当于图像样本乘以数量。 若值未设置，值默认是1。该函数与已有的opacity属性很相似，不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。</td>
</tr>
<tr>
<td>saturate(<em>%</em>)</td>
<td>转换图像饱和度。值定义转换的比例。值为0%则是完全不饱和，值为100%则图像无变化。其他值，则是效果的线性乘子。超过100%的值是允许的，则有更高的饱和度。 若值未设置，值默认是1。</td>
</tr>
<tr>
<td>sepia(<em>%</em>)</td>
<td>将图像转换为深褐色。值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0；</td>
</tr>
<tr>
<td>url()</td>
<td>URL函数接受一个XML文件，该文件设置了 一个SVG滤镜，且可以包含一个锚点来指定一个具体的滤镜元素。例如：<code>filter: url(svg-url#element-id)</code></td>
</tr>
<tr>
<td>initial</td>
<td>设置属性为默认值，可参阅： <a href="https://www.w3cschool.cn/cssref/css-initial.html" target="_blank" rel="noopener">CSS initial 关键字</a></td>
</tr>
<tr>
<td>inherit</td>
<td>从父元素继承该属性，可参阅：<a href="https://www.w3cschool.cn/cssref/css-inherit.html" target="_blank" rel="noopener">CSS inherit 关键字</a></td>
</tr>
</tbody></table>
<h2 id="三-常见模型和样式表"><a href="#三-常见模型和样式表" class="headerlink" title="三 . 常见模型和样式表"></a>三 . 常见模型和样式表</h2><p><strong>行内元素只有左右边距，没有上下边距，指定padding值可能有bug</strong></p>
<h4 id="1-居中对齐汇总"><a href="#1-居中对齐汇总" class="headerlink" title="1.居中对齐汇总"></a>1.居中对齐汇总</h4><h5 id="1-1-水平居中对齐"><a href="#1-1-水平居中对齐" class="headerlink" title="1-1 . 水平居中对齐"></a>1-1 . 水平居中对齐</h5><h5 id="margin-0-auto"><a href="#margin-0-auto" class="headerlink" title="margin:0 auto;"></a>margin:0 auto;</h5><p>必须是块级元素，且给定了宽度</p>
<h5 id="text-align-center"><a href="#text-align-center" class="headerlink" title="text-align:center;"></a>text-align:center;</h5><p>父级元素是块级元素，自身是行内元素或者行内块元素</p>
<p><strong>width:内容宽；height：内容高；padding：盒宽减去内容宽再除以2；background-clip：content-box；</strong></p>
<p>利用padding和background-clip配合实现div的水平居中</p>
<p>.parent{margin:0 auto;width:200px;height:200px;background-color:red;}.children {width: 100px;height: 100px;padding: 50px;background-color: black;background-clip:content-box;/<em>居中的关键</em>/</p>
<h4 id="2-垂直居中"><a href="#2-垂直居中" class="headerlink" title="2 . 垂直居中"></a>2 . 垂直居中</h4><p><strong>line-height:盒子高</strong></p>
<p>自身或者父级元素必须有具体行高</p>
<p>position加translate（-50%，-50%），百分比以自身为基准,适合没固定大小的内容（min-width,max-height,overflow:scroll)</p>
<style> #ex3_container{ width:200px; height:200px; background-color:yellow; position:relative; } #ex3_content{ left:50%; top:50%; transform:translate(-50%,-50%); -webkit-transform:translate(-50%,-50%); background-color:gray; color:white; position:absolute; } </style>

<p><strong>绝对定位</strong></p>
<p>祖先容器：position：relative；</p>
<p>自身：height：***；position：absolute；margin：auto；top：0；left：0；</p>
<p><em>高度必须给出，建议加overflow：auto；防止内容溢出</em></p>
<h5 id="内容元素：position-fixed，z-index-999，记住父容器元素position-relative"><a href="#内容元素：position-fixed，z-index-999，记住父容器元素position-relative" class="headerlink" title="内容元素：position: fixed，z-index: 999，记住父容器元素position: relative **"></a>内容元素：position: fixed，z-index: 999，记住父容器元素position: relative **</h5><p>.Absolute-Center.is-Fixed { width: 50%; height: 50%; overflow: auto; margin: auto; position: fixed; top: 0; left: 0; bottom: 0; right: 0; z-index: 999;}</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><h5 id="1-相邻的垂直块级盒子，外边距会合并，且以最大的外边距为准"><a href="#1-相邻的垂直块级盒子，外边距会合并，且以最大的外边距为准" class="headerlink" title="1.相邻的垂直块级盒子，外边距会合并，且以最大的外边距为准"></a>1.相邻的垂直块级盒子，外边距会合并，且以最大的外边距为准</h5><h4 id="2-嵌套块元素垂直外边距的合并"><a href="#2-嵌套块元素垂直外边距的合并" class="headerlink" title="2.嵌套块元素垂直外边距的合并"></a>2.嵌套块元素垂直外边距的合并</h4><p>对于两个嵌套关系的块级元素，如果父级元素没有上内边距及边框，则父元素的上边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会合并</p>
<p>解决方法：</p>
<ul>
<li>可以为父级盒子加上1px的上边框或上内边距</li>
<li>可以为父元素添加overflow：hidden；</li>
</ul>
<h4 id="3-宽度属性width和高度属性仅适用于块级元素，对行内元素无效（img标签和input除外）"><a href="#3-宽度属性width和高度属性仅适用于块级元素，对行内元素无效（img标签和input除外）" class="headerlink" title="3.宽度属性width和高度属性仅适用于块级元素，对行内元素无效（img标签和input除外）"></a>3.宽度属性width和高度属性仅适用于块级元素，对行内元素无效（img标签和input除外）</h4><p>计算盒子模型总高度时，还应考虑上下两个盒子外边框合并问题</p>
<p>如果一个盒子没有给定宽度/高度或者继承父亲的宽度/高度，则padding不会影响本盒子的大小</p>
<p>内盒尺寸（元素实际大小）=width/height+padding+border</p>
<h4 id="4-盒子模型布局稳定性"><a href="#4-盒子模型布局稳定性" class="headerlink" title="4.盒子模型布局稳定性"></a>4.盒子模型布局稳定性</h4><p>按照优先使用宽度（width），内边距（padding）外边距（margin）</p>
<p>width &gt; padding &gt; margin</p>
<p>原因：</p>
<ul>
<li>margin会有外边距合并问题还有ie下面的margin加倍的bug，所以最后使用</li>
<li>padding 会影响盒子的大小，需要进行加减计算，比较麻烦，其次使用</li>
<li>width没有什么问题</li>
</ul>
<h4 id="5-CSS盒模型"><a href="#5-CSS盒模型" class="headerlink" title="5. CSS盒模型"></a>5. CSS盒模型</h4><p>CSS3中可以通过box-sizing来指定盒模型，即指定为content-box，border-box，这样我们在计算盒子大小的方式就发生了变化</p>
<p>可分为以下两种情况：</p>
<ul>
<li><p>box-sizing : content-box ;盒子大小为 width+padding +border，content-border指事默认值，其让元素维持W3C的标准Box Mode</p>
</li>
<li><p>box-sizing ： border-box；盒子大小就是width，即padding和border是包含在width里面的，新添属性</p>
<p><strong>注意</strong>：上面的标注的width指的是CSS属性里设置的width：length；content的值会自动调整的</p>
</li>
</ul>
<h4 id="6-CSS层叠样式"><a href="#6-CSS层叠样式" class="headerlink" title="6 . CSS层叠样式"></a>6 . CSS层叠样式</h4><ul>
<li>样式冲突，遵循就近原则。哪个样式离结构近，就执行哪个样式</li>
<li>样式不冲突不会层叠</li>
</ul>
<h4 id="7-CSS继承性"><a href="#7-CSS继承性" class="headerlink" title="7.CSS继承性"></a>7.CSS继承性</h4><p>恰当地使用继承可以简化代码，子元素可以继承父元素的样式（text-，font-，line-，这些元素开头的都可以继承，以及color属性）</p>
<h4 id="8-CSS优先级"><a href="#8-CSS优先级" class="headerlink" title="8.CSS优先级"></a>8.CSS优先级</h4><p>定义css样式时，经常出现两个或更多规则应用在同一元素上，这时就出现优先级问题</p>
<p>继承样式的权重为0.即在嵌套结构中，不管父元素权重多大，被子元素继承时，他的权重都为0，也就是说子元素定义的样式会覆盖继承来的样式，行内样式优先，应用style属性的元素，其行内样式的权重非常高，远大于100.</p>
<p>权重相同时遵循就近原则。！important拥有最大的权重</p>
<h4 id="9-浮动Float"><a href="#9-浮动Float" class="headerlink" title="9.浮动Float"></a>9.浮动Float</h4><ul>
<li><p>浮动首先包含块的概念（包裹）。也就是说，浮动的元素总是找离他最近的父级元素对齐，但是不会超过内边距的范围</p>
</li>
<li><p>浮动元素排列元素，跟上一个元素（块级）有关。如果上一个元素有浮动，则A元素顶部会和上一个元素的顶部对齐；如果上一个元素是标准流，则A元素的顶部会和上一个元素的底部对齐。</p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Grid布局" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/26/Grid布局/" class="article-date">
      <time datetime="2020-03-26T03:26:54.000Z" itemprop="datePublished">2020-03-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/Grid布局/">Grid布局</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="一-Grid布局"><a href="#一-Grid布局" class="headerlink" title="一 . Grid布局"></a>一 . Grid布局</h2><ul>
<li>CSS Grid 布局是CSS中最强大的布局系统，是一个二维布局系统（flexbox是一维布局系统），也就意味着它可以同时处理行和列</li>
<li>grid的目标是完全改变我们基于网格的用户界面的布局方式</li>
<li>Grid布局由两个核心组成部分是wrapper（父元素）和item（子元素）。wrapper是实际的grid（网格），items是grid（网格内的内容）</li>
</ul>
<h4 id="1-网格容器"><a href="#1-网格容器" class="headerlink" title="1 . 网格容器"></a><strong>1 . 网格容器</strong></h4><ul>
<li>要把wrapper元素变成grid，只要简单将其display设置为grid即可。应用 <code>display: grid</code> 的元素。这是所有 网格项（grid item）的直接父级元素。</li>
<li>属性<ul>
<li>display：将网格定义为网格容器，并为其内容建立新的网格格式上下文。grid （生成一个块级网格） ；inline-grid （内联网格）</li>
</ul>
</li>
</ul>
<h4 id="2-网格项"><a href="#2-网格项" class="headerlink" title="2 .网格项"></a>2 .<strong>网格项</strong></h4><ul>
<li>是网格容器的直接子元素（注意：通过嵌套元素（也称为子网格，即 subgrid ）向下传递网格参数的能力已移至 CSS Grid 规范的 Level 2 版本(详情访问 <a href="https://www.w3.org/TR/css-grid-2/#subgrids" target="_blank" rel="noopener">https://www.w3.org/TR/css-grid-2/#subgrids</a>）</li>
</ul>
<h4 id="3-网格线"><a href="#3-网格线" class="headerlink" title="3.网格线"></a>3.<strong>网格线</strong></h4><ul>
<li>构成网格结构的分界线。它们既可以是垂直的（“列网格线(column grid lines)”），也可以是水平的（“行网格线(row grid lines)”），并位于行或列的任一侧。例如，这里的黄线就是一条列网格线。</li>
<li><img src="https://www.html.cn/newimg88/2018/12/terms-grid-line.svg" alt="网格线(Grid Line)"></li>
</ul>
<h4 id="4-网格轨道"><a href="#4-网格轨道" class="headerlink" title="4.网格轨道"></a>4.<strong>网格轨道</strong></h4><ul>
<li>两条相邻网格线之间的空间。你可以把它们想象成网格的列或行。下图是第二条和第三条 行网格线 之间的 网格轨道(Grid Track)。</li>
<li><img src="https://www.html.cn/newimg88/2018/12/terms-grid-track.svg" alt="网格轨道(Grid Track)"></li>
</ul>
<h4 id="5-网格单元格"><a href="#5-网格单元格" class="headerlink" title="5.网格单元格"></a>5.<strong>网格单元格</strong></h4><ul>
<li>两个相邻的行和两个相邻的列网格线之间的空间。这是 Grid(网格) 系统的一个“单元”。</li>
</ul>
<h4 id="6-网格区域-grid-template-areas"><a href="#6-网格区域-grid-template-areas" class="headerlink" title="6 .网格区域(grid-template-areas)"></a>6 .<strong>网格区域</strong>(grid-template-areas)</h4><ul>
<li><p>4条网格线包围的总空间。一个 网格区域(Grid Area) 可以由任意数量的 网格单元格(Grid Cell) 组成。</p>
</li>
<li><p>网格单元格可以认为是网格线行为1和2，以及列网格线1和2之间的网格区域</p>
</li>
<li><p>通过引用grid-area属性指定的网格区域名称来定义网格模板，重复网格区域的名称导致内容跨越这些单元格。一个点号（.）代表空单元格。这个语法本身可视作网格的可视化结构。</p>
<ul>
<li><p><grid-area-name>:由网格项的grid-area指定网格区域名称</grid-area-name></p>
</li>
<li><p>none：不定义网格区域</p>
</li>
<li><p>.container{  grid-template-columns: 50px 50px 50px 50px;  grid-template-rows: auto;  grid-template-areas:     “header header header header”    “main main . sidebar”    “footer footer footer footer”; }</p>
</li>
<li><p><img src="https://www.html.cn/newimg88/2018/12/dddgrid-template-areas.svg" alt="网格区域名称模板"></p>
</li>
<li><h5 id="注意你不能-用这个语法来命名网格线，只是命名-网格区域"><a href="#注意你不能-用这个语法来命名网格线，只是命名-网格区域" class="headerlink" title="注意你不能 用这个语法来命名网格线，只是命名 网格区域"></a><strong>注意你不能 用这个语法来命名网格线，只是命名 网格区域</strong></h5><ul>
<li>当你使用这种语法时，区域两端的网格线实际上会自动命名。如果你的网格区域的名字是 <strong>foo</strong>，该区域的起始行网格线 和 起始列网格线 的名称将为 <strong>foo-start</strong>，而最后一条行网格线 和 最后一条列网格线 的名称将为 <strong>foo-end</strong>。这意味着某些网格线可能有多个名字，如上例中最左边的网格线，它将有三个名称：header-start，main-start 和 footer-start 。</li>
</ul>
</li>
</ul>
</li>
<li><p>columns（列）和rows（行）</p>
<ul>
<li><p>为了使其成为网格的二维容器，需要定义行和列。</p>
</li>
<li><p>要定位和调整items（子元素）大小，我们将使用grid-column和grid-row属性来设置。使用空格分隔的值列表，用来定义网格的列和行。这些值表示 网格轨道(Grid Track) 大小，它们之间的空格表示网格线。</p>
<ul>
<li><p>track-size： 可以是长度值，百分比，或者等份网格容器中可用空间（使用 <code>fr</code> 单位）     line-name`：你可以选择的任意名称</p>
</li>
<li><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...;</span><br><span class="line"> grid-template-rows: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义100px宽的3列  grid-template-columns ：100px  100px  100px;</p>
</li>
<li><p>定义50px高的两行   grid-template-rows : 50px  50px；</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns: 40px 50px auto 50px 40px;</span><br><span class="line"> grid-template-rows: 25% 100px auto;</span><br></pre></td></tr></table></figure>
</li>
<li><p><img src="https://www.html.cn/newimg88/2018/12/template-columns-rows-01.svg" alt="网格线名称"></p>
</li>
<li><p>.wrapper{display: grid；grid-template-columns: 100px 100px 100px;grid-template-rows: 100px 100px 100px；}</p>
</li>
<li><p>如果你的定义包含多个重复值，则可以使用 <code>repeat()</code> 表示法来简化定义：  grid-template-columns:repeate(3,20px [col-start]);</p>
</li>
<li><p>你也可以明确的指定网格线(Grid Line)名称   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];</span><br><span class="line">  grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line]</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果多行共享相同的名称，则可通过网格线名称和计数来引用它们 grid-template-start: col-start 2;</p>
</li>
<li><p>fr单元允许你用等分网格容器剩余可用空间来设置 网格轨道(Grid Track) 的大小 。例如grid-temp-columns : 1fr  1fr  1fr ;该代码会将每个网格项设置为网格容器宽度的三分之一：</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>放置items（子元素）</p>
<ul>
<li>设置子元素的大小可通过网格线来设置</li>
<li><ul>
<li>.item1{grid-column-start :1;grid-column-end :4;}</li>
<li>简写式 .item1{grid-column: 1 / 4 ;}</li>
<li>表示item1占据从第一条网格线开始，到第四条网格线结束（<strong>注意</strong>：3列有4条网格线）<img src="https://www.html.cn/newimg88/2017/12/1_l-adYpQCGve7W6DWY949pw.png" alt="Grid 布局，列网格线"></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.item1 &#123;</span><br><span class="line">    grid-column-start: 1;</span><br><span class="line">    grid-column-end: 3;</span><br><span class="line">&#125;</span><br><span class="line">.item3 &#123;</span><br><span class="line">    grid-row-start: 2;</span><br><span class="line">    grid-row-end: 4;</span><br><span class="line">&#125;</span><br><span class="line">.item4 &#123;</span><br><span class="line">    grid-column-start: 2;</span><br><span class="line">    grid-column-end: 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.html.cn/newimg88/2017/12/1_QDSybpxjXSat6UtoHgUapQ.png" alt="Grid 布局"></p>
<h4 id="7-简写属性grid-template"><a href="#7-简写属性grid-template" class="headerlink" title="7. 简写属性grid-template"></a>7. 简写属性grid-template</h4><ul>
<li>用于定义rows , columns , areas 简写属性   grid-template: none | <grid-template-rows> / <grid-template-columns>;</grid-template-columns></grid-template-rows></li>
<li><code>none</code>：将所有三个属性设置为其初始值</li>
<li><code>&lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;</code>：将 grid-template-columns 和 grid-template-rows`设置为相应地特定的值，并且设置grid-template-areas为none</li>
</ul>
<p>游戏：</p>
<p>如果你觉得同时输入<code>grid-column</code>和<code>grid-row</code>也很复杂，我们还有另一种缩写。<code>grid-area</code>属性接受4个由’/‘分开的值：<code>grid-row-start</code>, <code>grid-column-start</code>, <code>grid-row-end</code>, 最后是<code>grid-column-end</code>。</p>
<p>举个例子如下所示：<code>grid-area: 1 / 1 / 3 / 6;</code>。</p>
<p>如果我们有很多个网格项呢？你可以任意覆盖它们不用有任何担心。用<code>grid-area</code>定义第二个网格项为所有未浇水的胡萝卜浇水。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 陈楚吟
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
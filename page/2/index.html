<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="陈楚吟">


    
    


<meta name="description" content="将学习技术点汇总">
<meta name="keywords" content="write myBlog">
<meta property="og:type" content="website">
<meta property="og:title" content="Nikita">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Nikita">
<meta property="og:description" content="将学习技术点汇总">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nikita">
<meta name="twitter:description" content="将学习技术点汇总">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Nikita" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Nikita</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">陈楚吟</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不负韶华</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">陈楚吟</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">陈楚吟</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不负韶华</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-typescript" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/17/typescript/" class="article-date">
      <time datetime="2020-06-17T07:35:59.000Z" itemprop="datePublished">2020-06-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/typescript/">typescript</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="ts基础"><a href="#ts基础" class="headerlink" title="ts基础"></a>ts基础</h4><h6 id="vscode配置自动编译ts"><a href="#vscode配置自动编译ts" class="headerlink" title="vscode配置自动编译ts"></a>vscode配置自动编译ts</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tsc --init  //生成tsconfig.json文件</span><br><span class="line">//在tsconfig.json文件 改 &quot;outDir&quot;: &quot;./js&quot;</span><br><span class="line">在导航栏找到  任务--&gt; 监视 tsconfig.json</span><br></pre></td></tr></table></figure>

<h6 id="hbuild配置自动编译ts"><a href="#hbuild配置自动编译ts" class="headerlink" title="hbuild配置自动编译ts"></a>hbuild配置自动编译ts</h6><ol>
<li>在最上面菜单栏，点击工具——插件安装。</li>
<li>点击下方浏览Eclipse插件市场，搜索typescript插件进行安装</li>
<li>安装完后重启编译器，点击菜单栏工具——选项，选择编译ts文件</li>
<li>在你的项目上右键点击——配置——Enable TypeScript Builder，之后你再保存</li>
<li>.ts文件时会自动保存在当前目录编译出对应的.js文件</li>
</ol>
<h6 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h6><p>布尔类型(boolean)</p>
<p>数字类型(number)</p>
<p>字符串类型(string)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var str:string = &apos;hello&apos;;</span><br></pre></td></tr></table></figure>

<p>数组类型(array)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr:Array&lt;number&gt; = [11,22,33];  //全是数字的数组</span><br><span class="line">var arr:number[] = [11,22,33];</span><br></pre></td></tr></table></figure>

<p>元组类型(tuple)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//元组类型属于数组类型用于给数组中每个位置指定类型</span><br><span class="line">let arr:[number,string] = [123,&apos;this is ts&apos;];</span><br></pre></td></tr></table></figure>

<p>枚举类型(enum)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum 枚举名&#123;</span><br><span class="line">	标识符[=整型常数]，</span><br><span class="line">	标识符[=整型常数]，</span><br><span class="line">	...</span><br><span class="line">	标识符[=整型常数]，</span><br><span class="line">&#125;;</span><br><span class="line">enum Flag &#123; success=1,error=2 &#125;;</span><br><span class="line">let s:Flag = Flag.success;</span><br><span class="line">console.log(s);   //1</span><br><span class="line">//如果标识符没有赋值，它的值就是下标。</span><br></pre></td></tr></table></figure>

<p>任意类型(any)</p>
<p>null 和 undefined</p>
<p>void类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//一般用于定义方法没有返回值</span><br><span class="line">function run():void&#123;</span><br><span class="line">	console.log(&apos;ksdkl&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>never类型</p>
<ul>
<li>never类型是其他类型（包括null和undefined）的子类型，代表从不会出现的值。这意味着声明never的变量只能被never类型所赋值。</li>
</ul>
<h6 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function run():string&#123;</span><br><span class="line">	//必须返回string类型的值</span><br><span class="line">&#125;</span><br><span class="line">//匿名函数</span><br><span class="line">let fun2 = function():number&#123;</span><br><span class="line">	//返回数字类型的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>es5里面方法的实参和形参可以不一样，但是ts中必须一样，如果不一样就需要配置可选参数。（加个 ? )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getInfo(name:string,age?:number):string&#123;</span><br><span class="line">	if(age)&#123;</span><br><span class="line">		return `$&#123;name&#125; --- $&#123;age&#125;`;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		return `$&#123;name&#125; --- 年龄保密`</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(getInfo(&apos;zhangsan&apos;));   //zhangsan --- 年龄保密</span><br></pre></td></tr></table></figure>

<h6 id="ts的重载"><a href="#ts的重载" class="headerlink" title="ts的重载"></a>ts的重载</h6><ul>
<li>java中的方法的重载，重载指的是两个或两个以上同名函数，但他们的参数不一样，这时会出现函数重载的情况。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getInfo(name:string):string;</span><br><span class="line">function getInfo(age:number):string;</span><br><span class="line">function getInfo(str:any):any&#123;</span><br><span class="line">	if(typeof str === &apos;string&apos;)&#123;</span><br><span class="line">		return &quot;我叫：&quot; + str;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		return &quot;我的年龄是&quot; + str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="对象继承"><a href="#对象继承" class="headerlink" title="对象继承"></a>对象继承</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//es5的类</span><br><span class="line">function Person()&#123;</span><br><span class="line">	this.name = &apos;张三&apos;;</span><br><span class="line">	this.age = 20;</span><br><span class="line">	this.run = function()&#123;</span><br><span class="line">		alert(this.name);  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex = &apos;男&apos;;</span><br><span class="line">Person.prototype.work = function()&#123;</span><br><span class="line">	alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">//web类继承Person类 原型链 + 对象冒充的组合继承模式</span><br><span class="line">function Web()&#123;</span><br><span class="line">	Person.call(this);  //对象冒充实现继承</span><br><span class="line">&#125;</span><br><span class="line">let w = new Web();</span><br><span class="line">w.run();  //对象冒充可以继承构造函数里面的属性和方法</span><br><span class="line">w.work();   //报错，对象冒充不可以继承原型链上的属性和方法</span><br><span class="line"></span><br><span class="line">function Web()&#123;&#125;</span><br><span class="line">Web.prototype = new Person();  //原型链实现继承</span><br><span class="line">let w = new Web();</span><br><span class="line">//原型链实现继承：可以继承构造函数里面的属性和方法，也可以继承原型链上的属性和方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//es6的类</span><br><span class="line">class Person&#123;</span><br><span class="line">	name:string;  //属性 前面省略了public关键字</span><br><span class="line">	constructor(a:string)&#123; </span><br><span class="line">		this.name = n;</span><br><span class="line">	&#125;</span><br><span class="line">	run():void&#123;</span><br><span class="line">		alert(this.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = new Person(&apos;张三&apos;);</span><br><span class="line">p.run();</span><br></pre></td></tr></table></figure>

<h6 id="ts接口"><a href="#ts接口" class="headerlink" title="ts接口"></a>ts接口</h6><ul>
<li>接口的作用：在面向对象编程中，接口是一种规范的定义，它定义了行为和动作的规范</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//封装请求的接口</span><br><span class="line">interface Config&#123;</span><br><span class="line">	type:string;</span><br><span class="line">	url: string;</span><br><span class="line">	data?: string;</span><br><span class="line">	dataType: string;</span><br><span class="line">&#125;</span><br><span class="line">function ajax(config:Config)&#123;</span><br><span class="line">	let xml = new XMLHttpResquest();</span><br><span class="line">	xhr.open(config.type,config.url,true);   //true表示异步请求</span><br><span class="line">	xhr.send(config.data);</span><br><span class="line">	xhr.onreadystatechange = function()&#123;</span><br><span class="line">		if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class="line">			console.log(&apos;success&apos;);</span><br><span class="line">			if(config.dataType == &apos;json&apos;)&#123;</span><br><span class="line">				JSON.parse(xhr.responseText);</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				console.log(xhr.responseText);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(&#123;</span><br><span class="line">	type: &apos;get&apos;,</span><br><span class="line">	data: &apos;name=zhangsan&apos;,</span><br><span class="line">	url: &apos;http://a.itying.com/api/productlist&apos;,</span><br><span class="line">	dataType: &apos;json&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>函数类型接口</strong></p>
<ul>
<li>对方法传入的参数以及返回值进行约束。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//加密的函数类型接口</span><br><span class="line">interface encrypt&#123;</span><br><span class="line">	(key:string,value:string):string;</span><br><span class="line">&#125;</span><br><span class="line">let md5:encrypt = function(key:string,value:string):string&#123;</span><br><span class="line">	return key + value;</span><br><span class="line">&#125;</span><br><span class="line">console.log(md5(&apos;name&apos;,&apos;zhangsan&apos;));</span><br></pre></td></tr></table></figure>

<h6 id="ts的实现和继承"><a href="#ts的实现和继承" class="headerlink" title="ts的实现和继承"></a>ts的实现和继承</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">	eat():void;</span><br><span class="line">&#125;</span><br><span class="line">interface Person extends Animal&#123;</span><br><span class="line">	work():void;</span><br><span class="line">&#125;</span><br><span class="line">class Web implements Person&#123;</span><br><span class="line">	public name:string;</span><br><span class="line">	constructor(name:string)&#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	eat()&#123;&#125;</span><br><span class="line">	work()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//web继承programmer，实现person</span><br><span class="line">class Programmer&#123;</span><br><span class="line">	public name:string;</span><br><span class="line">	constructor(name:string)&#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	coding(code:string)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Web extends Programmer implements Person&#123;</span><br><span class="line">	constructor(name:string)&#123;&#125;</span><br><span class="line">	eat()&#123;&#125;</span><br><span class="line">	work()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="ts泛型"><a href="#ts泛型" class="headerlink" title="ts泛型"></a>ts泛型</h6><ul>
<li>泛型：在软件工程中，我们不仅要创建一致的良好的API，也要考虑其可重用性，组件不仅能够支持大哥钱的数据类型，同时也能能支持未来的数据类型，这在创建大型系统时为你提供灵活的功能。</li>
<li>在像C#和java这样的语言中，可以使用泛型来创建可重用地组件，一个组件支持多种类型的数据，这样用户就可以以自己的数据来使用组件。</li>
<li>泛型就是解决类 接口 方法的复用性，以及对不特定数据类型的支持。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//使用any相当于放弃了数据类型检查</span><br><span class="line">function getData(value:any):any&#123;</span><br><span class="line">	return value;</span><br><span class="line">&#125;</span><br><span class="line">//T表示泛型，具体什么类型是调用这个方法时决定的，可支持不特定类型的数据类型。可支持传入参数与返回参数的类型一致。</span><br><span class="line">function getData&lt;T&gt;(value:T):T&#123;</span><br><span class="line">	return value;</span><br><span class="line">&#125;</span><br><span class="line">getDate&lt;number&gt;(123);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//操作数据库的泛型类</span><br><span class="line">class Mysql&lt;T&gt;&#123;</span><br><span class="line">	add(info:T):boolean&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ArticleCate&#123;</span><br><span class="line">	title: string|undefined;</span><br><span class="line">	desc: string|undefined;</span><br><span class="line">	status: number|undefined;</span><br><span class="line">	constructor(params:&#123;</span><br><span class="line">		title: string|undefined;</span><br><span class="line">		desc: string|undefined;</span><br><span class="line">		status?: number|undefined;</span><br><span class="line">	&#125;)&#123;</span><br><span class="line">		this.title = params.title</span><br><span class="line">		this.deac = params.desc;</span><br><span class="line">		this.status = params.status;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var a = new ArticleCate(&#123;</span><br><span class="line">	title: &apos;分类&apos;,</span><br><span class="line">	desc: &apos;111&apos;,</span><br><span class="line">	status: 1</span><br><span class="line">&#125;)</span><br><span class="line">//类当作参数的泛型类</span><br><span class="line">var Db = new MySqlDb&lt;ArticleCate&gt;();</span><br><span class="line">Db.add(a);</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-jquery" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/17/jquery/" class="article-date">
      <time datetime="2020-06-17T07:29:38.000Z" itemprop="datePublished">2020-06-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/jquery/">jquery</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>jquery对象是一个包含所有匹配的dom元素的伪数组对象。</strong></p>
<h1 id="js-加载时间线"><a href="#js-加载时间线" class="headerlink" title="js 加载时间线"></a><a href="https://www.cnblogs.com/wenlv88/articles/9932919.html" target="_blank" rel="noopener">js 加载时间线</a></h1><p>1、创建document对象，开始<strong>解析</strong>web页面。创建HTMLHtmlElement对象，添加到document中。这个阶段document.readyState = ‘loading’；</p>
<p>2、遇到link外部css，创建线程加载，并继续解析文档。<strong>并发；</strong></p>
<p>3、遇到script外部js，并且没有设置async、defer，浏览器创建线程加载，并<strong>阻塞</strong>，等待js加载完成并执行该脚本，然后继续解析文档。<strong>js拥有修改dom的能力</strong>–&gt;domcument.write；</p>
<p>4、遇到script外部js，并且设置有async、defter，浏览器创建线程加载，并继续解析文档；</p>
<p>　　defer属性设置后，表示加载script外部js和解析html页面是异步，并且等到html解析完成再执行js解析后的代码；</p>
<p>　　async属性设置后，表示加载script外部js和解析html页面是异步，但是当js解析完成，立刻执行它，此时html解析是<strong>被阻塞</strong>的；</p>
<p>document.createElement(‘script’)的方式动态插入script元素来模拟async属性，实现脚本异步加载和执行；</p>
<p>5、遇到img等，浏览器创建线程加载，并继续解析文档。<strong>并发；</strong></p>
<p>6、当文档解析完成，document.readyState = ‘interactive’；</p>
<p>7、文档解析完成后，所有设置有defer的脚本会按照顺序执行（注意与async的不同）；</p>
<p>8、document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，<strong>转化为事件驱动阶段；</strong></p>
<p>9、当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’，window对象触发load事件；</p>
<p>10、从此，以异步响应方式处理用户输入、网络事件等。</p>
<h1 id="jQeury"><a href="#jQeury" class="headerlink" title="jQeury"></a>jQeury</h1><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络上的内容分发网络，依靠部署在各边缘服务器，通过中心平台的负载均衡，内容分发，调度等功能模块，使用户就近获取所需的内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术在于内容存储和分发技术。</p>
<p>使用Google的CDN</p>
<p>src=”<a href="http://ajax.googleapis.com/ajax/libs/jquery/1.4.0/jquery.min.js&quot;" target="_blank" rel="noopener">http://ajax.googleapis.com/ajax/libs/jquery/1.4.0/jquery.min.js&quot;</a></p>
<p>使用Microsoft的CDN</p>
<p>src=”<a href="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.mim.js&quot;" target="_blank" rel="noopener">http://ajax.microsoft.com/ajax/jquery/jquery-1.4.mim.js&quot;</a></p>
<p>如果您不希望下载并存放 jQuery，那么也可以通过 CDN（内容分发网络） 引用它。</p>
<p>百度、又拍云、新浪、谷歌和微软的服务器都存有 jQuery 。</p>
<p>如果你的站点用户是国内的，建议使用百度、又拍云、新浪等国内CDN地址，如果你站点用户是国外的可以使用谷歌和微软。</p>
<p>使用百度，又拍云，新浪，谷歌或微软的jQuery的一大优势：</p>
<p>当用户在访问其他站点时，已经从百度，又拍云，新浪，谷歌或1微软加载过jQuery，所以当他们访问你的站点时，会从缓存中加载jQuery,这样就减少了加载时间。同时，大多数CDN都可以确保当用户向其请求文件时，会从离用户最近的服务器上访问响应，这样也可以提高加载速度</p>
<p>$(document).ready(function(){//jQuery代码})；</p>
<p>这是为了防止文档未完全加载之前就执行jQuery代码，可能会失败</p>
<table>
<thead>
<tr>
<th align="left">语法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$(“*”)</td>
<td align="left">选取所有元素</td>
</tr>
<tr>
<td align="left">$(this)</td>
<td align="left">选取当前 HTML 元素</td>
</tr>
<tr>
<td align="left">$(“p.intro”)</td>
<td align="left">选取 class 为 intro 的 <p> 元素</p></td>
</tr>
<tr>
<td align="left">$(“p:first”)</td>
<td align="left">选取第一个 <p> 元素</p></td>
</tr>
<tr>
<td align="left">$(“ul li:first”)</td>
<td align="left">选取第一个 <ul> 元素的第一个 <li> 元素</li></ul></td>
</tr>
<tr>
<td align="left">$(“ul li:first-child”)</td>
<td align="left">选取每个 <ul> 元素的第一个 <li> 元素</li></ul></td>
</tr>
<tr>
<td align="left">$(“[href]”)</td>
<td align="left">选取带有 href 属性的元素</td>
</tr>
<tr>
<td align="left">$(“a[target=’_blank’]”)</td>
<td align="left">选取所有 target 属性值等于 “_blank” 的 <a> 元素</a></td>
</tr>
<tr>
<td align="left">$(“a[target!=’_blank’]”)</td>
<td align="left">选取所有 target 属性值不等于 “_blank” 的 <a> 元素</a></td>
</tr>
<tr>
<td align="left">$(“:button”)</td>
<td align="left">选取所有 type=”button” 的 <input> 元素 和 <button> 元素</button></td>
</tr>
<tr>
<td align="left">$(“tr:even”)</td>
<td align="left">选取偶数位置的 </td></tr><tr> 元素
</tr>
<tr>
<td align="left">$(“tr:odd”)</td>
<td align="left">选取奇数位置的 </td></tr><tr> 元素
</tr>
</tbody></table>
<p>常见 DOM 事件：</p>
<table>
<thead>
<tr>
<th align="left">鼠标事件</th>
<th align="left">键盘事件</th>
<th align="left">表单事件</th>
<th align="left">文档/窗口事件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">click</td>
<td align="left">keypress</td>
<td align="left">submit</td>
<td align="left">load</td>
</tr>
<tr>
<td align="left">dblclick</td>
<td align="left">keydown</td>
<td align="left">change</td>
<td align="left">resize</td>
</tr>
<tr>
<td align="left">mouseenter</td>
<td align="left">keyup</td>
<td align="left">focus</td>
<td align="left">scroll</td>
</tr>
<tr>
<td align="left">mouseleave</td>
<td align="left"></td>
<td align="left">blur</td>
<td align="left">unload</td>
</tr>
</tbody></table>
<h4 id="基本行为"><a href="#基本行为" class="headerlink" title="基本行为"></a>基本行为</h4><ul>
<li>length：包含dom元素个数</li>
<li>[index]/get(index)：得到对应位置的DOM元素</li>
<li>each()：遍历包含所有的DOM元素</li>
<li>index():得到所在兄弟元素中的下标</li>
</ul>
<h6 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h6><ul>
<li><p>多个过滤器不是同时执行的，而是依次执行的。</p>
<p>$(‘li:gt(0):lt(3)’).css(‘background’,’red’)      下标是 1  2  3变底色</p>
<p>$(‘li:lt(3):gt(0)’).css(‘background’,’red’)       下标是1  2 变底色</p>
</li>
</ul>
<h6 id="mouseover与mouseenter区别"><a href="#mouseover与mouseenter区别" class="headerlink" title="mouseover与mouseenter区别"></a>mouseover与mouseenter区别</h6><ul>
<li>mouseover：在移入子元素时才会触发，对应mouseout</li>
<li>mouseenter：只在移入当前元素才触发，对应mouseleave</li>
<li>hover（）使用的是mouseenter与mouseleave</li>
</ul>
<h4 id="事件委托（委派-代理）"><a href="#事件委托（委派-代理）" class="headerlink" title="事件委托（委派/代理）"></a>事件委托（委派/代理）</h4><ul>
<li>将多个元素（li）的事件监听委托给父辈元素上（ul）处理。</li>
<li>监听回调是加在父辈元素上</li>
<li>当操作任何一个子元素时（li），事件会冒泡到父辈元素上（ul）</li>
<li>父辈元素不会直接处理事件，而是通过event.target得到发生事件的子元素（li），通过这个子元素调用事件回调函数。</li>
<li>$(‘ul’).delegate(‘li’,’click’,function(){})</li>
<li>委托2方<ul>
<li>委托方：业主   li</li>
<li>被委托方     中介   ul</li>
</ul>
</li>
<li>好处<ul>
<li>新添加的子元素自动有事件响应处理。</li>
<li>减少事件监听的数量 ： n==&gt;1</li>
</ul>
</li>
<li>API<ul>
<li>设置事件委托：$(parentSelector).delegate(childrenSelector,eventName,callback)</li>
<li>移出事件委托：$(parentSlector).undelegate(eventName)</li>
</ul>
</li>
</ul>
<h2 id="比较keypress、keydown与keyup"><a href="#比较keypress、keydown与keyup" class="headerlink" title="比较keypress、keydown与keyup"></a>比较keypress、keydown与keyup</h2><ul>
<li>keydown：在键盘上按下某键时发生，一直按着则会不断触发（opera浏览器除外），它返回的是键盘代码;</li>
<li>keypress：在键盘上按下一个按键，并产生一个字符时发生, 返回ASCII码。注意: shift、alt、ctrl等键按下并不会产生字符，所以监听无效，换句话说，只有按下能在屏幕上输出字符的按键时keypress事件才会触发。若一直按着某按键则会不断触发。</li>
<li>keyup：用户松开某一个按键时触发，与keydown相对，返回键盘代码.</li>
</ul>
<p>$(<em>selector</em>).hide(<em>speed,callback</em>);<br>$(<em>selector</em>).show(<em>speed,callback</em>);</p>
<p>$(selector).toggle(speed,callback);  //切换hide（）和show（）方法</p>
<p>可选的 speed 参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast” 或毫秒。</p>
<p>可选的 callback 参数是 toggle() 方法完成后所执行的函数名称。</p>
<p>可选的 callback 参数，具有以下三点说明：</p>
<ol>
<li>$(selector)选中的元素的个数为n个，则callback函数会执行n次</li>
<li>callback函数名后加括号，会立刻执行函数体，而不是等到显示/隐藏完成后才执行</li>
<li>callback既可以是函数名，也可以是匿名函数</li>
</ol>
<p>在在jQuery中可以通过四个方法来实现元素的淡入淡出，这四个方法分别是：fadeIn()、fadeOut()、fadeToggle() 以及 fadeTo()</p>
<p>$(document).ready(function(){<br>  $(“button”).click(function(){<br>    $(“#div1”).fadeIn();<br>    $(“#div2”).fadeIn(“slow”);<br>    $(“#div3”).fadeIn(3000);<br>  });<br>});</p>
<p>jQuery fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间）。</p>
<p>$(<em>selector</em>).fadeTo(<em>speed,opacity,callback</em>);</p>
<p>jQuery slideDown() 方法用于向下滑动元素。</p>
<p>$(<em>selector</em>).slideDown(<em>speed,callback</em>);</p>
<h2 id="jQuery-slideToggle-方法"><a href="#jQuery-slideToggle-方法" class="headerlink" title="jQuery slideToggle() 方法"></a>jQuery slideToggle() 方法</h2><p>jQuery slideToggle() 方法可以在 slideDown() 与 slideUp() 方法之间进行切换。</p>
<p>如果元素向下滑动，则 slideToggle() 可向上滑动它们。</p>
<p>如果元素向上滑动，则 slideToggle() 可向下滑动它们。</p>
<p> $(<em>selector</em>).animate({<em>params</em>}<em>,speed,callback</em>);</p>
<p>必需的 params 参数定义形成动画的 CSS 属性。</p>
<p>可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。</p>
<p>可选的 callback 参数是动画完成后所执行的函数名称。</p>
<p>默认情况下，所有的 HTML 元素有一个静态的位置，且是不可移动的。 如果需要改变为，我们需要将元素的 position 属性设置为 relative, fixed, 或 absolute!</p>
<p><strong>可以用 animate() 方法来操作所有 CSS 属性吗？</strong><br>是的，几乎可以！不过，需要记住一件重要的事情：当使用 animate() 时，必须使用 Camel 标记法书写所有的属性名，比如，必须使用 paddingLeft 而不是 padding-left，使用 marginRight 而不是 margin-right，等等。</p>
<p>jQuery stop() 方法用于停止动画或效果，在它们完成之前。</p>
<p>stop() 方法适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画。</p>
<p> $(<em>selector</em>).stop(<em>stopAll,goToEnd</em>);</p>
<p>可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。</p>
<p>可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。</p>
<p>因此，默认地，stop() 会清除在被选元素上指定的当前动画。</p>
<p>三个简单实用的用于 DOM 操作的 jQuery 方法：</p>
<ul>
<li>text() - 设置或返回所选元素的文本内容</li>
<li>html() - 设置或返回所选元素的内容（包括 HTML 标记）</li>
<li>val() - 设置或返回表单字段的值</li>
</ul>
<p>jQuery attr() 方法用于获取属性值。</p>
<h2 id="添加新的-HTML-内容"><a href="#添加新的-HTML-内容" class="headerlink" title="添加新的 HTML 内容"></a>添加新的 HTML 内容</h2><p>我们将学习用于添加新内容的四个 jQuery 方法：</p>
<ul>
<li><p><a href="https://www.w3cschool.cn/jquery/html-append.html" target="_blank" rel="noopener">append()</a> - 在被选元素内部的结尾插入指定内容</p>
</li>
<li><p><a href="https://www.w3cschool.cn/jquery/html-prepend.html" target="_blank" rel="noopener">prepend()</a> - 在被选元素内部的开头插入指定内容</p>
</li>
<li><p><a href="https://www.w3cschool.cn/jquery/html-after.html" target="_blank" rel="noopener">after()</a> - 在被选元素之后插入内容</p>
</li>
<li><p><a href="https://www.w3cschool.cn/jquery/html-before.html" target="_blank" rel="noopener">before()</a> - 在被选元素之前插入内容</p>
<p>$(“img”).after(“在后面添加文本”); </p>
</li>
</ul>
<p>$(“img”).before(“在前面添加文本”);  </p>
<p><strong>提示：</strong>在jQuery中，append/prepend 是在选择元素内部嵌入，而after/before 是在元素外面追加。</p>
<h2 id="删除元素-内容"><a href="#删除元素-内容" class="headerlink" title="删除元素/内容"></a>删除元素/内容</h2><p>如需删除元素和内容，一般可使用以下两个 jQuery 方法：</p>
<ul>
<li><a href="https://www.w3cschool.cn/jquery/html-remove.html" target="_blank" rel="noopener">remove()</a> - 删除被选元素（及其子元素）</li>
<li><a href="https://www.w3cschool.cn/jquery/html-empty.html" target="_blank" rel="noopener">empty()</a> - 从被选元素中删除子元素</li>
</ul>
<h2 id="jQuery-操作-CSS"><a href="#jQuery-操作-CSS" class="headerlink" title="jQuery 操作 CSS"></a>jQuery 操作 CSS</h2><p>jQuery 拥有若干进行 CSS 操作的方法。我们将学习下面这些：</p>
<ul>
<li><a href="https://www.w3cschool.cn/jquery/html-addclass.html" target="_blank" rel="noopener">addClass()</a> - 向被选元素添加一个或多个类</li>
<li><a href="https://www.w3cschool.cn/jquery/html-removeclass.html" target="_blank" rel="noopener">removeClass()</a> - 从被选元素删除一个或多个类</li>
<li><a href="https://www.w3cschool.cn/jquery/html-toggleclass.html" target="_blank" rel="noopener">toggleClass()</a> - 对被选元素进行添加/删除类的切换操作</li>
<li><a href="https://www.w3cschool.cn/jquery/jquery-css.html" target="_blank" rel="noopener">css()</a> - 设置或返回样式属性</li>
</ul>
<h2 id="设置-CSS-属性"><a href="#设置-CSS-属性" class="headerlink" title="设置 CSS 属性"></a>设置 CSS 属性</h2><p>如需设置指定的 CSS 属性，请使用如下语法：    </p>
<p>css({“<em>propertyname</em>“:”<em>value</em>“,”<em>propertyname</em>“:”<em>value</em>“,…});</p>
<p>jQuery 提供多个处理尺寸的重要方法：</p>
<ul>
<li><a href="https://www.w3cschool.cn/jquery/css-width.html" target="_blank" rel="noopener">width()</a></li>
<li><a href="https://www.w3cschool.cn/jquery/css-height.html" target="_blank" rel="noopener">height()</a></li>
<li><a href="https://www.w3cschool.cn/jquery/html-innerwidth.html" target="_blank" rel="noopener">innerWidth()</a></li>
<li><a href="https://www.w3cschool.cn/jquery/html-innerheight.html" target="_blank" rel="noopener">innerHeight()</a></li>
<li><a href="https://www.w3cschool.cn/jquery/html-outerwidth.html" target="_blank" rel="noopener">outerWidth()</a></li>
<li><a href="https://www.w3cschool.cn/jquery/html-outerheight.html" target="_blank" rel="noopener">outerHeight()</a></li>
</ul>
<p><img src="https://7n.w3cschool.cn/statics/images/course/img_jquerydim.gif" alt="jQuery Dimensions"></p>
<h2 id="向上遍历-DOM-树"><a href="#向上遍历-DOM-树" class="headerlink" title="向上遍历 DOM 树"></a>向上遍历 DOM 树</h2><ul>
<li><a href="https://www.w3cschool.cn/jquery/traversing-parent.html" target="_blank" rel="noopener">parent()</a><ul>
<li>parent() 方法返回被选元素的直接父元素。</li>
</ul>
</li>
<li><a href="https://www.w3cschool.cn/jquery/traversing-parents.html" target="_blank" rel="noopener">parents()</a><ul>
<li>parents() 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (<html>)。</html></li>
</ul>
</li>
<li><a href="https://www.w3cschool.cn/jquery/traversing-parentsuntil.html" target="_blank" rel="noopener">parentsUntil()</a><ul>
<li>parentsUntil() 方法返回介于两个给定元素之间的所有祖先元素。</li>
<li>返回介于 <span> 与 <div> 元素之间的所有祖先元素： $(“span”).parentsUntil(“div”);</div></span></li>
</ul>
</li>
</ul>
<h2 id="向下遍历-DOM-树"><a href="#向下遍历-DOM-树" class="headerlink" title="向下遍历 DOM 树"></a>向下遍历 DOM 树</h2><p>下面是两个用于向下遍历 DOM 树的 jQuery 方法：</p>
<ul>
<li><a href="https://www.w3cschool.cn/jquery/traversing-children.html" target="_blank" rel="noopener">children()</a></li>
<li><a href="https://www.w3cschool.cn/jquery/traversing-find.html" target="_blank" rel="noopener">find()</a></li>
</ul>
<h2 id="在-DOM-树中水平遍历"><a href="#在-DOM-树中水平遍历" class="headerlink" title="在 DOM 树中水平遍历"></a>在 DOM 树中水平遍历</h2><p>有许多有用的方法让我们在 DOM 树进行水平遍历：</p>
<ul>
<li>siblings()：返回被选元素的所有同胞元素</li>
<li>next()：返回被选元素的下一个同胞元素</li>
<li>nextAll()：返回被选元素的所有跟随的同胞元素</li>
<li>nextUntil()：返回介于两个给定参数之间的所有跟随的同胞元素</li>
<li>prev()</li>
<li>prevAll()</li>
<li>prevUntil()</li>
</ul>
<h2 id="缩小搜索元素的范围"><a href="#缩小搜索元素的范围" class="headerlink" title="缩小搜索元素的范围"></a>缩小搜索元素的范围</h2><p>三个最基本的过滤方法是：first(), last() 和 eq()，它们允许您基于其在一组元素中的位置来选择一个特定的元素。</p>
<p>其他过滤方法，比如 filter() 和 not() 允许您选取匹配或不匹配某项指定标准的元素。</p>
<p>first（）：返回被选元素的首个元素</p>
<p>last（）：返回被选元素的最后一个元素</p>
<p><a href="https://www.w3cschool.cn/jquery/traversing-eq.html" target="_blank" rel="noopener">eq() 方法</a>返回被选元素中带有指定索引号的元素。</p>
<p>索引号从 0 开始，因此首个元素的索引号是 0 而不是 1。</p>
<p><a href="https://www.w3cschool.cn/jquery/traversing-filter.html" target="_blank" rel="noopener">filter() 方法</a>允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。</p>
<p>jQuery  AJAX</p>
<ul>
<li>AJAX是与服务器交换数据的技术，它在不重载全部页面的情况下，实现对部分页面的更新</li>
<li>AJAX=异步JavaScript和XML（Asynchronous  JavaScript   and  XML),通过AJAX方法，你可以使用HTTP Get和HTTP Post从远程服务器上请求文本，HTML,XML,JSON,同时你可把这些外部数据直接载入网页的被选元素中</li>
</ul>
<h4 id="作为一般函数调用-param"><a href="#作为一般函数调用-param" class="headerlink" title="作为一般函数调用$(param)"></a>作为一般函数调用$(param)</h4><ol>
<li>参数为函数：当DOM加载完成后，执行此回调函数。</li>
<li>参数为选择器字符串：查找所有匹配的标签，并把它们封装成jquery对象。</li>
<li>参数是DOM对象：将dom对象封装成jquery对象。</li>
<li>参数为html标签字符串（用得最少）：创建标签对象并封装成jquery对象。</li>
</ol>
<h4 id="作为对象使用"><a href="#作为对象使用" class="headerlink" title="作为对象使用"></a>作为对象使用</h4><ol>
<li>$.each()：隐式遍历数组</li>
<li>$.trim()：去除两端的空格</li>
</ol>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h4 id="load（）"><a href="#load（）" class="headerlink" title="load（）"></a>load（）</h4><ul>
<li>load（）方法从服务器加载数据，并把返回的数据放入被选元素中<ul>
<li>$(selector).load(URL,data,callback);</li>
<li>必须的URL参数规定你希望加载的URL</li>
<li>可选的data参数规定与请求一同发送的查询字符串键/值对集合</li>
<li>可选的callback（responseTxt，statusTXT，xhr）参数是load（）完成后执行的函数名称，无论AJAX请求是否成功，一旦请求完成后，函数callback立即被触发</li>
<li>responseTxt–包含调用成功时的结果内容     statusTXT—包含调用的状态        xhr——包含XMLHttpRequest对象</li>
</ul>
</li>
</ul>
<h4 id="get（URL-callback）和post（）"><a href="#get（URL-callback）和post（）" class="headerlink" title="$.get（URL,callback）和post（）"></a>$.get（URL,callback）和post（）</h4><ul>
<li>两者都能通过HTTP或POST请求从服务器请求数据</li>
<li>get是从指定的资源请求数据，基本用于从服务器获得数据，可能返回缓存数据</li>
<li>post向指定的资源提交要处理的数据，可用于从服务器获取数据。不过，post方法不会缓存数据，并且常用于连同请求一起发送数据</li>
</ul>
<h4 id="noConflict（）方法"><a href="#noConflict（）方法" class="headerlink" title="$.noConflict（）方法"></a>$.noConflict（）方法</h4><ul>
<li>解决在页面同时使用jQuery和其他框架（在同一个页面加载多个jQuery实例，尤其是不同版本的jQuery）</li>
<li>noConflict（）会释放对$($是jQuery的简写）</li>
</ul>
<h4 id="selector-bind-event-data-function-map"><a href="#selector-bind-event-data-function-map" class="headerlink" title="$(selector).bind(event,data,function,map)"></a>$(selector).bind(event,data,function,map)</h4><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>event</em></td>
<td align="left">必需。规定添加到元素的一个或多个事件。  由空格分隔多个事件值。必须是有效的事件。</td>
</tr>
<tr>
<td align="left"><em>data</em></td>
<td align="left">可选。规定传递到函数的额外数据。</td>
</tr>
<tr>
<td align="left"><em>function</em></td>
<td align="left">必需。规定当事件发生时运行的函数。</td>
</tr>
<tr>
<td align="left"><em>map</em></td>
<td align="left">规定事件映射 (<em>{event:function, event:function, …})</em>，包含要添加到元素的一个或多个事件，以及当事件发生时运行的函数。</td>
</tr>
</tbody></table>
<ul>
<li><p>bind() 方法向被选元素添加一个或多个事件处理程序，以及当事件发生时运行的函数。</p>
</li>
<li><p>自 jQuery 版本 1.7 起，<a href="https://www.w3cschool.cn/jquery/event-on.html" target="_blank" rel="noopener">on()</a> 方法是向被选元素添加事件处理程序的首选方法。</p>
</li>
</ul>
<h4 id="selector-delegate-childSelector-event-data-function"><a href="#selector-delegate-childSelector-event-data-function" class="headerlink" title="$(selector).delegate(childSelector,event,data,function)"></a>$(selector).delegate(childSelector,event,data,function)</h4><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>childSelector</em></td>
<td align="left">必需。规定要添加事件处理程序的一个或多个子元素。</td>
</tr>
<tr>
<td align="left"><em>event</em></td>
<td align="left">必需。规定添加到元素的一个或多个事件。  由空格分隔多个事件值。必须是有效的事件。</td>
</tr>
<tr>
<td align="left"><em>data</em></td>
<td align="left">可选。规定传递到函数的额外数据。</td>
</tr>
<tr>
<td align="left"><em>function</em></td>
<td align="left">必需。规定当事件发生时运行的函数。</td>
</tr>
</tbody></table>
<h1 id="原生js与jQuery的区别"><a href="#原生js与jQuery的区别" class="headerlink" title="原生js与jQuery的区别"></a>原生js与jQuery的区别</h1><p>1.原生JS与jQuery入口函数的加载模式不同</p>
<ul>
<li>原生JS会等到DOM元素和图片都加载完毕再执行</li>
<li>jQuery只是等DOM加载完毕之后就执行</li>
</ul>
<p>2.覆盖问题</p>
<ul>
<li>原生js如果有多个入口函数，后面编写的会覆盖前面的</li>
<li>jQuery有多个入口函数时不会相互覆盖，都会执行</li>
</ul>
<p>3.多个框架时的冲突问题</p>
<ul>
<li>解决方法：释放$的使用权</li>
</ul>
<p>iQuery.noConflict();</p>
<p>注意点：释放操作必须在编写其他jQuery代码之前编写</p>
<p>​              释放之后就不能再使用$改为jQuery</p>
<ul>
<li>自定义访问符号</li>
</ul>
<p>var  nj = jQuery.noConflict();</p>
<p>nj(function (){ });</p>
<p>4.遍历数组</p>
<ul>
<li><p>js中用forEach（）只能遍历数组，不能遍历伪数组，参数位置不同</p>
<p>arr.forEach(function (value,index){  });</p>
</li>
<li><p>利用jQuery的Each（）静态方法遍历数组/伪数组,参数位置不同</p>
<p>$.each(arr,function (index,value){  });//遍历数组</p>
<p>$.each(obj，function (index,value){  });//遍历伪数组</p>
</li>
</ul>
<p>jQuery中的each（）静态方法和map（）静态方法的区别：</p>
<ul>
<li>each（）静态方法默认的返回值就是遍历谁就返回谁，不支持在回调函数中对数组进行处理</li>
<li>map（）静态方法默认的返回值是一个空数组，可通过回调函数进行处理，然后生成一个新的数组返回</li>
</ul>
<h2 id="复习jquery"><a href="#复习jquery" class="headerlink" title="复习jquery"></a>复习jquery</h2><ul>
<li>DOM中的顶级对象：document ——页面中的顶级对象</li>
<li>BOM中的顶级对象：window</li>
<li>jQuery的顶级对象：jQuery——$</li>
</ul>
<h6 id="与-的区别"><a href="#与-的区别" class="headerlink" title="$与$()的区别"></a>$与$()的区别</h6><ul>
<li>$是一个函数对象，包含很多静态方法，这种方法，一般的js也是可以使用。</li>
<li>$（）是调用这个函数对象的一个实例，返回一个对象，一般是由$对象拓展的对象属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$().css();</span><br><span class="line">$().html();</span><br><span class="line"></span><br><span class="line">$.trim();</span><br><span class="line">$.proxy();</span><br></pre></td></tr></table></figure>

<h6 id="常见属性方法"><a href="#常见属性方法" class="headerlink" title="$常见属性方法"></a>$常见属性方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">trim()			去除前后格</span><br><span class="line">makeArray()		类数组转为真数组</span><br><span class="line">inArray()		数组版indexOf</span><br><span class="line">merge()			合并数组</span><br><span class="line">grep()			过滤新数组</span><br><span class="line">map()			映射新数组</span><br><span class="line">guid			唯一标识符</span><br><span class="line">proxy()			改this指向</span><br><span class="line">access()		多功能操作值（内部）</span><br><span class="line">now()			当前时间</span><br><span class="line">swap()			CSS交换（内部）</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-js动画篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/17/js动画篇/" class="article-date">
      <time datetime="2020-06-17T07:27:46.000Z" itemprop="datePublished">2020-06-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/js动画篇/">js动画篇</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><h4 id="一-keyframes规则是创建动画，它指定一个css样式和动画将逐步从当前样式更改为新的样式"><a href="#一-keyframes规则是创建动画，它指定一个css样式和动画将逐步从当前样式更改为新的样式" class="headerlink" title="一. @keyframes规则是创建动画，它指定一个css样式和动画将逐步从当前样式更改为新的样式"></a>一. @keyframes规则是创建动画，它指定一个css样式和动画将逐步从当前样式更改为新的样式</h4><p>当在keyframes创建动画时，把他绑定到一个选择器，否则动画不会有任何效果，至少指定这两个动画属性</p>
<ul>
<li>规定动画名称</li>
<li>规定动画时长</li>
<li>animation:  myfirst  5s;</li>
</ul>
<h4 id="二-animation属性"><a href="#二-animation属性" class="headerlink" title="二 . animation属性"></a>二 . animation属性</h4><p>语法：</p>
<p>animation: name    duration    time-function    delay    iteration-count    direction;</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>animation-name</td>
<td>规定需要绑定到选择器的keyframe名称</td>
</tr>
</tbody></table>
<p>animation-duration    规定完成动画所花费的时间，以s/ms记</p>
<p>animation-time-function    规定动画的速度曲线</p>
<p>animation-iteration-count    规定动画应该播放的次数</p>
<p>animation-direction    规定是否应该轮流方向播放动画</p>
<p><strong>注意</strong>：请始终规定animation-duration属性，否则时长为0，就不会播放动画。</p>
<h4 id="三-animation-delay属性"><a href="#三-animation-delay属性" class="headerlink" title="三  . animation-delay属性"></a>三  . animation-delay属性</h4><h5 id="1-定义动画什么时候开始（s-ms）"><a href="#1-定义动画什么时候开始（s-ms）" class="headerlink" title="1.定义动画什么时候开始（s/ms）"></a>1.定义动画什么时候开始（s/ms）</h5><ul>
<li>可为负值，-2s使动画马上开始，但跳过2s进入动画</li>
</ul>
<h4 id="四-animation-direction属性"><a href="#四-animation-direction属性" class="headerlink" title="四 . animation-direction属性"></a>四 . animation-direction属性</h4><h5 id="1-animation-direction：属性控制如何在reverse或alternate周期播放动画。"><a href="#1-animation-direction：属性控制如何在reverse或alternate周期播放动画。" class="headerlink" title="1.animation-direction：属性控制如何在reverse或alternate周期播放动画。"></a>1.animation-direction：属性控制如何在<code>reverse</code>或<code>alternate</code>周期播放动画。</h5><p>如果 animation-direction 值是 “alternate”，则动画会在奇数次数（1、3、5 等等）正常播放，而在偶数次数（2、4、6 等等）向后播放。</p>
<p>注释：如果把动画设置为只播放一次，则该属性没有效果。</p>
<ul>
<li>属性值</li>
</ul>
<table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>normal</td>
<td>以正常的方式播放动画</td>
</tr>
<tr>
<td>reverse</td>
<td>以相反方向播放动画</td>
</tr>
<tr>
<td>alternate</td>
<td>播放动画作为正常每奇数时间（1,3,5等）和反方向每偶数时间（2,4,6，等…）</td>
</tr>
<tr>
<td>alternate-reverse</td>
<td>在每个奇数时间（1,3,5等）在相反方向上播放动画，并且在每个偶数时间（2,4,6等等）的正常方向上播放动画</td>
</tr>
</tbody></table>
<h4 id="五-animation-duration属性"><a href="#五-animation-duration属性" class="headerlink" title="五 . animation-duration属性"></a>五 . animation-duration属性</h4><h5 id="1-定义完成一个动画需要的时间s-ms"><a href="#1-定义完成一个动画需要的时间s-ms" class="headerlink" title="1.定义完成一个动画需要的时间s/ms"></a>1.定义完成一个动画需要的时间s/ms</h5><p>animation-duration：time；</p>
<h4 id="六-animation-fill-mode属性"><a href="#六-animation-fill-mode属性" class="headerlink" title="六 . animation-fill-mode属性"></a>六 . animation-fill-mode属性</h4><h5 id="1-设置样式以在动画不播放时应用元素"><a href="#1-设置样式以在动画不播放时应用元素" class="headerlink" title="1.设置样式以在动画不播放时应用元素"></a>1.设置样式以在动画不播放时应用元素</h5><ul>
<li><p>animation-fill-mode:none | forwards | backwards |both |initial |inherit ;</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>默认值，无样式</td>
</tr>
</tbody></table>
<p>forwards    动画结束后，使用元素的结束属性值</p>
<p>backwards    使用元素的起始值</p>
<p>both    动画遵循向前向后的规则</p>
</li>
</ul>
<h4 id="七-animation-iteration-count属性"><a href="#七-animation-iteration-count属性" class="headerlink" title="七 . animation-iteration-count属性"></a>七 . animation-iteration-count属性</h4><h5 id="1-定义动画应该播放几次"><a href="#1-定义动画应该播放几次" class="headerlink" title="1 . 定义动画应该播放几次"></a>1 . 定义动画应该播放几次</h5><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><em>n</em></td>
<td>定义播放动画多少次。 默认值为1</td>
</tr>
<tr>
<td>infinite</td>
<td>指定动画应该播放无限次（永远）</td>
</tr>
</tbody></table>
<h4 id="八-animation-name属性"><a href="#八-animation-name属性" class="headerlink" title="八 . animation-name属性"></a>八 . animation-name属性</h4><h5 id="1-animation-name属性为-keyframes动画规定名称"><a href="#1-animation-name属性为-keyframes动画规定名称" class="headerlink" title="1. animation-name属性为@keyframes动画规定名称"></a>1. animation-name属性为@keyframes动画规定名称</h5><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>keyframename</td>
<td>规定需要绑定到选择器的 keyframe 的名称。</td>
</tr>
<tr>
<td>none</td>
<td>规定无动画效果（可用于覆盖来自级联的动画）。</td>
</tr>
</tbody></table>
<h4 id="九-animation-play-state属性"><a href="#九-animation-play-state属性" class="headerlink" title="九 . animation-play-state属性"></a>九 . animation-play-state属性</h4><h5 id="1-设置是否运行或者暂停动画"><a href="#1-设置是否运行或者暂停动画" class="headerlink" title="1.设置是否运行或者暂停动画"></a>1.设置是否运行或者暂停动画</h5><p>你可以在js中使用该属性，这样就可以在播放过程中暂停动画</p>
<p>animation-play-state：paused | running；</p>
<h4 id="十-animation-timing-function属性"><a href="#十-animation-timing-function属性" class="headerlink" title="十 . animation-timing-function属性"></a>十 . animation-timing-function属性</h4><h5 id="1-指定动画速度曲线"><a href="#1-指定动画速度曲线" class="headerlink" title="1 . 指定动画速度曲线"></a>1 . 指定动画速度曲线</h5><p>​    速度曲线定义动画从一套CSS样式变为另一套所用的时间，速度曲线用于使变化更为平滑</p>
<p>​    animation-timing-function : linear | ease | ease-in | ease-out | cubic-bezier(n,n,n,n);</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">linear</td>
<td align="left">动画从开始到结束具有相同的速度。</td>
</tr>
<tr>
<td align="left">ease</td>
<td align="left">动画有一个缓慢的开始，然后快，结束慢。</td>
</tr>
<tr>
<td align="left">ease-in</td>
<td align="left">动画有一个缓慢的开始。</td>
</tr>
<tr>
<td align="left">ease-out</td>
<td align="left">动画结束缓慢。</td>
</tr>
<tr>
<td align="left">ease-in-out</td>
<td align="left">动画具有缓慢的开始和慢的结束。</td>
</tr>
<tr>
<td align="left">cubic-bezier(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td align="left">在立方贝塞尔函数中定义速度函数。 可能的值是从0到1的数字值。</td>
</tr>
</tbody></table>
<hr>

<h1 id="转换transform"><a href="#转换transform" class="headerlink" title="转换transform"></a>转换transform</h1><h2 id="一-2D转换"><a href="#一-2D转换" class="headerlink" title="一 . 2D转换"></a>一 . 2D转换</h2><h5 id="1-旋转transform-rotate-30deg"><a href="#1-旋转transform-rotate-30deg" class="headerlink" title="1.旋转transform : rotate(30deg);"></a>1.旋转transform : rotate(30deg);</h5><p>在给定度数顺时针旋转的元素。负值表示逆时针deg表示度数。</p>
<h5 id="2-移动-transform-translate-50px-100px"><a href="#2-移动-transform-translate-50px-100px" class="headerlink" title="2.移动 transform:translate(50px,100px);"></a>2.移动 transform:translate(50px,100px);</h5><p>往左往上为正</p>
<h5 id="3-缩放-transform：scale（2，4）；"><a href="#3-缩放-transform：scale（2，4）；" class="headerlink" title="3.缩放 transform：scale（2，4）；"></a>3.缩放 transform：scale（2，4）；</h5><p>scale（2,4）转变宽度为原来的大小的2倍，和其原始大小4倍的高度。</p>
<h5 id="4-倾斜-transform：skew（30deg，20deg）；"><a href="#4-倾斜-transform：skew（30deg，20deg）；" class="headerlink" title="4.倾斜 transform：skew（30deg，20deg）；"></a>4.倾斜 transform：skew（30deg，20deg）；</h5><p>包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。</p>
<ul>
<li>skewX( );表示只在X轴(水平方向)倾斜。</li>
</ul>
<ul>
<li>skewY( );表示只在Y轴(垂直方向)倾斜。 </li>
<li>skew(30deg,20deg) 是元素在X轴和Y轴上倾斜20度30度。</li>
</ul>
<h2 id="总的语法"><a href="#总的语法" class="headerlink" title="总的语法"></a>总的语法</h2><p>transform: none|<em>transform-functions</em>;</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">none</td>
<td align="left">定义不进行转换。</td>
<td></td>
</tr>
<tr>
<td align="left">matrix(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td align="left">定义 2D 转换，使用六个值的矩阵。</td>
<td></td>
</tr>
<tr>
<td align="left">matrix3d(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td align="left">定义 3D 转换，使用 16 个值的 4x4 矩阵。</td>
<td></td>
</tr>
<tr>
<td align="left">translate(<em>x</em>,<em>y</em>)</td>
<td align="left">定义 2D 转换。</td>
<td></td>
</tr>
<tr>
<td align="left">translate3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td align="left">定义 3D 转换。</td>
<td></td>
</tr>
<tr>
<td align="left">translateX(<em>x</em>)</td>
<td align="left">定义转换，只是用 X 轴的值。</td>
<td></td>
</tr>
<tr>
<td align="left">translateY(<em>y</em>)</td>
<td align="left">定义转换，只是用 Y 轴的值。</td>
<td></td>
</tr>
<tr>
<td align="left">translateZ(<em>z</em>)</td>
<td align="left">定义 3D 转换，只是用 Z 轴的值。</td>
<td></td>
</tr>
<tr>
<td align="left">scale(<em>x</em>[,<em>y</em>]?)</td>
<td align="left">定义 2D 缩放转换。</td>
<td></td>
</tr>
<tr>
<td align="left">scale3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td align="left">定义 3D 缩放转换。</td>
<td></td>
</tr>
<tr>
<td align="left">scaleX(<em>x</em>)</td>
<td align="left">通过设置 X 轴的值来定义缩放转换。</td>
<td></td>
</tr>
<tr>
<td align="left">scaleY(<em>y</em>)</td>
<td align="left">通过设置 Y 轴的值来定义缩放转换。</td>
<td></td>
</tr>
<tr>
<td align="left">scaleZ(<em>z</em>)</td>
<td align="left">通过设置 Z 轴的值来定义 3D 缩放转换。</td>
<td></td>
</tr>
<tr>
<td align="left">rotate(<em>angle</em>)</td>
<td align="left">定义 2D 旋转，在参数中规定角度。</td>
<td></td>
</tr>
<tr>
<td align="left">rotate3d(<em>x</em>,<em>y</em>,<em>z</em>,<em>angle</em>)</td>
<td align="left">定义 3D 旋转。</td>
<td></td>
</tr>
<tr>
<td align="left">rotateX(<em>angle</em>)</td>
<td align="left">定义沿着 X 轴的 3D 旋转。</td>
<td></td>
</tr>
<tr>
<td align="left">rotateY(<em>angle</em>)</td>
<td align="left">定义沿着 Y 轴的 3D 旋转。</td>
<td></td>
</tr>
<tr>
<td align="left">rotateZ(<em>angle</em>)</td>
<td align="left">定义沿着 Z 轴的 3D 旋转。</td>
<td></td>
</tr>
<tr>
<td align="left">skew(<em>x-angle</em>,<em>y-angle</em>)</td>
<td align="left">定义沿着 X 和 Y 轴的 2D 倾斜转换。</td>
<td></td>
</tr>
<tr>
<td align="left">skewX(<em>angle</em>)</td>
<td align="left">定义沿着 X 轴的 2D 倾斜转换。</td>
<td></td>
</tr>
<tr>
<td align="left">skewY(<em>angle</em>)</td>
<td align="left">定义沿着 Y 轴的 2D 倾斜转换。</td>
<td></td>
</tr>
<tr>
<td align="left">perspective(<em>n</em>)</td>
<td align="left">为 3D 转换元素定义透视视图。</td>
<td></td>
</tr>
</tbody></table>
<h4 id="二-transform-origin"><a href="#二-transform-origin" class="headerlink" title="二 . transform-origin"></a>二 . transform-origin</h4><h5 id="1-transform-Origin属性允许您更改转换元素的位置。"><a href="#1-transform-Origin属性允许您更改转换元素的位置。" class="headerlink" title="1.transform-Origin属性允许您更改转换元素的位置。"></a>1.transform-Origin属性允许您更改转换元素的位置。</h5><p>2D转换元素可以改变元素的X和Y轴。 3D转换元素，还可以更改元素的Z轴。</p>
<p>transform-origin: <em>x-axis y-axis z-axis</em>;</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">x-axis</td>
<td align="left">定义视图被置于 X 轴的何处。left center right <em>length</em> <em>%</em></td>
</tr>
<tr>
<td align="left">y-axis</td>
<td align="left">定义视图被置于 Y 轴的何处。可能的值：top center bottom   <em>length</em>     <em>%</em></td>
</tr>
<tr>
<td align="left">z-axis</td>
<td align="left">定义视图被置于 Z 轴的何处。可能的值：<em>length</em></td>
</tr>
</tbody></table>
<h5 id="2-transform-style属性指定嵌套元素是怎么在三维空间中呈现"><a href="#2-transform-style属性指定嵌套元素是怎么在三维空间中呈现" class="headerlink" title="2.transform-style属性指定嵌套元素是怎么在三维空间中呈现"></a>2.transform-style属性指定嵌套元素是怎么在三维空间中呈现</h5><ul>
<li><p>transform-style: flat | preserve-3d;</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">flat</td>
<td align="left">子元素将不保留其 3D 位置。</td>
</tr>
<tr>
<td align="left">preserve-3d</td>
<td align="left">子元素将保留其 3D 位置。</td>
</tr>
</tbody></table>
</li>
</ul>
<p>让转换的子元素保留3D转换：</p>
<p>div<br>{<br>transform: rotateY(60deg);<br>transform-style: preserve-3d;<br>-webkit-transform: rotateY(60deg); /* Safari and Chrome <em>/<br>-webkit-transform-style: preserve-3d; /</em> Safari and Chrome */<br>}</p>
<h1 id="transition属性过渡"><a href="#transition属性过渡" class="headerlink" title="transition属性过渡"></a>transition属性过渡</h1><p>transition 属性是一个简写属性，用于设置四个过渡属性：</p>
<ul>
<li>transition-property</li>
<li>transition-duration</li>
<li>transition-timing-function</li>
<li>transition-delay</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition: property duration timing-function delay;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transition-property</td>
<td>规定设置过渡效果的 CSS 属性的名称。</td>
</tr>
<tr>
<td>transition-duration</td>
<td>规定完成过渡效果需要多少秒或毫秒。</td>
</tr>
<tr>
<td>transition-timing-function</td>
<td>规定速度效果的速度曲线。</td>
</tr>
<tr>
<td>transition-delay</td>
<td>定义过渡效果何时开始。</td>
</tr>
</tbody></table>
<ul>
<li><p>transition-property属性指定css属性的nametransition效果（transition效果时将会启动指定的css属性的变化。</p>
</li>
<li><p>一个转场效果通常发生在当鼠标悬停在一个元素上</p>
</li>
<li><p>始终指定transition-duration属性，否则持续时间为0，transition不会有效果默认值是all，多项改变要添加多个样式的变换效果，添加的属性由逗号分隔</p>
<p>transition-property: none|all| <em>property</em>;</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">none</td>
<td align="left">没有属性会获得过渡效果。</td>
</tr>
<tr>
<td align="left">all</td>
<td align="left">所有属性都将获得过渡效果。</td>
</tr>
<tr>
<td align="left"><em>property</em></td>
<td align="left">定义应用过渡效果的 CSS 属性名称列表，列表以逗号分隔。</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="三-透视3D属性perspective"><a href="#三-透视3D属性perspective" class="headerlink" title="三 . 透视3D属性perspective"></a>三 . 透视3D属性perspective</h4><p>多少像素的3D元素是从视图的perspective属性定义。这个属性允许你改变3D元素是怎样查看透视图。perspective 属性只影响 3D 转换元素；定义时的perspective属性，它是一个元素的子元素，透视图，而不是元素本身。</p>
<p>perspective: <em>number</em>|none;</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>number</em></td>
<td align="left">元素距离视图的距离，以像素计。</td>
</tr>
<tr>
<td align="left">none</td>
<td align="left">默认值。与 0 相同。不设置透视。</td>
</tr>
</tbody></table>
<p>一般跟perspective-origin属性配合使用，默认值都是50%</p>
<h4 id="四-。-backface-visibility属性"><a href="#四-。-backface-visibility属性" class="headerlink" title="四 。 backface-visibility属性"></a>四 。 backface-visibility属性</h4><h5 id="1-backface-visibility属性定义当元素不面向屏幕时是否可见，默认可见"><a href="#1-backface-visibility属性定义当元素不面向屏幕时是否可见，默认可见" class="headerlink" title="1. backface-visibility属性定义当元素不面向屏幕时是否可见，默认可见"></a>1. backface-visibility属性定义当元素不面向屏幕时是否可见，默认可见</h5><p>如果在旋转元素不希望看到其背面时，该属性很有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backface-visibility: visible|hidden;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>visible</td>
<td>默认值。 背面是可见的。</td>
</tr>
<tr>
<td>hidden</td>
<td>背面是不可见的。</td>
</tr>
</tbody></table>
<h4 id="五-盒阴影box-shadow"><a href="#五-盒阴影box-shadow" class="headerlink" title="五 . 盒阴影box-shadow"></a>五 . 盒阴影box-shadow</h4><p>box-shadow : 向左偏移量  向下偏移量  阴影半径  颜色；</p>
<p><strong>注意</strong>：向右向下为正</p>
<h4 id="六-边界图片border-image"><a href="#六-边界图片border-image" class="headerlink" title="六 . 边界图片border-image"></a>六 . 边界图片border-image</h4><p>border-image属性允许你指定一个图片作为边框！用于创建上文边框的原始图像</p>
<p>border-image:url(border.png) 30 30 round; </p>
<p>速记属性</p>
<p>border-image：source    slice   width    outset   repeat；</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>border-image-source</em></td>
<td align="left">用于指定要用于绘制边框的图像的位置</td>
</tr>
<tr>
<td align="left"><em>border-image-slice</em></td>
<td align="left">图像边界向内偏移</td>
</tr>
<tr>
<td align="left"><em>border-image-width</em></td>
<td align="left">图像边界的宽度</td>
</tr>
<tr>
<td align="left"><em>border-image-outset</em></td>
<td align="left">用于指定在边框外部绘制 border-image-area 的量</td>
</tr>
<tr>
<td align="left"><em>border-image-repeat</em></td>
<td align="left">这个例子演示了如何创建一个border-image 属性的按钮。</td>
</tr>
</tbody></table>
<ul>
<li>border-image-source: url(border.png);</li>
</ul>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">none</td>
<td align="left">没有图像被使用</td>
</tr>
<tr>
<td align="left"><em>image</em></td>
<td align="left">边框使用图像的路径</td>
</tr>
</tbody></table>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-image-outset: length|number（代表对应的border-width的倍数）;</span><br></pre></td></tr></table></figure>

<p><strong>注释：</strong>border-image-outset 属性规定边框图像超出边框盒的量。在上、右、下、左侧。如果忽略第四个值，则与第二个值相同。如果省略第三个值，则与第一个值相同。如果省略第二个值，则与第一个值相同。不允许任何负值作为 border-image-outset 值。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-image-width: number|%|auto;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>border-image -width的4个值指定用于把border图像区域分为九个部分。他们代表上，右，底部，左，两侧向内距离。如果第四个值被省略，它和第二个是相同的。如果也省略了第三个，它和第一个是相同的。如果也省略了第二个，它和第一个是相同的。负值是不允许的。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><em>number</em></td>
<td>代表对应的 border-width 的倍数。</td>
</tr>
<tr>
<td><em>%</em></td>
<td>参考边框图像区域的尺寸：区域的高度影响水平偏移，宽度影响垂直偏移。</td>
</tr>
<tr>
<td><em>auto</em></td>
<td>如果规定该属性，则宽度为对应的图像切片的固有宽度。</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="七-border-collapse-属性"><a href="#七-border-collapse-属性" class="headerlink" title="七 . border-collapse 属性"></a>七 . border-collapse 属性</h4><p>设置表格的边框是否被合并为一个单一的边框</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">collapse</td>
<td align="left">如果可能，边框会合并为一个单一的边框。会忽略 border-spacing 和 empty-cells 属性</td>
</tr>
<tr>
<td align="left">separate</td>
<td align="left">默认值。边框会被分开。不会忽略 border-spacing 和 empty-cells 属性</td>
</tr>
<tr>
<td align="left">inherit</td>
<td align="left">规定应该从父元素继承 border-collapse 属性的值</td>
</tr>
</tbody></table>
<h4 id="八-border-color-红，绿，蓝-粉红色"><a href="#八-border-color-红，绿，蓝-粉红色" class="headerlink" title="八 .border-color:红，绿，蓝,粉红色;"></a>八 .<strong>border-color:红，绿，蓝,粉红色;</strong></h4><ul>
<li>上边框是红色</li>
<li>右边框是绿色</li>
<li>底部边框是蓝</li>
<li>左边框是粉红色</li>
</ul>
<p><strong>border-color：红，绿，蓝;</strong></p>
<ul>
<li>上边框是红色</li>
<li>左，右边框是绿色</li>
<li>底部边框是蓝</li>
</ul>
<p><strong>border-color：红，绿;</strong></p>
<ul>
<li>顶部和底部边框是红色</li>
<li>左右边框是绿色</li>
</ul>
<p><strong>border-color：红色;</strong></p>
<ul>
<li>所有四个边框是红色</li>
</ul>
<p>请始终把 border-style 属性声明到 border-color 属性之前。元素必须在您改变其颜色之前获得边框。</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>color</em></td>
<td align="left">指定背景颜色。在CSS颜色值查找颜色值的完整列表</td>
</tr>
<tr>
<td align="left">transparent</td>
<td align="left">指定边框的颜色应该是透明的。这是默认</td>
</tr>
<tr>
<td align="left">inherit</td>
<td align="left">指定边框的颜色，应该从父元素继承</td>
</tr>
</tbody></table>
<h1 id="颜色渐变"><a href="#颜色渐变" class="headerlink" title="颜色渐变"></a>颜色渐变</h1><h2 id="一-线性渐变（Linear-Gradients）"><a href="#一-线性渐变（Linear-Gradients）" class="headerlink" title="一 . 线性渐变（Linear Gradients）"></a>一 . 线性渐变（Linear Gradients）</h2><ul>
<li>background: linear-gradient(direction, color-stop1, color-stop2, …);   <ul>
<li>background: -webkit-linear-gradient(red, blue); /* Safari  */ </li>
<li>background: -o-linear-gradient(red, blue); /* Opera **/ *</li>
<li>background: -moz-linear-gradient(red, blue); /* Firefox  */ </li>
<li>background: linear-gradient(red, blue); /* 标准的语法 */ </li>
</ul>
</li>
</ul>
<h2 id="二-径向渐变（Radial-Gradients）"><a href="#二-径向渐变（Radial-Gradients）" class="headerlink" title="二 . 径向渐变（Radial Gradients）"></a>二 . 径向渐变（Radial Gradients）</h2><ul>
<li><p>默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。</p>
</li>
<li><p>background: radial-gradient(center, shape size, start-color, …, last-color);  </p>
</li>
<li><p><strong>径向渐变 - 颜色结点不均匀分布</strong></p>
<ul>
<li>background: -webkit-radial-gradient(red 5%, green 15%, blue 60%);</li>
</ul>
</li>
<li><p>shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse。</p>
<h5 id="不同尺寸大小关键字的使用"><a href="#不同尺寸大小关键字的使用" class="headerlink" title="不同尺寸大小关键字的使用"></a>不同尺寸大小关键字的使用</h5><p>size 参数定义了渐变的大小。它可以是以下四个值：</p>
<ul>
<li><strong>closest-side</strong></li>
<li><strong>farthest-side</strong></li>
<li><strong>closest-corner</strong></li>
<li><strong>farthest-corner</strong></li>
</ul>
</li>
</ul>
<h3 id="三-透明度transparency"><a href="#三-透明度transparency" class="headerlink" title="三 . 透明度transparency"></a>三 . 透明度transparency</h3><ul>
<li>用于创建减弱变淡的效果；为了添加透明度，我们使用 rgba() 函数来定义颜色结点。rgba() 函数中的最后一个参数可以是从 0 到 1 的值，它定义了颜色的透明度：0 表示完全透明，1 表示完全不透明。</li>
<li>repeating-linear-gradient() 函数用于重复线性渐变：</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-js精研" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/17/js精研/" class="article-date">
      <time datetime="2020-06-17T07:15:42.000Z" itemprop="datePublished">2020-06-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/js精研/">js精研</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="一-基础补充"><a href="#一-基础补充" class="headerlink" title="一 . 基础补充"></a>一 . 基础补充</h2><h4 id="1-值，变量和类型"><a href="#1-值，变量和类型" class="headerlink" title="1.值，变量和类型"></a>1.值，变量和类型</h4><ul>
<li><p>typeof  undefined;//“undefined”</p>
</li>
<li><p>js是基于32位整数的</p>
</li>
<li><p>以下两种情况，js会自动将数值转为科学计数法</p>
<ul>
<li>小数点前的数字多于21位</li>
<li>小数点后的0多于5个</li>
</ul>
</li>
<li><p>在js内部，实际存在两个0：+0和-0，他们是等价的</p>
</li>
<li><p>当js在算数运算时发生溢出（overflow，结果是Infinity），下溢（underflow，结果是-Infinity）或被0整除时不会报错</p>
</li>
<li><p>Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。isFinite函数返回一个布尔值，检查某个值是不是正常数值，而不是Infinity。</p>
</li>
<li><p><strong>注意</strong>：0除以0是无意义的，会返回NaN</p>
<ul>
<li>isNaN判断一个值是否为NaN，它只对数值有效，若传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true时，有可能不是NaN，而不是一个字符串</li>
<li>使用isNaN前，最好判断一下数据类型  typeof  value===’number’&amp;&amp; isNaN(value)</li>
<li>判断NaN更可靠的方法是利用NaN在js中唯一不等于自身的值这个特点进行判断   value!==value</li>
</ul>
</li>
<li><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。</p>
<ul>
<li><p>length属性返回字符串的长度，该属性也是无法改变的。</p>
</li>
<li><p>如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。</p>
</li>
<li><p>注意：字符串与数组仅仅是相似而已。字符串是无法改变字符串之中的单个字符。</p>
<p>var a = ‘hello’;</p>
<p>delete s[0];</p>
<p>s // “hello”</p>
<p>s[0] = ‘a’;</p>
<p>s  // “hello”</p>
</li>
</ul>
</li>
<li><p>尽管null和undefined是不同的，但它们都表示“值的空缺”，两者往往可以互换。当用相等运算符“==”来比较两者时，会返回true。（要使用严格相等运算符“===”来区分它们）</p>
</li>
<li><p>如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。</p>
<p>undefined<br>null<br>false<br>0<br>NaN<br>“”或’’（空字符串）</p>
</li>
<li><p>如果一个变量没有声明就直接使用，JavaScript会<strong>报错</strong>，告诉你变量未定义。</p>
</li>
<li><p><strong>声明提前（变量提升）</strong> </p>
<ul>
<li>JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就是声明提前（变量提升，hoisting）。</li>
<li>变量提升只对var命令声明的变量有效，如果一个变量不是用var命令声明的，就不会发生变量提升。</li>
</ul>
</li>
<li><p>typeof运算符对未声明的变量运算，不会报错，输出值也是“undefined”，故不能区分该值是否已声明，但是其他运算符对未声明变量进行运算会报错</p>
</li>
<li><p><strong>对于浮点字面量的有趣之处在于，用它进行计算之前，真正存储的是字符串。</strong>任何值在输出时一般都会转化成字符串输出</p>
</li>
<li><p>ECMAScript默认把具有6个或6个以上前导0的浮点数转化成科学计数法。也可以用64位IEEE 754形式存储浮点值，这意味着十进制最多可以有17个十进制位，17位之后的值将被裁剪，从而造成较小的误差</p>
</li>
<li><p>当计算生成的数大于 Number.MAX_VALUE 时，它将被赋予值Number.POSITIVE_INFINITY，意味着不再有数字值。同样，生成的数值小于Number.MIN_VALUE 的计算也会被赋予值Number.NEGATIVE_INFINITY，也意味着不再有数字值。如果计算返回的是无穷大值，那么生成的结果不能再用于其他计算。</p>
</li>
<li></li>
</ul>
<h4 id="2-语句"><a href="#2-语句" class="headerlink" title="2.语句"></a>2.语句</h4><ul>
<li><p><strong>注意</strong>：由于对每个case的匹配操作实际是“===”恒等运算符比较，而不是“==”相等运算符比较，因此，表达式和case的匹配并不会做任何类型转换。</p>
</li>
<li><p>使用while(true)则会创建一个死循环。</p>
</li>
<li><p><strong>标签语句</strong></p>
<ul>
<li><p>语句是可以添加标签的，标签是由语句前的标识符和冒号组成：</p>
<p>label  :  statement</p>
</li>
</ul>
</li>
<li><p>return语句只能在函数体内出现，否则报错。当执行到return语句时，函数终止执行。</p>
</li>
<li><p><strong>throw语句</strong>:异常是指当发生了某种异常情况或错误时产生的一个信号。</p>
</li>
<li><p>with语句：用于临时扩展作用域链</p>
<p>with ( object ){</p>
<p>statement</p>
<p>}</p>
<p>将object添加到作用域链的头部，然后执行statement，最后把作用域链恢复到原生状态。</p>
<p>注意：在严格模式中是禁止使用with语句的。</p>
</li>
<li><p>debugger语句用来产生一个断点（breakpoint），JavaScript代码的执行会停止在断点的位置。一般用来调试代码。</p>
</li>
<li><p><strong>“use strict”</strong></p>
<p>使用”use strict”指令的目的是说明后续的代码将会解析成严格代码。</p>
</li>
</ul>
<h4 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h4><ul>
<li><p>对象是一个基本数据类型，成员以键值对形式存在</p>
</li>
<li><p>键名：对象的所有键名都是字符串，所以加不加引号都可以。如果键名是数值，会被自动转为字符串。</p>
</li>
<li><p>对象的每一个“键名”又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。</p>
</li>
<li><p>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），也不是数字，则必须加上引号，否则会报错。</p>
</li>
<li><p>为了避免这种歧义，JavaScript规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。</p>
</li>
<li><p><strong>创建对象</strong></p>
<p>在JavaScript中，有三种方法创建对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象直接量： var o=&#123;&#125;;</span><br><span class="line">关键字new： var o=new Object();</span><br><span class="line">Object.create()函数： var o=Object.create(null)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象直接量中的最后一个属性后的逗号可有可无，但是在ie中，如果多了一个逗号，会报错。<strong>通过new创建对象</strong></p>
<p>new运算符创建并初始化一个新对象。关键字new后跟随一个函数调用，这个函数称做<strong>构造函数</strong>（constructor）。</p>
</li>
<li><p>属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性。</p>
</li>
<li><p>读取对象的属性</p>
<ul>
<li>有两种方法，一种是使用点运算符（最终还是得先变成方括号），还有一种是使用方括号运算符</li>
<li>数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。</li>
<li>通过点（.）或方括号（[]）运算符来获取属性的值时，运算符左侧应当是一个表达式，它返回一个对象。</li>
</ul>
</li>
<li><p>查看一个对象本身的所有属性，可以使用Object.keys方法，返回一个类数组</p>
<p>var o = {</p>
<p>  name : ‘a’,</p>
<p>  age : 12</p>
<p>}</p>
<p>Object.keys(o)  //[‘name’,’age’]</p>
</li>
<li><p><strong>删除属性</strong></p>
<ul>
<li><p>delete运算符只能删除自有属性，不能删除继承属性。</p>
</li>
<li><h6 id="删除一个不存在的属性，delete不报错，而且返回true。"><a href="#删除一个不存在的属性，delete不报错，而且返回true。" class="headerlink" title="删除一个不存在的属性，delete不报错，而且返回true。"></a>删除一个不存在的属性，delete不报错，而且返回true。</h6></li>
<li><p>只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。</p>
</li>
</ul>
</li>
<li><p><strong>检测属性</strong>是否存在于某个对象中</p>
<ul>
<li><p>用“！==”来判断一个属性是否是undefined（无法判断属性是否是继承来的）</p>
</li>
<li><h6 id="hasOwnPreperty（）方法：检测的是自身属性，无关继承来的属性"><a href="#hasOwnPreperty（）方法：检测的是自身属性，无关继承来的属性" class="headerlink" title="hasOwnPreperty（）方法：检测的是自身属性，无关继承来的属性"></a>hasOwnPreperty（）方法：检测的是自身属性，无关继承来的属性</h6></li>
<li><h6 id="propertyIsEnumerable（）方法：只有检测到自有属性且这个属性的可枚举性为true时才返回true"><a href="#propertyIsEnumerable（）方法：只有检测到自有属性且这个属性的可枚举性为true时才返回true" class="headerlink" title="propertyIsEnumerable（）方法：只有检测到自有属性且这个属性的可枚举性为true时才返回true"></a>propertyIsEnumerable（）方法：只有检测到自有属性且这个属性的可枚举性为true时才返回true</h6></li>
<li><p>in元素符左侧属性名（字符串），右侧是对象。如果对象的自有属性或继承属性中包含这个属性就返回true（无法判断属性是否是继承来的）</p>
</li>
</ul>
</li>
<li><p>对象的三大属性</p>
<ul>
<li>每个对象都有与之相关的<strong>原型（prototype）</strong>，类（class）和可扩展性（extensible  attribute）</li>
<li>将对象作为参数传入Object.getPrototypeOf()可以查询他的原型</li>
<li>检测一个对象是否是另一个对象的原型，可使用isPrototypeOf（）方法</li>
</ul>
</li>
<li><p>序列化对象</p>
<ul>
<li><p>对象序列化是指将对象的状态转换为字符串，也可将字符串还原为对象</p>
</li>
<li><p>在js中，提供内置函数JSON.stringify（）和JSON.parse（）用来序列化和还原js对象</p>
</li>
<li><p>NaN,Infinity和-Infinity序列化的结果是null</p>
<p>var o = {</p>
<p>  name : ‘a’,</p>
<p>  age : 12,</p>
<p>  intro : [false,null,’’]</p>
<p>}</p>
<p>s= JSON.stringify(o)  // s {“name”:”a”,”age”:12,”intro”:[false,null,””]}</p>
<p>p=JSON.parse(s)  // p是o的深拷贝</p>
</li>
<li><p>JSON.stringify（）只能序列化对象可枚举的自有属性，对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉</p>
</li>
<li><p>深拷贝与浅拷贝的区别</p>
<ul>
<li><p>浅拷贝只是复制了对象的地址，两个对象指向同一个地址，所以修改其中的值，另一个值都会随之改变</p>
</li>
<li><p>深拷贝是将对象及值复制过来，两个对象修改其中任意值，另一个值不会随之改变，这就是深拷贝（如：JSON.stringify（）和JSON.parse（），但是此方法无法复制函数数据类型）</p>
</li>
<li><p>当你需要深拷贝对象中的方法时可使用lodash.js（提高js原生方法性能的js库）中的cloneDeep（）方法</p>
<p>var objA = { “name”: “戈德斯文” };</p>
<p>var objB =lodash.cloneDeep(objA);</p>
</li>
<li><p>深拷贝首推的方法简单有效，JSON.stringfy()和JSON.parse()即可搞定。但是这种简单粗暴的方法有其局限性。当值为<code>undefined</code>、<code>function</code>、<code>symbol</code> 会在转换过程中被忽略。所以，对象值有这三种的话用这种方法会导致属性丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var syb = Symbol(&apos;obj&apos;);</span><br><span class="line">var person = &#123;</span><br><span class="line">   name :&apos;tino&apos;,</span><br><span class="line">   say: function()&#123;</span><br><span class="line">      console.log(&apos;hi&apos;);</span><br><span class="line">   &#125;,</span><br><span class="line">   ok: syb,</span><br><span class="line">   un: undefined</span><br><span class="line">&#125;</span><br><span class="line">var copy = JSON.parse(JSON.stringify(person))</span><br><span class="line">// copy</span><br><span class="line">// &#123;name: &quot;tino&quot;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>js中对象的可枚举属性和不可枚举属性是由属性的enumerable值决定的。可枚举性决定了这个属性能否被for….in查找遍历到</p>
<ul>
<li>js中的基本包装类的原型属性是不可枚举的，如Object，Array，Number，这些对象的内置属性是不可枚举的</li>
<li>需要注意的是：如果判断的属性存在于Object对象的原型内，不管它是否可枚举都会返回false。</li>
</ul>
</li>
<li><p>构造函数是用来生成“对象”的函数。一个构造函数可生成多个对象，这些对象都有相同的结构</p>
<ul>
<li><p>构造函数的特点：函数体内使用this关键字代表所要生成的对象实例。生成对象时，必须用new命令，构造函数名字的首字母通常大写</p>
</li>
<li><p>new命令本身就可以执行构造函数，所以后面的构造函数可带括号可不带</p>
<p>var c = new Car();</p>
<p>var c = new Car;</p>
</li>
<li><p>每一个构造函数都有prototype属性</p>
</li>
</ul>
</li>
</ul>
<h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><p><strong>事件机制之冒泡、传播、委托</strong></p>
<p>DOM事件流（event flow）存在三个阶段：<strong>事件捕获阶段，处于目标阶段，事件冒泡阶段</strong>。</p>
<h4 id="事件捕获阶段（event-capuring）"><a href="#事件捕获阶段（event-capuring）" class="headerlink" title="事件捕获阶段（event  capuring）"></a>事件捕获阶段（event  capuring）</h4><p>通俗理解就是，当鼠标点击或触发dom事件时，浏览器会从根节点<strong>由外往内</strong>进行事件传播，即点击了子元素，如果父元素通过事件捕获注册了对应的事件的话，会先触发父元素绑定的的事件。</p>
<h4 id="事件冒泡（dubbed-bubbling）"><a href="#事件冒泡（dubbed-bubbling）" class="headerlink" title="事件冒泡（dubbed bubbling）"></a>事件冒泡（dubbed bubbling）</h4><p>与事件捕获相反，事件冒泡是从目标元素<strong>由内往外</strong>进行事件传播，直到根节点。</p>
<p>无论是事件冒泡还是事件捕获，都有一个共同点就是事件传播，她就像一根引线，只有通过引线才能将绑在引线上的鞭炮（事件监听器）引爆，试想一下，如果引线不导火了，那鞭炮就只有一响了！</p>
<p>dom事件标准事件流的触发先后顺序是：<strong>先捕获后冒泡</strong>，即当触发dom事件时，会进行事件捕获，捕获到事件源后通过事件传播进行事件冒泡。不同浏览器对此有不同的实现，IE10及以下不支持捕获型事件，所以就少了一个时间捕获阶段，IE11,Chrome，Firefox，Safari等浏览器则同时存在。</p>
<h4 id="事件绑定的方法"><a href="#事件绑定的方法" class="headerlink" title="事件绑定的方法"></a>事件绑定的方法</h4><h6 id="addEventlistener-event-listener-useCapture"><a href="#addEventlistener-event-listener-useCapture" class="headerlink" title="addEventlistener(event,listener,useCapture)"></a>addEventlistener(event,listener,useCapture)</h6><p>参数定义：event——（事件名称：如click，不带on）</p>
<p>listener——事件监听函数，</p>
<p>useCapture——是否采用事件捕获进行事件捕获，默认为false，即采用事件冒泡方式。</p>
<p>addEventListener在IE11，Chrome，Firefox，Safari等浏览器都得到支持。</p>
<h6 id="attachEvent（event，listener）"><a href="#attachEvent（event，listener）" class="headerlink" title="attachEvent（event，listener）"></a>attachEvent（event，listener）</h6><p>参数定义：event—（事件名称，如onclick，带on），</p>
<p>listener—事件监听函数。</p>
<p>attachEvent主要用于IE浏览器，并且仅在IE10及以下才支持，IE11已经废了这个方法了</p>
<h6 id="事件冒泡例子"><a href="#事件冒泡例子" class="headerlink" title="事件冒泡例子"></a>事件冒泡例子</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">    #parent&#123;width:200px;height:200px;background:yellow;margin:10px auto;border:1px solid black;&#125;</span><br><span class="line">    #children&#123;width:50px;height:50px;background:pink;margin:80px auto;&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;children&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var children = document.getElementById(&apos;children&apos;);</span><br><span class="line">    var parent = document.getElementById(&apos;parent&apos;);</span><br><span class="line">    document.body.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;body&apos;)&#125;,false);</span><br><span class="line">    parent.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;parent&apos;)&#125;,false);</span><br><span class="line">    children.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;children&apos;);</span><br><span class="line">    //event.stopProparation;</span><br><span class="line">    //可停止事件传播&#125;,false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当点击子盒子时，打印结果依次为children——parent——body</p>
<p>事件触发的顺序是由内到外的，这就是事件冒泡，虽然只点击了子元素，但是他的父元素也会触发相应的事件，其实这也是合理的，因为父元素里面，点击了子元素不就相当于变相的点击了父元素。</p>
<p>若不想触发父元素可停止事件传播只需在子元素中添加<strong>event.stopProparation;</strong>即可。</p>
<h6 id="事件捕获例子"><a href="#事件捕获例子" class="headerlink" title="事件捕获例子"></a>事件捕获例子</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">    body&#123;background: green;&#125;</span><br><span class="line">    #parent&#123;width:200px;height:200px;background:yellow;margin:10px auto;border:1px solid black;&#125;</span><br><span class="line">    #children&#123;width:50px;height:50px;background:pink;margin:80px auto;&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;children&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var children = document.getElementById(&apos;children&apos;);</span><br><span class="line">    var parent = document.getElementById(&apos;parent&apos;);</span><br><span class="line">    document.body.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;body&apos;)&#125;,true);</span><br><span class="line">    parent.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;parent&apos;)&#125;,true);</span><br><span class="line">    children.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;children&apos;)&#125;,true);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>点击children方块，打印body——parent——childre</p>
<p>点击parent方块，打印body——parent</p>
<p>点击body区域，打印body</p>
<p>事件通过事件捕获的方式注册了click事件，所以在事件捕获阶段就会触发，先是触发最外围注册了事件捕获的body，而后触发事件捕获的parent，最后触发事件源。这就是事件的时间流程。</p>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><h4 id="高质量代码"><a href="#高质量代码" class="headerlink" title="高质量代码"></a>高质量代码</h4><ul>
<li>bug暴露</li>
<li>不扩展内置原型，多用this取代构造函数的prototype</li>
<li>使用switch模式增强可读性和健壮性</li>
<li>使用绝对相等或绝对不等，避免隐式类型转换</li>
<li>避免使用eval（），因此方法接受任意的字符串，被执行的代码可能被篡改，有极大的安全隐患。且会污染全局变量</li>
<li>用方括号表示法访问动态属性</li>
<li>parseInt（）下数值转换，最好指定基数参数，不然，可能以0开头的数据被当成8进制使用</li>
</ul>
<h4 id="提高性能"><a href="#提高性能" class="headerlink" title="提高性能"></a>提高性能</h4><h6 id="（类）数组循环获取值时缓存长度"><a href="#（类）数组循环获取值时缓存长度" class="headerlink" title="（类）数组循环获取值时缓存长度"></a>（类）数组循环获取值时缓存长度</h6><ul>
<li>不足：每次循环时数组的长度都要去获取，会降低代码</li>
<li>若是类数组，需实时查询基本文档（html页面），这意味着每次你访问任何集合的长度，你要实时查询DOM，而DOM操作一般都是比较昂贵的。</li>
<li>解决：把数组长度放在一个变量里；从后往下标为0的数数，因为和0做比较要比和数组长度或是其他不是0的东西作比较更有效率。</li>
</ul>
<h6 id="for循环遍历数组，for-in循环遍历类数组"><a href="#for循环遍历数组，for-in循环遍历类数组" class="headerlink" title="for循环遍历数组，for-in循环遍历类数组"></a>for循环遍历数组，for-in循环遍历类数组</h6><h6 id="遍历属性时使用hasOwnProperty（）方法过滤原型上的属性"><a href="#遍历属性时使用hasOwnProperty（）方法过滤原型上的属性" class="headerlink" title="遍历属性时使用hasOwnProperty（）方法过滤原型上的属性"></a>遍历属性时使用hasOwnProperty（）方法过滤原型上的属性</h6><h4 id="var的作用"><a href="#var的作用" class="headerlink" title="var的作用"></a>var的作用</h4><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul>
<li>避免创建隐式全局变量：1.函数中未声明就使用变量  2.使用任务链进行部分var声明</li>
<li>可移植性：可在不同主机上使用</li>
</ul>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>通过var创建的全局变量不可通过delete删除，无var创建的隐式全局变量（并非真正的全局变量，只是全局变量的属性）可通过delete删除</li>
</ul>
<h4 id="执行层面"><a href="#执行层面" class="headerlink" title="执行层面"></a>执行层面</h4><h6 id="代码处理的两个阶段（预解析hoisting）"><a href="#代码处理的两个阶段（预解析hoisting）" class="headerlink" title="代码处理的两个阶段（预解析hoisting）"></a>代码处理的两个阶段（预解析hoisting）</h6><ul>
<li>变量，函数声明，以及正常格式的参数创建，这是一个解析和进入上下文的阶段</li>
<li>代码执行，函数表达式和不合格的标识符（为声明的变量）被创建。</li>
</ul>
<h2 id="二-JavaScript对象"><a href="#二-JavaScript对象" class="headerlink" title="二 . JavaScript对象"></a>二 . JavaScript对象</h2><ul>
<li><p>JavaScript是一种直译式脚本语言，是一种动态类型，弱类型，基于原型的语言，内置支持类型</p>
</li>
<li><h6 id="日常用途"><a href="#日常用途" class="headerlink" title="日常用途"></a>日常用途</h6><ol>
<li>嵌入动态文本于HTML页面。</li>
<li>对浏览器事件做出响应。</li>
<li>读写<a href="https://www.w3cschool.cn/html/html-elements.html" target="_blank" rel="noopener">HTML元素</a>。 </li>
<li>在数据被提交到服务器之前验证数据。</li>
<li>检测访客的浏览器信息。 </li>
<li>控制cookies，包括创建和修改等。</li>
<li>基于Node.js技术进行服务器端编程。</li>
</ol>
</li>
</ul>
<h4 id="对象公共属性"><a href="#对象公共属性" class="headerlink" title="对象公共属性"></a>对象公共属性</h4><h5 id="1-constructor属性"><a href="#1-constructor属性" class="headerlink" title="1.constructor属性"></a>1.constructor属性</h5><ul>
<li>constructor属性返回对创建此对象的函数的引用</li>
<li>函数对象。 返回创建布尔对象的函数原型。=函数.constructor;</li>
</ul>
<h5 id="2-prototype属性"><a href="#2-prototype属性" class="headerlink" title="2.prototype属性"></a>2.prototype属性</h5><ul>
<li>是您有能力向对象添加属性和方法</li>
<li>当构造一个原型，所有的对应对象默认都添加了属性和方法</li>
<li>每个js对象（除了null）都和另一个对象相关联，即继承另一个对象。另一个对象就是我们熟知的“原型（prototype），每个对象都从原型继承属性。只有null除外，他没有自己的原型对象</li>
<li>通过Object.prototype获得对原型对象的引用，通过对象或构造函数调用创建的对象的原型就是构造函数的prototype属性的值，找不到原型，返回undefined</li>
</ul>
<h5 id="3-toString（-把对象转为字符串并返回结果"><a href="#3-toString（-把对象转为字符串并返回结果" class="headerlink" title="3.toString（)把对象转为字符串并返回结果"></a>3.toString（)把对象转为字符串并返回结果</h5><ul>
<li>String=对象.toString()</li>
</ul>
<h5 id="4-valueOf（）-返回对象的原始值"><a href="#4-valueOf（）-返回对象的原始值" class="headerlink" title="4.valueOf（）  返回对象的原始值"></a>4.valueOf（）  返回对象的原始值</h5><p>Array=<em>array</em>.valueOf()  不会改变原数组</p>
<h5 id="5-Object-getPrototypeOf"><a href="#5-Object-getPrototypeOf" class="headerlink" title="5.Object.getPrototypeOf()"></a>5.Object.getPrototypeOf()</h5><ul>
<li>返回一个对象的原型</li>
</ul>
<h5 id="6-Object-setPrototypeOf"><a href="#6-Object-setPrototypeOf" class="headerlink" title="6.Object.setPrototypeOf()"></a>6.Object.setPrototypeOf()</h5><ul>
<li>为现有对象设置原型，返回一个新对象</li>
<li>接受两个参数，第一个是现有对象，第二个是原型对象</li>
</ul>
<h5 id="7-Object-create"><a href="#7-Object-create" class="headerlink" title="7.Object.create()"></a>7.Object.create()</h5><ul>
<li>用于从原型对象生成新的实例对象，可以替代new命令</li>
<li>它接受一个对象作为参数，返回一个新的对象，后者完全继承前者的属性，即原有对象成为新对象的原型</li>
</ul>
<h5 id="8-Object-prototype-isPrototypeOf"><a href="#8-Object-prototype-isPrototypeOf" class="headerlink" title="8.Object.prototype.isPrototypeOf()"></a>8.Object.prototype.isPrototypeOf()</h5><ul>
<li>判断一个对象是否是另一个对象的原型</li>
<li>Object.prototype.isPrototypeOf({}) //true</li>
</ul>
<h5 id="9-Object-prototype-proto"><a href="#9-Object-prototype-proto" class="headerlink" title="9.Object.prototype.proto_"></a>9.Object.prototype.<em>proto_</em></h5><p>_proto__属性（前后各两个下划线）可以改写某个对象的原型对象</p>
<h5 id="10-Object-getPropertyOfNames"><a href="#10-Object-getPropertyOfNames" class="headerlink" title="10.Object.getPropertyOfNames()"></a>10.Object.getPropertyOfNames()</h5><ul>
<li>该方法返回一个数组，成员是对象本身的所有属性的键名，不包含的属性键名</li>
</ul>
<h5 id="11-Object-prototype-hasOwnProperty"><a href="#11-Object-prototype-hasOwnProperty" class="headerlink" title="11.Object.prototype.hasOwnProperty()"></a>11.Object.prototype.hasOwnProperty()</h5><ul>
<li>返回一个布尔值，用于判断某个属性定义在对象本身还是在原型链上</li>
</ul>
<h3 id="1-Array数组对象"><a href="#1-Array数组对象" class="headerlink" title="1.Array数组对象"></a>1.Array数组对象</h3><ul>
<li>数组对象的作用是使用单独的变量名来存储一系列的值</li>
<li>length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。</li>
</ul>
<h5 id="1-concat（）连接两个或多个数组"><a href="#1-concat（）连接两个或多个数组" class="headerlink" title="1.concat（）连接两个或多个数组"></a>1.concat（）连接两个或多个数组</h5><ul>
<li>该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本</li>
<li><em>array1</em>.concat(<em>array2</em>,<em>array3</em>,…,<em>arrayX</em>)</li>
</ul>
<h5 id="2-every（-检查所有数组元素-返回boolear"><a href="#2-every（-检查所有数组元素-返回boolear" class="headerlink" title="2.every（)检查所有数组元素,返回boolear"></a>2.every（)检查所有数组元素,返回boolear</h5><ul>
<li><p>用于检测数组所有元素是否都符合指定条件（通过函数提供），只有所有元素都满足条件才返回true</p>
</li>
<li><p>every（）不会对空数组进行检测，且不会改变原始数组</p>
</li>
<li><p>array.every（function（currentValue，index，arr），thisValue）</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>function(currentValue, index,arr)</em></td>
<td align="left">必须。函数，数组中的每个元素都会执行这个函数 函数参数: 参数描述<em>currentValue</em>必须。当前元素的值<em>index</em>可选。当期元素的索引值<em>arr</em>可选。当期元素属于的数组对象</td>
</tr>
<tr>
<td align="left"><em>thisValue</em></td>
<td align="left">可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。 如果省略了 thisValue ，”this” 的值为 “undefined”</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="3-filter-创建所有符合条件元素的数组"><a href="#3-filter-创建所有符合条件元素的数组" class="headerlink" title="3.filter()创建所有符合条件元素的数组"></a>3.filter()创建所有符合条件元素的数组</h5><ul>
<li>创建一个新数组，不会对空数据进行检测，也不会改变原始数组.如果没有符合条件的元素则返回空数组。</li>
<li>array.filter(function(currentValue,index,arr),thisValue)</li>
</ul>
<h5 id="4-indexOf（）返回指定字符串值首次出现的位置"><a href="#4-indexOf（）返回指定字符串值首次出现的位置" class="headerlink" title="4.indexOf（）返回指定字符串值首次出现的位置"></a>4.indexOf（）返回指定字符串值首次出现的位置</h5><ul>
<li>array.indexOf(item,start)</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>item</em></td>
<td align="left">必须。查找的元素。</td>
</tr>
<tr>
<td align="left"><em>start</em></td>
<td align="left">可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。</td>
</tr>
</tbody></table>
<ul>
<li>返回值为number值，如果没有搜索到则返回-1</li>
<li>lastIndexOf()  查找字符串最后出现的位置</li>
</ul>
<h5 id="5-join-把数组中的所有元素为一个字符串"><a href="#5-join-把数组中的所有元素为一个字符串" class="headerlink" title="5.join()  把数组中的所有元素为一个字符串"></a>5.join()  把数组中的所有元素为一个字符串</h5><ul>
<li><p>元素是通过指定的分隔符进行分隔的</p>
</li>
<li><p>string =array.join(separator)</p>
<p>参数separator是可选的，是指定要使用的分隔符，若省略，默认使用逗号</p>
<p>返回值是一字符串。该字符串是通过把arrayObject的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入separator字符串生成</p>
</li>
</ul>
<h5 id="6-map（）通过指定函数处理原始数组，并返回处理后的数组"><a href="#6-map（）通过指定函数处理原始数组，并返回处理后的数组" class="headerlink" title="6.map（）通过指定函数处理原始数组，并返回处理后的数组"></a>6.map（）通过指定函数处理原始数组，并返回处理后的数组</h5><ul>
<li>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。map() 方法按照原始数组元素顺序依次处理元素。</li>
<li>map() 不会对空数组进行检测。map() 不会改变原始数组。</li>
<li>array.map(function(currentValue,index,arr),thisValue)</li>
</ul>
<h5 id="7-pop-删除数组最后一个元素并返回处理后的数组"><a href="#7-pop-删除数组最后一个元素并返回处理后的数组" class="headerlink" title="7.pop()删除数组最后一个元素并返回处理后的数组"></a>7.pop()删除数组最后一个元素并返回处理后的数组</h5><ul>
<li>array.pop();</li>
<li>array.shift();删除数组的第一个元素</li>
</ul>
<h5 id="8-push-向数组的末尾添加一个或更多元素，并返回新的长度"><a href="#8-push-向数组的末尾添加一个或更多元素，并返回新的长度" class="headerlink" title="8.push()向数组的末尾添加一个或更多元素，并返回新的长度"></a>8.push()向数组的末尾添加一个或更多元素，并返回新的长度</h5><ul>
<li>Number =array.push(item1,item2,…,itemX);</li>
<li>array.unshift(item1,item2,…,itemX)) ; 向数组的开头添加一个或多个元素，并返回新的长度</li>
</ul>
<h5 id="9-reverse-颠倒数组中元素的顺序"><a href="#9-reverse-颠倒数组中元素的顺序" class="headerlink" title="9.reverse()颠倒数组中元素的顺序"></a>9.reverse()颠倒数组中元素的顺序</h5><ul>
<li>不影响原数组</li>
</ul>
<ul>
<li>Array=array.reverse()；</li>
</ul>
<h5 id="10-slice（）选取数组中的一部分，并返回一个新数组"><a href="#10-slice（）选取数组中的一部分，并返回一个新数组" class="headerlink" title="10.slice（）选取数组中的一部分，并返回一个新数组"></a>10.slice（）选取数组中的一部分，并返回一个新数组</h5><ul>
<li><p>新数组中不包括end对应的值</p>
</li>
<li><p>Array=array.slice(start,end);</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>start</em></td>
<td align="left">必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</td>
</tr>
<tr>
<td align="left"><em>end</em></td>
<td align="left">可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</td>
</tr>
</tbody></table>
<h5 id="11-some-检测数组元素中是否有元素符合指定条件"><a href="#11-some-检测数组元素中是否有元素符合指定条件" class="headerlink" title="11.some()检测数组元素中是否有元素符合指定条件"></a>11.some()检测数组元素中是否有元素符合指定条件</h5><ul>
<li>some() 方法会依次执行数组的每个元素：如果有一个元素满足条件，则表达式返回<em>true</em> , 剩余的元素不会再执行检测。如果没有满足条件的元素，则返回false。</li>
<li>Boolean =array.some(function(currentValue,index,arr),thisValue);</li>
</ul>
<h5 id="12-sort-对数组的元素进行排序"><a href="#12-sort-对数组的元素进行排序" class="headerlink" title="12.sort()对数组的元素进行排序"></a>12.sort()对数组的元素进行排序</h5><ul>
<li><p>排序顺序可以是字符或数字，并按升序或降序。默认按字母升序。 这种方法会改变原始数组！</p>
</li>
<li><p><strong>注意：</strong>当数字是按字母顺序排列时”40”将排在”5”前面。使用数字排序，你必须通过一个函数作为参数来调用。函数指定数字是按照升序还是降序排列。</p>
</li>
<li><p>Array =array.sort(sortfunction);</p>
<p>参数sortfunction可选，规定排定顺序，必须是函数</p>
<p>返回值Array是对原数组的引用。<strong>注意</strong>，数组在原数组进行排序，不生成副本</p>
</li>
</ul>
<h5 id="13-splice（）从数组中添加或删除，替换元素"><a href="#13-splice（）从数组中添加或删除，替换元素" class="headerlink" title="13.splice（）从数组中添加或删除，替换元素"></a>13.splice（）从数组中添加或删除，替换元素</h5><ul>
<li><p>改变原数组</p>
</li>
<li><p>Array =array.splice(index,howmany,item1,item2,…,itemsX);</p>
<p>参数index是必须的，规定从何处添加或删除元素，该参数是开始插入或删除的数组元素的下标，必须是数字</p>
<p>howmany是必填项，规定应该删除多少元素，若未规定，则默认从index开始删除直到原数组结尾的所有元素</p>
<p>item1，可选，要添加到数组的新元素</p>
</li>
</ul>
<h5 id="14-toString（-把数组转为字符串并返回结果"><a href="#14-toString（-把数组转为字符串并返回结果" class="headerlink" title="14.toString（)把数组转为字符串并返回结果"></a>14.toString（)把数组转为字符串并返回结果</h5><ul>
<li>数组元素之间用逗号分隔</li>
<li>String=array.toString()</li>
</ul>
<h5 id="15-valueOf（）-返回数组对象的原始值"><a href="#15-valueOf（）-返回数组对象的原始值" class="headerlink" title="15.valueOf（）  返回数组对象的原始值"></a>15.valueOf（）  返回数组对象的原始值</h5><p>Array=<em>array</em>.valueOf()  不会改变原数组</p>
<h5 id="16-reduce-返回累计值"><a href="#16-reduce-返回累计值" class="headerlink" title="16.reduce()返回累计值"></a>16.reduce()返回累计值</h5><ul>
<li>定义：对数组中的每个元素执行一个自定义的累计器，将其结果汇总为单个返回值</li>
<li>形式：<code>array.reduce((t, v, i, a) =&gt; {}, initValue)</code></li>
<li>参数<ul>
<li><strong>callback</strong>：回调函数(<code>必选</code>)</li>
<li><strong>initValue</strong>：初始值(<code>可选</code>)</li>
</ul>
</li>
<li>回调函数的参数<ul>
<li><strong>total</strong>(<code>t</code>)：累计器完成计算的返回值(<code>必选</code>)</li>
<li><strong>value</strong>(<code>v</code>)：当前元素(<code>必选</code>)</li>
<li><strong>index</strong>(<code>i</code>)：当前元素的索引(<code>可选</code>)</li>
<li><strong>array</strong>(<code>a</code>)：当前元素所属的数组对象(<code>可选</code>)</li>
</ul>
</li>
<li>过程<ul>
<li>以<code>t</code>作为累计结果的初始值，不设置<code>t</code>则以数组第一个元素为初始值</li>
<li>开始遍历，使用累计器处理<code>v</code>，将<code>v</code>的映射结果累计到<code>t</code>上，结束此次循环，返回<code>t</code></li>
<li>进入下一次循环，重复上述操作，直至数组最后一个元素</li>
<li>结束遍历，返回最终的<code>t</code></li>
</ul>
</li>
</ul>
<p><code>reduce</code>的精华所在是将累计器逐个作用于数组成员上，<strong>把上一次输出的值作为下一次输入的值</strong>。</p>
<h4 id="2-Boolean对象"><a href="#2-Boolean对象" class="headerlink" title="2.Boolean对象"></a>2.Boolean对象</h4><ul>
<li>Boolean 对象用于转换一个不是 Boolean 类型的值转换为 Boolean 类型值 (true 或者false).</li>
</ul>
<h4 id="3-Date对象"><a href="#3-Date对象" class="headerlink" title="3.Date对象"></a>3.Date对象</h4><ul>
<li>四种创建方法<ul>
<li>var d =new Date();</li>
<li>var d =new Date(<em>milliseconds</em>);</li>
<li>var d =new Date(<em>dateString</em>);</li>
<li>var d =new Date(<em>year</em>, <em>month</em>, <em>day</em>, <em>hours</em>, <em>minutes</em>, <em>seconds</em>, <em>milliseconds</em>);</li>
</ul>
</li>
</ul>
<h4 id="4-Number对象"><a href="#4-Number对象" class="headerlink" title="4.Number对象"></a>4.Number对象</h4><ul>
<li><p>Number对象是原始数值的包装对象</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-constructor-number.html" target="_blank" rel="noopener">constructor</a></td>
<td align="left">返回对创建此对象的 Number 函数的引用。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-max-value.html" target="_blank" rel="noopener">MAX_VALUE</a></td>
<td align="left">可表示的最大的数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-min-value.html" target="_blank" rel="noopener">MIN_VALUE</a></td>
<td align="left">可表示的最小的数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-negative-infinity.html" target="_blank" rel="noopener">NEGATIVE_INFINITY</a></td>
<td align="left">负无穷大，溢出时返回该值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-number-nan.html" target="_blank" rel="noopener">NaN</a></td>
<td align="left">非数字值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-positive-infinity.html" target="_blank" rel="noopener">POSITIVE_INFINITY</a></td>
<td align="left">正无穷大，溢出时返回该值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-prototype-num.html" target="_blank" rel="noopener">prototype</a></td>
<td align="left">允许您有能力向对象添加属性和方法。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-toexponential.html" target="_blank" rel="noopener">toExponential(x)</a></td>
<td align="left">把对象的值转换为指数计数法。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-tofixed.html" target="_blank" rel="noopener">toFixed(x)</a></td>
<td align="left">把数字转换为字符串，结果的小数点后有指定位数的数字。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-toprecision.html" target="_blank" rel="noopener">toPrecision(x)</a></td>
<td align="left">把数字格式化为指定的长度。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-tostring-number.html" target="_blank" rel="noopener">toString()</a></td>
<td align="left">把数字转换为字符串，使用指定的基数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-valueof-number.html" target="_blank" rel="noopener">valueOf()</a></td>
<td align="left">返回一个 Number 对象的基本数字值。</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="三-深入理解js"><a href="#三-深入理解js" class="headerlink" title="三 . 深入理解js"></a>三 . 深入理解js</h2><h4 id="1-最小全局变量（Minimizing-Globals）"><a href="#1-最小全局变量（Minimizing-Globals）" class="headerlink" title="1.最小全局变量（Minimizing Globals）"></a>1.最小全局变量（Minimizing Globals）</h4><ul>
<li><p>js通过函数管理作用域。在函数内部声明的变量只在这个函数内部，函数外面不能使用。另一方面，全局变量就是在任何函数外面声明的或是未声明直接简单实用的</p>
</li>
<li><p>每个js环境都有一个全局对象，但你在任意函数外面使用this就可以访问到。你创建的每一个全局变量都是这个全局对象的属性。在浏览器中，为方便起见，该全局对象有个附加属性叫做window，此window指向该全局对象本身</p>
</li>
<li><p>全局变量的问题在于，你的JavaScript应用程序和web页面上的所有代码都共享了这些全局变量，他们住在同一个全局命名空间，所以当程序的两个不同部分定义同名但不同作用的全局变量的时候，命名冲突在所难免。</p>
<ul>
<li>第三方的JavaScript库</li>
<li>广告方的脚本代码</li>
<li>第三方用户跟踪和分析脚本代码</li>
<li>不同类型的小组件，标志和按钮</li>
</ul>
</li>
<li><p>要想和其他脚本成为好邻居的话，尽可能少的使用全局变量是很重要的。一些减少全局变量的策略，例如命名空间模式或是函数立即自动执行，但是要想让全局变量少最重要的还是始终使用var来声明变量。</p>
</li>
<li><p>js因其特征，会不自觉地创建出全局变量。隐式创建全局变量的情况</p>
<ul>
<li><p>你可以不声明就可以使用变量，js会默认是全局对象的属性（js有隐含的全局概念）</p>
</li>
<li><p>使用任务链进行var声明    在函数内部     var  a=b=0；</p>
<p>其中a是本地变量，而b是全局变量，因为这个是从右到左的赋值，首先通过赋值表达式b=0，此情况下b是未声明的。这个表达式的值是0，然后这个0就分配给通过var定义的全局变量a。若你提前声明了变量，使用链分配是比较好的，不会产生意料之外的情况</p>
</li>
</ul>
</li>
<li><p>另外一个避免全局变量的原因是可移植性，如果你想你的代码在不同环境（主机下）运行，使用全局变量如履薄冰，因为你会无意中覆盖你最初环境下不存在的主机对象（所以你原以为名称可以放心使用，实际上对于有些情况并不适用）</p>
</li>
<li><h6 id="忘记var的副作用（Side-Effect-when-forgetting-var）"><a href="#忘记var的副作用（Side-Effect-when-forgetting-var）" class="headerlink" title="忘记var的副作用（Side Effect when forgetting  var）"></a>忘记var的副作用（Side Effect when forgetting  var）</h6><ul>
<li>隐式全局变量和明确全局变量有小差异，即通过delete操作符让变量未定义的能力。<ul>
<li>通过var创建的全局变量（任何函数之外的程序中创建）是不能被删除的</li>
<li>无var创建的隐式全局变量（无视是否在函数中创建）是能被删除的</li>
</ul>
</li>
<li>这表明，在技术上，隐式全局变量并不是真正的全局变量，但他们是全局对象的属性。属性是可以通过delete操作符删除的，而变量不能</li>
</ul>
</li>
</ul>
<p>// 定义三个全局变量<br>var global_var = 1;<br>global_novar = 2; // 反面教材<br>(function () {<br>global_fromfunc = 3; // 反面教材<br>}());<br>// 试图删除<br>delete global_var; // false<br>delete global_novar; // true<br>delete global_fromfunc; // true<br>// 测试该删除<br>typeof global_var; // “number”<br>typeof global_novar; // “undefined”<br>typeof global_fromfunc; // “undefined”</p>
<ul>
<li><h6 id="访问全局对象-Access-to-the-Global-Object"><a href="#访问全局对象-Access-to-the-Global-Object" class="headerlink" title="访问全局对象(Access to the Global Object)"></a>访问全局对象(Access to the Global Object)</h6><p>在浏览器中，全局对象可以通过<code>window</code>属性在代码的任何位置访问（除非你做了些比较出格的事情，像是声明了一个名为window的局部变量）。但是在其他环境下，这个方便的属性可能被叫做其他什么东西（甚至在程序中不可用）。如果你需要在没有硬编码的<code>window</code>标识符下访问全局对象，你可以在任何层级的函数作用域中做如下操作：</p>
</li>
</ul>
<p>var  global=(function(){</p>
<p>return  this;</p>
<p>}()); 这种方法可随时获得全局对象，因其在函数中被当作一个函数调用了（不是通过new构造），this总是指向全局对象。实际上这个病不适用于ECMAScript 5严格模式，所以，在严格模式下时，你必须采取不同的形式。例如，你正在开发一个JavaScript库，你可以将你的代码包裹在一个即时函数中，然后从 全局作用域中，传递一个引用指向this作为你即时函数的参数。</p>
<ul>
<li><h6 id="单var形式（Single-var-Pattern）"><a href="#单var形式（Single-var-Pattern）" class="headerlink" title="单var形式（Single var Pattern）"></a>单var形式（Single var Pattern）</h6><p>在函数顶部使用单var语句是比较有用的一种形式，其好处在于：</p>
<ul>
<li>提供了一个单一的地方去寻找功能所需要的所有局部变量</li>
<li>防止变量在定义之前使用的逻辑错误</li>
<li>帮助你记住声明的全局变量，因此较少了全局变量</li>
<li>少代码（类型啊传值啊单线完成）</li>
</ul>
</li>
<li><h6 id="预解析：var散布的问题-Hoisting-A-Problem-with-Scattered-vars"><a href="#预解析：var散布的问题-Hoisting-A-Problem-with-Scattered-vars" class="headerlink" title="预解析：var散布的问题(Hoisting: A Problem with Scattered vars)"></a>预解析：var散布的问题(Hoisting: A Problem with Scattered vars)</h6><p>JavaScript中，你可以在函数的任何位置声明多个var语句，并且它们就好像是在函数顶部声明一样发挥作用，这种行为称为 hoisting（悬置/置顶解析/预解析）。当你使用了一个变量，然后不久在函数中又重新声明的话，就可能产生逻辑错误。对于JavaScript，只 要你的变量是在同一个作用域中（同一函数），它都被当做是声明的，即使是它在var声明前使用的时候。</p>
<p>// 反例<br>myname = “global”; // 全局变量<br>function func() {<br>alert(myname); // “undefined”<br>var myname = “local”;<br>alert(myname); // “local”<br>}<br>func();</p>
</li>
</ul>
<h4 id="2-代码处理的两个阶段"><a href="#2-代码处理的两个阶段" class="headerlink" title="2.代码处理的两个阶段"></a>2.代码处理的两个阶段</h4><ul>
<li>第一阶段是变量，函数声明，以及正常格式的参数创建，这是一个解析和进入上下文的阶段</li>
<li>第二阶段是代码执行，函数表达式和不合格的标识符（未声明的变量）被创建</li>
</ul>
<h2 id="四-this-精讲"><a href="#四-this-精讲" class="headerlink" title="四 . this 精讲"></a>四 . this 精讲</h2><h4 id="谁调用这个函数或方法，this关键字就指向谁"><a href="#谁调用这个函数或方法，this关键字就指向谁" class="headerlink" title="谁调用这个函数或方法，this关键字就指向谁"></a>谁调用这个函数或方法，this关键字就指向谁</h4><ul>
<li>this总是返回属性或方法“当前”所在的对象</li>
<li>如果一个函数在全局环境中运行，那么this就是指顶层对象（浏览器中为window对象）。</li>
</ul>
<h4 id="1-改变this指向的三大方法"><a href="#1-改变this指向的三大方法" class="headerlink" title="1.改变this指向的三大方法"></a>1.改变this指向的三大方法</h4><h6 id="1-call、apply、bind方法的共同点和区别："><a href="#1-call、apply、bind方法的共同点和区别：" class="headerlink" title="1.call、apply、bind方法的共同点和区别："></a>1.call、apply、bind方法的共同点和区别：</h6><ul>
<li><p>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；</p>
</li>
<li><p>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文（函数的每次调用都会拥有一个特殊值——本次调用的上下文（context）——这就是this关键字的值。）；</p>
</li>
<li><p>apply 、 call 、bind 三者都可以利用后续参数传参；</p>
</li>
<li><p>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</p>
</li>
</ul>
<h6 id="2-thisObj的取值有以下4种情况："><a href="#2-thisObj的取值有以下4种情况：" class="headerlink" title="2.thisObj的取值有以下4种情况："></a>2.thisObj的取值有以下4种情况：</h6><p>（1） 不传，或者传null,undefined， 函数中的this指向window对象</p>
<p>（2） 传递另一个函数的函数名，函数中的this指向这个函数的引用</p>
<p>（3） 传递字符串、数值或布尔类型等基础类型，函数中的this指向其对应的包装对象，如 String、Number、Boolean</p>
<p>（4） 传递一个对象，函数中的this指向这个对象</p>
<ul>
<li>function.prototype.call(obj,arg1,arg2,…)<ul>
<li>obj是this要指向的对象（一般会写成this），也就是想指定的上下文；arg1，arg2都是要传入的参数</li>
<li>如果参数为空，null和undefined，则默认传入全局对象</li>
</ul>
</li>
<li>function.prototype.apply(obj,[arg1,arg2,..])<ul>
<li>apply()和call（）差不多，但是apply的第二个参数是数组</li>
</ul>
</li>
<li>function.prototype.bind(obj)<ul>
<li>将函数绑定到某个对象，然后返回一个新的函数</li>
</ul>
</li>
</ul>
<h6 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;     console.log(this);   //输出函数a中的this对象&#125;       </span><br><span class="line">function b()&#123;&#125;       </span><br><span class="line">var c=&#123;name:&quot;call&quot;&#125;;    //定义对象c  </span><br><span class="line">a.call();   //window</span><br><span class="line">a.call(null);   //window</span><br><span class="line">a.call(undefined);   //window</span><br><span class="line">a.call(1);   //Number</span><br><span class="line">a.call(&apos;&apos;);   //String</span><br><span class="line">a.call(true);   //Boolean</span><br><span class="line">a.call(b);   //function b()&#123;&#125;</span><br><span class="line">a.call(c);   //Object</span><br></pre></td></tr></table></figure>

<p>function class1(){   </p>
<p>  this.name=function(){   </p>
<p>​    console.log(“我是class1内的方法”);   </p>
<p>  }   </p>
<p>}   </p>
<p>function class2(){ </p>
<p>  class1.call(this); //此行代码执行后，当前的this指向了class1（也可以说class2继承了class1）   </p>
<p>}  </p>
<p>var f=new class2();   </p>
<p>f.name();   //调用的是class1内的方法，将class1的name方法交给class2使用</p>
<p>function eat(x,y){   </p>
<p>  console.log(x+y);   </p>
<p>}   </p>
<p>function drink(x,y){   </p>
<p>  console.log(x-y);   </p>
<p>}   </p>
<p>eat.call(drink,3,2)；/<em>输出：5。这个例子中的意思就是用 eat 来替换 drink，eat.call(drink,3,2) == eat(3,2) ，所以运行结果为：console.log(5);</em>/</p>
<p>function Animal(){   </p>
<p>  this.name=”animal”;   </p>
<p>  this.showName=function(){   </p>
<p>​    console.log(this.name);   </p>
<p>  }   </p>
<p>}   </p>
<p>function Dog(){   </p>
<p>  this.name=”dog”;   </p>
<p>}   </p>
<p>var animal=new Animal();   </p>
<p>var dog=new Dog();       </p>
<p>animal.showName.call(dog);//输出：dog</p>
<p>在上面的代码中，我们可以看到Dog里并没有showName方法，那为什么（this.name）的值是dog呢？</p>
<p>关键就在于最后一段代码（animal.showName.call(dog)），意思是把animal的方法放到dog上执行，也可以说，把animal 的showName()方法放到 dog上来执行，所以this.name 应该是 dog。</p>
<p>function Animal(name){   </p>
<p>  this.name=name;   </p>
<p>  this.showName=function(){   </p>
<p>​    console.log(this.name);   </p>
<p>  }   </p>
<p>}   </p>
<p>function Dog(name){   </p>
<p>  Animal.call(this,name);   </p>
<p>}   </p>
<p>var dog=new Dog(“Crazy dog”);   </p>
<p>dog.showName();//输出：Crazy dog</p>
<p>Animal.call(this) 的意思就是使用 Animal对象代替this对象，那么Dog就能直接调用Animal的所有属性和方法。著作权归作者所有。</p>
<ul>
<li>在JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call ；而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数。著作权归作者所有。</li>
</ul>
<p>详情请看：<a href="http://ghmagical.com/article/page/id/UPLfoGI9vJ91" target="_blank" rel="noopener">http://ghmagical.com/article/page/id/UPLfoGI9vJ91</a></p>
<h2 id="五-垃圾回收机制"><a href="#五-垃圾回收机制" class="headerlink" title="五 . 垃圾回收机制"></a>五 . 垃圾回收机制</h2><ul>
<li>js具有自动垃圾回收机制（GC:Garbage  Collection），也就是说执行环境会负责管理代码执行过程中使用的内存</li>
<li>原理：垃圾收集器会定期（周期性）找出那些不再继续使用的变量，然后释放其内存。此过程并非实时的，因其开销会很大。</li>
<li>不再使用的变量也就是生命周期结束的变量，当让只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束，局部变量只在函数执行过程中存在，而在这个过程会为局部变量在堆和栈分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包由于内部函数的原因，外部函数并不能算是结束。</li>
<li></li>
</ul>
<h2 id="六-枚举"><a href="#六-枚举" class="headerlink" title="六. 枚举"></a>六. 枚举</h2><h2 id="ECMAScript原始值和引用值"><a href="#ECMAScript原始值和引用值" class="headerlink" title="ECMAScript原始值和引用值"></a>ECMAScript原始值和引用值</h2><h4 id="1-原始值"><a href="#1-原始值" class="headerlink" title="1.原始值"></a>1.原始值</h4><p>存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。</p>
<h4 id="2-引用值"><a href="#2-引用值" class="headerlink" title="2.引用值"></a>2.引用值</h4><p>存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。</p>
<p>为变量赋值时，ECMAScript 的解释程序必须判断该值是原始类型，还是引用类型。要实现这一点，解释程序则需尝试判断<em>该值是否为 ECMAScript 的原始类型之一</em>，即 Undefined、Null、Boolean、Number和String型。由于这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 - 栈中。这样存储便于迅速查寻变量的值。</p>
<p><strong>在许多语言中，字符串都被看作引用类型，而非原始类型，因为字符串的长度是可变的。ECMAScript打破了这一传统。</strong></p>
<p>如果一个值是引用类型的，那么它的存储空间将从堆中分配。由于引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响</p>
<p><img src="https://7n.w3cschool.cn/attachments/day_160920/201609201937112397.gif" alt="存储在堆和栈中的原始值和引用值"></p>
<h4 id="3-对象-1"><a href="#3-对象-1" class="headerlink" title="3.对象"></a>3.对象</h4><h6 id="1-属性"><a href="#1-属性" class="headerlink" title="1.属性"></a>1.属性</h6><ul>
<li>constructor：对创建对象的函数的引用（指针）。对于Object对象，该指针指向原始的Object（）函数</li>
<li>prototype：对该对象的原型的引用。对于所有的对象，他默认返回Object对象的一个实例</li>
</ul>
<h6 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h6><ul>
<li>hasOwnProperty（property）：判断对象是否有某个特定的属性。必须用字符串指定该属性（o.hasOwnProperty(“name”))</li>
<li>IsPrototypeOf(object):判断该对象是否为另一个对象的原型</li>
<li>PropertyIsEnumerable：判断给定的属性是否可以用for…in语句进行枚举</li>
<li>ToString（）：返回对象的原始字符串表示。对于Object对象，ECMA-262没有定义这个值，所以不同的ECMAScript实现具有不同的值</li>
<li>ValueOf（）返回最适合该对象的原始值。对于许多对象，该方法返回的值都与ToString（）的返回值相同</li>
<li>上面列出的每种属性和方法都会被其他对象覆盖</li>
</ul>
<h4 id="4-String对象"><a href="#4-String对象" class="headerlink" title="4.String对象"></a>4.String对象</h4><ul>
<li><p>localeCompare（）方法，对字符串进行排序。该方法有一个参数-要进行比较的字符串，返回的是下列三个值之一</p>
<ul>
<li>如果String对象按照字母顺序排在参数中的字符串之前，返回负数</li>
<li>等于参数中的字符串，返回0</li>
<li>排在参数中的字符串之后，返回正数</li>
</ul>
</li>
<li><p>localeCompare()方法的独特之处在于，实现所处的区域（locale，兼指国家/地区和语言）确切说明了这种方法运行的方式。在美国，英语是ECMAScript实现的标准语言，localeCompare()是区分大小写的，大写字母在字母顺序上排在小写字母之后。不过，在其他区域，情况可能并非如此。</p>
</li>
<li><p>slice（）和substring（）</p>
<ul>
<li><p>ECMAScript提供了两种方法从字串创建字符串值，即slice（）和substring（）。这两种返回的都是要处理的字符串的子串，都接受一个或两个参数，第一个参数是要获取字串的起始位置，第二个参数（如果使用的话）是要获取<strong>子串终止前的位置</strong>（也就是说，获取终止位置不包括在返回值内）。若省略第二个参数，终值位就默认为字符串的长度。但是两种方法都不影响String对象本身的值</p>
</li>
<li><p>对于负数参数，slice（）方法会用字符串的长度加上参数，substring（）方法则将其作为0处理（也就是忽略他）</p>
<p>var oStringObject = new String(“hello world”);<br>alert(oStringObject.slice(“-3”));        //输出 “rld”<br>alert(oStringObject.substring(“-3”));    //输出 “hello world”<br>alert(oStringObject.slice(“3, -4”));        //输出 “lo w”<br>alert(oStringObject.substring(“3, -4”));    //输出 “hel”</p>
<p>substring()方法则将两个参数解释为substring(3, 0)，实际上即substring(0, 3)，因为substring()总把较小的数字作为起始位，较大的数字作为终止位。因此，substring(“3, -4”)返回的是”hel”。</p>
</li>
</ul>
</li>
<li><p>toLowerCase()和toUpperCase()方法是原始的，是以java.lang.String中相同方法为原型实现的。</p>
<p>toLocaleLowerCase()和toLocaleUpperCase()方法是基于特定的区域实现的</p>
<ul>
<li>一般来说，如果不知道在以哪种编码运行一种语言，则使用区域特定的方法比较安全。</li>
<li>String对象的所有属性和方法都可应用于String原始值上，因为它们是伪对象。</li>
</ul>
</li>
<li><p>instanceof运算符</p>
<ul>
<li>解决使用typeof运算符时，所有类型的对象都返回“object”</li>
</ul>
</li>
</ul>
<h4 id="5-整数"><a href="#5-整数" class="headerlink" title="5.整数"></a>5.整数</h4><ul>
<li><p>ECMAScript中，所有整数字面量默认都是有符号32位整数，前31位（每一位都表示2的幂）是整数数值，最后一位表示符号，0表示正数，1表示负数</p>
</li>
<li><p>负整数：负数也存储为二进制代码，不过采用的形式是二进制补码。计算补码三部曲：</p>
<ul>
<li>确定该数字的非负版本的二进制表示（如，要计算-18的二进制补码，首先要确定18的二进制表示）</li>
<li>求得二进制反码，即把0替换成1，把1替换成0</li>
<li>在二进制反码上加上1</li>
</ul>
</li>
<li><p>位运算NOT（~）三部曲</p>
<ul>
<li><p>把运算数转化成32位数字</p>
</li>
<li><p>把二进制转换成他的二进制反码</p>
</li>
<li><p>把二进制数转化成浮点数</p>
<p><strong>位运算NOT实质上是对数字求负，然后减1</strong>，因此25变成-26</p>
</li>
<li><p>如果运算数是对象，返回false</p>
</li>
<li><p>如果运算数是数字0，返回true</p>
</li>
<li><p>如果运算数是0以外的任何数字，返回false</p>
</li>
<li><p>如果运算数是null，返回true</p>
</li>
<li><p>如果运算数是NaN，返回true</p>
</li>
<li><p>如果运算数是undefined，发生错误。</p>
</li>
</ul>
</li>
<li><p>AND运算符的运算数可以是任何类型的</p>
<ul>
<li>obj &amp;&amp;  boolean  ——–obj</li>
<li>obj1  &amp;&amp;  obj2  ———obj2</li>
<li>有null ———–null</li>
<li>有NaN ——返回NaN</li>
<li>第一个是undefined或第一个是true，第二个是undefined——发生错误</li>
<li>第一个是false，第二个是undefined——返回false，因为第二个没被计算</li>
</ul>
</li>
<li><p>乘法运算符*</p>
<ul>
<li>如果某个运算数是NaN，结果就是NaN</li>
<li>Infinity乘以0，结果是NaN</li>
<li>Infinity乘以0以外的数，结果为Infinity或-Infinity</li>
</ul>
</li>
<li><p>除法运算符/</p>
<ul>
<li>如果结果太大或太小，生成的结果是Infinity或-infinity</li>
<li>如果某个运算数是NaN，结果是NaN</li>
<li>Infinity被Infinity除，结果是NaN。Infinity/Infinity=NaN</li>
<li>Infinity被任何数字除，结果是Infinity    某个数/Infinity=Infinity</li>
<li>0除以一个非无穷大的数字，结果为NaN   0/某个数=NaN</li>
</ul>
</li>
<li><p>取余%</p>
<ul>
<li>Infinity%某数=NaN      某数%0=NaN</li>
<li>Infinity%Infinity=NaN</li>
<li>被除数%Infinity=被除数</li>
<li>0%某数=0</li>
</ul>
</li>
<li><p>加法+</p>
<ul>
<li>某个运算数是NaN，结果为NaN</li>
<li>（-Infinity）+（-Infinity）= -Infinity</li>
<li>Infinity + （-Infinity）=NaN</li>
<li>（+0）+（+0）=（+0）</li>
<li>（-0）+（+0）=（+0）</li>
<li>（-0）-（-0）=（-0）</li>
<li>（-0）+（-0）=（-0）</li>
<li>如果两个运算数都是字符串，把第二个字符串连接到第一个上。</li>
<li>如果只有一个运算数是字符串，把另一个运算数转换成字符串，结果是两个字符串连接成的字符串。</li>
</ul>
</li>
<li><p>等性运算符==和！=</p>
<ul>
<li><p>如果一个运算数是Boolean值，在检查相等性之前，把它转换成数字值，true为1，false为0</p>
</li>
<li><p>字符串和数字，将字符串转成数字</p>
</li>
<li><p>对象和字符串，将对象转为字符串</p>
</li>
<li><p>对象和数字，将对象转成数字</p>
</li>
<li><p>值null和undefined相等</p>
</li>
<li><p>在检查相等性时，不能把null和undefined转换成其他值</p>
</li>
<li><p>有NaN，等号返回false，非等号返回true</p>
</li>
<li><p>如果两个运算数是对象，那比较的是他们的引用值，若指向同一对象，则等号返回true，否则两个运算数不等</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>null == undefined</td>
<td>true</td>
</tr>
<tr>
<td>“NaN” == NaN</td>
<td>false</td>
</tr>
<tr>
<td>5 == NaN</td>
<td>false</td>
</tr>
<tr>
<td>NaN == NaN</td>
<td>false</td>
</tr>
<tr>
<td>NaN != NaN</td>
<td>true</td>
</tr>
<tr>
<td>false == 0</td>
<td>true</td>
</tr>
<tr>
<td>true == 1</td>
<td>true</td>
</tr>
<tr>
<td>true == 2</td>
<td>false</td>
</tr>
<tr>
<td>undefined == 0</td>
<td>false</td>
</tr>
<tr>
<td>null == 0</td>
<td>false</td>
</tr>
<tr>
<td>“5” == 5</td>
<td>true</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="6-语句"><a href="#6-语句" class="headerlink" title="6.语句"></a>6.语句</h4><h6 id="1-有标签的语句"><a href="#1-有标签的语句" class="headerlink" title="1.有标签的语句"></a>1.有标签的语句</h6><ul>
<li>break 语句和 continue 语句都可以与有标签的语句联合使用，返回代码中的特定位置。当循环内部还有循环时，会这样做</li>
<li>with语句用于设置代码在特定对象中的作用域</li>
</ul>
<p>var sMessage = “hello”;<br>with(sMessage) {<br>alert(toUpperCase());    //输出 “HELLO”<br>}</p>
<p>（1）在这个例子中，with语句用于字符串，所以调用toUpperCase()方法时，解释程序将检查该方法是否是本地程序。如果不是，他将检查伪对象sMessage，看他是否为该对象的方法，然后，alert输出“HELLO”,因为解释程序找到了字符串”hello“的toUpperCase（）方法</p>
<p>（2）with语句是运行缓慢的代码块，尤其是在已设置了属性值时。大多情况下，如果可能，最好避免使用它</p>
<h2 id="七-面向对象"><a href="#七-面向对象" class="headerlink" title="七. 面向对象"></a>七. 面向对象</h2><h4 id="1-具备的四种能力"><a href="#1-具备的四种能力" class="headerlink" title="1.具备的四种能力"></a>1.具备的四种能力</h4><ul>
<li>封装：把相关信息（数据或方法）存储在对象中的能力</li>
<li>聚集：把一个对象存储在另一个对象内的能力</li>
<li>继承：有另一个类（或多个类）得来类的属性和方法的能力</li>
<li>多态：编写能以多种方法运行的函数或方法的能力</li>
</ul>
<h4 id="2-对象的应用"><a href="#2-对象的应用" class="headerlink" title="2.对象的应用"></a>2.对象的应用</h4><ul>
<li>对象的创建和销毁都在js执行过程中发生</li>
</ul>
<h4 id="3-对象废除"><a href="#3-对象废除" class="headerlink" title="3.对象废除"></a>3.对象废除</h4><ul>
<li>ECNAScript拥有无用存储单元搜集程序（garbage collection routine），意味着不必专门销毁对象来释放内存。当没有对象引用时，称该对象被废除了（derefence）。运行无用存储单元收集程序时，所有废除的对象都被销毁。每当执行完它的代码，无用存储单元收集程序都会运行，释放所有的局部变量，还有在一些不可预知的情况下，无用存储单元收集程序也会运行</li>
<li>把对象的所有引用都设置为null，可以强制性的废除材料</li>
</ul>
<h4 id="4-绑定"><a href="#4-绑定" class="headerlink" title="4.绑定"></a>4.绑定</h4><ul>
<li>即把对象的接口与对象实例结合起来的方法</li>
<li>早绑定（early binding）是指在实例化对象之前定义它的属性和方法，这样编译器或解释程序就能够提前转换机器代码。在 Java 和 Visual Basic 这样的语言中，有了早绑定，就可以在开发环境中使用 IntelliSense（即给开发者提供对象中属性和方法列表的功能）。ECMAScript 不是强类型语言，所以不支持早绑定。</li>
<li>另一方面，晚绑定（late binding）指的是编译器或解释程序在运行前，不知道对象的类型。使用晚绑定，无需检查对象的类型，只需检查对象是否支持属性和方法即可。ECMAScript 中的所有变量都采用晚绑定方法。这样就允许执行大量的对象操作，而无任何惩罚。</li>
</ul>
<h4 id="5-作用域"><a href="#5-作用域" class="headerlink" title="5.作用域"></a>5.作用域</h4><ul>
<li>指的是变量的适用范围</li>
<li>ECMAScript只有公共作用域，所有对象的作用域都是公共的。由于缺少私有作用域，开发者确定了一个规约，说明哪些属性和方法应该被看做私有的。这种规约规定在属性前后加下划线</li>
<li>ECMAScript没有静态作用域（静态作用域定义的属性和方法任何时候都能从同一位置访问），但可以为构造函数提供属性和方法，构造函数是函数，函数是对象，对象可以有属性和方法</li>
</ul>
<h4 id="6-使用动态原型方法类的属性和方法"><a href="#6-使用动态原型方法类的属性和方法" class="headerlink" title="6.使用动态原型方法类的属性和方法"></a>6.使用动态原型方法类的属性和方法</h4><ul>
<li>在构造函数内定义非函数属性，而函数属性则利用原型属性定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Car(sColor,iDoors,iMpg) &#123;</span><br><span class="line">  this.color = sColor;</span><br><span class="line">  this.doors = iDoors;</span><br><span class="line">  this.mpg = iMpg;</span><br><span class="line">  this.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;);</span><br><span class="line">  </span><br><span class="line">  if (typeof Car._initialized == &quot;undefined&quot;) &#123;</span><br><span class="line">    Car.prototype.showColor = function() &#123;</span><br><span class="line">      alert(this.color);</span><br><span class="line">    &#125;;</span><br><span class="line">	</span><br><span class="line">    Car._initialized = true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>知道检查typeof Car.__initialized是否等于“undefined”之前，这个构造函数都为改变。这行代码是动态原型方法中最重要的一部分。如果这个值没定义，构造函数将用原型方法继续定义对象的方法，然后把Car._initialized设置为true，如果这个值定义了，（它的值为true，typeof的值为Boolean），那么就不再创建该方法。简而言之，该方法使用（_initialized)来判断是否已给原型赋予了任何方法，该方法只创建并赋值一次。</li>
</ul>
<h4 id="7-ECMAScript的字符串"><a href="#7-ECMAScript的字符串" class="headerlink" title="7.ECMAScript的字符串"></a>7.ECMAScript的字符串</h4><ul>
<li>ECMAScript的字符串是不可变的，即它们的值是不可变的</li>
</ul>
<p>var  str=”hello”;str += “world”;</p>
<p>创建此段代码的实际步骤（特别耗资源）</p>
<ul>
<li>创建存储“hello”字符串</li>
<li>创建存储“world”的字符串</li>
<li>创建连接结果的字符串</li>
<li>把str的当前结果复制到结果中</li>
<li>把“world”复制到结果中</li>
<li>更新str，使它指向结果</li>
</ul>
<p>解决方法是用Array对象存储字符串，然后用join（）方法（参数是空字符串）创建最后的字符串（但是不能确切反映出他的意图）</p>
<p>var arr = new Array();<br>arr[0] = “hello “;<br>arr[1] = “world”;<br>var str = arr.join(“”);</p>
<p>实现步骤</p>
<ul>
<li>创建存储结果的字符串</li>
<li>把每个字符串复制到结果中的合适位置</li>
</ul>
<p>最好的方法是使用StringBuffer类包装该功能</p>
<p>function   StringBuffer(){</p>
<p>this.<em>_strings</em>=new Array();</p>
<p>}</p>
<p>StringBuffer.prototype.append=function(str){</p>
<p>this.<em>_strings</em>.push(str);</p>
<p>};</p>
<p>StringBuffer.prototype.toString=function(){</p>
<p>return this.<em>_strings</em>.join(“”);</p>
<p>};</p>
<p>这段代码首先要注意的是strings属性，本意是私有属性。它只有两个方法，append（）和toString（）方法。append（）方法只有一个参数，他把该参数附加到字符串数组中，toString（）方法调用数组的join方法，返回真正连接成的字符串。</p>
<p>var buffer = new StringBuffer ();<br>buffer.append(“hello “);<br>buffer.append(“world”);<br>var result = buffer.toString();</p>
<h2 id="八-继承机制实现"><a href="#八-继承机制实现" class="headerlink" title="八 . 继承机制实现"></a>八 . 继承机制实现</h2><ul>
<li><p>要用ECMAScript实现继承机制，您可以从要继承的基类入手。所有开发者定义的类都可以作为基类。出于安全原因，本地类和宿主类不能作为基类，这样可以防止公用访问编译过的浏览器级的代码，因为这些代码可被用于恶意攻击</p>
</li>
<li><p>选定基类后，就可以创建它的子类了。是否使用基类完全由你决定。有时，你可能创建一个不能直接使用的基类，他只是用于给函数提供通用函数。这种情况下，基类被看成是抽象类。</p>
</li>
<li><p>创建的子类将继承超类的所有属性和方法，包括构造函数及方法的实现。记住，所有的属性和方法都是公用的，因此子类可以直接访问这些方法。子类还可以添加超类中没有的属性和方法，也可以覆盖超类中的属性和方法</p>
</li>
<li><p>JavaScript实现继承并非明确规定，而是通过模仿实现的，故和其他功能一样，不止一种实现方式。这意味着所有的继承细节并非完全由解释程序处理。作为开发者，你有权决定最适合的继承方法</p>
</li>
</ul>
<h4 id="1-对象冒充"><a href="#1-对象冒充" class="headerlink" title="1.对象冒充"></a>1.对象冒充</h4><p>原理：构造函数使用this关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。因为构造函数只是一个函数，所以可以使ClassA构造函数成为ClassB的方法，然后调用它。ClassB就会收到ClassA的构造函数中定义的属性和方法。</p>
<p>function  ClassA(scolor){</p>
<p>this.color=scolor;</p>
<p>this.sayColor=function(){</p>
<p>alert(this.color);}</p>
<p>}</p>
<p>function  ClassB(scolor){  </p>
<p>this.newMethod=ClassA; this.newMethod(scolor);  delete  this.newMethod;</p>
<p>  this.name = sName;<br>this.sayName = function () {<br>alert(this.name);<br>};</p>
<p> }</p>
<p>在这段段代码中，为ClassA赋予方法newMethod（请记住，函数名只是指向它的指针）。然后调用该方法，传递给它的是ClassB构造函数，第三行行删除对ClassA的引用，这样以后就不能再调用它了。所有新属性或新方法都必须在删除了新方法的代码行后才能执行。否则，可能会覆盖超类的相关方法和属性。</p>
<ul>
<li>对象冒充可以实现多重继承，即一个类可继承多个超类</li>
</ul>
<p><img src="https://7n.w3cschool.cn/attachments/day_160921/201609211757355298.gif" alt="继承机制 UML 图示实例"></p>
<p>function ClassZ() {<br>this.newMethod = ClassX;<br>this.newMethod();<br>delete this.newMethod;<br>this.newMethod = ClassY;<br>this.newMethod();<br>delete this.newMethod;<br>}</p>
<p>这里存在一个弊端，如果存在两个类 ClassX 和 ClassY 具有同名的属性或方法，ClassY 具有高优先级。因为它从后面的类继承。除这点小问题之外，用对象冒充实现多重继承机制轻而易举。</p>
<h4 id="2-使用call（对象参数，形参1，2，"><a href="#2-使用call（对象参数，形参1，2，" class="headerlink" title="2.使用call（对象参数，形参1，2，..)"></a>2.使用call（对象参数，形参1，2，..)</h4><h4 id="3-使用apply（对象参数，形参数组）"><a href="#3-使用apply（对象参数，形参数组）" class="headerlink" title="3.使用apply（对象参数，形参数组）"></a>3.使用apply（对象参数，形参数组）</h4><h2 id="九-object对象"><a href="#九-object对象" class="headerlink" title="九.object对象"></a>九.object对象</h2><ul>
<li><p>JavaScript 原生提供<code>Object</code>对象（注意起首的<code>O</code>是大写），所有其他对象都继承自这个对象。<code>Object</code>本身也是一个构造函数，可以直接通过它来生成新对象。</p>
<p>var obj = new Object();</p>
</li>
<li><p>Object作为构造函数使用时，可接受一个参数。如果该参数是一个对象，则直接返回这个对象；如果是原始类型的值，则返回该值的包装对象。注意，通过<code>new Object()</code>的写法生成新对象，与字面量的写法<code>o = {}</code>是等价的。</p>
<p>var o1 = {a: 1};<br>var o2 = new Object(o1);<br>o1 === o2 // true<br>new Object(123) instanceof Number<br>// true</p>
</li>
</ul>
<h4 id="Object对象上面部署一个方法的两种做法。"><a href="#Object对象上面部署一个方法的两种做法。" class="headerlink" title="Object对象上面部署一个方法的两种做法。"></a><code>Object</code>对象上面部署一个方法的两种做法。</h4><h6 id="1-部署在Object对象本身"><a href="#1-部署在Object对象本身" class="headerlink" title="1.部署在Object对象本身"></a>1.部署在Object对象本身</h6><p>比如，在<code>Object</code>对象上面定义一个<code>print</code>方法，显示其他对象的内容。</p>
<p>Object.print = function (o) { console.log(o) } ;</p>
<p>var o =new Object() ;</p>
<p>Object.print(o);</p>
<h6 id="2-部署在Object-prototype对象"><a href="#2-部署在Object-prototype对象" class="headerlink" title="2.部署在Object.prototype对象"></a>2.部署在Object.prototype对象</h6><ul>
<li><p>所有构造函数都有一个prototype属性，指向一个原型对象。凡是在Object.prototype对象上面定义的属性都将被所有实例对象所共享</p>
<p>Object.prototype.print = function () { console.log(this) };</p>
<p>var o = new Object();</p>
<p>o.print();</p>
<p>上面代码在Object.prototype定义了一个print方法，然后生成一个Object的实例o。o直接继承了Object.prototype的属性和方法，可以在自身调用它们，也就是说，o对象的print方法实质上是调用Object.prototype.print方法。。</p>
</li>
</ul>
<h4 id="Object-方法"><a href="#Object-方法" class="headerlink" title="Object()方法"></a>Object()方法</h4><ul>
<li><p>可将任意值转为对象。这个方法常用于保证某个值一定是对象。如果参数是原始类型的值，Object方法返回对应的包装对象的实例</p>
<p>Object() instanceof Object // true<br>Object(undefined) // 返回一个空对象<br>Object(undefined) instanceof Object // true<br>Object(null) // 返回一个空对象<br>Object(null) instanceof Object // true<br>Object(1) // 等同于 new Number(1)<br>Object(1) instanceof Object // true<br>Object(1) instanceof Number // true<br>Object(‘foo’) // 等同于 new String(‘foo’)<br>Object(‘foo’) instanceof Object // true<br>Object(‘foo’) instanceof String // true<br>Object(true) // 等同于 new Boolean(true)<br>Object(true) instanceof Object // true<br>Object(true) instanceof Boolean // true</p>
</li>
<li><p>如果参数是一个对象，他总是返回原对象</p>
<p>var arr = [];<br>Object(arr) // 返回原数组<br>Object(arr) === arr // true<br>var obj = {};<br>Object(obj) // 返回原对象<br>Object(obj) === obj // true<br>var fn = function () {};<br>Object(fn) // 返回原函数<br>Object(fn) === fn // true</p>
<p>利用这一点，可以写一个判断变量是否为对象的函数。</p>
<p>function isObject(value) {<br>return value === Object(value);<br>}<br>isObject([]) // true<br>isObject(true) // false</p>
</li>
</ul>
<h4 id="Object对象的静态方法"><a href="#Object对象的静态方法" class="headerlink" title="Object对象的静态方法"></a>Object对象的静态方法</h4><ul>
<li><p>是指部署在Object对象自身的方法</p>
</li>
<li><p><code>Object.keys</code>方法和<code>Object.getOwnPropertyNames</code>方法很相似，一般用来遍历对象的属性。它们的参数都是一个对象，都返回一个数组，该数组的成员都是对象自身的（而不是继承的）所有属性名。它们的区别在于，<code>Object.keys</code>方法只返回可枚举的属性Object.getOwnPropertyNames`方法还返回不可枚举的属性名。</p>
<p>var o = {<br>p1: 123,<br>p2: 456<br>};<br>Object.keys(o)<br>// [“p1”, “p2”]<br>Object.getOwnPropertyNames(o)<br>// [“p1”, “p2”]</p>
<p>有不可枚举属性length</p>
<p>var a = [“Hello”, “World”];<br>Object.keys(a)<br>// [“0”, “1”]<br>Object.getOwnPropertyNames(a)<br>// [“0”, “1”, “length”]</p>
</li>
<li><p>由于JavaScript没有提供计算对象属性个数的方法，所以可以用这两个方法代替。</p>
<p>Object.keys(o).length</p>
<p>Object.getOwnPropertyNames(o).length</p>
<p>一般情况下，几乎总是使用Object.keys方法遍历数组的属性</p>
</li>
</ul>
<h4 id="对象属性模型的相关方法"><a href="#对象属性模型的相关方法" class="headerlink" title="对象属性模型的相关方法"></a>对象属性模型的相关方法</h4><ul>
<li><code>Object.getOwnPropertyDescriptor()</code>：获取某个属性的<code>attributes</code>对象。</li>
<li><code>Object.defineProperty()</code>：通过<code>attributes</code>对象，定义某个属性。</li>
<li><code>Object.defineProperties()</code>：通过<code>attributes</code>对象，定义多个属性。</li>
<li><code>Object.getOwnPropertyNames()</code>：返回直接定义在某个对象上面的全部属性的名称。</li>
</ul>
<h4 id="控制对象状态的方法"><a href="#控制对象状态的方法" class="headerlink" title="控制对象状态的方法"></a><strong>控制对象状态的方法</strong></h4><ul>
<li><code>Object.preventExtensions()</code>：防止对象扩展。</li>
<li><code>Object.isExtensible()</code>：判断对象是否可扩展。</li>
<li><code>Object.seal()</code>：禁止对象配置。</li>
<li><code>Object.isSealed()</code>：判断一个对象是否可配置。</li>
<li><code>Object.freeze()</code>：冻结一个对象。</li>
<li><code>Object.isFrozen()</code>：判断一个对象是否被冻结。</li>
</ul>
<h4 id="原型链相关方法"><a href="#原型链相关方法" class="headerlink" title="原型链相关方法"></a><strong>原型链相关方法</strong></h4><ul>
<li><code>Object.create()</code>：该方法可以指定原型对象和属性，返回一个新的对象。</li>
<li><code>Object.getPrototypeOf()</code>：获取对象的<code>Prototype</code>对象。</li>
</ul>
<h4 id="Object对象都有的六大实例方法"><a href="#Object对象都有的六大实例方法" class="headerlink" title="Object对象都有的六大实例方法"></a>Object对象都有的六大实例方法</h4><ul>
<li><p>valueOf（）：返回当前对象对应的值</p>
<ul>
<li><p><code>valueOf</code>方法的作用是返回一个对象的“值”，默认情况下返回对象本身。</p>
<p>var o = new Object();<br>o.valueOf() === o // true</p>
</li>
<li><p>valueOf`方法的主要用途是，JavaScript自动类型转换时会默认调用这个方法</p>
<p>var o = new Object();<br>o.valueOf = function (){<br>return 2;<br>};<br>1 + o // 3</p>
</li>
</ul>
</li>
<li><p>toString（）：返回当前对象对应的字符串形式</p>
<ul>
<li><p><code>toString</code>方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。</p>
<p>var o1 = new Object();<br>o1.toString() // “[object Object]”<br>var o2 = {a:1};<br>o2.toString() // “[object Object]”</p>
</li>
<li><p>自动类型转换时</p>
<p>var o = new Object();<br>o.toString = function () {<br>return ‘hello’;<br>};<br>o + ‘ ‘ + ‘world’ // “hello world”</p>
</li>
</ul>
</li>
</ul>
<pre><code>[1, 2, 3].toString() // &quot;1,2,3&quot;
&apos;123&apos;.toString() // &quot;123&quot;
(function () {
return 123;
}).toString()
// &quot;function () {
//   return 123;
// }&quot;
(new Date()).toString()
// &quot;Tue May 10 2016 09:11:31 GMT+0800 (CST)&quot;</code></pre><ul>
<li><p>实例对象可能会自定义<code>toString</code>方法，覆盖掉<code>Object.prototype.toString</code>方法。通过函数的<code>call</code>方法，可以在任意值上调用<code>Object.prototype.toString</code>方法，帮助我们判断这个值的类型。</p>
<p>Object.prototype.toString.call(value)</p>
<p>不同数据类型的<code>Object.prototype.toString</code>方法返回值如下。</p>
<ul>
<li>数值：返回<code>[object Number]</code>。</li>
<li>字符串：返回<code>[object String]</code>。</li>
<li>布尔值：返回<code>[object Boolean]</code>。</li>
<li>undefined：返回<code>[object Undefined]</code>。</li>
<li>null：返回<code>[object Null]</code>。</li>
<li>数组：返回<code>[object Array]</code>。</li>
<li>arguments对象：返回<code>[object Arguments]</code>。</li>
<li>函数：返回<code>[object Function]</code>。</li>
<li>Error对象：返回<code>[object Error]</code>。</li>
<li>Date对象：返回<code>[object Date]</code>。</li>
<li>RegExp对象：返回<code>[object RegExp]</code>。</li>
<li>其他对象：返回<code>[object Object]</code>。</li>
</ul>
</li>
<li><p>也就是说，<code>Object.prototype.toString</code>可以得到一个实例对象的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(2) // &quot;[object Number]&quot;</span><br><span class="line">Object.prototype.toString.call(&apos;&apos;) // &quot;[object String]&quot;</span><br><span class="line">Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;</span><br><span class="line">Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;</span><br><span class="line">Object.prototype.toString.call(null) // &quot;[object Null]&quot;</span><br><span class="line">Object.prototype.toString.call(Math) // &quot;[object Math]&quot;</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;) // &quot;[object Object]&quot;</span><br><span class="line">Object.prototype.toString.call([]) // &quot;[object Array]&quot;</span><br></pre></td></tr></table></figure>

<p>利用这个特性，可以写出一个比<code>typeof</code>运算符更准确的类型判断函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var type = function (o)&#123;</span><br><span class="line">  var s = Object.prototype.toString.call(o);</span><br><span class="line">  return s.match(/\[object (.*?)\]/)[1].toLowerCase();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type(&#123;&#125;); // &quot;object&quot;</span><br><span class="line">type([]); // &quot;array&quot;</span><br><span class="line">type(5); // &quot;number&quot;</span><br><span class="line">type(null); // &quot;null&quot;</span><br><span class="line">type(); // &quot;undefined&quot;</span><br><span class="line">type(/abcd/); // &quot;regex&quot;</span><br><span class="line">type(new Date()); // &quot;date&quot;</span><br></pre></td></tr></table></figure>

<p>在上面这个<code>type</code>函数的基础上，还可以加上专门判断某种类型数据的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[&apos;Null&apos;,</span><br><span class="line"> &apos;Undefined&apos;,</span><br><span class="line"> &apos;Object&apos;,</span><br><span class="line"> &apos;Array&apos;,</span><br><span class="line"> &apos;String&apos;,</span><br><span class="line"> &apos;Number&apos;,</span><br><span class="line"> &apos;Boolean&apos;,</span><br><span class="line"> &apos;Function&apos;,</span><br><span class="line"> &apos;RegExp&apos;,</span><br><span class="line"> &apos;NaN&apos;,</span><br><span class="line"> &apos;Infinite&apos;</span><br><span class="line">].forEach(function (t) &#123;</span><br><span class="line">  type[&apos;is&apos; + t] = function (o) &#123;</span><br><span class="line">    return type(o) === t.toLowerCase();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">type.isObject(&#123;&#125;) // true</span><br><span class="line">type.isNumber(NaN) // true</span><br><span class="line">type.isRegExp(/abc/) // true</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>toLocaleString（）：返回当前对象对应的本地字符串形式。</p>
</li>
<li><p>hasOwnProperty（）：判断某个属性是否为当前对象自身的属性值还是继承自原型对象的属性</p>
</li>
<li><p>isPrototypeOf（）：判断当前对象是否为另一个对象的原型</p>
</li>
<li><p>propertyIsEnumerable（）：判断某个属性是否可枚举</p>
</li>
</ul>
<h4 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h4><ul>
<li><p><code>Array</code>是JavaScript的内置对象，同时也是一个构造函数，可以用它生成新的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(2);</span><br><span class="line">arr.length // 2</span><br><span class="line">arr // [ undefined x 2 ]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array</code>构造函数有一个很大的问题，就是不同的参数，会导致它的行为不一致。`因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。</p>
<p>// 无参数时，返回一个空数组<br>new Array() // []<br>// 单个正整数参数，表示返回的新数组的长度<br>new Array(1) // [ undefined ]<br>new Array(2) // [ undefined x 2 ]<br>// 非正整数的数值作为参数，会报错<br>new Array(3.2) // RangeError: Invalid array length<br>new Array(-3) // RangeError: Invalid array length<br>// 单个非正整数参数（比如字符串、布尔值、对象等），<br>// 则该参数是返回的新数组的成员<br>new Array(‘abc’) // [‘abc’]<br>new Array([1]) // [Array[1]]<br>// 多参数时，所有参数都是返回的新数组的成员<br>new Array(1, 2) // [1, 2]<br>new Array(‘a’, ‘b’, ‘c’) // [‘a’, ‘b’, ‘c’]</p>
</li>
<li><p>注意，如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回<code>undefined</code>，但实际上该位置没有任何值。虽然可以取到<code>length</code>属性，但是取不到键名。</p>
<p>var arr = new Array(3);<br>arr.length // 3<br>arr[0] // undefined<br>arr[1] // undefined<br>arr[2] // undefined<br>0 in arr // false<br>1 in arr // false<br>2 in arr // false</p>
</li>
<li><p>Array.isArray():判断一个值是否为数组，弥补typeof运算符的不足</p>
</li>
</ul>
<h6 id="1-Array实例的方法"><a href="#1-Array实例的方法" class="headerlink" title="1.Array实例的方法"></a>1.Array实例的方法</h6><ul>
<li><p>valueOf（）方法返回数组本身</p>
<p>var a = [1, 2, 3];<br>a.valueOf() // [1, 2, 3]</p>
</li>
<li><p>toString（）方法返回数组的字符串形式</p>
<p>var a = [1, 2, 3];<br>a.toString() // “1,2,3”<br>var a = [1, 2, 3, [4, 5, 6]];<br>a.toString() // “1,2,3,4,5,6”</p>
</li>
<li><p>push（）方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p>
<p>var a = [];<br>a.push(1) // 1<br>a.push(‘a’) // 2<br>a.push(true, {}) // 4<br>a // [1, ‘a’, true, {}]</p>
</li>
<li><p>合并两个数组</p>
<p>var a = [1, 2, 3];<br>var b = [4, 5, 6];<br>Array.prototype.push.apply(a, b)<br>// 或者<br>a.push.apply(a, b)<br>// 上面两种写法等同于<br>a.push(4, 5, 6)<br>a // [1, 2, 3, 4, 5, 6]</p>
</li>
<li><p>push方法还可用于向对象添加元素，添加后的对象变成类似数组的对象，即新加入元素的键对应数组的索引，并且对象有一个length属性,其中的length属性是指加入键名的个数</p>
<p>var  a= {a:1};</p>
<p>[].push.call(a,2); </p>
<p>a  //{a:1 ,0:2 ,  length :1}</p>
<p>[].push.call(a,[3]);</p>
<p>a     // {a:1,0:2,1:[3],length:2};</p>
</li>
<li><p>pop（）方法用于删除数组的最后一个元素，并返回该元素。该方法会改变原数组</p>
<p>var  arr=[‘a’,’b’,’c’];</p>
<p>a.pop()  //‘c’</p>
<p>a  //[‘a’,’b’]</p>
</li>
<li><p>对空数组使用pop方法，不是犯错，而是返回undefined</p>
<p>[ ].pop()   //undefined</p>
</li>
<li><p>push和pop结合使用就构成后进先出的栈结构</p>
</li>
<li><p>join（）方法以参数作为分隔符，将所有数组组成一个字符串返回。如果不提供参数，默认用逗号分隔</p>
<p>var   str=”abcdefgh”;</p>
<p>var  arr=str.split(‘’);    //[“a”, “b”, “c”, “d”, “e”, “f”, “g”, “h”]</p>
<p>arr.join(‘’);   //“abcdefgh”</p>
<p>arr.join(‘ ‘);     //a b c d e f g h’;</p>
</li>
<li><p>如果数组成员是undefined或null或空位，会被转成空字符串</p>
<p>[undefined,null].join(‘#’)      //‘#’</p>
<p>[‘a’, ,’b’].join(‘-‘)    //‘a- -b’</p>
</li>
<li><p>这个方法也可以用于字符串，通过call方法</p>
<p>Array.prototype.join.call(‘hello’,’-‘)       //“h-e-l-l-o”</p>
</li>
<li><p>join方法也可以用于类似数组的对象</p>
<p>var  obj={0:’a’,1:’b’,length:2};</p>
<p>Array.prototype.join.call(obj,’-‘)   //‘a-b’</p>
</li>
<li><p>concat()用于将多个数组合并。它将新数组的成员添加到原数组的尾部，然后返回一个新数组，原数组不变</p>
<p>[‘hello’].concat([‘world’], [‘!’])<br>// [“hello”, “world”, “!”]</p>
</li>
<li><p>concat方法如果不提供参数，<code>concat</code>方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是如果数组成员包括复合类型的值（比如对象），则新数组拷贝的是该值的引用（你改我也会改）。</p>
<p>var obj = { a:1 };<br>var oldArray = [obj];<br>var newArray = oldArray.concat();<br>obj.a = 2;<br>newArray[0].a // 2</p>
</li>
<li><p>concat方法也可以用于将对象合并为数组，但是必须借助call方法</p>
<p>[].concat.call({a: 1}, {b: 2})<br>// [{ a: 1 }, { b: 2 }]<br>[].concat.call({a: 1}, [2])<br>// [{a: 1}, 2]<br>[2].concat({a: 1})<br>// [2, {a: 1}]</p>
</li>
<li><p>shift用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组</p>
<p>var   a=[‘a’,’b’,’c’];</p>
<p>a.shift();</p>
<p>a    //[‘b’,’c’]</p>
</li>
<li><p><code>shift</code>方法可以遍历并清空一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var list = [1, 2, 3, 4, 5, 6];</span><br><span class="line">var item;</span><br><span class="line"></span><br><span class="line">while (item = list.shift()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list // []</span><br></pre></td></tr></table></figure>

<p><code>push</code>和<code>shift</code>结合使用，就构成了“先进先出”的队列结构（queue）。</p>
</li>
<li><p><code>unshift</code>方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">a.unshift(&apos;x&apos;); // 4</span><br><span class="line">a // [&apos;x&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>

<p><code>unshift</code>方法可以在数组头部添加多个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ &apos;c&apos;, &apos;d&apos; ];</span><br><span class="line">arr.unshift(&apos;a&apos;, &apos;b&apos;) // 4</span><br><span class="line">arr // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos; ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>reverse()方法用于颠倒数组中的元素的顺序，返回改变后的数组。注意，会改变原数组</p>
<p>var a = [‘a’, ‘b’, ‘c’];<br>a.reverse() // [“c”, “b”, “a”]<br>a // [“c”, “b”, “a”]</p>
</li>
<li><p>slice方法用于提取原数组的一部分，返回一个新数组，原数组不变。它的第一个参数为起始位置（从零开始），第二个参数为1终止位置（但不包括该元素本身）。若省略第二个参数，则一直返回到原数组最后一个成员，相当于原数组的拷贝。</p>
<p>a.slice(0) // [“a”, “b”, “c”]<br>a.slice(1) // [“b”, “c”]<br>a.slice(1, 2) // [“b”]<br>a.slice(2, 6) // [“c”]<br>a.slice() // [“a”, “b”, “c”]</p>
</li>
<li><p>slice方法的参数是负数时表示倒数计算的位置。</p>
<p>var a = [‘a’, ‘b’, ‘c’];<br>a.slice(-2) // [“b”, “c”]<br>a.slice(-2, -1) // [“b”]</p>
</li>
<li><p>如果参数值大于数组成员的个数，或者第二个参数小于第一个参数，则返回空数组。</p>
<p>var a = [‘a’, ‘b’, ‘c’];<br>a.slice(4) // []<br>a.slice(2, 1) // []</p>
</li>
<li><p><code>slice</code>方法的一个重要应用，是将类似数组的对象转为真正的数组。</p>
<p>Array.prototype.slice.call({ 0: ‘a’, 1: ‘b’, length: 2 })<br>// [‘a’, ‘b’]<br>Array.prototype.slice.call(document.querySelectorAll(“div”));<br>Array.prototype.slice.call(arguments);</p>
</li>
<li><p><code>splice</code>方法用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</p>
<p><code>splice</code>的第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</p>
<p>// 格式<br>arr.splice(index, count_to_remove, addElement1, addElement2, …);<br>// 用法<br>var a = [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’];<br>a.splice(4, 2) // [“e”, “f”]<br>a // [“a”, “b”, “c”, “d”]</p>
</li>
<li><p>如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</p>
<p>var a = [1, 2, 3, 4];<br>a.splice(2) // [3, 4]<br>a // [1, 2]</p>
</li>
<li><p><code>sort</code>方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</p>
</li>
<li><p>如果想让<code>sort</code>方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于<code>0</code>，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。</p>
<p>[10111, 1101, 111].sort(function (a, b) {<br>return a - b;<br>})<br>// [111, 1101, 10111]<br>[<br>{ name: “张三”, age: 30 },<br>{ name: “李四”, age: 24 },<br>{ name: “王五”, age: 28  }<br>].sort(function (o1, o2) {<br>return o1.age - o2.age;<br>})<br>// [<br>//   { name: “李四”, age: 24 },<br>//   { name: “王五”, age: 28  },<br>//   { name: “张三”, age: 30 }<br>// ]</p>
</li>
<li><p><code>map</code>方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。<code>map</code>方法接受一个函数作为参数。该函数调用时，<code>map</code>方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。</p>
<p>var numbers = [1, 2, 3];<br>numbers.map(function (n) {<br>return n + 1;<br>});<br>// [2, 3, 4]</p>
<p>numbers<br>// [1, 2, 3]</p>
<p>[1, 2, 3].map(function(elem, index, arr) {<br>return elem * index;<br>});<br>// [0, 2, 6]</p>
<p><code>map</code>方法不仅可以用于数组，还可以用于字符串，用来遍历字符串的每个字符。但是，不能直接使用，而要通过函数的<code>call</code>方法间接使用，或者先将字符串转为数组，然后使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> upper = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.toUpperCase();</span><br><span class="line">  &#125;;</span><br><span class="line">  [].map.call(<span class="string">'abc'</span>, upper)</span><br><span class="line">  <span class="comment">// [ 'A', 'B', 'C' ]</span></span><br><span class="line">  <span class="comment">// 或者</span></span><br><span class="line">  <span class="string">'abc'</span>.split(<span class="string">''</span>).map(upper)</span><br><span class="line"><span class="comment">// [ 'A', 'B', 'C' ]</span></span><br></pre></td></tr></table></figure>





















</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-js基础" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/17/js基础/" class="article-date">
      <time datetime="2020-06-17T07:14:31.000Z" itemprop="datePublished">2020-06-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/js基础/">js基础</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在线工具库：<a href="https://123.w3cschool.cn/webtools" target="_blank" rel="noopener">https://123.w3cschool.cn/webtools</a></p>
<h2 id="一-js简介"><a href="#一-js简介" class="headerlink" title="一 . js简介"></a>一 . js简介</h2><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><ul>
<li>javascript是<strong>世界上最流行的脚本语言</strong>。js是属于web的语言，他适合与PC，笔记本电脑，平板电脑和移动电话。ja被设计成向HTNL页面增加交互性。<ul>
<li>脚本语言：指的是他不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”</li>
</ul>
</li>
<li>通过嵌入HTML来实现各种酷炫的动态效果，为用户提供赏心悦目的浏览效果。所有现代的 HTML 页面都使用 JavaScript，可以用于改进设计、验证表单、检测浏览器、创建cookies等。</li>
<li>javaScript 是一种轻量级的编程语言。JavaScript 是可插入 HTML 页面的编程代码。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</li>
<li>javascript也是一种<strong>嵌入式（embedded）语言</strong>。它本身提供的核心语法不算很多，只是用来做一些数学和逻辑运算。js本身不提供任何与I/O(输入/输出）相关的API，主要靠宿主环境（host）提供，所以js只适合嵌入更大型的应用程序环境，去调用宿主环境提供的底层API。目前，已经嵌入JavaScript的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是Node项目</li>
<li>从语法角度看，javascript语言是一种“对象模型”语言。各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过js控制这些功能。但是，js并不是纯粹的“面型对象语言”，还支持其他编程范式（比如函数式编程）</li>
</ul>
<h4 id="2-支持编译运行。"><a href="#2-支持编译运行。" class="headerlink" title="2.支持编译运行。"></a>2.<strong>支持编译运行。</strong></h4><ul>
<li>JavaScript 语言本身，虽然是一种解释型语言，但是在现代浏览器中，JavaScript 都是编译后运行。程序会被高度优化，运行效率接近二进制程序。而且，JavaScript 引擎正在快速发展，性能将越来越好。</li>
<li>此外，还有一种 WebAssembly 格式，它是 JavaScript 引擎的中间码格式，全部都是二进制代码。由于跳过了编译步骤，可以达到接近原生二进制代码的运行速度。各种语言（主要是 C 和 C++）通过编译成 WebAssembly，就可以在浏览器里面运行。</li>
</ul>
<h4 id="3-事件驱动和非阻塞式设计"><a href="#3-事件驱动和非阻塞式设计" class="headerlink" title="3.事件驱动和非阻塞式设计"></a>3.事件驱动和非阻塞式设计</h4><ul>
<li>JavaScript 程序可以采用事件驱动（event-driven）和非阻塞式（non-blocking）设计，在服务器端适合高并发环境，普通的硬件就可以承受很大的访问量。</li>
</ul>
<h4 id="4-javascript与java的关系"><a href="#4-javascript与java的关系" class="headerlink" title="4.javascript与java的关系"></a>4.javascript与java的关系</h4><table>
<thead>
<tr>
<th>Java</th>
<th>javascript</th>
</tr>
</thead>
<tbody><tr>
<td>强类型</td>
<td>弱类型（同一变量可以存放不同类型的变量（但是始终存放同一类型是良好的编码习惯）</td>
</tr>
</tbody></table>
<p>必须在JAVA虚拟机上运行，且事先需要进行编译    不依托编辑器，在浏览器就可以实现，边解释边执行</p>
<h2 id="二-输出"><a href="#二-输出" class="headerlink" title="二 . 输出"></a>二 . 输出</h2><h4 id="1-直接写入HTML输出流"><a href="#1-直接写入HTML输出流" class="headerlink" title="1.直接写入HTML输出流"></a>1.直接写入HTML输出流</h4><p>document.write(“输出内容”);  将内容写入HTML<strong>文档</strong>中</p>
<ul>
<li>你只能在HTNL输出中使用document.write。如果在文档加载完成后使用该方法，会覆盖整个文档。</li>
</ul>
<h4 id="2-弹出警告框alert"><a href="#2-弹出警告框alert" class="headerlink" title="2.弹出警告框alert"></a>2.弹出警告框alert</h4><p>window.alert（“输出内容”）；</p>
<h4 id="3-在指定位置输出innerHTML"><a href="#3-在指定位置输出innerHTML" class="headerlink" title="3.在指定位置输出innerHTML"></a>3.在指定位置输出innerHTML</h4><p>var  x=document.getElementById(“id名”)；//使用id属性查找元素</p>
<p>x.innerHTML=”输出内容”;//改变内容，写入到HTML<strong>元素</strong></p>
<h4 id="4-在控制台上输出"><a href="#4-在控制台上输出" class="headerlink" title="4.在控制台上输出"></a>4.在控制台上输出</h4><p>console.log(‘输出内容’)；</p>
<p>1、console.log 用于输出普通信息</p>
<p>2、console.info 用于输出提示性信息</p>
<p>3、console.error用于输出错误信息</p>
<p>4、console.warn用于输出警示信息</p>
<p>5、console.debug用于输出调试信息</p>
<p>可以通过在控制台输入console.clear()来实现清空控制台信息。</p>
<p><a href="https://jingyan.baidu.com/article/6dad507505f714a123e36e8a.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/6dad507505f714a123e36e8a.html</a></p>
<h2 id="三-js基本语法"><a href="#三-js基本语法" class="headerlink" title="三 . js基本语法"></a>三 . js基本语法</h2><h4 id="1-语句"><a href="#1-语句" class="headerlink" title="1.语句"></a>1.语句</h4><ul>
<li>js程序执行单位为行，也就是一行一行地执行一般，每一行就是一个语句。语句是为了完成某种任务而进行的操作（赋值语句），语句以分号结束，分号前没有任何内容，js引擎将其视为空语句</li>
<li>表达式（需要得出结果）不需要分号结尾，不然js引擎会将其视为语句，这样会产生一些没有意义的语句</li>
</ul>
<h4 id="2-js用法"><a href="#2-js用法" class="headerlink" title="2.js用法"></a>2.js用法</h4><ul>
<li>HTML脚本必须位于<script>和</script>标签之间，脚本可放置在body或head标签中</li>
<li>如需在HTML页面中插入脚本，请使用script标签，他会告诉js在何处开始和结束</li>
<li>引入外部脚本<script src></script></li>
</ul>
<h5 id="js区分大小写"><a href="#js区分大小写" class="headerlink" title="js区分大小写"></a>js区分大小写</h5><h4 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h4><ul>
<li>局部变量不声明变量，即不写var，会自动创建全局变量；如果使用<code>var</code>重新声明一个已经存在的变量，是无效的。但第二次声明的时候还进行了赋值，则会覆盖掉前面的值。</li>
<li>如果一个变量没有声明就直接使用，js会报错，告诉你变量未定义</li>
<li>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</li>
<li>变量是一个名称，字面量是一个值</li>
<li>JavaScript 标识符必须以字母、下划线（_）或美元符（$）开始。后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的，以便 JavaScript 可以轻易区分开标识符和数字）。</li>
<li>undefined：声明变量却没赋值的变量，表示“无定义”</li>
<li>单行用   / /   注释，多行注释用 /*   */ </li>
<li>当您向变量分配文本值时，应该用双引号或单引号包围这个值。当您向变量赋的值是数值时，不要使用引号。如果您用引号包围数值，该值会被作为文本来处理。</li>
</ul>
<h5 id="1-变量类型"><a href="#1-变量类型" class="headerlink" title="1 .变量类型"></a>1 .变量类型</h5><ul>
<li>值类型<ul>
<li>占用空间固定，保存在栈中</li>
<li>保存复制的是值本身</li>
<li>使用typeof检测数据的类型</li>
<li>基本类型数据是值类型</li>
</ul>
</li>
<li>引用类型<ul>
<li>占用空间不固定，保存在堆中</li>
<li>保存和复制的是指向对象的一个指针</li>
<li>使用instanceof检测数据的类型</li>
<li>使用new（）方法构造出来的对象是引用型的</li>
</ul>
</li>
</ul>
<h5 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2.作用域"></a>2.作用域</h5><ul>
<li>全局变量<ul>
<li>在函数体外定义的变量或者在函数体内部定义的无var的变量</li>
<li>在任何位置都可以调用</li>
</ul>
</li>
<li>局部变量<ul>
<li>在函数体内部用var声明的变量或函数的参数变量</li>
<li>在当前函数体内部调用</li>
</ul>
</li>
<li>优先级<ul>
<li>同名全局变量 &gt; 参数变量 &gt; 局部变量 &gt; 全局变量</li>
</ul>
</li>
<li>特性<ul>
<li>忽略块级作用域</li>
<li>全局变量是全局对象的属性</li>
<li>局部变量是调用对象的属性</li>
<li>作用域链<ul>
<li>内层函数可以访问外层函数的局部变量</li>
<li>外层函数不能访问内层函数局部变量</li>
</ul>
</li>
<li>生命周期<ul>
<li>全局变量：除非被显示删除，否则一直存在</li>
<li>局部变量：自声明起至函数运行完毕或者显示删除</li>
<li>收回机制<ul>
<li>标记清除，引用计数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4.数据类型"></a>4.数据类型</h4><h5 id="1-数字-Number"><a href="#1-数字-Number" class="headerlink" title="1.数字 Number"></a>1.数字 Number</h5><h5 id="2-字符串String"><a href="#2-字符串String" class="headerlink" title="2.字符串String"></a>2.字符串String</h5><ul>
<li><p>由0个或多个16位Unicode字符组成</p>
</li>
<li><p>单引号与双引号不能交叉使用</p>
</li>
<li><p>使用length属性访问字符串长度</p>
<ul>
<li>转义字符算一个字符</li>
<li>无法精确返回双字节字符长度</li>
</ul>
</li>
<li><p>字符串一旦被创建，其值将不能修改，若要改变必须销毁原有字符串</p>
</li>
<li><p>不要创建 String 对象。它会拖慢执行速度，并可能产生其他副作用</p>
</li>
<li><p>类型转换</p>
<ul>
<li><p>toString（）使用类型</p>
<p>​     1.number</p>
<p>​     2.boolean</p>
<p>​     3.string</p>
<p>​     4.object</p>
</li>
<li><p>eval()：计算字符串表达式的值并以数值形式返回</p>
</li>
</ul>
</li>
</ul>
<h5 id="3-布尔Boolean"><a href="#3-布尔Boolean" class="headerlink" title="3.布尔Boolean"></a>3.布尔Boolean</h5><ul>
<li><p>任何值和布尔值比较时，<strong>两边都会转化为Number类型</strong></p>
</li>
<li><p>[0]用if判断的时候为true，和布尔值比较的时候转换为0。{x:0}用if判断的时候为true，和布尔值比较的时候转换为NaN</p>
</li>
<li><p>转换为true</p>
<ul>
<li>任何非空字符串</li>
<li>任何非0的数值</li>
<li>数组和对象（包括空数组和空对象）</li>
</ul>
</li>
<li><p>转换为false</p>
<ul>
<li>空字符串</li>
<li>0和NaN</li>
<li>null和undefined</li>
</ul>
</li>
</ul>
<h5 id="4-数组Array"><a href="#4-数组Array" class="headerlink" title="4.数组Array"></a>4.数组Array</h5><ul>
<li><p>对象Object</p>
</li>
<li><p>空Null</p>
<ul>
<li>逻辑上null表示一个空对象的指针，使用typeof检测时会返回object</li>
</ul>
</li>
<li><p>未定义Undefined</p>
<ul>
<li>使用var声明变量但未初始化</li>
<li>区分空对象指针与尚未定义的变量</li>
<li>对未初始化的变量及未声明的变量使用typeof运算符均会返回undefined</li>
</ul>
</li>
<li><h5 id="undefined与null的关系"><a href="#undefined与null的关系" class="headerlink" title="undefined与null的关系"></a>undefined与null的关系</h5><ul>
<li>undefined派生于null因此在使用“==”进行比较的时候会返回true</li>
<li>没有必要将变量值声明为undefined</li>
<li>声明空对象的时候应将其值赋值为null</li>
</ul>
</li>
</ul>
<h5 id="5-非数值NaN-Not-a-Number"><a href="#5-非数值NaN-Not-a-Number" class="headerlink" title="5.非数值NaN(Not a Number)"></a>5.非数值NaN(Not a Number)</h5><ul>
<li><p>任何涉及NaN的操作都将返回NaN</p>
</li>
<li><h6 id="NaN与任何数值都不相等包括自身"><a href="#NaN与任何数值都不相等包括自身" class="headerlink" title="NaN与任何数值都不相等包括自身"></a>NaN与任何数值都不相等包括自身</h6></li>
<li><p>检测isNaN（）</p>
<ul>
<li>可转换成数值false</li>
<li>不可转换成数值true</li>
</ul>
</li>
</ul>
<h5 id="6-未定义undefined"><a href="#6-未定义undefined" class="headerlink" title="6.未定义undefined"></a>6.未定义undefined</h5><ul>
<li>变量声明了却没有赋值</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于undefined</li>
<li>对象没有赋值的属性</li>
<li>函数没有返回值，默认返回undefined</li>
</ul>
<h4 id="5-数值转换"><a href="#5-数值转换" class="headerlink" title="5.数值转换"></a>5.数值转换</h4><h5 id="1-Number"><a href="#1-Number" class="headerlink" title="1.Number()"></a>1.Number()</h5><ul>
<li>Boolean——(true  1)(false  0)</li>
<li>null——0</li>
<li>undefined / { }———NaN    (<code>null</code>是一个表示”无”的对象，转为数值时为<code>0</code>；<code>undefined</code>是一个表示”无”的原始值，转为数值时为<code>NaN</code>)</li>
<li>String除数字和空字符串（0）外，其余都是NaN</li>
</ul>
<h5 id="2-解析parseInt（“要解析的字符串”，转换时使用的基数）"><a href="#2-解析parseInt（“要解析的字符串”，转换时使用的基数）" class="headerlink" title="2.解析parseInt（“要解析的字符串”，转换时使用的基数）"></a>2.解析parseInt（“要解析的字符串”，转换时使用的基数）</h5><ul>
<li>忽略前置空格</li>
<li>直接找到第一个非空格字符<ul>
<li>NaN：不是数字字符或符号</li>
<li>如果是数字字符解析所有后续字符，或一直解析直到遇到非数字字符便结束</li>
</ul>
</li>
</ul>
<h5 id="3-parseFloat（）"><a href="#3-parseFloat（）" class="headerlink" title="3.parseFloat（）"></a>3.parseFloat（）</h5><ul>
<li>从第一个字符开始解析，遇到无效浮点格式后结束</li>
<li>只有第一个小数点有效，忽略前导0</li>
<li>十六进制数始终为0，没有小数点或小数点后全0</li>
</ul>
<h4 id="6-对象object"><a href="#6-对象object" class="headerlink" title="6.对象object"></a>6.对象object</h4><ul>
<li>一组数据或功能的集合</li>
<li>声明 var  o=new Object（）</li>
<li>属性和方法<ul>
<li>Constructor：保存用于创建当前对象的函数</li>
<li>hasOwnProperty（propertyName）：检测给定属性在当前对象实例中是否存在</li>
<li>isPrototypeOf（object）检测传入的对象是否为另一个对象的原型</li>
<li>propertyisEnumerable（propertyName）检测给定属性是否能用for-in语句枚举</li>
<li>toLocalString（）返回对象的字符串表示，该字符串与执行环境的地区对应</li>
<li>toString（）返回对象的字符串表示</li>
<li>valueOf（）返回对象的字符串，数值或布尔值表示；通常和toString（）的值相同</li>
</ul>
</li>
</ul>
<h5 id="https-blog-csdn-net-IT-10-article-details-81806665"><a href="#https-blog-csdn-net-IT-10-article-details-81806665" class="headerlink" title="https://blog.csdn.net/IT_10/article/details/81806665"></a><a href="https://blog.csdn.net/IT_10/article/details/81806665" target="_blank" rel="noopener">https://blog.csdn.net/IT_10/article/details/81806665</a></h5><h2 id="四-数据类型的概述"><a href="#四-数据类型的概述" class="headerlink" title="四 . 数据类型的概述"></a>四 . 数据类型的概述</h2><h4 id="1-六大数据类型（number-string-boolean-undefined-null-onject"><a href="#1-六大数据类型（number-string-boolean-undefined-null-onject" class="headerlink" title="1.六大数据类型（number,string,boolean,undefined,null,onject)"></a>1.六大数据类型（number,string,boolean,undefined,null,onject)</h4><ul>
<li>原始类型（primitive type）<ul>
<li>不能再细分，最基本的数据类型</li>
<li>number，string，boolean</li>
</ul>
</li>
<li>合成类型（complex type）<ul>
<li>可看作一个存放多个原始类型值的容器</li>
<li>狭义对象（object），数组（array），函数（function）</li>
</ul>
</li>
<li>undefined和null一般将他们看成两个特殊值</li>
<li>狭义的对象（object）和数组是两种不同的数据组合方式，而函数其实是处理数据的方法。js把函数当成一种数据类型，可以像其他类型的数据一样，进行赋值和传递，这为编程带来了很大的灵活性，体现了js作为“函数式语言”的本质</li>
<li>js的所有数据都可以视为广义的对象。不仅数组和函数属于对象，就连原始值也可用对象方式调用，（不过都是隐式转换，就像输入数值都会隐式转换成字符串数值一样）</li>
</ul>
<h4 id="2-确定值是什么类型的几种方法"><a href="#2-确定值是什么类型的几种方法" class="headerlink" title="2.确定值是什么类型的几种方法"></a>2.确定值是什么类型的几种方法</h4><h6 id="1-typeof运算符"><a href="#1-typeof运算符" class="headerlink" title="1.typeof运算符"></a>1.typeof运算符</h6><ul>
<li>typeof 123     //“number”</li>
<li>typeof  ‘123’   //“string”</li>
<li>typeof   false  //“boolean”</li>
<li>function  f（）{}  typeof  f   //“function”</li>
<li>typeof   undefined   //“undefined”（利用这一点，可用来检查一个没有申明的变量而不报错）</li>
<li>typeof   window / { } / [ ]  / null    //“object”（表明数组本质上只是一种特殊的对象。<code>null</code>的类型也是<code>object</code>，这是由于历史原因造成的）</li>
</ul>
<h6 id="2-instanceof运算符"><a href="#2-instanceof运算符" class="headerlink" title="2.instanceof运算符"></a>2.instanceof运算符</h6><ul>
<li>解决typeof没法区分数组和对象的缺陷</li>
<li>{}/[] instanceof  Object/Array     //true</li>
<li>(function(0{}))   instanceof  Function     //true</li>
<li>原始类型   instanceof    各种类型     //一般都是false</li>
</ul>
<h6 id="3-Object-prototype-toString方法"><a href="#3-Object-prototype-toString方法" class="headerlink" title="3.Object.prototype.toString方法"></a>3.Object.prototype.toString方法</h6><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call([1,2,3])</span><br><span class="line">   &apos;[object Array]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="4-应用typeof方法写方法"><a href="#4-应用typeof方法写方法" class="headerlink" title="4.应用typeof方法写方法"></a>4.应用typeof方法写方法</h6><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var toType = function(obj) &#123;</span><br><span class="line">   return (&#123;&#125;).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">toType(&#123;a: 4&#125;) // &quot;object&quot;</span><br><span class="line">   toType([1, 2, 3]) // &quot;array&quot;</span><br><span class="line">   (function() &#123; return toType(arguments) &#125;()) // &quot;arguments&quot;</span><br><span class="line">   toType(new ReferenceError()) // &quot;error&quot;</span><br><span class="line">   toType(new Date()) // &quot;date&quot;</span><br><span class="line">   toType(/a-z/) // &quot;regexp&quot;</span><br><span class="line">   toType(Math) // &quot;math&quot;</span><br><span class="line">   toType(JSON) // &quot;json&quot;</span><br><span class="line">   toType(new Number(4)) // &quot;number&quot;</span><br><span class="line">   toType(new String(&quot;abc&quot;)) // &quot;string&quot;</span><br><span class="line">   toType(new Boolean(true)) // &quot;boolean&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2011/11/improving-typeof.html" target="_blank" rel="noopener">Improving the JavaScript typeof operator</a></li>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2013/01/categorizing-values.html" target="_blank" rel="noopener">Categorizing values in JavaScript</a></li>
</ul>
<h2 id="五-JavaScript函数"><a href="#五-JavaScript函数" class="headerlink" title="五 . JavaScript函数"></a>五 . JavaScript函数</h2><h4 id="1-定义方法"><a href="#1-定义方法" class="headerlink" title="1.定义方法"></a>1.定义方法</h4><ul>
<li>静态方法function function nane（){执行代码}</li>
<li>动态匿名方法  var 函数名=new Function([“虚参数列表”]，“函数体”)；</li>
<li>直接量方法  函数名=function（【虚参列表】）{函数体}</li>
</ul>
<h4 id="2-调用方法"><a href="#2-调用方法" class="headerlink" title="2.调用方法"></a>2.调用方法</h4><ul>
<li><p>函数作为对象方法调用，会使得 <strong>this</strong> 的值成为对象本身。</p>
</li>
<li><p><strong>call()</strong>（传入的参数是一系列的参数值，但是从第二个参数开始） 和 <strong>apply()</strong> （传入的参数只能是由各参数值组成的数组）是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身。</p>
</li>
<li><p>在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 <strong>this</strong> 的值， 即使该参数不是一个对象。</p>
</li>
<li><p>在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。</p>
</li>
<li><p>在 HTML 中默认的全局对象是 HTML 页面本身，所以函数是属于 HTML 页面。</p>
</li>
<li><p>在浏览器中的页面对象是浏览器窗口(window 对象)。以上函数会自动变为 window 对象的函数。</p>
</li>
<li><p>直接调用    函数名（实参列表）</p>
</li>
<li><p>在连接中调用   <a href="javascript:函数名()" target="_blank" rel="noopener"></a></p>
</li>
<li><p>在事件中调用     事件类型=“函数名（）”</p>
</li>
<li><p>递归调用（在函数体内部调用自身）   function  函数名(){代码    函数名（）；}</p>
</li>
<li><p>构造函数调用</p>
<ul>
<li><p>构造函数中 <strong>this</strong> 关键字没有任何的值。<br><strong>this</strong> 的值在函数调用时实例化对象(new object)时创建。</p>
</li>
<li><p>如果函数或者方法调用之前带有关键字new，他就构成构造函数调用。凡是没有形参的构造函数调用都可以省略圆括号 var  o=new Object;</p>
</li>
<li><p>立即调用函数（IIFE)</p>
<ul>
<li><p>一对圆括号()是一种运算符，跟在函数名之后，表示调用该函数</p>
</li>
<li><p>(function(){  </p>
<p>statement</p>
<p>}())</p>
</li>
<li><p>上面代码的圆括号的用法，function之前的左圆括号是必需的，因为如果不写这个左圆括号，JavaScript解释器会试图将关键字function解析为函数声明语句。而使用圆括号，JavaScript解释器才会正确地将其解析为函数定义表达式。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3.常用方法"></a>3.常用方法</h4><ul>
<li>apply：将函数作为对象的方法来调用，将参数传递给该方法</li>
<li>call：将函数作为对象的方法来调用，将参数传递给该方法</li>
<li>toString：返回函数的字符串表示</li>
</ul>
<h4 id="4-arguments对象"><a href="#4-arguments对象" class="headerlink" title="4.arguments对象"></a>4.arguments对象</h4><ul>
<li><p>功能：存放实参的参数列表</p>
</li>
<li><p>特性 </p>
<ul>
<li>仅能在函数体内使用</li>
<li>带有下标属性，但并非数组</li>
<li>函数声明时自动初始化</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li><p>length：获取函数实参的长度</p>
</li>
<li><p>callee ：返回当前正在指向的对象</p>
</li>
<li><p>caller：返回调用当前正在执行函数的函数名</p>
</li>
<li><p>name属性：返回紧跟在function关键字后的那个函数名</p>
</li>
<li><p>toString方法返回函数的源码</p>
</li>
<li><p>eval命令的作用是将字符串当作语句执行，eval没有自己的作用域，都是在当前作用域内执行</p>
<p>eval（‘var  a=1’）；</p>
<p>JavaScript规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。</p>
<p>(function(){</p>
<p>  ‘use strict’;</p>
<p>  eval(‘var a=1’);</p>
<p>  console.log(a);  //ReferenceError: a is not defined</p>
<p>})();</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-指针标识"><a href="#5-指针标识" class="headerlink" title="5.指针标识"></a>5.指针标识</h4><ul>
<li><p>this：指向当前操作对象</p>
</li>
<li><p>callee：指向参数集合所属函数</p>
</li>
<li><p>prototype：指向函数附带的原型对象</p>
</li>
<li><p>constructor：指向创建该函数的构造函数</p>
</li>
<li><p>JavaScript 变量的生命期从它们被声明的时间开始。局部变量会在函数运行以后被删除。全局变量会在页面关闭后被删除。</p>
</li>
<li><p>如果您把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。</p>
</li>
</ul>
<h4 id="6-函数变量提升"><a href="#6-函数变量提升" class="headerlink" title="6.函数变量提升"></a>6.函数变量提升</h4><ul>
<li>全局变量用var命令声明，不管在什么位置声明，变量声明都会被提升头部</li>
<li>函数作用域内部也会产生变量提升</li>
</ul>
<h4 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7.闭包"></a>7.<strong>闭包</strong></h4><ul>
<li>JavaScript的函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量，这就是JavaScript的闭包。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。</li>
<li>闭包的另一个用处，是封装对象的私有属性和私有方法。</li>
</ul>
<h4 id="8-数组"><a href="#8-数组" class="headerlink" title="8.数组"></a>8.数组</h4><ul>
<li><p>数组属于一种特殊的对象</p>
</li>
<li><p>数组长度length属性</p>
<ul>
<li>length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。</li>
<li>将数组清空的一个有效方法，就是将length属性设为0。</li>
<li>如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</li>
<li>在ECMAScript 5中，可以用Object.defineProperty() 让数组的length属性变成只读。</li>
</ul>
</li>
<li><p>空位</p>
<ul>
<li>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位   var   arr=【1，，2】</li>
<li>但是，如果最后一个元素后面有逗号，并不会产生空位。数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。</li>
</ul>
</li>
<li><p><strong>类数组对象</strong></p>
<ul>
<li><p>在JavaScript中，有些对象被称为“类数组对象”。意思是，它们看上去很像数组，可以使用length属性，但是它们并不是数组，无法使用一些数组的方法。</p>
</li>
<li><p>由于类数组对象没有继承自Array.prototype，那就不能在它们上面直接调用数组方法。不过我们可以间接的使用Function.call方法调用。</p>
</li>
</ul>
</li>
</ul>
<h2 id="六-JavaScript错误处理机制"><a href="#六-JavaScript错误处理机制" class="headerlink" title="六 . JavaScript错误处理机制"></a>六 . JavaScript错误处理机制</h2><ul>
<li><p>javascript解析或执行时，一旦发生错误，引擎就会自动抛出一个错误对象，js提供一个Error构造函数，所有抛出的错误都是这个构造函数的实例 var  err=new  Error（‘出错了’）；err.message</p>
</li>
<li><p>Erroe对象的属性</p>
<ul>
<li>message：错误提示信息</li>
<li>name：错误名称（非标准属性）</li>
<li>stack：错误的堆栈（非标准属性）</li>
</ul>
</li>
<li><p>Error的六大派生对象</p>
<ul>
<li>SyntaxError：是解析代码时发生的错误（变量名错误或者缺少括号）</li>
<li>ReferenceError：是引用一个不存在的变量时发生的的错误或者将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值（console.log()=1)</li>
<li>RangeError:是当一个值超过有效范围时发生的错误，主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值<ul>
<li>new  Array(-1)</li>
<li>(1234).toExponential(21)//toExponential()  argument  must  be  between  0  and  20</li>
</ul>
</li>
<li>TypeError:是参数或变量不是预期类型时发生的错误。比如，对字符串，布尔值，数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数  new 123</li>
<li>URIError：是URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI（），decodeURI（），encodeURIComponent（），decodeURIComponent（），escape（），unescape（）</li>
<li>EvalError:函数没有被正确执行时抛出EvalError错误，该错误类型已不再ES5中出现，只是为了与以前代码兼容</li>
</ul>
</li>
<li><p>自定义错误</p>
<p>function UserError(message){</p>
<p>this.message=message ||”默认信息”；</p>
<p>this.name=”UserError”;}</p>
<p>UserError.prototype=new  Error();</p>
<p>UserError.prototype.constructor=UserError;</p>
</li>
<li><p>throw语句：作用是中断程序执行，抛出一个意外或错误，他接受一个表达式作为参数，可以抛出各种值</p>
</li>
</ul>
<h2 id="七-JavaScript-JSON"><a href="#七-JavaScript-JSON" class="headerlink" title="七 . JavaScript  JSON"></a>七 . JavaScript  JSON</h2><ul>
<li><p>JSON英文全称JavaScript  Object  Notation</p>
</li>
<li><p>是一种易于理解的独立的语言，也是一种轻量级的数据交换格式</p>
</li>
<li><p>JSON使用JavaScript语法，但是JSON格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据传递格式</p>
</li>
<li><p>语法规则</p>
<ul>
<li>数据以键值对形式出现</li>
<li>数据由逗号分隔</li>
<li>大括号保存对象</li>
<li>方括号保存数组</li>
</ul>
</li>
<li><p>通常我们从服务器中读取JSON数据，并在网页中显示数据</p>
</li>
<li><p>JSON字符串转换为js对象</p>
<ul>
<li><p>创建js字符串，字符串为JSON格式的数据</p>
<p>var text = ‘{ “employees” : [‘ +<br>‘{ “firstName”:”John” , “lastName”:”Doe” },’ +<br>‘{ “firstName”:”Anna” , “lastName”:”Smith” },’ +<br>‘{ “firstName”:”Peter” , “lastName”:”Jones” } ]}’;</p>
</li>
<li><p>然后使用js内置函数JSON.parse（）将字符串转化为js对象</p>
</li>
<li><p>var  obj=JSON.parse（text）；</p>
</li>
<li><p>最后在你的页面使用js对象</p>
</li>
</ul>
</li>
</ul>
<h2 id="八-JavaScript：void（0）的含义"><a href="#八-JavaScript：void（0）的含义" class="headerlink" title="八 . JavaScript：void（0）的含义"></a>八 . JavaScript：void（0）的含义</h2><ul>
<li><p>void关键字是js中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值</p>
<p><a href="javascript:void(alert('Warning!!!'))" target="_blank" rel="noopener">点我!</a></p>
</li>
<li><h6 id="href-”-”与href-”javascript-void-0-”的区别"><a href="#href-”-”与href-”javascript-void-0-”的区别" class="headerlink" title="href=”#”与href=”javascript:void(0)”的区别"></a>href=”#”与href=”javascript:void(0)”的区别</h6><p><strong>#</strong> 包含了一个位置信息，默认的锚是<strong>#top</strong> 也就是网页的上端。</p>
<p>而javascript:void(0), 仅仅表示一个死链接。</p>
<p>在页面很长的时候会使用 <strong>#</strong> 来定位页面的具体位置，格式为：<strong># + id</strong>。</p>
<p>如果你要定义一个死链接请使用 javascript:void(0) 。</p>
</li>
<li><p>void()仅仅是代表不返回任何值，但是括号内的表达式还是要运行</p>
</li>
</ul>
<h2 id="九-命名规范"><a href="#九-命名规范" class="headerlink" title="九 . 命名规范"></a>九 . 命名规范</h2><ul>
<li><p>变量名应该区分大小写，允许包含字母、数字、美元符号($)和下划线，但第一个字符不允许是数字，不允许包含空格和其他标点符号；</p>
</li>
<li><p>变量命名长度应该尽可能的短，并抓住要点，尽量在变量名中体现出值的类型；</p>
</li>
<li><p>变量名的命名应该是有意义的；</p>
</li>
<li><p>变量名不能为JavaScript中的关键词、保留字全名；</p>
</li>
<li><p>变量名命名方法常见的有匈牙利命名法、驼峰命名法和帕斯卡命名法。</p>
</li>
<li><h6 id="空格与运算符"><a href="#空格与运算符" class="headerlink" title="空格与运算符"></a>空格与运算符</h6><p>通常运算符 ( = + - * / ) 前后需要添加空格:</p>
</li>
<li><h6 id="代码缩进"><a href="#代码缩进" class="headerlink" title="代码缩进"></a>代码缩进</h6><p>通常使用 4 个空格符号来缩进代码块：</p>
<p>注意:不推荐使用 TAB 键来缩进，因为不同编辑器 TAB 键的解析不一样。</p>
</li>
<li><p>复杂语句的通用规则:</p>
<ul>
<li>一条语句通常以分号作为结束符。</li>
<li>将左花括号放在第一行的结尾。</li>
<li>左花括号前添加一空格。</li>
<li>将右花括号独立放在一行。</li>
<li>不要以分号结束一个复杂的声明。</li>
</ul>
</li>
<li><p>对象定义的规则:</p>
<ul>
<li>将左花括号与类名放在同一行。</li>
<li>冒号与属性值间有个空格。</li>
<li>字符串使用双引号，数字不需要。</li>
<li>最后一个属性-值对后面不要添加逗号。</li>
<li>将右花括号独立放在一行，并以分号作为结束符号。</li>
</ul>
</li>
<li><h6 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h6><ul>
<li>变量和函数为驼峰法（ <strong>camelCase</strong>）</li>
<li>全局变量为大写 (<strong>UPPERCASE</strong> )</li>
<li>常量 (如 PI) 为大写 (<strong>UPPERCASE</strong> )</li>
</ul>
</li>
</ul>
<h2 id="十-文档对象模型HTML-DOM"><a href="#十-文档对象模型HTML-DOM" class="headerlink" title="十.文档对象模型HTML DOM"></a>十.文档对象模型HTML DOM</h2><p><img src="https://7n.w3cschool.cn/statics/images/course/pic_htmltree.gif" alt="DOM HTML tree"></p>
<ul>
<li>通过可编程的对象模型，js能够改变页面中的所有HTML元素，属性，CSS样式，能对页面中的所有事件作出反应</li>
</ul>
<h4 id="1-找HTML元素"><a href="#1-找HTML元素" class="headerlink" title="1.找HTML元素"></a>1.找HTML元素</h4><ul>
<li>通过id    document.getElementById(“id值”);</li>
<li>通过标签名   document.getElementByTagName(“标签名”);</li>
<li>通过类名    document.getElementByClassName(“类名”)；</li>
</ul>
<h4 id="2-节点指针"><a href="#2-节点指针" class="headerlink" title="2.节点指针"></a>2.节点指针</h4><ul>
<li>firstChild ：获取元素的首个子节点</li>
<li>lastChild ：获取元素的最后一个子节点</li>
<li>父节点.childNodes ：获取元素的子节点列表</li>
<li>兄弟节点.previousSibling：获取已知节点的前一个节点</li>
<li>兄弟节点.nextSibling ： 获取已知节点的后一个节点</li>
<li>子节点.parentNode :获取已知节点的父节点</li>
</ul>
<h4 id="3-创建节点"><a href="#3-创建节点" class="headerlink" title="3.创建节点"></a>3.创建节点</h4><ul>
<li>创建元素节点    document.createElement(元素标签)</li>
<li>创建属性节点     document.createAttribute(元素属性)</li>
<li>创建文本节点     document.createTextNode(文本内容)</li>
</ul>
<h4 id="4-插入节点"><a href="#4-插入节点" class="headerlink" title="4.插入节点"></a>4.插入节点</h4><ul>
<li>向节点的子节点列表的末尾添加新的子节点           appendChild（所添加的新节点）</li>
<li>在已知的子节点前插入一个新的子节点      insertBefore（所要添加的新节点，已知节点）</li>
</ul>
<p><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470709730442234.gif" alt="img"></p>
<h4 id="5-改变HTML元素样式"><a href="#5-改变HTML元素样式" class="headerlink" title="5.改变HTML元素样式"></a>5.改变HTML元素样式</h4><p>document.getElementById(id).style.property=new style;</p>
<h4 id="6-添加监听事件"><a href="#6-添加监听事件" class="headerlink" title="6.添加监听事件"></a>6.添加监听事件</h4><p>element.addEventListener(event,function,useCapture);</p>
<p>第一个参数就是事件的类型（如“click”或“mousedown”。注意不要使用“on”前缀，是“click”而非“onclick”）</p>
<p>第二个参数就是事件触发时调用的函数</p>
<p>第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的</p>
<h4 id="7-事件冒泡或事件捕获"><a href="#7-事件冒泡或事件捕获" class="headerlink" title="7.事件冒泡或事件捕获"></a>7.事件冒泡或事件捕获</h4><p>事件传递有两种方式：冒泡与捕获。</p>
<p>事件传递定义了元素事件触发的顺序。 如果你将 </p><p> 元素插入到 <div> 元素中，用户点击 <p> 元素, 哪个元素的 “click” 事件先被触发呢？</p>
<p>在冒泡中，内部元素的事件会先被触发，然后再触发外部元素，即： </p><p> 元素的点击事件先触发，然后会触发 <div> 元素的点击事件。</div></p>
<p>在捕获中，外部元素的事件会先被触发</p>
<p><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470710444592947.gif" alt="img"></p>
<p>在线工具库：<a href="https://123.w3cschool.cn/webtools" target="_blank" rel="noopener">https://123.w3cschool.cn/webtools</a></p>
<h2 id="一-js简介-1"><a href="#一-js简介-1" class="headerlink" title="一 . js简介"></a>一 . js简介</h2><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1.概念"></a>1.概念</h4><ul>
<li>javascript是<strong>世界上最流行的脚本语言</strong>。js是属于web的语言，他适合与PC，笔记本电脑，平板电脑和移动电话。ja被设计成向HTNL页面增加交互性。<ul>
<li>脚本语言：指的是他不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”</li>
</ul>
</li>
<li>通过嵌入HTML来实现各种酷炫的动态效果，为用户提供赏心悦目的浏览效果。所有现代的 HTML 页面都使用 JavaScript，可以用于改进设计、验证表单、检测浏览器、创建cookies等。</li>
<li>javaScript 是一种轻量级的编程语言。JavaScript 是可插入 HTML 页面的编程代码。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</li>
<li>javascript也是一种<strong>嵌入式（embedded）语言</strong>。它本身提供的核心语法不算很多，只是用来做一些数学和逻辑运算。js本身不提供任何与I/O(输入/输出）相关的API，主要靠宿主环境（host）提供，所以js只适合嵌入更大型的应用程序环境，去调用宿主环境提供的底层API。目前，已经嵌入JavaScript的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是Node项目</li>
<li>从语法角度看，javascript语言是一种“对象模型”语言。各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过js控制这些功能。但是，js并不是纯粹的“面型对象语言”，还支持其他编程范式（比如函数式编程）</li>
</ul>
<h4 id="2-支持编译运行。-1"><a href="#2-支持编译运行。-1" class="headerlink" title="2.支持编译运行。"></a>2.<strong>支持编译运行。</strong></h4><ul>
<li>JavaScript 语言本身，虽然是一种解释型语言，但是在现代浏览器中，JavaScript 都是编译后运行。程序会被高度优化，运行效率接近二进制程序。而且，JavaScript 引擎正在快速发展，性能将越来越好。</li>
<li>此外，还有一种 WebAssembly 格式，它是 JavaScript 引擎的中间码格式，全部都是二进制代码。由于跳过了编译步骤，可以达到接近原生二进制代码的运行速度。各种语言（主要是 C 和 C++）通过编译成 WebAssembly，就可以在浏览器里面运行。</li>
</ul>
<h4 id="3-事件驱动和非阻塞式设计-1"><a href="#3-事件驱动和非阻塞式设计-1" class="headerlink" title="3.事件驱动和非阻塞式设计"></a>3.事件驱动和非阻塞式设计</h4><ul>
<li>JavaScript 程序可以采用事件驱动（event-driven）和非阻塞式（non-blocking）设计，在服务器端适合高并发环境，普通的硬件就可以承受很大的访问量。</li>
</ul>
<h4 id="4-javascript与java的关系-1"><a href="#4-javascript与java的关系-1" class="headerlink" title="4.javascript与java的关系"></a>4.javascript与java的关系</h4><table>
<thead>
<tr>
<th>Java</th>
<th>javascript</th>
</tr>
</thead>
<tbody><tr>
<td>强类型</td>
<td>弱类型（同一变量可以存放不同类型的变量（但是始终存放同一类型是良好的编码习惯）</td>
</tr>
</tbody></table>
<p>必须在JAVA虚拟机上运行，且事先需要进行编译    不依托编辑器，在浏览器就可以实现，边解释边执行</p>
<h2 id="二-输出-1"><a href="#二-输出-1" class="headerlink" title="二 . 输出"></a>二 . 输出</h2><h4 id="1-直接写入HTML输出流-1"><a href="#1-直接写入HTML输出流-1" class="headerlink" title="1.直接写入HTML输出流"></a>1.直接写入HTML输出流</h4><p>document.write(“输出内容”);  将内容写入HTML<strong>文档</strong>中</p>
<ul>
<li>你只能在HTNL输出中使用document.write。如果在文档加载完成后使用该方法，会覆盖整个文档。</li>
</ul>
<h4 id="2-弹出警告框alert-1"><a href="#2-弹出警告框alert-1" class="headerlink" title="2.弹出警告框alert"></a>2.弹出警告框alert</h4><p>window.alert（“输出内容”）；</p>
<h4 id="3-在指定位置输出innerHTML-1"><a href="#3-在指定位置输出innerHTML-1" class="headerlink" title="3.在指定位置输出innerHTML"></a>3.在指定位置输出innerHTML</h4><p>var  x=document.getElementById(“id名”)；//使用id属性查找元素</p>
<p>x.innerHTML=”输出内容”;//改变内容，写入到HTML<strong>元素</strong></p>
<h4 id="4-在控制台上输出-1"><a href="#4-在控制台上输出-1" class="headerlink" title="4.在控制台上输出"></a>4.在控制台上输出</h4><p>console.log(‘输出内容’)；</p>
<p>1、console.log 用于输出普通信息</p>
<p>2、console.info 用于输出提示性信息</p>
<p>3、console.error用于输出错误信息</p>
<p>4、console.warn用于输出警示信息</p>
<p>5、console.debug用于输出调试信息</p>
<p>可以通过在控制台输入console.clear()来实现清空控制台信息。</p>
<p><a href="https://jingyan.baidu.com/article/6dad507505f714a123e36e8a.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/6dad507505f714a123e36e8a.html</a></p>
<h2 id="三-js基本语法-1"><a href="#三-js基本语法-1" class="headerlink" title="三 . js基本语法"></a>三 . js基本语法</h2><h4 id="1-语句-1"><a href="#1-语句-1" class="headerlink" title="1.语句"></a>1.语句</h4><ul>
<li>js程序执行单位为行，也就是一行一行地执行一般，每一行就是一个语句。语句是为了完成某种任务而进行的操作（赋值语句），语句以分号结束，分号前没有任何内容，js引擎将其视为空语句</li>
<li>表达式（需要得出结果）不需要分号结尾，不然js引擎会将其视为语句，这样会产生一些没有意义的语句</li>
</ul>
<h4 id="2-js用法-1"><a href="#2-js用法-1" class="headerlink" title="2.js用法"></a>2.js用法</h4><ul>
<li>HTML脚本必须位于<script>和</script>标签之间，脚本可放置在body或head标签中</li>
<li>如需在HTML页面中插入脚本，请使用script标签，他会告诉js在何处开始和结束</li>
<li>引入外部脚本<script src></script></li>
</ul>
<h5 id="js区分大小写-1"><a href="#js区分大小写-1" class="headerlink" title="js区分大小写"></a>js区分大小写</h5><h4 id="3-变量-1"><a href="#3-变量-1" class="headerlink" title="3.变量"></a>3.变量</h4><ul>
<li>局部变量不声明变量，即不写var，会自动创建全局变量；如果使用<code>var</code>重新声明一个已经存在的变量，是无效的。但第二次声明的时候还进行了赋值，则会覆盖掉前面的值。</li>
<li>如果一个变量没有声明就直接使用，js会报错，告诉你变量未定义</li>
<li>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</li>
<li>变量是一个名称，字面量是一个值</li>
<li>JavaScript 标识符必须以字母、下划线（_）或美元符（$）开始。后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的，以便 JavaScript 可以轻易区分开标识符和数字）。</li>
<li>undefined：声明变量却没赋值的变量，表示“无定义”</li>
<li>单行用   / /   注释，多行注释用 /*   */ </li>
<li>当您向变量分配文本值时，应该用双引号或单引号包围这个值。当您向变量赋的值是数值时，不要使用引号。如果您用引号包围数值，该值会被作为文本来处理。</li>
</ul>
<h5 id="1-变量类型-1"><a href="#1-变量类型-1" class="headerlink" title="1 .变量类型"></a>1 .变量类型</h5><ul>
<li>值类型<ul>
<li>占用空间固定，保存在栈中</li>
<li>保存复制的是值本身</li>
<li>使用typeof检测数据的类型</li>
<li>基本类型数据是值类型</li>
</ul>
</li>
<li>引用类型<ul>
<li>占用空间不固定，保存在堆中</li>
<li>保存和复制的是指向对象的一个指针</li>
<li>使用instanceof检测数据的类型</li>
<li>使用new（）方法构造出来的对象是引用型的</li>
</ul>
</li>
</ul>
<h5 id="2-作用域-1"><a href="#2-作用域-1" class="headerlink" title="2.作用域"></a>2.作用域</h5><ul>
<li>全局变量<ul>
<li>在函数体外定义的变量或者在函数体内部定义的无var的变量</li>
<li>在任何位置都可以调用</li>
</ul>
</li>
<li>局部变量<ul>
<li>在函数体内部用var声明的变量或函数的参数变量</li>
<li>在当前函数体内部调用</li>
</ul>
</li>
<li>优先级<ul>
<li>同名全局变量 &gt; 参数变量 &gt; 局部变量 &gt; 全局变量</li>
</ul>
</li>
<li>特性<ul>
<li>忽略块级作用域</li>
<li>全局变量是全局对象的属性</li>
<li>局部变量是调用对象的属性</li>
<li>作用域链<ul>
<li>内层函数可以访问外层函数的局部变量</li>
<li>外层函数不能访问内层函数局部变量</li>
</ul>
</li>
<li>生命周期<ul>
<li>全局变量：除非被显示删除，否则一直存在</li>
<li>局部变量：自声明起至函数运行完毕或者显示删除</li>
<li>收回机制<ul>
<li>标记清除，引用计数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-数据类型-1"><a href="#4-数据类型-1" class="headerlink" title="4.数据类型"></a>4.数据类型</h4><h5 id="1-数字-Number-1"><a href="#1-数字-Number-1" class="headerlink" title="1.数字 Number"></a>1.数字 Number</h5><h5 id="2-字符串String-1"><a href="#2-字符串String-1" class="headerlink" title="2.字符串String"></a>2.字符串String</h5><ul>
<li><p>由0个或多个16位Unicode字符组成</p>
</li>
<li><p>单引号与双引号不能交叉使用</p>
</li>
<li><p>使用length属性访问字符串长度</p>
<ul>
<li>转义字符算一个字符</li>
<li>无法精确返回双字节字符长度</li>
</ul>
</li>
<li><p>字符串一旦被创建，其值将不能修改，若要改变必须销毁原有字符串</p>
</li>
<li><p>不要创建 String 对象。它会拖慢执行速度，并可能产生其他副作用</p>
</li>
<li><p>类型转换</p>
<ul>
<li><p>toString（）使用类型</p>
<p>​     1.number</p>
<p>​     2.boolean</p>
<p>​     3.string</p>
<p>​     4.object</p>
</li>
<li><p>eval()：计算字符串表达式的值并以数值形式返回</p>
</li>
</ul>
</li>
</ul>
<h5 id="3-布尔Boolean-1"><a href="#3-布尔Boolean-1" class="headerlink" title="3.布尔Boolean"></a>3.布尔Boolean</h5><ul>
<li><p>任何值和布尔值比较时，<strong>两边都会转化为Number类型</strong></p>
</li>
<li><p>[0]用if判断的时候为true，和布尔值比较的时候转换为0。{x:0}用if判断的时候为true，和布尔值比较的时候转换为NaN</p>
</li>
<li><p>转换为true</p>
<ul>
<li>任何非空字符串</li>
<li>任何非0的数值</li>
<li>数组和对象（包括空数组和空对象）</li>
</ul>
</li>
<li><p>转换为false</p>
<ul>
<li>空字符串</li>
<li>0和NaN</li>
<li>null和undefined</li>
</ul>
</li>
</ul>
<h5 id="4-数组Array-1"><a href="#4-数组Array-1" class="headerlink" title="4.数组Array"></a>4.数组Array</h5><ul>
<li><p>对象Object</p>
</li>
<li><p>空Null</p>
<ul>
<li>逻辑上null表示一个空对象的指针，使用typeof检测时会返回object</li>
</ul>
</li>
<li><p>未定义Undefined</p>
<ul>
<li>使用var声明变量但未初始化</li>
<li>区分空对象指针与尚未定义的变量</li>
<li>对未初始化的变量及未声明的变量使用typeof运算符均会返回undefined</li>
</ul>
</li>
<li><h5 id="undefined与null的关系-1"><a href="#undefined与null的关系-1" class="headerlink" title="undefined与null的关系"></a>undefined与null的关系</h5><ul>
<li>undefined派生于null因此在使用“==”进行比较的时候会返回true</li>
<li>没有必要将变量值声明为undefined</li>
<li>声明空对象的时候应将其值赋值为null</li>
</ul>
</li>
</ul>
<h5 id="5-非数值NaN-Not-a-Number-1"><a href="#5-非数值NaN-Not-a-Number-1" class="headerlink" title="5.非数值NaN(Not a Number)"></a>5.非数值NaN(Not a Number)</h5><ul>
<li><p>任何涉及NaN的操作都将返回NaN</p>
</li>
<li><h6 id="NaN与任何数值都不相等包括自身-1"><a href="#NaN与任何数值都不相等包括自身-1" class="headerlink" title="NaN与任何数值都不相等包括自身"></a>NaN与任何数值都不相等包括自身</h6></li>
<li><p>检测isNaN（）</p>
<ul>
<li>可转换成数值false</li>
<li>不可转换成数值true</li>
</ul>
</li>
</ul>
<h5 id="6-未定义undefined-1"><a href="#6-未定义undefined-1" class="headerlink" title="6.未定义undefined"></a>6.未定义undefined</h5><ul>
<li>变量声明了却没有赋值</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于undefined</li>
<li>对象没有赋值的属性</li>
<li>函数没有返回值，默认返回undefined</li>
</ul>
<h4 id="5-数值转换-1"><a href="#5-数值转换-1" class="headerlink" title="5.数值转换"></a>5.数值转换</h4><h5 id="1-Number-1"><a href="#1-Number-1" class="headerlink" title="1.Number()"></a>1.Number()</h5><ul>
<li>Boolean——(true  1)(false  0)</li>
<li>null——0</li>
<li>undefined / { }———NaN    (<code>null</code>是一个表示”无”的对象，转为数值时为<code>0</code>；<code>undefined</code>是一个表示”无”的原始值，转为数值时为<code>NaN</code>)</li>
<li>String除数字和空字符串（0）外，其余都是NaN</li>
</ul>
<h5 id="2-解析parseInt（“要解析的字符串”，转换时使用的基数）-1"><a href="#2-解析parseInt（“要解析的字符串”，转换时使用的基数）-1" class="headerlink" title="2.解析parseInt（“要解析的字符串”，转换时使用的基数）"></a>2.解析parseInt（“要解析的字符串”，转换时使用的基数）</h5><ul>
<li>忽略前置空格</li>
<li>直接找到第一个非空格字符<ul>
<li>NaN：不是数字字符或符号</li>
<li>如果是数字字符解析所有后续字符，或一直解析直到遇到非数字字符便结束</li>
</ul>
</li>
</ul>
<h5 id="3-parseFloat（）-1"><a href="#3-parseFloat（）-1" class="headerlink" title="3.parseFloat（）"></a>3.parseFloat（）</h5><ul>
<li>从第一个字符开始解析，遇到无效浮点格式后结束</li>
<li>只有第一个小数点有效，忽略前导0</li>
<li>十六进制数始终为0，没有小数点或小数点后全0</li>
</ul>
<h4 id="6-对象object-1"><a href="#6-对象object-1" class="headerlink" title="6.对象object"></a>6.对象object</h4><ul>
<li>一组数据或功能的集合</li>
<li>声明 var  o=new Object（）</li>
<li>属性和方法<ul>
<li>Constructor：保存用于创建当前对象的函数</li>
<li>hasOwnProperty（propertyName）：检测给定属性在当前对象实例中是否存在</li>
<li>isPrototypeOf（object）检测传入的对象是否为另一个对象的原型</li>
<li>propertyisEnumerable（propertyName）检测给定属性是否能用for-in语句枚举</li>
<li>toLocalString（）返回对象的字符串表示，该字符串与执行环境的地区对应</li>
<li>toString（）返回对象的字符串表示</li>
<li>valueOf（）返回对象的字符串，数值或布尔值表示；通常和toString（）的值相同</li>
</ul>
</li>
</ul>
<h5 id="https-blog-csdn-net-IT-10-article-details-81806665-1"><a href="#https-blog-csdn-net-IT-10-article-details-81806665-1" class="headerlink" title="https://blog.csdn.net/IT_10/article/details/81806665"></a><a href="https://blog.csdn.net/IT_10/article/details/81806665" target="_blank" rel="noopener">https://blog.csdn.net/IT_10/article/details/81806665</a></h5><h2 id="四-数据类型的概述-1"><a href="#四-数据类型的概述-1" class="headerlink" title="四 . 数据类型的概述"></a>四 . 数据类型的概述</h2><h4 id="1-六大数据类型（number-string-boolean-undefined-null-onject-1"><a href="#1-六大数据类型（number-string-boolean-undefined-null-onject-1" class="headerlink" title="1.六大数据类型（number,string,boolean,undefined,null,onject)"></a>1.六大数据类型（number,string,boolean,undefined,null,onject)</h4><ul>
<li>原始类型（primitive type）<ul>
<li>不能再细分，最基本的数据类型</li>
<li>number，string，boolean</li>
</ul>
</li>
<li>合成类型（complex type）<ul>
<li>可看作一个存放多个原始类型值的容器</li>
<li>狭义对象（object），数组（array），函数（function）</li>
</ul>
</li>
<li>undefined和null一般将他们看成两个特殊值</li>
<li>狭义的对象（object）和数组是两种不同的数据组合方式，而函数其实是处理数据的方法。js把函数当成一种数据类型，可以像其他类型的数据一样，进行赋值和传递，这为编程带来了很大的灵活性，体现了js作为“函数式语言”的本质</li>
<li>js的所有数据都可以视为广义的对象。不仅数组和函数属于对象，就连原始值也可用对象方式调用，（不过都是隐式转换，就像输入数值都会隐式转换成字符串数值一样）</li>
</ul>
<h4 id="2-确定值是什么类型的几种方法-1"><a href="#2-确定值是什么类型的几种方法-1" class="headerlink" title="2.确定值是什么类型的几种方法"></a>2.确定值是什么类型的几种方法</h4><h6 id="1-typeof运算符-1"><a href="#1-typeof运算符-1" class="headerlink" title="1.typeof运算符"></a>1.typeof运算符</h6><ul>
<li>typeof 123     //“number”</li>
<li>typeof  ‘123’   //“string”</li>
<li>typeof   false  //“boolean”</li>
<li>function  f（）{}  typeof  f   //“function”</li>
<li>typeof   undefined   //“undefined”（利用这一点，可用来检查一个没有申明的变量而不报错）</li>
<li>typeof   window / { } / [ ]  / null    //“object”（表明数组本质上只是一种特殊的对象。<code>null</code>的类型也是<code>object</code>，这是由于历史原因造成的）</li>
</ul>
<h6 id="2-instanceof运算符-1"><a href="#2-instanceof运算符-1" class="headerlink" title="2.instanceof运算符"></a>2.instanceof运算符</h6><ul>
<li>解决typeof没法区分数组和对象的缺陷</li>
<li>{}/[] instanceof  Object/Array     //true</li>
<li>(function(0{}))   instanceof  Function     //true</li>
<li>原始类型   instanceof    各种类型     //一般都是false</li>
</ul>
<h6 id="3-Object-prototype-toString方法-1"><a href="#3-Object-prototype-toString方法-1" class="headerlink" title="3.Object.prototype.toString方法"></a>3.Object.prototype.toString方法</h6><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call([1,2,3])</span><br><span class="line">   &apos;[object Array]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="4-应用typeof方法写方法-1"><a href="#4-应用typeof方法写方法-1" class="headerlink" title="4.应用typeof方法写方法"></a>4.应用typeof方法写方法</h6><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var toType = function(obj) &#123;</span><br><span class="line">   return (&#123;&#125;).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">toType(&#123;a: 4&#125;) // &quot;object&quot;</span><br><span class="line">   toType([1, 2, 3]) // &quot;array&quot;</span><br><span class="line">   (function() &#123; return toType(arguments) &#125;()) // &quot;arguments&quot;</span><br><span class="line">   toType(new ReferenceError()) // &quot;error&quot;</span><br><span class="line">   toType(new Date()) // &quot;date&quot;</span><br><span class="line">   toType(/a-z/) // &quot;regexp&quot;</span><br><span class="line">   toType(Math) // &quot;math&quot;</span><br><span class="line">   toType(JSON) // &quot;json&quot;</span><br><span class="line">   toType(new Number(4)) // &quot;number&quot;</span><br><span class="line">   toType(new String(&quot;abc&quot;)) // &quot;string&quot;</span><br><span class="line">   toType(new Boolean(true)) // &quot;boolean&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2011/11/improving-typeof.html" target="_blank" rel="noopener">Improving the JavaScript typeof operator</a></li>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2013/01/categorizing-values.html" target="_blank" rel="noopener">Categorizing values in JavaScript</a></li>
</ul>
<h2 id="五-JavaScript函数-1"><a href="#五-JavaScript函数-1" class="headerlink" title="五 . JavaScript函数"></a>五 . JavaScript函数</h2><h4 id="1-定义方法-1"><a href="#1-定义方法-1" class="headerlink" title="1.定义方法"></a>1.定义方法</h4><ul>
<li>静态方法function function nane（){执行代码}</li>
<li>动态匿名方法  var 函数名=new Function([“虚参数列表”]，“函数体”)；</li>
<li>直接量方法  函数名=function（【虚参列表】）{函数体}</li>
</ul>
<h4 id="2-调用方法-1"><a href="#2-调用方法-1" class="headerlink" title="2.调用方法"></a>2.调用方法</h4><ul>
<li><p>函数作为对象方法调用，会使得 <strong>this</strong> 的值成为对象本身。</p>
</li>
<li><p><strong>call()</strong>（传入的参数是一系列的参数值，但是从第二个参数开始） 和 <strong>apply()</strong> （传入的参数只能是由各参数值组成的数组）是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身。</p>
</li>
<li><p>在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 <strong>this</strong> 的值， 即使该参数不是一个对象。</p>
</li>
<li><p>在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。</p>
</li>
<li><p>在 HTML 中默认的全局对象是 HTML 页面本身，所以函数是属于 HTML 页面。</p>
</li>
<li><p>在浏览器中的页面对象是浏览器窗口(window 对象)。以上函数会自动变为 window 对象的函数。</p>
</li>
<li><p>直接调用    函数名（实参列表）</p>
</li>
<li><p>在连接中调用   <a href="javascript:函数名()" target="_blank" rel="noopener"></a></p>
</li>
<li><p>在事件中调用     事件类型=“函数名（）”</p>
</li>
<li><p>递归调用（在函数体内部调用自身）   function  函数名(){代码    函数名（）；}</p>
</li>
<li><p>构造函数调用</p>
<ul>
<li><p>构造函数中 <strong>this</strong> 关键字没有任何的值。<br><strong>this</strong> 的值在函数调用时实例化对象(new object)时创建。</p>
</li>
<li><p>如果函数或者方法调用之前带有关键字new，他就构成构造函数调用。凡是没有形参的构造函数调用都可以省略圆括号 var  o=new Object;</p>
</li>
<li><p>立即调用函数（IIFE)</p>
<ul>
<li><p>一对圆括号()是一种运算符，跟在函数名之后，表示调用该函数</p>
</li>
<li><p>(function(){  </p>
<p>statement</p>
<p>}())</p>
</li>
<li><p>上面代码的圆括号的用法，function之前的左圆括号是必需的，因为如果不写这个左圆括号，JavaScript解释器会试图将关键字function解析为函数声明语句。而使用圆括号，JavaScript解释器才会正确地将其解析为函数定义表达式。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-常用方法-1"><a href="#3-常用方法-1" class="headerlink" title="3.常用方法"></a>3.常用方法</h4><ul>
<li>apply：将函数作为对象的方法来调用，将参数传递给该方法</li>
<li>call：将函数作为对象的方法来调用，将参数传递给该方法</li>
<li>toString：返回函数的字符串表示</li>
</ul>
<h4 id="4-arguments对象-1"><a href="#4-arguments对象-1" class="headerlink" title="4.arguments对象"></a>4.arguments对象</h4><ul>
<li><p>功能：存放实参的参数列表</p>
</li>
<li><p>特性 </p>
<ul>
<li>仅能在函数体内使用</li>
<li>带有下标属性，但并非数组</li>
<li>函数声明时自动初始化</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li><p>length：获取函数实参的长度</p>
</li>
<li><p>callee ：返回当前正在指向的对象</p>
</li>
<li><p>caller：返回调用当前正在执行函数的函数名</p>
</li>
<li><p>name属性：返回紧跟在function关键字后的那个函数名</p>
</li>
<li><p>toString方法返回函数的源码</p>
</li>
<li><p>eval命令的作用是将字符串当作语句执行，eval没有自己的作用域，都是在当前作用域内执行</p>
<p>eval（‘var  a=1’）；</p>
<p>JavaScript规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。</p>
<p>(function(){</p>
<p>  ‘use strict’;</p>
<p>  eval(‘var a=1’);</p>
<p>  console.log(a);  //ReferenceError: a is not defined</p>
<p>})();</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-指针标识-1"><a href="#5-指针标识-1" class="headerlink" title="5.指针标识"></a>5.指针标识</h4><ul>
<li><p>this：指向当前操作对象</p>
</li>
<li><p>callee：指向参数集合所属函数</p>
</li>
<li><p>prototype：指向函数附带的原型对象</p>
</li>
<li><p>constructor：指向创建该函数的构造函数</p>
</li>
<li><p>JavaScript 变量的生命期从它们被声明的时间开始。局部变量会在函数运行以后被删除。全局变量会在页面关闭后被删除。</p>
</li>
<li><p>如果您把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。</p>
</li>
</ul>
<h4 id="6-函数变量提升-1"><a href="#6-函数变量提升-1" class="headerlink" title="6.函数变量提升"></a>6.函数变量提升</h4><ul>
<li>全局变量用var命令声明，不管在什么位置声明，变量声明都会被提升头部</li>
<li>函数作用域内部也会产生变量提升</li>
</ul>
<h4 id="7-闭包-1"><a href="#7-闭包-1" class="headerlink" title="7.闭包"></a>7.<strong>闭包</strong></h4><ul>
<li>JavaScript的函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量，这就是JavaScript的闭包。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。</li>
<li>闭包的另一个用处，是封装对象的私有属性和私有方法。</li>
</ul>
<h4 id="8-数组-1"><a href="#8-数组-1" class="headerlink" title="8.数组"></a>8.数组</h4><ul>
<li><p>数组属于一种特殊的对象</p>
</li>
<li><p>数组长度length属性</p>
<ul>
<li>length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。</li>
<li>将数组清空的一个有效方法，就是将length属性设为0。</li>
<li>如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</li>
<li>在ECMAScript 5中，可以用Object.defineProperty() 让数组的length属性变成只读。</li>
</ul>
</li>
<li><p>空位</p>
<ul>
<li>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位   var   arr=【1，，2】</li>
<li>但是，如果最后一个元素后面有逗号，并不会产生空位。数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。</li>
</ul>
</li>
<li><p><strong>类数组对象</strong></p>
<ul>
<li><p>在JavaScript中，有些对象被称为“类数组对象”。意思是，它们看上去很像数组，可以使用length属性，但是它们并不是数组，无法使用一些数组的方法。</p>
</li>
<li><p>由于类数组对象没有继承自Array.prototype，那就不能在它们上面直接调用数组方法。不过我们可以间接的使用Function.call方法调用。</p>
</li>
</ul>
</li>
</ul>
<h2 id="六-JavaScript错误处理机制-1"><a href="#六-JavaScript错误处理机制-1" class="headerlink" title="六 . JavaScript错误处理机制"></a>六 . JavaScript错误处理机制</h2><ul>
<li><p>javascript解析或执行时，一旦发生错误，引擎就会自动抛出一个错误对象，js提供一个Error构造函数，所有抛出的错误都是这个构造函数的实例 var  err=new  Error（‘出错了’）；err.message</p>
</li>
<li><p>Erroe对象的属性</p>
<ul>
<li>message：错误提示信息</li>
<li>name：错误名称（非标准属性）</li>
<li>stack：错误的堆栈（非标准属性）</li>
</ul>
</li>
<li><p>Error的六大派生对象</p>
<ul>
<li>SyntaxError：是解析代码时发生的错误（变量名错误或者缺少括号）</li>
<li>ReferenceError：是引用一个不存在的变量时发生的的错误或者将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值（console.log()=1)</li>
<li>RangeError:是当一个值超过有效范围时发生的错误，主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值<ul>
<li>new  Array(-1)</li>
<li>(1234).toExponential(21)//toExponential()  argument  must  be  between  0  and  20</li>
</ul>
</li>
<li>TypeError:是参数或变量不是预期类型时发生的错误。比如，对字符串，布尔值，数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数  new 123</li>
<li>URIError：是URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI（），decodeURI（），encodeURIComponent（），decodeURIComponent（），escape（），unescape（）</li>
<li>EvalError:函数没有被正确执行时抛出EvalError错误，该错误类型已不再ES5中出现，只是为了与以前代码兼容</li>
</ul>
</li>
<li><p>自定义错误</p>
<p>function UserError(message){</p>
<p>this.message=message ||”默认信息”；</p>
<p>this.name=”UserError”;}</p>
<p>UserError.prototype=new  Error();</p>
<p>UserError.prototype.constructor=UserError;</p>
</li>
<li><p>throw语句：作用是中断程序执行，抛出一个意外或错误，他接受一个表达式作为参数，可以抛出各种值</p>
</li>
</ul>
<h2 id="七-JavaScript-JSON-1"><a href="#七-JavaScript-JSON-1" class="headerlink" title="七 . JavaScript  JSON"></a>七 . JavaScript  JSON</h2><ul>
<li><p>JSON英文全称JavaScript  Object  Notation</p>
</li>
<li><p>是一种易于理解的独立的语言，也是一种轻量级的数据交换格式</p>
</li>
<li><p>JSON使用JavaScript语法，但是JSON格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据传递格式</p>
</li>
<li><p>语法规则</p>
<ul>
<li>数据以键值对形式出现</li>
<li>数据由逗号分隔</li>
<li>大括号保存对象</li>
<li>方括号保存数组</li>
</ul>
</li>
<li><p>通常我们从服务器中读取JSON数据，并在网页中显示数据</p>
</li>
<li><p>JSON字符串转换为js对象</p>
<ul>
<li><p>创建js字符串，字符串为JSON格式的数据</p>
<p>var text = ‘{ “employees” : [‘ +<br>‘{ “firstName”:”John” , “lastName”:”Doe” },’ +<br>‘{ “firstName”:”Anna” , “lastName”:”Smith” },’ +<br>‘{ “firstName”:”Peter” , “lastName”:”Jones” } ]}’;</p>
</li>
<li><p>然后使用js内置函数JSON.parse（）将字符串转化为js对象</p>
</li>
<li><p>var  obj=JSON.parse（text）；</p>
</li>
<li><p>最后在你的页面使用js对象</p>
</li>
</ul>
</li>
</ul>
<h2 id="八-JavaScript：void（0）的含义-1"><a href="#八-JavaScript：void（0）的含义-1" class="headerlink" title="八 . JavaScript：void（0）的含义"></a>八 . JavaScript：void（0）的含义</h2><ul>
<li><p>void关键字是js中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值</p>
<p><a href="javascript:void(alert('Warning!!!'))" target="_blank" rel="noopener">点我!</a></p>
</li>
<li><h6 id="href-”-”与href-”javascript-void-0-”的区别-1"><a href="#href-”-”与href-”javascript-void-0-”的区别-1" class="headerlink" title="href=”#”与href=”javascript:void(0)”的区别"></a>href=”#”与href=”javascript:void(0)”的区别</h6><p><strong>#</strong> 包含了一个位置信息，默认的锚是<strong>#top</strong> 也就是网页的上端。</p>
<p>而javascript:void(0), 仅仅表示一个死链接。</p>
<p>在页面很长的时候会使用 <strong>#</strong> 来定位页面的具体位置，格式为：<strong># + id</strong>。</p>
<p>如果你要定义一个死链接请使用 javascript:void(0) 。</p>
</li>
<li><p>void()仅仅是代表不返回任何值，但是括号内的表达式还是要运行</p>
</li>
</ul>
<h2 id="九-命名规范-1"><a href="#九-命名规范-1" class="headerlink" title="九 . 命名规范"></a>九 . 命名规范</h2><ul>
<li><p>变量名应该区分大小写，允许包含字母、数字、美元符号($)和下划线，但第一个字符不允许是数字，不允许包含空格和其他标点符号；</p>
</li>
<li><p>变量命名长度应该尽可能的短，并抓住要点，尽量在变量名中体现出值的类型；</p>
</li>
<li><p>变量名的命名应该是有意义的；</p>
</li>
<li><p>变量名不能为JavaScript中的关键词、保留字全名；</p>
</li>
<li><p>变量名命名方法常见的有匈牙利命名法、驼峰命名法和帕斯卡命名法。</p>
</li>
<li><h6 id="空格与运算符-1"><a href="#空格与运算符-1" class="headerlink" title="空格与运算符"></a>空格与运算符</h6><p>通常运算符 ( = + - * / ) 前后需要添加空格:</p>
</li>
<li><h6 id="代码缩进-1"><a href="#代码缩进-1" class="headerlink" title="代码缩进"></a>代码缩进</h6><p>通常使用 4 个空格符号来缩进代码块：</p>
<p>注意:不推荐使用 TAB 键来缩进，因为不同编辑器 TAB 键的解析不一样。</p>
</li>
<li><p>复杂语句的通用规则:</p>
<ul>
<li>一条语句通常以分号作为结束符。</li>
<li>将左花括号放在第一行的结尾。</li>
<li>左花括号前添加一空格。</li>
<li>将右花括号独立放在一行。</li>
<li>不要以分号结束一个复杂的声明。</li>
</ul>
</li>
<li><p>对象定义的规则:</p>
<ul>
<li>将左花括号与类名放在同一行。</li>
<li>冒号与属性值间有个空格。</li>
<li>字符串使用双引号，数字不需要。</li>
<li>最后一个属性-值对后面不要添加逗号。</li>
<li>将右花括号独立放在一行，并以分号作为结束符号。</li>
</ul>
</li>
<li><h6 id="命名规则-1"><a href="#命名规则-1" class="headerlink" title="命名规则"></a>命名规则</h6><ul>
<li>变量和函数为驼峰法（ <strong>camelCase</strong>）</li>
<li>全局变量为大写 (<strong>UPPERCASE</strong> )</li>
<li>常量 (如 PI) 为大写 (<strong>UPPERCASE</strong> )</li>
</ul>
</li>
</ul>
<h2 id="十-文档对象模型HTML-DOM-1"><a href="#十-文档对象模型HTML-DOM-1" class="headerlink" title="十.文档对象模型HTML DOM"></a>十.文档对象模型HTML DOM</h2><p><img src="https://7n.w3cschool.cn/statics/images/course/pic_htmltree.gif" alt="DOM HTML tree"></p>
<ul>
<li>通过可编程的对象模型，js能够改变页面中的所有HTML元素，属性，CSS样式，能对页面中的所有事件作出反应</li>
</ul>
<h4 id="1-找HTML元素-1"><a href="#1-找HTML元素-1" class="headerlink" title="1.找HTML元素"></a>1.找HTML元素</h4><ul>
<li>通过id    document.getElementById(“id值”);</li>
<li>通过标签名   document.getElementByTagName(“标签名”);</li>
<li>通过类名    document.getElementByClassName(“类名”)；</li>
</ul>
<h4 id="2-节点指针-1"><a href="#2-节点指针-1" class="headerlink" title="2.节点指针"></a>2.节点指针</h4><ul>
<li>firstChild ：获取元素的首个子节点</li>
<li>lastChild ：获取元素的最后一个子节点</li>
<li>父节点.childNodes ：获取元素的子节点列表</li>
<li>兄弟节点.previousSibling：获取已知节点的前一个节点</li>
<li>兄弟节点.nextSibling ： 获取已知节点的后一个节点</li>
<li>子节点.parentNode :获取已知节点的父节点</li>
</ul>
<h4 id="3-创建节点-1"><a href="#3-创建节点-1" class="headerlink" title="3.创建节点"></a>3.创建节点</h4><ul>
<li>创建元素节点    document.createElement(元素标签)</li>
<li>创建属性节点     document.createAttribute(元素属性)</li>
<li>创建文本节点     document.createTextNode(文本内容)</li>
</ul>
<h4 id="4-插入节点-1"><a href="#4-插入节点-1" class="headerlink" title="4.插入节点"></a>4.插入节点</h4><ul>
<li>向节点的子节点列表的末尾添加新的子节点           appendChild（所添加的新节点）</li>
<li>在已知的子节点前插入一个新的子节点      insertBefore（所要添加的新节点，已知节点）</li>
</ul>
<p><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470709730442234.gif" alt="img"></p>
<h4 id="5-改变HTML元素样式-1"><a href="#5-改变HTML元素样式-1" class="headerlink" title="5.改变HTML元素样式"></a>5.改变HTML元素样式</h4><p>document.getElementById(id).style.property=new style;</p>
<h4 id="6-添加监听事件-1"><a href="#6-添加监听事件-1" class="headerlink" title="6.添加监听事件"></a>6.添加监听事件</h4><p>element.addEventListener(event,function,useCapture);</p>
<p>第一个参数就是事件的类型（如“click”或“mousedown”。注意不要使用“on”前缀，是“click”而非“onclick”）</p>
<p>第二个参数就是事件触发时调用的函数</p>
<p>第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的</p>
<h4 id="7-事件冒泡或事件捕获？"><a href="#7-事件冒泡或事件捕获？" class="headerlink" title="7.事件冒泡或事件捕获？"></a>7.事件冒泡或事件捕获？</h4><p>事件传递有两种方式：冒泡与捕获。</p>
<p>事件传递定义了元素事件触发的顺序。 如果你将 </p><p> 元素插入到 <div> 元素中，用户点击 <p> 元素, 哪个元素的 “click” 事件先被触发呢？</p>
<p>在冒泡中，内部元素的事件会先被触发，然后再触发外部元素，即： </p><p> 元素的点击事件先触发，然后会触发 <div> 元素的点击事件。</div></p>
<p>在捕获中，外部元素的事件会先被触发</p>
<p><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470710444592947.gif" alt="img"></p>
<p>在线工具库：<a href="https://123.w3cschool.cn/webtools" target="_blank" rel="noopener">https://123.w3cschool.cn/webtools</a></p>
<h2 id="一-js简介-2"><a href="#一-js简介-2" class="headerlink" title="一 . js简介"></a>一 . js简介</h2><h4 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1.概念"></a>1.概念</h4><ul>
<li>javascript是<strong>世界上最流行的脚本语言</strong>。js是属于web的语言，他适合与PC，笔记本电脑，平板电脑和移动电话。ja被设计成向HTNL页面增加交互性。<ul>
<li>脚本语言：指的是他不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”</li>
</ul>
</li>
<li>通过嵌入HTML来实现各种酷炫的动态效果，为用户提供赏心悦目的浏览效果。所有现代的 HTML 页面都使用 JavaScript，可以用于改进设计、验证表单、检测浏览器、创建cookies等。</li>
<li>javaScript 是一种轻量级的编程语言。JavaScript 是可插入 HTML 页面的编程代码。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</li>
<li>javascript也是一种<strong>嵌入式（embedded）语言</strong>。它本身提供的核心语法不算很多，只是用来做一些数学和逻辑运算。js本身不提供任何与I/O(输入/输出）相关的API，主要靠宿主环境（host）提供，所以js只适合嵌入更大型的应用程序环境，去调用宿主环境提供的底层API。目前，已经嵌入JavaScript的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是Node项目</li>
<li>从语法角度看，javascript语言是一种“对象模型”语言。各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过js控制这些功能。但是，js并不是纯粹的“面型对象语言”，还支持其他编程范式（比如函数式编程）</li>
</ul>
<h4 id="2-支持编译运行。-2"><a href="#2-支持编译运行。-2" class="headerlink" title="2.支持编译运行。"></a>2.<strong>支持编译运行。</strong></h4><ul>
<li>JavaScript 语言本身，虽然是一种解释型语言，但是在现代浏览器中，JavaScript 都是编译后运行。程序会被高度优化，运行效率接近二进制程序。而且，JavaScript 引擎正在快速发展，性能将越来越好。</li>
<li>此外，还有一种 WebAssembly 格式，它是 JavaScript 引擎的中间码格式，全部都是二进制代码。由于跳过了编译步骤，可以达到接近原生二进制代码的运行速度。各种语言（主要是 C 和 C++）通过编译成 WebAssembly，就可以在浏览器里面运行。</li>
</ul>
<h4 id="3-事件驱动和非阻塞式设计-2"><a href="#3-事件驱动和非阻塞式设计-2" class="headerlink" title="3.事件驱动和非阻塞式设计"></a>3.事件驱动和非阻塞式设计</h4><ul>
<li>JavaScript 程序可以采用事件驱动（event-driven）和非阻塞式（non-blocking）设计，在服务器端适合高并发环境，普通的硬件就可以承受很大的访问量。</li>
</ul>
<h4 id="4-javascript与java的关系-2"><a href="#4-javascript与java的关系-2" class="headerlink" title="4.javascript与java的关系"></a>4.javascript与java的关系</h4><table>
<thead>
<tr>
<th>Java</th>
<th>javascript</th>
</tr>
</thead>
<tbody><tr>
<td>强类型</td>
<td>弱类型（同一变量可以存放不同类型的变量（但是始终存放同一类型是良好的编码习惯）</td>
</tr>
</tbody></table>
<p>必须在JAVA虚拟机上运行，且事先需要进行编译    不依托编辑器，在浏览器就可以实现，边解释边执行</p>
<h2 id="二-输出-2"><a href="#二-输出-2" class="headerlink" title="二 . 输出"></a>二 . 输出</h2><h4 id="1-直接写入HTML输出流-2"><a href="#1-直接写入HTML输出流-2" class="headerlink" title="1.直接写入HTML输出流"></a>1.直接写入HTML输出流</h4><p>document.write(“输出内容”);  将内容写入HTML<strong>文档</strong>中</p>
<ul>
<li>你只能在HTNL输出中使用document.write。如果在文档加载完成后使用该方法，会覆盖整个文档。</li>
</ul>
<h4 id="2-弹出警告框alert-2"><a href="#2-弹出警告框alert-2" class="headerlink" title="2.弹出警告框alert"></a>2.弹出警告框alert</h4><p>window.alert（“输出内容”）；</p>
<h4 id="3-在指定位置输出innerHTML-2"><a href="#3-在指定位置输出innerHTML-2" class="headerlink" title="3.在指定位置输出innerHTML"></a>3.在指定位置输出innerHTML</h4><p>var  x=document.getElementById(“id名”)；//使用id属性查找元素</p>
<p>x.innerHTML=”输出内容”;//改变内容，写入到HTML<strong>元素</strong></p>
<h4 id="4-在控制台上输出-2"><a href="#4-在控制台上输出-2" class="headerlink" title="4.在控制台上输出"></a>4.在控制台上输出</h4><p>console.log(‘输出内容’)；</p>
<p>1、console.log 用于输出普通信息</p>
<p>2、console.info 用于输出提示性信息</p>
<p>3、console.error用于输出错误信息</p>
<p>4、console.warn用于输出警示信息</p>
<p>5、console.debug用于输出调试信息</p>
<p>可以通过在控制台输入console.clear()来实现清空控制台信息。</p>
<p><a href="https://jingyan.baidu.com/article/6dad507505f714a123e36e8a.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/6dad507505f714a123e36e8a.html</a></p>
<h2 id="三-js基本语法-2"><a href="#三-js基本语法-2" class="headerlink" title="三 . js基本语法"></a>三 . js基本语法</h2><h4 id="1-语句-2"><a href="#1-语句-2" class="headerlink" title="1.语句"></a>1.语句</h4><ul>
<li>js程序执行单位为行，也就是一行一行地执行一般，每一行就是一个语句。语句是为了完成某种任务而进行的操作（赋值语句），语句以分号结束，分号前没有任何内容，js引擎将其视为空语句</li>
<li>表达式（需要得出结果）不需要分号结尾，不然js引擎会将其视为语句，这样会产生一些没有意义的语句</li>
</ul>
<h4 id="2-js用法-2"><a href="#2-js用法-2" class="headerlink" title="2.js用法"></a>2.js用法</h4><ul>
<li>HTML脚本必须位于<script>和</script>标签之间，脚本可放置在body或head标签中</li>
<li>如需在HTML页面中插入脚本，请使用script标签，他会告诉js在何处开始和结束</li>
<li>引入外部脚本<script src></script></li>
</ul>
<h5 id="js区分大小写-2"><a href="#js区分大小写-2" class="headerlink" title="js区分大小写"></a>js区分大小写</h5><h4 id="3-变量-2"><a href="#3-变量-2" class="headerlink" title="3.变量"></a>3.变量</h4><ul>
<li>局部变量不声明变量，即不写var，会自动创建全局变量；如果使用<code>var</code>重新声明一个已经存在的变量，是无效的。但第二次声明的时候还进行了赋值，则会覆盖掉前面的值。</li>
<li>如果一个变量没有声明就直接使用，js会报错，告诉你变量未定义</li>
<li>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</li>
<li>变量是一个名称，字面量是一个值</li>
<li>JavaScript 标识符必须以字母、下划线（_）或美元符（$）开始。后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的，以便 JavaScript 可以轻易区分开标识符和数字）。</li>
<li>undefined：声明变量却没赋值的变量，表示“无定义”</li>
<li>单行用   / /   注释，多行注释用 /*   */ </li>
<li>当您向变量分配文本值时，应该用双引号或单引号包围这个值。当您向变量赋的值是数值时，不要使用引号。如果您用引号包围数值，该值会被作为文本来处理。</li>
</ul>
<h5 id="1-变量类型-2"><a href="#1-变量类型-2" class="headerlink" title="1 .变量类型"></a>1 .变量类型</h5><ul>
<li>值类型<ul>
<li>占用空间固定，保存在栈中</li>
<li>保存复制的是值本身</li>
<li>使用typeof检测数据的类型</li>
<li>基本类型数据是值类型</li>
</ul>
</li>
<li>引用类型<ul>
<li>占用空间不固定，保存在堆中</li>
<li>保存和复制的是指向对象的一个指针</li>
<li>使用instanceof检测数据的类型</li>
<li>使用new（）方法构造出来的对象是引用型的</li>
</ul>
</li>
</ul>
<h5 id="2-作用域-2"><a href="#2-作用域-2" class="headerlink" title="2.作用域"></a>2.作用域</h5><ul>
<li>全局变量<ul>
<li>在函数体外定义的变量或者在函数体内部定义的无var的变量</li>
<li>在任何位置都可以调用</li>
</ul>
</li>
<li>局部变量<ul>
<li>在函数体内部用var声明的变量或函数的参数变量</li>
<li>在当前函数体内部调用</li>
</ul>
</li>
<li>优先级<ul>
<li>同名全局变量 &gt; 参数变量 &gt; 局部变量 &gt; 全局变量</li>
</ul>
</li>
<li>特性<ul>
<li>忽略块级作用域</li>
<li>全局变量是全局对象的属性</li>
<li>局部变量是调用对象的属性</li>
<li>作用域链<ul>
<li>内层函数可以访问外层函数的局部变量</li>
<li>外层函数不能访问内层函数局部变量</li>
</ul>
</li>
<li>生命周期<ul>
<li>全局变量：除非被显示删除，否则一直存在</li>
<li>局部变量：自声明起至函数运行完毕或者显示删除</li>
<li>收回机制<ul>
<li>标记清除，引用计数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-数据类型-2"><a href="#4-数据类型-2" class="headerlink" title="4.数据类型"></a>4.数据类型</h4><h5 id="1-数字-Number-2"><a href="#1-数字-Number-2" class="headerlink" title="1.数字 Number"></a>1.数字 Number</h5><h5 id="2-字符串String-2"><a href="#2-字符串String-2" class="headerlink" title="2.字符串String"></a>2.字符串String</h5><ul>
<li><p>由0个或多个16位Unicode字符组成</p>
</li>
<li><p>单引号与双引号不能交叉使用</p>
</li>
<li><p>使用length属性访问字符串长度</p>
<ul>
<li>转义字符算一个字符</li>
<li>无法精确返回双字节字符长度</li>
</ul>
</li>
<li><p>字符串一旦被创建，其值将不能修改，若要改变必须销毁原有字符串</p>
</li>
<li><p>不要创建 String 对象。它会拖慢执行速度，并可能产生其他副作用</p>
</li>
<li><p>类型转换</p>
<ul>
<li><p>toString（）使用类型</p>
<p>​     1.number</p>
<p>​     2.boolean</p>
<p>​     3.string</p>
<p>​     4.object</p>
</li>
<li><p>eval()：计算字符串表达式的值并以数值形式返回</p>
</li>
</ul>
</li>
</ul>
<h5 id="3-布尔Boolean-2"><a href="#3-布尔Boolean-2" class="headerlink" title="3.布尔Boolean"></a>3.布尔Boolean</h5><ul>
<li><p>任何值和布尔值比较时，<strong>两边都会转化为Number类型</strong></p>
</li>
<li><p>[0]用if判断的时候为true，和布尔值比较的时候转换为0。{x:0}用if判断的时候为true，和布尔值比较的时候转换为NaN</p>
</li>
<li><p>转换为true</p>
<ul>
<li>任何非空字符串</li>
<li>任何非0的数值</li>
<li>数组和对象（包括空数组和空对象）</li>
</ul>
</li>
<li><p>转换为false</p>
<ul>
<li>空字符串</li>
<li>0和NaN</li>
<li>null和undefined</li>
</ul>
</li>
</ul>
<h5 id="4-数组Array-2"><a href="#4-数组Array-2" class="headerlink" title="4.数组Array"></a>4.数组Array</h5><ul>
<li><p>对象Object</p>
</li>
<li><p>空Null</p>
<ul>
<li>逻辑上null表示一个空对象的指针，使用typeof检测时会返回object</li>
</ul>
</li>
<li><p>未定义Undefined</p>
<ul>
<li>使用var声明变量但未初始化</li>
<li>区分空对象指针与尚未定义的变量</li>
<li>对未初始化的变量及未声明的变量使用typeof运算符均会返回undefined</li>
</ul>
</li>
<li><h5 id="undefined与null的关系-2"><a href="#undefined与null的关系-2" class="headerlink" title="undefined与null的关系"></a>undefined与null的关系</h5><ul>
<li>undefined派生于null因此在使用“==”进行比较的时候会返回true</li>
<li>没有必要将变量值声明为undefined</li>
<li>声明空对象的时候应将其值赋值为null</li>
</ul>
</li>
</ul>
<h5 id="5-非数值NaN-Not-a-Number-2"><a href="#5-非数值NaN-Not-a-Number-2" class="headerlink" title="5.非数值NaN(Not a Number)"></a>5.非数值NaN(Not a Number)</h5><ul>
<li><p>任何涉及NaN的操作都将返回NaN</p>
</li>
<li><h6 id="NaN与任何数值都不相等包括自身-2"><a href="#NaN与任何数值都不相等包括自身-2" class="headerlink" title="NaN与任何数值都不相等包括自身"></a>NaN与任何数值都不相等包括自身</h6></li>
<li><p>检测isNaN（）</p>
<ul>
<li>可转换成数值false</li>
<li>不可转换成数值true</li>
</ul>
</li>
</ul>
<h5 id="6-未定义undefined-2"><a href="#6-未定义undefined-2" class="headerlink" title="6.未定义undefined"></a>6.未定义undefined</h5><ul>
<li>变量声明了却没有赋值</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于undefined</li>
<li>对象没有赋值的属性</li>
<li>函数没有返回值，默认返回undefined</li>
</ul>
<h4 id="5-数值转换-2"><a href="#5-数值转换-2" class="headerlink" title="5.数值转换"></a>5.数值转换</h4><h5 id="1-Number-2"><a href="#1-Number-2" class="headerlink" title="1.Number()"></a>1.Number()</h5><ul>
<li>Boolean——(true  1)(false  0)</li>
<li>null——0</li>
<li>undefined / { }———NaN    (<code>null</code>是一个表示”无”的对象，转为数值时为<code>0</code>；<code>undefined</code>是一个表示”无”的原始值，转为数值时为<code>NaN</code>)</li>
<li>String除数字和空字符串（0）外，其余都是NaN</li>
</ul>
<h5 id="2-解析parseInt（“要解析的字符串”，转换时使用的基数）-2"><a href="#2-解析parseInt（“要解析的字符串”，转换时使用的基数）-2" class="headerlink" title="2.解析parseInt（“要解析的字符串”，转换时使用的基数）"></a>2.解析parseInt（“要解析的字符串”，转换时使用的基数）</h5><ul>
<li>忽略前置空格</li>
<li>直接找到第一个非空格字符<ul>
<li>NaN：不是数字字符或符号</li>
<li>如果是数字字符解析所有后续字符，或一直解析直到遇到非数字字符便结束</li>
</ul>
</li>
</ul>
<h5 id="3-parseFloat（）-2"><a href="#3-parseFloat（）-2" class="headerlink" title="3.parseFloat（）"></a>3.parseFloat（）</h5><ul>
<li>从第一个字符开始解析，遇到无效浮点格式后结束</li>
<li>只有第一个小数点有效，忽略前导0</li>
<li>十六进制数始终为0，没有小数点或小数点后全0</li>
</ul>
<h4 id="6-对象object-2"><a href="#6-对象object-2" class="headerlink" title="6.对象object"></a>6.对象object</h4><ul>
<li>一组数据或功能的集合</li>
<li>声明 var  o=new Object（）</li>
<li>属性和方法<ul>
<li>Constructor：保存用于创建当前对象的函数</li>
<li>hasOwnProperty（propertyName）：检测给定属性在当前对象实例中是否存在</li>
<li>isPrototypeOf（object）检测传入的对象是否为另一个对象的原型</li>
<li>propertyisEnumerable（propertyName）检测给定属性是否能用for-in语句枚举</li>
<li>toLocalString（）返回对象的字符串表示，该字符串与执行环境的地区对应</li>
<li>toString（）返回对象的字符串表示</li>
<li>valueOf（）返回对象的字符串，数值或布尔值表示；通常和toString（）的值相同</li>
</ul>
</li>
</ul>
<h5 id="https-blog-csdn-net-IT-10-article-details-81806665-2"><a href="#https-blog-csdn-net-IT-10-article-details-81806665-2" class="headerlink" title="https://blog.csdn.net/IT_10/article/details/81806665"></a><a href="https://blog.csdn.net/IT_10/article/details/81806665" target="_blank" rel="noopener">https://blog.csdn.net/IT_10/article/details/81806665</a></h5><h2 id="四-数据类型的概述-2"><a href="#四-数据类型的概述-2" class="headerlink" title="四 . 数据类型的概述"></a>四 . 数据类型的概述</h2><h4 id="1-六大数据类型（number-string-boolean-undefined-null-onject-2"><a href="#1-六大数据类型（number-string-boolean-undefined-null-onject-2" class="headerlink" title="1.六大数据类型（number,string,boolean,undefined,null,onject)"></a>1.六大数据类型（number,string,boolean,undefined,null,onject)</h4><ul>
<li>原始类型（primitive type）<ul>
<li>不能再细分，最基本的数据类型</li>
<li>number，string，boolean</li>
</ul>
</li>
<li>合成类型（complex type）<ul>
<li>可看作一个存放多个原始类型值的容器</li>
<li>狭义对象（object），数组（array），函数（function）</li>
</ul>
</li>
<li>undefined和null一般将他们看成两个特殊值</li>
<li>狭义的对象（object）和数组是两种不同的数据组合方式，而函数其实是处理数据的方法。js把函数当成一种数据类型，可以像其他类型的数据一样，进行赋值和传递，这为编程带来了很大的灵活性，体现了js作为“函数式语言”的本质</li>
<li>js的所有数据都可以视为广义的对象。不仅数组和函数属于对象，就连原始值也可用对象方式调用，（不过都是隐式转换，就像输入数值都会隐式转换成字符串数值一样）</li>
</ul>
<h4 id="2-确定值是什么类型的几种方法-2"><a href="#2-确定值是什么类型的几种方法-2" class="headerlink" title="2.确定值是什么类型的几种方法"></a>2.确定值是什么类型的几种方法</h4><h6 id="1-typeof运算符-2"><a href="#1-typeof运算符-2" class="headerlink" title="1.typeof运算符"></a>1.typeof运算符</h6><ul>
<li>typeof 123     //“number”</li>
<li>typeof  ‘123’   //“string”</li>
<li>typeof   false  //“boolean”</li>
<li>function  f（）{}  typeof  f   //“function”</li>
<li>typeof   undefined   //“undefined”（利用这一点，可用来检查一个没有申明的变量而不报错）</li>
<li>typeof   window / { } / [ ]  / null    //“object”（表明数组本质上只是一种特殊的对象。<code>null</code>的类型也是<code>object</code>，这是由于历史原因造成的）</li>
</ul>
<h6 id="2-instanceof运算符-2"><a href="#2-instanceof运算符-2" class="headerlink" title="2.instanceof运算符"></a>2.instanceof运算符</h6><ul>
<li>解决typeof没法区分数组和对象的缺陷</li>
<li>{}/[] instanceof  Object/Array     //true</li>
<li>(function(0{}))   instanceof  Function     //true</li>
<li>原始类型   instanceof    各种类型     //一般都是false</li>
</ul>
<h6 id="3-Object-prototype-toString方法-2"><a href="#3-Object-prototype-toString方法-2" class="headerlink" title="3.Object.prototype.toString方法"></a>3.Object.prototype.toString方法</h6><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call([1,2,3])</span><br><span class="line">   &apos;[object Array]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="4-应用typeof方法写方法-2"><a href="#4-应用typeof方法写方法-2" class="headerlink" title="4.应用typeof方法写方法"></a>4.应用typeof方法写方法</h6><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var toType = function(obj) &#123;</span><br><span class="line">   return (&#123;&#125;).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">toType(&#123;a: 4&#125;) // &quot;object&quot;</span><br><span class="line">   toType([1, 2, 3]) // &quot;array&quot;</span><br><span class="line">   (function() &#123; return toType(arguments) &#125;()) // &quot;arguments&quot;</span><br><span class="line">   toType(new ReferenceError()) // &quot;error&quot;</span><br><span class="line">   toType(new Date()) // &quot;date&quot;</span><br><span class="line">   toType(/a-z/) // &quot;regexp&quot;</span><br><span class="line">   toType(Math) // &quot;math&quot;</span><br><span class="line">   toType(JSON) // &quot;json&quot;</span><br><span class="line">   toType(new Number(4)) // &quot;number&quot;</span><br><span class="line">   toType(new String(&quot;abc&quot;)) // &quot;string&quot;</span><br><span class="line">   toType(new Boolean(true)) // &quot;boolean&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2011/11/improving-typeof.html" target="_blank" rel="noopener">Improving the JavaScript typeof operator</a></li>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2013/01/categorizing-values.html" target="_blank" rel="noopener">Categorizing values in JavaScript</a></li>
</ul>
<h2 id="五-JavaScript函数-2"><a href="#五-JavaScript函数-2" class="headerlink" title="五 . JavaScript函数"></a>五 . JavaScript函数</h2><h4 id="1-定义方法-2"><a href="#1-定义方法-2" class="headerlink" title="1.定义方法"></a>1.定义方法</h4><ul>
<li>静态方法function function nane（){执行代码}</li>
<li>动态匿名方法  var 函数名=new Function([“虚参数列表”]，“函数体”)；</li>
<li>直接量方法  函数名=function（【虚参列表】）{函数体}</li>
</ul>
<h4 id="2-调用方法-2"><a href="#2-调用方法-2" class="headerlink" title="2.调用方法"></a>2.调用方法</h4><ul>
<li><p>函数作为对象方法调用，会使得 <strong>this</strong> 的值成为对象本身。</p>
</li>
<li><p><strong>call()</strong>（传入的参数是一系列的参数值，但是从第二个参数开始） 和 <strong>apply()</strong> （传入的参数只能是由各参数值组成的数组）是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身。</p>
</li>
<li><p>在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 <strong>this</strong> 的值， 即使该参数不是一个对象。</p>
</li>
<li><p>在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。</p>
</li>
<li><p>在 HTML 中默认的全局对象是 HTML 页面本身，所以函数是属于 HTML 页面。</p>
</li>
<li><p>在浏览器中的页面对象是浏览器窗口(window 对象)。以上函数会自动变为 window 对象的函数。</p>
</li>
<li><p>直接调用    函数名（实参列表）</p>
</li>
<li><p>在连接中调用   <a href="javascript:函数名()" target="_blank" rel="noopener"></a></p>
</li>
<li><p>在事件中调用     事件类型=“函数名（）”</p>
</li>
<li><p>递归调用（在函数体内部调用自身）   function  函数名(){代码    函数名（）；}</p>
</li>
<li><p>构造函数调用</p>
<ul>
<li><p>构造函数中 <strong>this</strong> 关键字没有任何的值。<br><strong>this</strong> 的值在函数调用时实例化对象(new object)时创建。</p>
</li>
<li><p>如果函数或者方法调用之前带有关键字new，他就构成构造函数调用。凡是没有形参的构造函数调用都可以省略圆括号 var  o=new Object;</p>
</li>
<li><p>立即调用函数（IIFE)</p>
<ul>
<li><p>一对圆括号()是一种运算符，跟在函数名之后，表示调用该函数</p>
</li>
<li><p>(function(){  </p>
<p>statement</p>
<p>}())</p>
</li>
<li><p>上面代码的圆括号的用法，function之前的左圆括号是必需的，因为如果不写这个左圆括号，JavaScript解释器会试图将关键字function解析为函数声明语句。而使用圆括号，JavaScript解释器才会正确地将其解析为函数定义表达式。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-常用方法-2"><a href="#3-常用方法-2" class="headerlink" title="3.常用方法"></a>3.常用方法</h4><ul>
<li>apply：将函数作为对象的方法来调用，将参数传递给该方法</li>
<li>call：将函数作为对象的方法来调用，将参数传递给该方法</li>
<li>toString：返回函数的字符串表示</li>
</ul>
<h4 id="4-arguments对象-2"><a href="#4-arguments对象-2" class="headerlink" title="4.arguments对象"></a>4.arguments对象</h4><ul>
<li><p>功能：存放实参的参数列表</p>
</li>
<li><p>特性 </p>
<ul>
<li>仅能在函数体内使用</li>
<li>带有下标属性，但并非数组</li>
<li>函数声明时自动初始化</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li><p>length：获取函数实参的长度</p>
</li>
<li><p>callee ：返回当前正在指向的对象</p>
</li>
<li><p>caller：返回调用当前正在执行函数的函数名</p>
</li>
<li><p>name属性：返回紧跟在function关键字后的那个函数名</p>
</li>
<li><p>toString方法返回函数的源码</p>
</li>
<li><p>eval命令的作用是将字符串当作语句执行，eval没有自己的作用域，都是在当前作用域内执行</p>
<p>eval（‘var  a=1’）；</p>
<p>JavaScript规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。</p>
<p>(function(){</p>
<p>  ‘use strict’;</p>
<p>  eval(‘var a=1’);</p>
<p>  console.log(a);  //ReferenceError: a is not defined</p>
<p>})();</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-指针标识-2"><a href="#5-指针标识-2" class="headerlink" title="5.指针标识"></a>5.指针标识</h4><ul>
<li><p>this：指向当前操作对象</p>
</li>
<li><p>callee：指向参数集合所属函数</p>
</li>
<li><p>prototype：指向函数附带的原型对象</p>
</li>
<li><p>constructor：指向创建该函数的构造函数</p>
</li>
<li><p>JavaScript 变量的生命期从它们被声明的时间开始。局部变量会在函数运行以后被删除。全局变量会在页面关闭后被删除。</p>
</li>
<li><p>如果您把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。</p>
</li>
</ul>
<h4 id="6-函数变量提升-2"><a href="#6-函数变量提升-2" class="headerlink" title="6.函数变量提升"></a>6.函数变量提升</h4><ul>
<li>全局变量用var命令声明，不管在什么位置声明，变量声明都会被提升头部</li>
<li>函数作用域内部也会产生变量提升</li>
</ul>
<h4 id="7-闭包-2"><a href="#7-闭包-2" class="headerlink" title="7.闭包"></a>7.<strong>闭包</strong></h4><ul>
<li>JavaScript的函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量，这就是JavaScript的闭包。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。</li>
<li>闭包的另一个用处，是封装对象的私有属性和私有方法。</li>
</ul>
<h4 id="8-数组-2"><a href="#8-数组-2" class="headerlink" title="8.数组"></a>8.数组</h4><ul>
<li><p>数组属于一种特殊的对象</p>
</li>
<li><p>数组长度length属性</p>
<ul>
<li>length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。</li>
<li>将数组清空的一个有效方法，就是将length属性设为0。</li>
<li>如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</li>
<li>在ECMAScript 5中，可以用Object.defineProperty() 让数组的length属性变成只读。</li>
</ul>
</li>
<li><p>空位</p>
<ul>
<li>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位   var   arr=【1，，2】</li>
<li>但是，如果最后一个元素后面有逗号，并不会产生空位。数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。</li>
</ul>
</li>
<li><p><strong>类数组对象</strong></p>
<ul>
<li><p>在JavaScript中，有些对象被称为“类数组对象”。意思是，它们看上去很像数组，可以使用length属性，但是它们并不是数组，无法使用一些数组的方法。</p>
</li>
<li><p>由于类数组对象没有继承自Array.prototype，那就不能在它们上面直接调用数组方法。不过我们可以间接的使用Function.call方法调用。</p>
</li>
</ul>
</li>
</ul>
<h2 id="六-JavaScript错误处理机制-2"><a href="#六-JavaScript错误处理机制-2" class="headerlink" title="六 . JavaScript错误处理机制"></a>六 . JavaScript错误处理机制</h2><ul>
<li><p>javascript解析或执行时，一旦发生错误，引擎就会自动抛出一个错误对象，js提供一个Error构造函数，所有抛出的错误都是这个构造函数的实例 var  err=new  Error（‘出错了’）；err.message</p>
</li>
<li><p>Erroe对象的属性</p>
<ul>
<li>message：错误提示信息</li>
<li>name：错误名称（非标准属性）</li>
<li>stack：错误的堆栈（非标准属性）</li>
</ul>
</li>
<li><p>Error的六大派生对象</p>
<ul>
<li>SyntaxError：是解析代码时发生的错误（变量名错误或者缺少括号）</li>
<li>ReferenceError：是引用一个不存在的变量时发生的的错误或者将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值（console.log()=1)</li>
<li>RangeError:是当一个值超过有效范围时发生的错误，主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值<ul>
<li>new  Array(-1)</li>
<li>(1234).toExponential(21)//toExponential()  argument  must  be  between  0  and  20</li>
</ul>
</li>
<li>TypeError:是参数或变量不是预期类型时发生的错误。比如，对字符串，布尔值，数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数  new 123</li>
<li>URIError：是URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI（），decodeURI（），encodeURIComponent（），decodeURIComponent（），escape（），unescape（）</li>
<li>EvalError:函数没有被正确执行时抛出EvalError错误，该错误类型已不再ES5中出现，只是为了与以前代码兼容</li>
</ul>
</li>
<li><p>自定义错误</p>
<p>function UserError(message){</p>
<p>this.message=message ||”默认信息”；</p>
<p>this.name=”UserError”;}</p>
<p>UserError.prototype=new  Error();</p>
<p>UserError.prototype.constructor=UserError;</p>
</li>
<li><p>throw语句：作用是中断程序执行，抛出一个意外或错误，他接受一个表达式作为参数，可以抛出各种值</p>
</li>
</ul>
<h2 id="七-JavaScript-JSON-2"><a href="#七-JavaScript-JSON-2" class="headerlink" title="七 . JavaScript  JSON"></a>七 . JavaScript  JSON</h2><ul>
<li><p>JSON英文全称JavaScript  Object  Notation</p>
</li>
<li><p>是一种易于理解的独立的语言，也是一种轻量级的数据交换格式</p>
</li>
<li><p>JSON使用JavaScript语法，但是JSON格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据传递格式</p>
</li>
<li><p>语法规则</p>
<ul>
<li>数据以键值对形式出现</li>
<li>数据由逗号分隔</li>
<li>大括号保存对象</li>
<li>方括号保存数组</li>
</ul>
</li>
<li><p>通常我们从服务器中读取JSON数据，并在网页中显示数据</p>
</li>
<li><p>JSON字符串转换为js对象</p>
<ul>
<li><p>创建js字符串，字符串为JSON格式的数据</p>
<p>var text = ‘{ “employees” : [‘ +<br>‘{ “firstName”:”John” , “lastName”:”Doe” },’ +<br>‘{ “firstName”:”Anna” , “lastName”:”Smith” },’ +<br>‘{ “firstName”:”Peter” , “lastName”:”Jones” } ]}’;</p>
</li>
<li><p>然后使用js内置函数JSON.parse（）将字符串转化为js对象</p>
</li>
<li><p>var  obj=JSON.parse（text）；</p>
</li>
<li><p>最后在你的页面使用js对象</p>
</li>
</ul>
</li>
</ul>
<h2 id="八-JavaScript：void（0）的含义-2"><a href="#八-JavaScript：void（0）的含义-2" class="headerlink" title="八 . JavaScript：void（0）的含义"></a>八 . JavaScript：void（0）的含义</h2><ul>
<li><p>void关键字是js中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值</p>
<p><a href="javascript:void(alert('Warning!!!'))" target="_blank" rel="noopener">点我!</a></p>
</li>
<li><h6 id="href-”-”与href-”javascript-void-0-”的区别-2"><a href="#href-”-”与href-”javascript-void-0-”的区别-2" class="headerlink" title="href=”#”与href=”javascript:void(0)”的区别"></a>href=”#”与href=”javascript:void(0)”的区别</h6><p><strong>#</strong> 包含了一个位置信息，默认的锚是<strong>#top</strong> 也就是网页的上端。</p>
<p>而javascript:void(0), 仅仅表示一个死链接。</p>
<p>在页面很长的时候会使用 <strong>#</strong> 来定位页面的具体位置，格式为：<strong># + id</strong>。</p>
<p>如果你要定义一个死链接请使用 javascript:void(0) 。</p>
</li>
<li><p>void()仅仅是代表不返回任何值，但是括号内的表达式还是要运行</p>
</li>
</ul>
<h2 id="九-命名规范-2"><a href="#九-命名规范-2" class="headerlink" title="九 . 命名规范"></a>九 . 命名规范</h2><ul>
<li><p>变量名应该区分大小写，允许包含字母、数字、美元符号($)和下划线，但第一个字符不允许是数字，不允许包含空格和其他标点符号；</p>
</li>
<li><p>变量命名长度应该尽可能的短，并抓住要点，尽量在变量名中体现出值的类型；</p>
</li>
<li><p>变量名的命名应该是有意义的；</p>
</li>
<li><p>变量名不能为JavaScript中的关键词、保留字全名；</p>
</li>
<li><p>变量名命名方法常见的有匈牙利命名法、驼峰命名法和帕斯卡命名法。</p>
</li>
<li><h6 id="空格与运算符-2"><a href="#空格与运算符-2" class="headerlink" title="空格与运算符"></a>空格与运算符</h6><p>通常运算符 ( = + - * / ) 前后需要添加空格:</p>
</li>
<li><h6 id="代码缩进-2"><a href="#代码缩进-2" class="headerlink" title="代码缩进"></a>代码缩进</h6><p>通常使用 4 个空格符号来缩进代码块：</p>
<p>注意:不推荐使用 TAB 键来缩进，因为不同编辑器 TAB 键的解析不一样。</p>
</li>
<li><p>复杂语句的通用规则:</p>
<ul>
<li>一条语句通常以分号作为结束符。</li>
<li>将左花括号放在第一行的结尾。</li>
<li>左花括号前添加一空格。</li>
<li>将右花括号独立放在一行。</li>
<li>不要以分号结束一个复杂的声明。</li>
</ul>
</li>
<li><p>对象定义的规则:</p>
<ul>
<li>将左花括号与类名放在同一行。</li>
<li>冒号与属性值间有个空格。</li>
<li>字符串使用双引号，数字不需要。</li>
<li>最后一个属性-值对后面不要添加逗号。</li>
<li>将右花括号独立放在一行，并以分号作为结束符号。</li>
</ul>
</li>
<li><h6 id="命名规则-2"><a href="#命名规则-2" class="headerlink" title="命名规则"></a>命名规则</h6><ul>
<li>变量和函数为驼峰法（ <strong>camelCase</strong>）</li>
<li>全局变量为大写 (<strong>UPPERCASE</strong> )</li>
<li>常量 (如 PI) 为大写 (<strong>UPPERCASE</strong> )</li>
</ul>
</li>
</ul>
<h2 id="十-文档对象模型HTML-DOM-2"><a href="#十-文档对象模型HTML-DOM-2" class="headerlink" title="十.文档对象模型HTML DOM"></a>十.文档对象模型HTML DOM</h2><p><img src="https://7n.w3cschool.cn/statics/images/course/pic_htmltree.gif" alt="DOM HTML tree"></p>
<ul>
<li>通过可编程的对象模型，js能够改变页面中的所有HTML元素，属性，CSS样式，能对页面中的所有事件作出反应</li>
</ul>
<h4 id="1-找HTML元素-2"><a href="#1-找HTML元素-2" class="headerlink" title="1.找HTML元素"></a>1.找HTML元素</h4><ul>
<li>通过id    document.getElementById(“id值”);</li>
<li>通过标签名   document.getElementByTagName(“标签名”);</li>
<li>通过类名    document.getElementByClassName(“类名”)；</li>
</ul>
<h4 id="2-节点指针-2"><a href="#2-节点指针-2" class="headerlink" title="2.节点指针"></a>2.节点指针</h4><ul>
<li>firstChild ：获取元素的首个子节点</li>
<li>lastChild ：获取元素的最后一个子节点</li>
<li>父节点.childNodes ：获取元素的子节点列表</li>
<li>兄弟节点.previousSibling：获取已知节点的前一个节点</li>
<li>兄弟节点.nextSibling ： 获取已知节点的后一个节点</li>
<li>子节点.parentNode :获取已知节点的父节点</li>
</ul>
<h4 id="3-创建节点-2"><a href="#3-创建节点-2" class="headerlink" title="3.创建节点"></a>3.创建节点</h4><ul>
<li>创建元素节点    document.createElement(元素标签)</li>
<li>创建属性节点     document.createAttribute(元素属性)</li>
<li>创建文本节点     document.createTextNode(文本内容)</li>
</ul>
<h4 id="4-插入节点-2"><a href="#4-插入节点-2" class="headerlink" title="4.插入节点"></a>4.插入节点</h4><ul>
<li>向节点的子节点列表的末尾添加新的子节点           appendChild（所添加的新节点）</li>
<li>在已知的子节点前插入一个新的子节点      insertBefore（所要添加的新节点，已知节点）</li>
</ul>
<p><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470709730442234.gif" alt="img"></p>
<h4 id="5-改变HTML元素样式-2"><a href="#5-改变HTML元素样式-2" class="headerlink" title="5.改变HTML元素样式"></a>5.改变HTML元素样式</h4><p>document.getElementById(id).style.property=new style;</p>
<h4 id="6-添加监听事件-2"><a href="#6-添加监听事件-2" class="headerlink" title="6.添加监听事件"></a>6.添加监听事件</h4><p>element.addEventListener(event,function,useCapture);</p>
<p>第一个参数就是事件的类型（如“click”或“mousedown”。注意不要使用“on”前缀，是“click”而非“onclick”）</p>
<p>第二个参数就是事件触发时调用的函数</p>
<p>第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的</p>
<h4 id="7-事件冒泡或事件捕获？-1"><a href="#7-事件冒泡或事件捕获？-1" class="headerlink" title="7.事件冒泡或事件捕获？"></a>7.事件冒泡或事件捕获？</h4><p>事件传递有两种方式：冒泡与捕获。</p>
<p>事件传递定义了元素事件触发的顺序。 如果你将 </p><p> 元素插入到 <div> 元素中，用户点击 <p> 元素, 哪个元素的 “click” 事件先被触发呢？</p>
<p>在冒泡中，内部元素的事件会先被触发，然后再触发外部元素，即： </p><p> 元素的点击事件先触发，然后会触发 <div> 元素的点击事件。</div></p>
<p>在捕获中，外部元素的事件会先被触发</p>
<p><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470710444592947.gif" alt="img"></p>
</div></p></div></p></div></p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-刷题笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/13/刷题笔记/" class="article-date">
      <time datetime="2020-06-13T01:16:13.000Z" itemprop="datePublished">2020-06-13</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/13/刷题笔记/">刷题笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><ol>
<li><p>form表单中input元素的disabled指当input元素加载时禁用此元素，input内容不会随着表单提交。readonly规定输入字段为只读，input内容会随着表单提交。但是无论设置readonly还是disabled，通过js脚本都能更改input的value。</p>
</li>
<li><p><code>&lt;parent&gt;&lt;child&gt;content&lt;/child&gt;&lt;/parent&gt;</code>可使child内容垂直居中。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*把parent变成table，child变成table-cell，而vertical-align可设置元素垂直对齐，前提是：只能应用于内联元素，当parent只有child一个子元素时，child会铺满parent全部空间，即使child有宽高*/</span></span><br><span class="line"><span class="selector-tag">parent</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">child</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>:table-cell;</span><br><span class="line">	<span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*弹性布局。*/</span></span><br><span class="line"><span class="selector-tag">parent</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>:flex;</span><br><span class="line">	<span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*父元素设置相对定位，子元素设置绝对定位，子元素的top设置50%，即父元素的高度一半，注意此时是child元素的左上角（0，0）移到了parent的（0，parent高度的50%），而不是子元素的中心点移到了父元素垂直方向的中心点。因此子元素需要上移自身高度的一半，即transform:translateY(-50%)*/</span></span><br><span class="line"><span class="selector-tag">parent</span>&#123;</span><br><span class="line">	<span class="attribute">positionn</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">child</span>&#123;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*设置伪元素。vertical-align属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。如：有两个行内元素a和b，a，b都是img，若s加了vertical-align：middle样式，b的底部（基线）就会对齐a的中间位置；若a，b都加了，则互相对齐了对方的中间位置，也就是他们在垂直方向上的中线对齐了。*/</span></span><br><span class="line"><span class="selector-tag">parent</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">	<span class="attribute">content</span>:<span class="string">''</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">vertical-align</span>: middle;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">child</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: inline-block;</span><br><span class="line">	<span class="attribute">vertical-align</span>: middle;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>display:none</code>指的是元素不完全陈列出来，不占据空间，涉及到了DOM结构，故产生重排和重绘。</p>
<p><code>visibility:hidden</code>指的是元素不可见但存在，保留空间，不影响结构，故只产生重绘，但不可触发绑定事件。</p>
<p><code>opacity=0</code>指的是元素不可见但存在，保留空间，不影响结构，并且如果如果该元素已经绑定了一些事件，如click事件，那么点击该区域，也能触发点击事件的。</p>
</li>
<li><p>Web SQL数据库API并不是HTML5规范的一部分，但它是一个独立的规范，引入了一组使用SQL操作数据库的APIs。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ele.clientWidth = 宽度 + padding</span><br><span class="line">ele.offsetWidth = 宽度 + padding + border</span><br><span class="line">ele.scrollTop = 被卷去的上侧距离</span><br><span class="line">ele.scrollHeight = 自身实际的高度（不包含边框）</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.keys()</code>不能遍历出对象原型链上的属性。<code>Object.assign(obj1,obj2)</code>可以实现对象的浅拷贝。</p>
</li>
<li><p><code>null === null</code>结果为true。</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下都为true</span></span><br><span class="line">a.__proto__ === A.prototype </span><br><span class="line">b.__proto__ === B.prototype</span><br><span class="line">B.__proto__ === A</span><br><span class="line">B.prototype.__proto__ === A.prototype</span><br><span class="line">b.__proto__.__proto__ === A.prototype</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-前端cookie解读" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/11/前端cookie解读/" class="article-date">
      <time datetime="2020-06-11T07:33:30.000Z" itemprop="datePublished">2020-06-11</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/11/前端cookie解读/">前端cookie解读</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>补充：当关闭浏览器或关机后重新打开，存放在硬盘上的数据不会消失，而存放在内存中的数据会消失。</p>
<h6 id="Cookie的引入"><a href="#Cookie的引入" class="headerlink" title="Cookie的引入"></a>Cookie的引入</h6><p>当用户在未登录状态下在京东购物网站向购物车中添加某些商品后将浏览器关闭，然后再打开浏览器访问京东，此时查看购物车会发现，购物车中仍然有刚才添加的商品，这其实就是cookie的功劳。</p>
<h6 id="Cookie的简介"><a href="#Cookie的简介" class="headerlink" title="Cookie的简介"></a>Cookie的简介</h6><p>cookie是属于web开发的技术，由若干键值对构成，且键值对均为字符串。它是所有web开发语言据支持的技术。它是一种进行网络会话状态跟踪的技术。</p>
<p>会话（当用户打开浏览器，从发出第一次请求开始，一直到最终关闭浏览器就表示一次会话的完成）则是由一组请求和响应组成，是围绕看一件相关事情所进行的请求和响应，所以这些请求和响应之间必须有数据传递，即进行会话状态跟踪。但http协议是一种无状态协议，在不同请求间无法进行数据传递。此时就需要一种可以进行请求间数据传递的会话跟踪技术，而cookie就是这样一种技术。</p>
<p>Cookie是由服务器生成，保存在客户端的一种信息载体。这个载体中存放着用户访问该站点的会话状态信息。只要cookie没有被清空，或cookie没有生效，那么保存在其中的会话状态就有效。用户在提交第一次请求后，由服务器生成cookie并将其封装到响应头中，以响应的形式发送给客户端，客户端接收到这个响应后，将cookie保存到客户端。当客户端再发起同类的请求（资源路径路径相同）后，在请求中会携带保存在客户端的cookie数据，发送给服务器，由服务器对会话进行跟踪。</p>
<p>注意：cookie禁用仅是客户端不接收来自客户端的cookie，后端服务器还是有响应cookie回来的。一般不会禁用cookie，否则就不能使用，会出现500错误。</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>session即会话，是web开发中的一种会话状态跟踪技术，跟cookie类似，不过cookie是将会话状态存放于客户端的，而session是存在于服务端的。</p>
<h6 id="服务端生成session"><a href="#服务端生成session" class="headerlink" title="服务端生成session"></a>服务端生成session</h6><p>在服务器中系统会为每个会话维护一个session。不同的会话，对应不同的session。服务器对当前应用中的session是以Map的形式进行管理的，这个Map称为Session列表，该map的key为一个32位长度的随机串，这个随机串称为JSession，value则为session对象的引用。当用户第一次提交请求时，服务端servlet中执行到<code>request.getSession()</code>后会自动生成一个<code>Map.Entry</code>对象，key为一个根据某种算法新生成的JSessionID，value则为新创建的HttpSession对象。</p>
<h6 id="服务器生成并发送cookie"><a href="#服务器生成并发送cookie" class="headerlink" title="服务器生成并发送cookie"></a>服务器生成并发送cookie</h6><p>在将Session信息写入session列表后，系统还会自动将JSESSIONID作为name，这个32位长度的随机串作为value，以cookie的形式存放到响应头中，并随着响应将该cookie发送到客户端。</p>
<h6 id="客户端接收并发送cookie"><a href="#客户端接收并发送cookie" class="headerlink" title="客户端接收并发送cookie"></a>客户端接收并发送cookie</h6><p>客户端接受到这个cookie后会将其存放到浏览器的缓存中。即只要客户端浏览器不关闭，浏览器缓存的cookie就不会消失。</p>
<p>当用户提交第二次请求时，会将缓存中的这个cookie伴随着请求的头部信息一块发到服务端。</p>
<h6 id="congsession列表中查找"><a href="#congsession列表中查找" class="headerlink" title="congsession列表中查找"></a>congsession列表中查找</h6><p>服务端从请求中读取到从客户端发来的cookie，并根据cookie的JSESSIONID的值，从Map中查找相应key所对应的value，即session对象。然后对该session对象的域属性进行读写操作。</p>
<h6 id="session的失效"><a href="#session的失效" class="headerlink" title="session的失效"></a>session的失效</h6><p>web开发中引入的session超时的概念，session的失效就是指session的超时。若某个session在指定的时间范围内一直未被访问，那session将超时，即将失效。</p>
<p>服务器针对不同的会话找到不同的session，是因为cookie完成了会话的跟踪。但是，若客户端浏览器将cookie禁用，则服务器每提交一次请求，服务器在给出的响应中都会包含名称为JSESSIONID的cookie，只不过这个cookie值每次都不同，也就是说客户端所提交的请求中没有包含JSESSIONID，服务器就会认为这是一次新的会话的开始，就会为其生成一个<code>Map.Entry</code>对象，所以也就无法实现会话跟踪了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-前端经验" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/04/前端经验/" class="article-date">
      <time datetime="2020-06-04T06:01:42.000Z" itemprop="datePublished">2020-06-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/04/前端经验/">前端经验</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="字体图标的使用"><a href="#字体图标的使用" class="headerlink" title="字体图标的使用"></a>字体图标的使用</h3><h6 id="字体图标的优势"><a href="#字体图标的优势" class="headerlink" title="字体图标的优势"></a>字体图标的优势</h6><ol>
<li>性能好，可以减少http请求。</li>
<li>解决图标放大失真问题。</li>
<li>解决图片占用内存问题。</li>
</ol>
<h6 id="图片格式分类"><a href="#图片格式分类" class="headerlink" title="图片格式分类"></a>图片格式分类</h6><ol>
<li>位图图片：bmp，jpg，gif，png。（大小改变时可能出现锯齿状）。</li>
<li>矢量图图片：以svg格式为代表，可缩放矢量图形（Scalable Vector Graphics）。SVG是一种使用XML格式定义的图像。（颜色和字体可选范围较小）</li>
</ol>
<h6 id="字体图标出现的背景"><a href="#字体图标出现的背景" class="headerlink" title="字体图标出现的背景"></a>字体图标出现的背景</h6><p><strong>雪碧图处理图标</strong></p>
<ul>
<li>首先载入带有所有图标的图片。</li>
<li>利用定位截取想要的图标。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.bgImg&#123;</span><br><span class="line">	background: url(img/logos.png);</span><br><span class="line">	display: block;</span><br><span class="line">	text-indent: -9999px;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">	background-repeate: no-repeate;</span><br><span class="line">	width: 16px;</span><br><span class="line">	height: 16px;</span><br><span class="line">&#125;</span><br><span class="line">.help&#123;</span><br><span class="line">	background-position: -48px -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优势：当有大量的小图标时，可减少请求次数，网页加载速度更快，减少阻塞网络的情况，用户体验不好。</p>
<p>缺点：需要先设置背景图片，再通过精灵图中小图标的宽度和位置，设置对应的div宽高和背景定位坐标。设计人员后期的维护难度较大，编码也比较难（对定位精准性要求较大）。</p>
<h6 id="字体图标的使用-1"><a href="#字体图标的使用-1" class="headerlink" title="字体图标的使用"></a>字体图标的使用</h6><ul>
<li>一般会再建一个新的css文件来设置<code>font-family</code>和字体颜色，一来可以整体设置，二来当新字体图标覆盖时，文字的样式可以保持原先的状态。</li>
</ul>
<h3 id="星级评分"><a href="#星级评分" class="headerlink" title="星级评分"></a>星级评分</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-linux学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/22/linux学习/" class="article-date">
      <time datetime="2020-05-22T01:12:25.000Z" itemprop="datePublished">2020-05-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/22/linux学习/">linux学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="linux基础"><a href="#linux基础" class="headerlink" title="linux基础"></a>linux基础</h4><h4 id="linux实战"><a href="#linux实战" class="headerlink" title="linux实战"></a>linux实战</h4><h6 id="远程登陆"><a href="#远程登陆" class="headerlink" title="远程登陆"></a>远程登陆</h6><p>xShell xFtp</p>
<h6 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h6><h6 id="远程管理"><a href="#远程管理" class="headerlink" title="远程管理"></a>远程管理</h6><h6 id="vi和vim编译器"><a href="#vi和vim编译器" class="headerlink" title="vi和vim编译器"></a>vi和vim编译器</h6><h6 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h6><h6 id="RPM与YUM"><a href="#RPM与YUM" class="headerlink" title="RPM与YUM"></a>RPM与YUM</h6>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pandas之excel" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/10/pandas之excel/" class="article-date">
      <time datetime="2020-05-10T04:44:58.000Z" itemprop="datePublished">2020-05-10</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/10/pandas之excel/">pandas之excel</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h4><h6 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'ID'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">'Name'</span>:[<span class="string">'Tim'</span>,<span class="string">'Victor'</span>,<span class="string">'Nick'</span>]&#125;)</span><br><span class="line">df = df.set_index(<span class="string">'ID'</span>)</span><br><span class="line">df.to_excel(<span class="string">'F:/webProject/python/output.xlsx'</span>)</span><br><span class="line">print(<span class="string">'Done'</span>)</span><br></pre></td></tr></table></figure>

<p>遇到问题：</p>
<ol>
<li><p>NameError: name ‘pandas’ is not defined？</p>
<p>这是没有pandas模块，这是因为python默认没有安装numpy和pandas，最直接的方法是在python的scripts中执行<code>pip install pandas</code>不过，据说用pip安装会损坏原文件。</p>
</li>
<li><p>或者在Spyder编辑器中安装<code>pip install pandas</code>,却报<code>Note: you may need to restart the kernel to use updated packages.</code>?</p>
<p>在Terminal中更新<code>conda update spyder</code>。</p>
</li>
</ol>
<h6 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line">people = pd.read_execl(<span class="string">'path'</span>,header=<span class="literal">None</span>)  <span class="comment">#表示没有行头</span></span><br><span class="line">people.set_index(<span class="string">'ID'</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">print(people.shape)   <span class="comment">#打印出多少行多少列</span></span><br><span class="line">print(people.columns)  <span class="comment">#列</span></span><br><span class="line">print(people.head(<span class="number">3</span>))  <span class="comment">#打印出前3行，head不加参数默认为5行</span></span><br><span class="line">print(people.tail(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">df = pd.read_excel(<span class="string">'path'</span>,index_col=<span class="string">'ID'</span>)  <span class="comment">#后面的参数是为了不要将系统自动添加的索引加到新的表中</span></span><br><span class="line">df.to_excel(<span class="string">'path'</span>)</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 陈楚吟
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
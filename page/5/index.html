<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="陈楚吟">


    
    


<meta name="description" content="将学习技术点汇总">
<meta name="keywords" content="write myBlog">
<meta property="og:type" content="website">
<meta property="og:title" content="Nikita">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Nikita">
<meta property="og:description" content="将学习技术点汇总">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nikita">
<meta name="twitter:description" content="将学习技术点汇总">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Nikita" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Nikita</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">陈楚吟</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不负韶华</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">陈楚吟</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">陈楚吟</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不负韶华</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-伪类与伪元素的区区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/26/伪类与伪元素的区区别/" class="article-date">
      <time datetime="2020-02-26T05:16:46.000Z" itemprop="datePublished">2020-02-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/26/伪类与伪元素的区区别/">伪类与伪元素的区别</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>详解伪类与伪元素推荐：</p>
<p><a href="https://www.cnblogs.com/slly/p/10239055.html" target="_blank" rel="noopener">https://www.cnblogs.com/slly/p/10239055.html</a></p>
<h4 id="伪类与伪元素的区别"><a href="#伪类与伪元素的区别" class="headerlink" title="伪类与伪元素的区别"></a>伪类与伪元素的区别</h4><ol>
<li>伪类本质上是为了<strong>弥补常规css选择器</strong>的不足，以便获取更多的信息。</li>
<li>伪元素本质上是创建一个<strong>有内容的虚拟容器</strong>。</li>
<li>CSS3中伪类和伪元素语法不同。<ol>
<li>伪类        :link        :hover</li>
<li>伪元素       ::before       ::after</li>
</ol>
</li>
<li>可以同时使用多个伪类，却只能同时使用一个伪元素。</li>
<li>其中伪元素和伪类的根本区别在于：<strong>他们是否创造了新的元素，这个新的元素就叫做“伪元素”</strong>。<ol>
<li>伪元素/伪对象：<strong>不存在在DOM文档中，是虚拟元素</strong>，是创建新元素。这个新元素是某个元素的子元素，这个元素虽然逻辑上存在，但却不存在于文档树中。</li>
<li>伪类：<strong>存在于DOM文档中</strong>，（无标签，只在触发条件时才能看到），逻辑上存在但在文档树上却无需标识的分类。</li>
</ol>
</li>
<li>因为伪元素类似于添加类，故可添加多个，而伪元素在一个选择其中只能出现一次，并且只能出现在末尾。</li>
</ol>
<h4 id="伪元素单冒号与双冒号区别"><a href="#伪元素单冒号与双冒号区别" class="headerlink" title="伪元素单冒号与双冒号区别"></a>伪元素单冒号与双冒号区别</h4><p>相同点</p>
<ul>
<li>都可以用来表示伪类对象，用来设置对象前的内容</li>
<li>:before和::before写法是等效的; :after和::after写法是等效的</li>
</ul>
<p>不同点</p>
<ul>
<li>:before/:after是css2的写法，::before/::after是css3的写法</li>
<li>所以css2的要比css3的兼容好  ,, :before/:after 的兼容性要比::before/::after好 ， </li>
</ul>
<ul>
<li>不过在H5开发中建议使用::before/::after比较好</li>
</ul>
<p>注意：</p>
<ol>
<li>伪对象要配合content属性一起使用。</li>
<li>伪对象不会出现在DOM中，所以不能通过js来操作，仅仅是在 CSS 渲染层加入。</li>
<li>伪对象的特效通常要使用:hover伪类样式来激活。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        span&#123;</span><br><span class="line">            background: yellow;</span><br><span class="line">        &#125;</span><br><span class="line">        span:hover::before&#123;</span><br><span class="line">            content: &quot;我出现扩大了所受的煎熬&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;span&gt;222还是666&lt;/span&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-深入理解包与NPM和package-json深入解读" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/17/深入理解包与NPM和package-json深入解读/" class="article-date">
      <time datetime="2020-02-17T06:47:02.000Z" itemprop="datePublished">2020-02-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/17/深入理解包与NPM和package-json深入解读/">深入理解包与NPMM,package.json深入解读</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="包与NPM"><a href="#包与NPM" class="headerlink" title="包与NPM"></a>包与NPM</h2><p>CommonJS的包规范的定义其实也十分简单，它由包结构和包描述文件两个部分组成，前者用于组织包中的各种文件，后者则用于描述包的相关信息，以供外部读取分析。</p>
<h4 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h4><p>包实际上是一个存档文件，即一个目录直接打包为 .zip 或 tar.gz 格式的文件，安装后解压还原为目录。完全符合CommonJS规范的包目录应该包含如下文件。</p>
<ol>
<li>package.json： 包描述文件。</li>
<li>bin：用于存放可执行二进制文件的目录。</li>
<li>lib：用于存放JavaScript代码的目录。</li>
<li>doc：用于存放文档的目录。</li>
<li>test：用于存放单元测试用例的代码。</li>
</ol>
<p>可以看到，CommonJS包规范从文档、测试等方面都做过考虑。当一个包完成后向外公布时，用户可以看到单元测试和文档时，会给人一种踏实可靠的感觉。</p>
<h4 id="包描述文件"><a href="#包描述文件" class="headerlink" title="包描述文件"></a>包描述文件</h4><p>包描述文件用于表达非代码相关的信息，它是一个JSON格式的文件——package.json，位于包的根目录下，是包的重要组成部分。而npm的所有行为都与包描述文件的字段息息相关。</p>
<p>CommonJS为package.json文件定义一些必须的字段。</p>
<ol>
<li>name：包名。规范定义它需要小写字符和数字的组成，可以包含. \ _和 - ，但不允许出现空格。包名必须是唯一的，以免对外公布时产生重名冲突的误解。除此以外，NPM还建议不要在包名中附带上node或js来重复表示它是JavaScript或Node模块。</li>
<li>description：包简介。</li>
<li>version：版本号。</li>
<li>keywords：关键词数组，NPM中主要用来做分类搜索。一个好的关键词数组有利于用户快速找到你编写的包。</li>
<li>maintainers：包维护者列表，每个维护者由name、email和web这3个属性组成。</li>
</ol>
<p>NPM通过该属性进行权限认证。</p>
<ol start="6">
<li>contribuctors：贡献者列表。</li>
<li>bugs：一个可以反馈bug的网页地址或邮箱地址。</li>
<li>licenses：当前包所使用的许可证列表，表示这个包在哪些许可证下使用。</li>
<li>repositories：托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码。</li>
<li>dependencies：使用当前包所依赖的包列表。这个属性非常重要，NPM会通过这个属性自动加载依赖的包。</li>
</ol>
<p>除了必选字段外，规范还定义了一部分可选的字段</p>
<ol start="11">
<li><p>homepage：当前包的网站地址。</p>
</li>
<li><p>os：操作系统支持的列表。这些操作系统的取值包括aix，freebsd，Linux，macos，solaris，vxworks，windows。如果设置了列表为空时，则不对操作系统做任何假设。</p>
</li>
<li><p>CPU：CPU架构的支持列表。</p>
</li>
<li><p>engine：支持的js引擎列表，有效的引擎列表取值包括ejs，flusspferd，gpsee，jsc，spidermonkey，narwhal，node，v8.</p>
</li>
<li><p>builtin：标志当前包是否是内建在底层系统的标准组件。</p>
</li>
<li><p>directories：包目录说明。</p>
</li>
<li><p>implements：实现规范的列表，标志当前包实现了CommonJS的那些规范。</p>
</li>
<li><p>scripts：脚本说明对象。它主要被包管理器用来安装，编译，测试和卸载包，为其提供钩子机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//示例如下：</span><br><span class="line">&quot;scripts&quot;:&#123;</span><br><span class="line">	&quot;install&quot;:&quot;install.js&quot;,</span><br><span class="line">	&quot;uninstall&quot;:&quot;uninstall.js&quot;,</span><br><span class="line">	&quot;build&quot;:&quot;build.js&quot;,</span><br><span class="line">	&quot;test&quot;:&quot;test.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>包规范的定义可以帮助Node解决依赖包安装的问题，而NPM正是基于该规范进行了实现。最初，NPM工具是有Issac Z.Schlueter单独创建，提供给node服务的Node包管理器，需要单独安装。后来，在v6.3版本时集成进Node中作为默认包管理器，作为软件包的一部分一起安装。</p>
<p>在包描述文件的规范中，NPM实际需要的字段主要有name，version，description，keywords，repositories，author，bin，main，scripts，engines，dependencies，devDependencies。</p>
<p>与包规范的区别在于多了author，bin，main和devDependencies这4个字段。</p>
<p>author：包作者。</p>
<p>bin：一些包作者希望包可以作为命令行工具使用。配置好bin字段后，通过<code>npm install package_name -g</code>命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行。通过-g命令安装的模块包称为全局模式。</p>
<p>main：模块引入方法require（）在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口。如果不存在这个字段，require（）方法会查找包目录下的 index.js , index.node  ,  index.json  文件作为默认入口。</p>
<p>devDependencies：一些模块只在开发时需要依赖。配置这个属性，可以提示包的后续开发者安装依赖包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">//以下是node比较有名的框架express项目的package.json文件</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;express&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Fast, unopinionated, minimalist web framework&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;4.17.1&quot;,</span><br><span class="line">  &quot;author&quot;: &quot;TJ Holowaychuk &lt;tj@vision-media.ca&gt;&quot;,</span><br><span class="line">  &quot;contributors&quot;: [</span><br><span class="line">    &quot;Aaron Heckmann &lt;aaron.heckmann+github@gmail.com&gt;&quot;,</span><br><span class="line">    &quot;Ciaran Jessup &lt;ciaranj@gmail.com&gt;&quot;,</span><br><span class="line">    &quot;Douglas Christopher Wilson &lt;doug@somethingdoug.com&gt;&quot;,</span><br><span class="line">    &quot;Guillermo Rauch &lt;rauchg@gmail.com&gt;&quot;,</span><br><span class="line">    &quot;Jonathan Ong &lt;me@jongleberry.com&gt;&quot;,</span><br><span class="line">    &quot;Roman Shtylman &lt;shtylman+expressjs@gmail.com&gt;&quot;,</span><br><span class="line">    &quot;Young Jae Sim &lt;hanul@hanul.me&gt;&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;repository&quot;: &quot;expressjs/express&quot;,</span><br><span class="line">  &quot;homepage&quot;: &quot;http://expressjs.com/&quot;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;express&quot;,</span><br><span class="line">    &quot;framework&quot;,</span><br><span class="line">    &quot;sinatra&quot;,</span><br><span class="line">    &quot;web&quot;,</span><br><span class="line">    &quot;rest&quot;,</span><br><span class="line">    &quot;restful&quot;,</span><br><span class="line">    &quot;router&quot;,</span><br><span class="line">    &quot;app&quot;,</span><br><span class="line">    &quot;api&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;accepts&quot;: &quot;~1.3.7&quot;,</span><br><span class="line">    &quot;array-flatten&quot;: &quot;1.1.1&quot;,</span><br><span class="line">    &quot;body-parser&quot;: &quot;1.19.0&quot;,</span><br><span class="line">    &quot;content-disposition&quot;: &quot;0.5.3&quot;,</span><br><span class="line">    &quot;content-type&quot;: &quot;~1.0.4&quot;,</span><br><span class="line">    &quot;cookie&quot;: &quot;0.4.0&quot;,</span><br><span class="line">    &quot;cookie-signature&quot;: &quot;1.0.6&quot;,</span><br><span class="line">    &quot;debug&quot;: &quot;2.6.9&quot;,</span><br><span class="line">    &quot;depd&quot;: &quot;~1.1.2&quot;,</span><br><span class="line">    &quot;encodeurl&quot;: &quot;~1.0.2&quot;,</span><br><span class="line">    &quot;escape-html&quot;: &quot;~1.0.3&quot;,</span><br><span class="line">    &quot;etag&quot;: &quot;~1.8.1&quot;,</span><br><span class="line">    &quot;finalhandler&quot;: &quot;~1.1.2&quot;,</span><br><span class="line">    &quot;fresh&quot;: &quot;0.5.2&quot;,</span><br><span class="line">    &quot;merge-descriptors&quot;: &quot;1.0.1&quot;,</span><br><span class="line">    &quot;methods&quot;: &quot;~1.1.2&quot;,</span><br><span class="line">    &quot;on-finished&quot;: &quot;~2.3.0&quot;,</span><br><span class="line">    &quot;parseurl&quot;: &quot;~1.3.3&quot;,</span><br><span class="line">    &quot;path-to-regexp&quot;: &quot;0.1.7&quot;,</span><br><span class="line">    &quot;proxy-addr&quot;: &quot;~2.0.5&quot;,</span><br><span class="line">    &quot;qs&quot;: &quot;6.7.0&quot;,</span><br><span class="line">    &quot;range-parser&quot;: &quot;~1.2.1&quot;,</span><br><span class="line">    &quot;safe-buffer&quot;: &quot;5.1.2&quot;,</span><br><span class="line">    &quot;send&quot;: &quot;0.17.1&quot;,</span><br><span class="line">    &quot;serve-static&quot;: &quot;1.14.1&quot;,</span><br><span class="line">    &quot;setprototypeof&quot;: &quot;1.1.1&quot;,</span><br><span class="line">    &quot;statuses&quot;: &quot;~1.5.0&quot;,</span><br><span class="line">    &quot;type-is&quot;: &quot;~1.6.18&quot;,</span><br><span class="line">    &quot;utils-merge&quot;: &quot;1.0.1&quot;,</span><br><span class="line">    &quot;vary&quot;: &quot;~1.1.2&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;after&quot;: &quot;0.8.2&quot;,</span><br><span class="line">    &quot;connect-redis&quot;: &quot;3.4.1&quot;,</span><br><span class="line">    &quot;cookie-parser&quot;: &quot;~1.4.4&quot;,</span><br><span class="line">    &quot;cookie-session&quot;: &quot;1.3.3&quot;,</span><br><span class="line">    &quot;ejs&quot;: &quot;2.6.1&quot;,</span><br><span class="line">    &quot;eslint&quot;: &quot;2.13.1&quot;,</span><br><span class="line">    &quot;express-session&quot;: &quot;1.16.1&quot;,</span><br><span class="line">    &quot;hbs&quot;: &quot;4.0.4&quot;,</span><br><span class="line">    &quot;istanbul&quot;: &quot;0.4.5&quot;,</span><br><span class="line">    &quot;marked&quot;: &quot;0.6.2&quot;,</span><br><span class="line">    &quot;method-override&quot;: &quot;3.0.0&quot;,</span><br><span class="line">    &quot;mocha&quot;: &quot;5.2.0&quot;,</span><br><span class="line">    &quot;morgan&quot;: &quot;1.9.1&quot;,</span><br><span class="line">    &quot;multiparty&quot;: &quot;4.2.1&quot;,</span><br><span class="line">    &quot;pbkdf2-password&quot;: &quot;1.2.1&quot;,</span><br><span class="line">    &quot;should&quot;: &quot;13.2.3&quot;,</span><br><span class="line">    &quot;supertest&quot;: &quot;3.3.0&quot;,</span><br><span class="line">    &quot;vhost&quot;: &quot;~3.0.2&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;engines&quot;: &#123;</span><br><span class="line">    &quot;node&quot;: &quot;&gt;= 0.10.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;LICENSE&quot;,</span><br><span class="line">    &quot;History.md&quot;,</span><br><span class="line">    &quot;Readme.md&quot;,</span><br><span class="line">    &quot;index.js&quot;,</span><br><span class="line">    &quot;lib/&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;lint&quot;: &quot;eslint .&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;mocha --require test/support/env --reporter spec --bail --check-leaks test/ test/acceptance/&quot;,</span><br><span class="line">    &quot;test-ci&quot;: &quot;istanbul cover node_modules/mocha/bin/_mocha --report lcovonly -- --require test/support/env --reporter spec --check-leaks test/ test/acceptance/&quot;,</span><br><span class="line">    &quot;test-cov&quot;: &quot;istanbul cover node_modules/mocha/bin/_mocha -- --require test/support/env --reporter dot --check-leaks test/ test/acceptance/&quot;,</span><br><span class="line">    &quot;test-tap&quot;: &quot;mocha --require test/support/env --reporter tap --check-leaks test/ test/acceptance/&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;__npminstall_done&quot;: &quot;Sun Feb 16 2020 11:22:54 GMT+0800 (GMT+08:00)&quot;,</span><br><span class="line">  &quot;_from&quot;: &quot;express@4.17.1&quot;,</span><br><span class="line">  &quot;_resolved&quot;: &quot;https://registry.npm.taobao.org/express/download/express-4.17.1.tgz&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NPM常用功能"><a href="#NPM常用功能" class="headerlink" title="NPM常用功能"></a>NPM常用功能</h4><p>CommonJS包规范是理论，NPM是其中的一种实践。对于Node而言，NPM帮助完成了第三方模块的发布，安装和依赖等。借助NPM，Node与第三方模块之间形成了很好地一个生态系统。</p>
<h6 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h6><p>安装依赖包是NPM最常见的用法，它的执行语句是npm  install  express.。执行该命令后，NPM会在当前目录下创建node_module目录，然后在node_module目录下创建express目录，接着将包解压到这个目录下。</p>
<p>安装好依赖包后，直接在代码中调用require(‘express’),即可引入该包，require（）方法在做路径分析时会通过，模块路径查找到express所在的位置。模块引入和包的安装是相辅相成的。</p>
<h6 id="全局模式安装"><a href="#全局模式安装" class="headerlink" title="全局模式安装"></a>全局模式安装</h6><p>如果包含有命令行工具，那么需要执行<code>npm install express -g</code>命令进行全局安装。需要注意的是，全局模式并不是将一个模块包安装为一个全局包的意思，他并不意味着可以从任何地方通过require（）来引用到它。</p>
<p>全局模式这个称谓其实并不精确，存在诸多误导。实际上，-g是将一个包安装为全局可用的可执行命令。他根据包描述文件中的bin字段配置，将实际脚本链接到与Node可执行文件相同的路径下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;bin&quot;:&#123;</span><br><span class="line">	&quot;express&quot;:&quot;./bin/express&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，通过全局模式安装的所有模块都被安装进一个统一的目录下，这个目录可以通过如下方式运算出来：</p>
<p>path.resolve(process.execPath, ‘..’ , ‘lib’ , ‘node_modules’);</p>
<p>如果Node可执行文件的位置是/user/local/bin/node，那么模块目录就是/user/local/lib/node_modules。最后，通过软链接的方式将bin字段配置的可执行文件链接到Node的可执行目录下。</p>
<h6 id="从本地安装"><a href="#从本地安装" class="headerlink" title="从本地安装"></a>从本地安装</h6><p>对于一些没有发布到NPM上的包，或是因为网络原因导致无法直接安装的包，可通过将包下载到本地，然后本地安装。本地安装只需要为NPM指定package.json文件所在的位置即可：它可以是一个包含package.json的存档文件，也可以是一个URL地址，也可以是一个目录下有package.json文件的目录位置。具体参数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;tarbar file&gt;</span><br><span class="line">npm install &lt;tarbar url&gt;</span><br><span class="line">npm install &lt;folder&gt;</span><br></pre></td></tr></table></figure>

<h6 id="从非官方源安装"><a href="#从非官方源安装" class="headerlink" title="从非官方源安装"></a>从非官方源安装</h6><p>如果不能通过官方源安装，可通过镜像安装。在执行命令时，添加 <code>--registry=http://registry.url</code>即可，实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm insatll underscore --registry=http://registry.yrl</span><br></pre></td></tr></table></figure>

<p>如果使用过程几乎使用镜像源安装，可执行命令指定默认源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http://registry.url</span><br></pre></td></tr></table></figure>

<h4 id="NPM潜在问题"><a href="#NPM潜在问题" class="headerlink" title="NPM潜在问题"></a>NPM潜在问题</h4><p>作为为模块和包服务的工具，NPM十分便捷。它实质上已经是一个包共享平台，所有人都可以贡献并将其打包分享到这个平台上，也可以在许可证的允许下免费使用他们</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-JS中外部文件的优势-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/15/JS中外部文件的优势-1/" class="article-date">
      <time datetime="2020-02-15T04:19:45.000Z" itemprop="datePublished">2020-02-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/15/JS中外部文件的优势-1/">JS中外部文件的优势</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="JS中外部文件的优势"><a href="#JS中外部文件的优势" class="headerlink" title="JS中外部文件的优势"></a>JS中外部文件的优势</h4><p>在HTML中嵌入js代码虽然没有问题，但一般认为最好使用外部文件来包含代码。不过，并不存在必须使用外部文件的硬性要求，但支持使用外部文件的人多会强调如下优点：</p>
<ol>
<li>可维护性：遍及不同HTML页面的js代码会造成维护问题，但把所有js文件放在一个文件夹中，维护起来就轻松多了。而且开发人员也可在不触及HTML标记的情况下，集中精力编辑js代码。</li>
<li>可缓存性：浏览器能够根据具体的缓存链接到所有的外部文件。也就是说，如果有两个页面都是使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的速度。</li>
<li>适应未来：通过外部文件来包含js无需使用前面提到的XHTML或注释hack。HTML和XHTM包含外部文件的语法是相同的。</li>
</ol>
<p>把JavaScript插入到HTML页面中要使用<code>&lt;script&gt;</code>元素。使用这个元素可以把JavaScript嵌入到HTML页面中，让脚本与标记混合在一起；也可以包含外部的JavaScript文件。而我们需要注意的地方有：</p>
<ol>
<li>在包含外部JavaScript文件时，必须将src属性设置为指向文件的 url 。而这个文件可以是与包含它的页面位于同一服务器上的文件，也可以是其他文件域中的文件。</li>
<li>所有<code>&lt;script&gt;</code>元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用defer，async属性的情况下，只有解析完前面<code>&lt;script&gt;</code>代码后才会开始解析后面的<code>&lt;/script&gt;</code>元素中的代码。</li>
<li>由于浏览器会先解析完不使用defer属性的<code>&lt;script&gt;</code>元素中的代码，然后再解析后面的内容，所以一般应该把<code>&lt;script&gt;</code>元素放在页面最后，及主要内容的后面，<code>&lt;/body&gt;</code>标签前面。</li>
<li>使用defer属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照它们指定的顺序执行。</li>
<li>使用ansyc属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。</li>
<li>另外，使用<code>&lt;noscript&gt;</code>元素可以指定在不支持脚本的浏览器中显示的替代内容。但在启动了脚本的情况下，浏览器不会显示<code>&lt;noscript&gt;</code>元素中的任何内容。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-vue进阶" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/03/vue进阶/" class="article-date">
      <time datetime="2020-02-03T08:25:10.000Z" itemprop="datePublished">2020-02-03</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/03/vue进阶/">vue进阶</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="独立构建VS运行时构建"><a href="#独立构建VS运行时构建" class="headerlink" title="独立构建VS运行时构建"></a>独立构建VS运行时构建</h4><ul>
<li>两者区别，独立构建包含模板编译器。模板编译是将编译vue模板字符串成纯js渲染函数，若想用template，则需要编译。</li>
</ul>
<h6 id="独立构建"><a href="#独立构建" class="headerlink" title="独立构建"></a>独立构建</h6><ul>
<li>独立构建包含模板编译器并支持template选项。他也依赖于浏览器接口的存在，所以你不能用其来为服务器渲染。</li>
</ul>
<h6 id="运行时构建"><a href="#运行时构建" class="headerlink" title="运行时构建"></a>运行时构建</h6><ul>
<li><p>运行时构建不包含模板编译器，只能用render选项但即使使用运行时构建，在单文件组件中也依然可以写模板，因为单文件组件的模板会在构建时预编译为render函数。运行时构建要比独立构建轻量30%；</p>
</li>
<li><p>默认npm导出的包是<strong>运行时构建</strong>。为使用独立构建在webpack配置中添加以下别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve:&#123;</span><br><span class="line">	alias:&#123;</span><br><span class="line">		&apos;vue$&apos;:&apos;vue/dist/vue.js&apos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要用import Vue from ‘vue/dist/vue.js’-用一些工具或第三方工具库引入Vue，这可能导致应用程序在同一加载运行时和独立构建并造成错误。</p>
</li>
</ul>
<h4 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h4><ul>
<li>核心方法是通过Object.definedProperty()来实现对属性进行劫持，达到监听数据变动的目的。</li>
</ul>
<p><strong>beforeDestroy</strong>（销毁前） 在实例销毁之前调用。实例仍然完全可用。<br>   <strong>destroyed</strong>（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p>
<h4 id="数据绑定原理"><a href="#数据绑定原理" class="headerlink" title="数据绑定原理"></a>数据绑定原理</h4><p>vue实现数据双向绑定主要是：采<strong>用数据劫持结合发布者-订阅者模式</strong>的方式，通过<strong>Object.defineProperty（）</strong>来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。<br>vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 ），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。</p>
<h4 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h4><p>父组件与子组件传值</p>
<p>父组件传给子组件：子组件通过props方法接受数据;</p>
<h6 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h6><ul>
<li>实现mvvm双向绑定需实现以下几点：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者。</span><br><span class="line">2.实现一个指令解析器Compile，对每个元素节点进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。</span><br><span class="line">3.实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的响应回调函数，从而更新视图。</span><br><span class="line">4.mvvm入口函数，整合以上三者。</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/bVBQYu?w=730&h=390" alt="图片描述"></p>
<ul>
<li>我们知道可以利用<code>Obeject.defineProperty()</code>来监听属性变动<br>那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 <code>setter</code>和<code>getter</code><br>这样的话，给这个对象的某个值赋值，就会触发<code>setter</code>，那么就能监听到了数据变化。。相关代码可以是这样：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">let data = &#123;name: &apos;kindom&apos;&#125;;</span><br><span class="line">observer(data);</span><br><span class="line">data.name = &apos;queue&apos;;</span><br><span class="line"></span><br><span class="line">function observer(data)&#123;</span><br><span class="line">	if(!data || typeof data!== &apos;object&apos;)&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	//取出所有属性的遍历</span><br><span class="line">	Object.keys(data).forEach(function(key)&#123;</span><br><span class="line">		defineReactive(data,key,data[key]);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">function defineReactive(data,key,val)&#123;</span><br><span class="line">	orserver(val);  //监听子属性</span><br><span class="line">	Object.defineProperty(data,key,&#123;</span><br><span class="line">		enumerable: true,  //可枚举</span><br><span class="line">		configurable: false,  //不可再定义</span><br><span class="line">		get: function()&#123;</span><br><span class="line">			return val;</span><br><span class="line">		&#125;,</span><br><span class="line">		set:functiion(newVal)&#123;</span><br><span class="line">			val = newVal;</span><br><span class="line">			dep.notify();  //通知所有的订阅者</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">functiion Dep()&#123;</span><br><span class="line">	this.subs = [];</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">	addSub: function(sub)&#123;</span><br><span class="line">		this.subs.push(sub);</span><br><span class="line">	&#125;,</span><br><span class="line">	notify: function()&#123;</span><br><span class="line">		this.subs.forEach(function(sub)&#123;</span><br><span class="line">			sub.update();</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="实现编译"><a href="#实现编译" class="headerlink" title="实现编译"></a>实现编译</h6><ul>
<li>compile主要的工作是解析模板指令，将模板指令替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知更新视图。</li>
</ul>
<p><img src="https://segmentfault.com/img/bVBQY3?w=625&h=259" alt="图片描述"></p>
<h4 id="introction"><a href="#introction" class="headerlink" title="introction"></a>introction</h4><ul>
<li>vue是一套构建用户的渐进式框架。与其他重量级框架不同，vue采用自底向上增量开发的设计。</li>
<li>指令带有v-，以表示它们是Vue.js提供的特殊属性，他们会在渲染过的DOM上应用特殊的响应式行为。</li>
<li>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ，且计算属性是基于他的依赖缓存的。</li>
</ul>
<h6 id="v-if-VS-v-show"><a href="#v-if-VS-v-show" class="headerlink" title="v-if    VS  v-show"></a>v-if    VS  v-show</h6><ul>
<li>v-if是真实的条件渲染，因为他会确保条件快在切换当中适当的销毁与重建。若初始条件为假时，则什么也不会做，仅在第一次变为真时才开始局部编译（编译会被缓存起来）。</li>
<li>相比之下， v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。</li>
<li>一般来说， v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换使用 v-show 较好，如果在运行时条件不大可能改变则使用 v-if 较好。</li>
</ul>
<h6 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h6><ul>
<li>.lazy:默认情况下，v-model在input事件中的同步框的值和数据，但你可以添加一个修饰符lazy，从而转变在change事件中同步。</li>
<li>.number</li>
<li>.trim</li>
</ul>
<h6 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h6><ul>
<li><p>Vue.component(tagName,options)</p>
</li>
<li><p>DOM模板解析说明:当DOM作为模板时，会受到一些HTML的一些限制，因为在Vue只有在浏览器解析和标准化HTML后才能获取模板内容。即table的子标签只能是tr，故需要is来指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">	&lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中的data必须是一个函数使每个组件中的数据引用都有一个自己的作用域，不会互相影响。</p>
</li>
<li><p>父传子：使用props传递数据。组件实例的作用域是孤立的即子组件的模版内不能直接引用父组件的数据。</p>
</li>
<li><p>子传父：通过自定义事件$emit</p>
</li>
<li><p>非父子组件通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var bus = new Vue()</span><br><span class="line">// 触发组件 A 中的事件</span><br><span class="line">bus.$emit(&apos;id-selected&apos;, 1)</span><br><span class="line">// 在组件 B 创建的钩子中监听事件</span><br><span class="line">bus.$on(&apos;id-selected&apos;, function (id) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h4><h6 id="如何跟踪变化"><a href="#如何跟踪变化" class="headerlink" title="如何跟踪变化"></a>如何跟踪变化</h6><ul>
<li><p>把一个普通js对象传给Vue实例来作为他的data选项，Vue将遍历它的属性，用Object.defineProperty将它们转为getting/setting。这是ES5的特性，不能打补丁实现，这便是为什么Vue不支持IE8及以下版本的原因。</p>
</li>
<li><p>用户看不到getting/setting，但在内部它们让Vue追踪依赖，在属性被访问和修改时通知变化。这里需要注意的是浏览器控制台在打印对象时getting/setting的格式化并不同，可通过vue-devtools</p>
<p>来获取更加友好地检查接口。</p>
</li>
<li><p>每个组件实例都有watcher程序实例，他会在渲染的过程中把属性记录为依赖，之后当依赖项的setting被调用时，就会通知watcher重新计算，从而使和它相关联的组件得以更新。</p>
</li>
</ul>
<p><img src="https://atts.w3cschool.cn/attachments/day_190316/201903161724311621.png" alt="data"></p>
<h6 id="变化检测问题"><a href="#变化检测问题" class="headerlink" title="变化检测问题"></a>变化检测问题</h6><ul>
<li><p>受现在的js影响，<strong>vue不能检测到对象的属性的添加或删除</strong>。因为Vue在初始化实例时将属性转为getting/setting，所以必须在data对象上在能让Vue转换它，这样才能是响应的。那种`vm.a=2’不是响应式的，因为js边解释边执行，不可能在初始化时将2付给a</p>
</li>
<li><p><strong>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性（root-level reactive properties）</strong>。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：</p>
</li>
<li><p>您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.someObject, &apos;b&apos;, 2)</span><br><span class="line"></span><br><span class="line">this.$set(this.someObject,&apos;b&apos;,2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>有时你想向已有对象上添加一些属性，例如使用Object.assign()或_.extend()方法来添加属性。但是，新添加到对象上的新属性不会被触发更新，这种情况下可可创建一个新的对象，让它包含原对象的属性和新对象属性。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//代替Object.assign(this.somObject,&#123;a:1,b:2&#125;)</span><br><span class="line">this.someObject = Object.assign(&#123;&#125;,this.someObject,&#123;c:5&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果不在data中声明message，则message不是一个响应式的，同时Vue将发出警告表明你的渲染方法正试图访问一个不存在的属性。因为在依赖项跟踪系统中，他消除了一类边界情况，也使Vue实例在检查系统的帮助下运行的更高效。在代码可维护方面上这一点很重要：data对象就像组件状态的模式，在它上面声明的所有属性让组织代码更易于被其他开发者或是自己回头重新阅读加速理解。</li>
</ul>
<h6 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h6><ul>
<li>Vue执行DOM更新是异步的，只要观察到数据变化，Vue就开始一个队列，将同一事件循环内的所有的数据变化缓存起来。如果watch被多次触发，只会推入一次到队列中。然后再接下来循环中，Vue刷新队列并仅执行必要的DOM更新。</li>
</ul>
<h4 id="过渡效果"><a href="#过渡效果" class="headerlink" title="过渡效果"></a>过渡效果</h4><ul>
<li>元素封装成过渡组件后，在遇到删除或添加时，Vue将<ul>
<li>自动嗅探到目标元素是否有CSS过渡或动画，并在合适时添加或删除CSS类名。</li>
<li>如果过渡组件设置了过渡的js钩子函数会在相应的阶段调用钩子函数。</li>
<li>如果没有找到js钩子也无css动画，DOM操作在下一帧立即执行。（注：此指浏览器逐帧动画机制，与Vue及其nextTick概念不同）</li>
</ul>
</li>
<li>当只用js过渡时，在enter和leave中，回调函数done是必须的。否则，他们会被同步调用，过渡立即完成。推荐对于仅使用js过渡的元素添加<code>:css=&quot;false&quot;</code>,Vue会跳过CSS的检测，这也是避免过渡过程中CSS的影响。</li>
</ul>
<h4 id="组件传值-1"><a href="#组件传值-1" class="headerlink" title="组件传值"></a>组件传值</h4><h6 id="非父子组件间传值"><a href="#非父子组件间传值" class="headerlink" title="非父子组件间传值"></a>非父子组件间传值</h6><ol>
<li><p>单独的事件中心管理组件间的通信</p>
<p><code>var eventHub = new Vue()</code></p>
</li>
<li><p>监听事件与销毁事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eventHub.$on(&apos;事件名称&apos;,触发的事件)</span><br><span class="line">eventHub.$off(&apos;事件名称&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>触发事件</p>
<p><code>eventHub.$emit(&#39;事件名称&#39;,数据)</code></p>
</li>
</ol>
<ul>
<li>新建一个js文件，然后引入vue，实例化vue，最后暴露该实例。</li>
<li>在要广播的地方引入定义好的实例。</li>
<li>通过ViewEvent.$emit(‘名称’,’数据’)</li>
<li>在要接收的地方通过ViewEvent.on(‘名称’，function（）{})，同时可通过<code>$event</code>获取到传过来的数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//新建ViewEvent.js文件</span><br><span class="line">import Vue from &apos;Vue&apos;;</span><br><span class="line">let ViewEvent = new Vue();</span><br><span class="line">export default ViewEvent;</span><br><span class="line"></span><br><span class="line">//app.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">	  &lt;home&gt;&lt;/home&gt;</span><br><span class="line">	  &lt;news&gt;&lt;/news&gt;</span><br><span class="line">	 &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">//home.vue</span><br><span class="line">import ViewEvent from &apos;ViewEvent&apos;;</span><br><span class="line">ViewEvent.$emit(&apos;test&apos;,&apos;123&apos;);</span><br><span class="line"></span><br><span class="line">//news.vue</span><br><span class="line">import ViewEvent from &apos;ViewEvent&apos;;</span><br><span class="line">ViewEvent.$on(&apos;test&apos;,function(data)&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="父子组件"><a href="#父子组件" class="headerlink" title="父子组件"></a>父子组件</h6><ul>
<li>利用在父组件中的html标签中定义ref属性，通过$refs获取子组件的dom节点进行操作。</li>
<li>利用$parents获取父组件的数据。</li>
<li>父组件可通过<code>$event</code>得到子组件中的信息</li>
</ul>
<p><strong>子组件通过自定义事件向父组件传递信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&apos;$emit(&quot;enlarge-text&quot;,0.1)&apos;&gt;扩大字体&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p><strong>父组件监听子组件的事件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;menu-item @enlarge-text=&apos;fontSize += $event&apos;&gt;&lt;/menu-item&gt;</span><br></pre></td></tr></table></figure>

<h6 id="props"><a href="#props" class="headerlink" title="props"></a>props</h6><ul>
<li>除了自定义数据可传外，还可将this或方法（不可加括号）</li>
</ul>
<h4 id="vue路由配置"><a href="#vue路由配置" class="headerlink" title="vue路由配置"></a>vue路由配置</h4><ol>
<li><p>安装</p>
<p><code>npm install vue-router --save</code>   /    <code>cnpm install vue-router --save</code></p>
</li>
<li><p>在main.js文件中引入并使用VueRouter</p>
<p><code>import  VueRouter  from vue-router</code></p>
<p><code>Vue.use(VueRouter)</code></p>
</li>
<li><p>配置路由</p>
<ol>
<li><p>创建组件，引入组件</p>
</li>
<li><p>定义路由</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const routes = &#123;</span><br><span class="line">	&#123;path: &apos;/bar&apos;,component: Bar&#125;,</span><br><span class="line">	&#123;path: &apos;/foo&apos;,component: Foo&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化VueRouter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line"> 	routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>挂载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在跟组件中加<code>&lt;router-view&gt;&lt;/router-view&gt;</code></p>
</li>
</ol>
</li>
</ol>
<h4 id="webpack-config配置"><a href="#webpack-config配置" class="headerlink" title="webpack.config配置"></a>webpack.config配置</h4><ul>
<li><p>当以命令行形式命令运行webpack或webpack-dev-server时，工具会发现我们并没有提供要打包的文件的入口和出口文件，此时他会检查项目根目录中的配置文件并读取这个文件就拿到了导出的这个配置对象，然后根据这个对象，进行打包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//在内存中，根据指定的模板页面生成一份内存中的首页，同时把自动打包好的bundle.js文件注入到页面底部</span><br><span class="line">const htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">//在输出对象中的plugins（是webpack插件的配置节点）数组中配置节点</span><br><span class="line">plugins:[</span><br><span class="line">	new htmlWebpackPlugin(&#123;</span><br><span class="line">	template:path.join(__dirname,&apos;./src/index.html&apos;), //指定模板文件路径</span><br><span class="line">	  filename:&apos;index.html&apos; //设置生成的内存页面的名称</span><br><span class="line">	&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置第三方loader模块</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//下载相应的包</span><br><span class="line">cnpm i style-loader css-loader -D</span><br><span class="line">cnpm i less-loader less -D</span><br><span class="line">cnpm i sass-loader node-sass -D</span><br><span class="line">//webpack.config.js文件中</span><br><span class="line">//在输出对象，与plugins平齐的地方配置模块中</span><br><span class="line">module:&#123;</span><br><span class="line">	rules:[</span><br><span class="line">	 &#123; test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;,  //处理css文件的loader</span><br><span class="line">	 &#123; test: /\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;, //处理less文件的loader</span><br><span class="line">	 &#123; test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125;, //处理less文件的loader</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">//在main.js文件中导入样式文件</span><br><span class="line">import &apos;./css/index.scss&apos;;</span><br></pre></td></tr></table></figure>

<ul>
<li>默认情况下，webpack无法处理css文件中的url地址，不管是图片还是字体库，只要是url地址都处理不了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cnpm i url-loader file-loader -D</span><br><span class="line">//在webpack.config.js文件中配置</span><br><span class="line">         &#123; test: /\.(jpg|png|gif|bmp|jpeg)$/, use: &apos;url-loader&apos; &#125; //处理文件路径</span><br><span class="line">         //若想不使用默认的base64格式，则可用与url地址传参一样</span><br><span class="line">         &#123; test: /\.(jpg|png|gif|bmp|jpeg)$/, use: &apos;url-loader?limit=100&apos;&#125;  //当图片大小大于100字节时会被转为base64格式，小于等于100子节时为普通图片</span><br></pre></td></tr></table></figure>

<h6 id="语法转换（高-——-gt-低）"><a href="#语法转换（高-——-gt-低）" class="headerlink" title="语法转换（高  ——&gt; 低）"></a>语法转换（高  ——&gt; 低）</h6><ul>
<li><p>在webpack中。默认只能处理一部分ES6新语法，一些更高级ES6语法或ES7语法，webpack是处理不了的，这时就需要借助第三方loader来帮助webpack处理这些高级语法，当第三方loader把高级语法转为低级语法后，会将结果交给webpack去打包到main.js中。</p>
</li>
<li><p>通过Babel，可将高级语法转为低级语法</p>
<ol>
<li>安装包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm i babel-core babel-loader babel-plugin-transform-runtime -D</span><br><span class="line">cnpm i babel-preset-env babel-preset-stage-0 -D</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>打开webpack的配置文件，在module节点下的rules数组中添加一个新的匹配规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; test: /\.js$/, use:&apos;babel-loader&apos;,exclude:/node_modules/&#125;</span><br><span class="line">注意：在配置babel的loader规则时，必须通过exclude选项将node_modules目录排除在外，原因有两：</span><br><span class="line">1.不排除node_modules时，Babel会将node_modules中的所有第三方js文件都打包编译，这样非常消耗内存，同时，打包速度也非常慢。</span><br><span class="line">2.哪怕最终Babel将所有node_modules中的js文件转换完毕，项目也无法正常进行。</span><br></pre></td></tr></table></figure>
</li>
<li><p>在项目根目录中新建一个叫做babelrc的Babel配置文件，这个配置文件属于JSON格式，故不可加注释，字符串需用双引号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在babelrc写如下配置：preset可翻译为【语法】</span><br><span class="line">&#123;</span><br><span class="line">	&quot;preset&quot;: &#123;&quot;env&quot;:&quot;stage-0&quot;&#125;,</span><br><span class="line">	&quot;plugins&quot;: [&quot;transform-runtime&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h6 id="包查找规则"><a href="#包查找规则" class="headerlink" title="包查找规则"></a>包查找规则</h6><ul>
<li>在webpack中尝试使用vue，即使用<code>import Vue from &#39;vue&#39;导入的Vue构造函数，功能不完整，只提供了runtime-only的方式，并没有提供像网页那样的使用方式。</code>可使用<code>import Vue from &#39;../node_modules/vue/dist/vue.js&#39;</code></li>
<li>包的使用规则</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.找项目的根目录中是否有node_modules文件夹</span><br><span class="line">2.在node_modules中根据包名找相应的vue文件夹</span><br><span class="line">3.在vue文件夹中找一个package.json的包配置属性</span><br><span class="line">4.在package.json文件中查找一个main属性【main属性指定了这个包在被加载时的入口文件】</span><br></pre></td></tr></table></figure>

<h4 id="渲染组件"><a href="#渲染组件" class="headerlink" title="渲染组件"></a>渲染组件</h4><ul>
<li>默认 webpack 无法打包 vue文件，需要安装相关的loader</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cnpm i vue-loader vue-template-compler -D</span><br><span class="line">//在配置文件中，新增loader配置项</span><br><span class="line">&#123; test:/\.vue$/, use: &apos;vue-loader&apos; &#125;</span><br><span class="line">//导入login组件</span><br><span class="line">import login from &apos;./login.vue&apos;</span><br></pre></td></tr></table></figure>

<ul>
<li>在webpack中，如果想要通过 vue ，把一个组件渲染到页面中去展示vm实例中的render函数可实现。</li>
<li>createElements是一个方法，调用它可将指定的组件模板渲染为html结构。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let vm = new Vue(&#123;</span><br><span class="line">	el: &apos;#app&apos;,</span><br><span class="line">	data:&#123;&#125;,</span><br><span class="line">	methods:&#123;&#125;,</span><br><span class="line">	render:function(createElements)&#123;</span><br><span class="line">		return createElements(login);</span><br><span class="line">		//注：这里的login会替换掉页面中的el指定的那个容器</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">//简写</span><br><span class="line">render: c =&gt; c(login)</span><br></pre></td></tr></table></figure>

<h6 id="webpack中使用vue"><a href="#webpack中使用vue" class="headerlink" title="webpack中使用vue"></a>webpack中使用vue</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.安装 vue 包，cnpm i vue -S</span><br><span class="line">2.由于在webpack中推荐使用vue组件模板文件定义组件，故需要安装能解析这种文件的loader    cnpm i vue-loader vue-template-compiler -D</span><br><span class="line">3.在main.js中导入vue模块， import Vue from &apos;vue&apos;</span><br><span class="line">4.定义.vue结尾的组件，由三部分组成：template script  style</span><br><span class="line">5.使用import login from &apos;./login.vue&apos;导入这个组件</span><br><span class="line">6.创建vm实例 let vm = new Vue(&#123; el: &apos;#app&apos;, render: c =&gt; c(login) &#125;)</span><br><span class="line">7.在页面创建一个id为app的div元素，作为我们vm实例要控制的区域；</span><br></pre></td></tr></table></figure>

<p>注意：App这个组件是通过vm实例的render函数渲染出来的，render函数如果要渲染组件，渲染出来的组件只能放到el：‘#app’ 所指定的元素中。</p>
<p>Account和Goodlist组件是通过路由配置监听到的，所以这两个组件只能展示到属于路由的<router-view></router-view>中去。</p>
<h4 id="加载轮播图"><a href="#加载轮播图" class="headerlink" title="加载轮播图"></a>加载轮播图</h4><ol>
<li>使用vue-resource获取数据。</li>
<li>使用vue-resource的this.$http.get获取数据</li>
<li>获取到的数据保存到data身上。</li>
<li>使用v-for循环渲染到每个item项。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">cnpm i vue-resource -D</span><br><span class="line">import VueResource from &apos;vue-resource&apos;</span><br><span class="line">Vue.use(VueResource);</span><br><span class="line"></span><br><span class="line">//组件文件，vue</span><br><span class="line">import &#123; Toast &#125; from &apos;mint-ui&apos;;</span><br><span class="line"></span><br><span class="line">  methods:&#123;</span><br><span class="line">        getLunBotu()&#123;</span><br><span class="line">            this.$http.get(&apos;https://api.dujin.org/pic/&apos;).then(res =&gt; &#123;</span><br><span class="line">               </span><br><span class="line">                if(res.status == 200)&#123;</span><br><span class="line">                     this.lunbotulist = res.body[0];</span><br><span class="line">                     console.log(this.lunbotulist);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    Toast(&apos;加载失败&apos;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        this.getLunBotu();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> //解决页面切换动画问题</span><br><span class="line"> &lt;transition&gt;</span><br><span class="line"> 	&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line"> &lt;/transition&gt;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	 .app-container&#123;</span><br><span class="line">        padding-top: 40px;</span><br><span class="line">		overflow-x: hidden;  //只能将x超出部分隐藏，若将y的也隐藏，则页面不可进行上下滑动</span><br><span class="line">    &#125; </span><br><span class="line">	.v-enter&#123;    //离开和进入需分开写，确保动画都是往左走</span><br><span class="line">		opacity: 0;</span><br><span class="line">		transform: translateX(100%); </span><br><span class="line">	&#125;</span><br><span class="line">	.v-leave-to&#123; </span><br><span class="line">		opacity: 0;</span><br><span class="line">		transform: translateX(-100%); </span><br><span class="line">		position: absolute;  //解决动画切换时，内容是从下到上替换</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.v-leave-active,</span><br><span class="line">	.v-enter-active&#123;</span><br><span class="line">		transition: all 0.5s ease; </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Promise使用"><a href="#Promise使用" class="headerlink" title="Promise使用"></a>Promise使用</h6><ul>
<li>promise本质就是解决回调地狱问题。</li>
</ul>
<ol>
<li>Promise是一个构造函数，故可通过 new Promise() 方法得到一个 Promise的实例。</li>
<li>Promise表示一个异步操作，每当我们 new 一个Promise 实例，就表示一个具体的异步操作。故内部拿到操作结果后，无法使用 return 把操作结果返回给调用者，只能通过回调函数将成功和失败结果返回给调用者。</li>
</ol>
<p><strong>普通读取文件方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">fs.readFile(path.join(__dirname,&apos;./files/1.txt&apos;),&apos;utf-8&apos;,(err, dataStr) =&gt; &#123;</span><br><span class="line">	if(err) throw err;</span><br><span class="line">	console.log(dataStr);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="导入时间插件"><a href="#导入时间插件" class="headerlink" title="导入时间插件"></a>导入时间插件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cnpm i moment -S</span><br><span class="line"></span><br><span class="line">//导入格式化的插件</span><br><span class="line">import moment from &apos;moment&apos;;</span><br><span class="line">//定义全局的过滤器</span><br><span class="line">Vue.filter(&apos;dateFormat&apos;,function(dataStr,pattern = &quot;YYYY-MM-DD HH:mm:ss&quot;)&#123;</span><br><span class="line">	return moment(dataStr).format(pattern);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="vue-resource请求数据"><a href="#vue-resource请求数据" class="headerlink" title="vue-resource请求数据"></a>vue-resource请求数据</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置请求的根路径</span><br><span class="line">Vue.http.options.root = &apos;http://****.com&apos;;</span><br><span class="line">//全局设置post 时的表单数据格式组织形式  application/x-www-form-urlencoded</span><br><span class="line">Vue.http.options.emulateJSON = true;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//post请求内容及拼接数据</span><br><span class="line">this.$http.post(&quot;api/postcomment/&quot; + this.$route.params.id,&#123;</span><br><span class="line">	content: this.msg.trim()</span><br><span class="line">&#125;).then(function(result)&#123;</span><br><span class="line">	if(result.body.status === 0)&#123;</span><br><span class="line">		//拼接出一个对象·</span><br><span class="line">		let cmt = &#123;</span><br><span class="line">			user_name: &apos;匿名用户&apos;，</span><br><span class="line">			add_time: Date.now(),</span><br><span class="line">			content: this.msg.trim()</span><br><span class="line">		&#125;;</span><br><span class="line">		this.comments.unshift(cmt);</span><br><span class="line">		this.msg = &quot;&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="制作顶部滑动条"><a href="#制作顶部滑动条" class="headerlink" title="制作顶部滑动条"></a>制作顶部滑动条</h6><ol>
<li><p>需要借助于 MUI 中的 tab-top-webview-main.html</p>
</li>
<li><p>需要把slider 区域 mui-fullscreen 类去掉</p>
</li>
<li><p>滑动条无法正常触发滑动，通过检查官方文档，发现这是 js 组件，需要初始化一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.导入mui.js文件</span><br><span class="line">2.调用官方提供的方式去初始化</span><br><span class="line">mounted()&#123;  //调用时机会重要</span><br><span class="line">	mui(&apos;.mui-scroll-wrapper&apos;).scroll(&#123;</span><br><span class="line">	deceleration: 0.0005  </span><br><span class="line">        //flick减速系数，系数越大，滚动速度越慢，滚动距离越小，默认为0.0006</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们在初始化 滑动条时，导入的 mui.js ，但是控制台报错：因webpack打包好的bundle.js文件默认启用严格模式，故无法解析mui.js文件里的一些属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">解决方法：remove &quot;use strict&quot; directive </span><br><span class="line">cnpm i babel-plugin-transform-remove-strict-mode -D</span><br><span class="line">//在 .babelrc文件中</span><br><span class="line">&#123;</span><br><span class="line">	&quot;plugins&quot;:[&quot;transform-remove-strict-mode&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="动画transition"><a href="#动画transition" class="headerlink" title="动画transition"></a>动画transition</h6><p>当插入或删除包含在transition组件中的元素，Vue将会做以下处理</p>
<ol>
<li>自动嗅探目标元素是否应用了css过渡或动画，如果是在恰当的时机添加/删除css类名。</li>
<li>如果过渡组件提供了js钩子函数，这些钩子函数将在恰当时机被调用。</li>
<li>如果没有找到js钩子并且没有检测到css过渡/动画，DOM操作*（插入/删除）在下一帧中立即执行。（注意：此指浏览器逐帧动画机制，和Vue的nextTick概念不同）</li>
</ol>
<h6 id="用手机调试项目"><a href="#用手机调试项目" class="headerlink" title="用手机调试项目"></a>用手机调试项目</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --hot --host 172.23.232.1&quot;   连接上电脑主机</span><br></pre></td></tr></table></figure>

<ol>
<li>保证手机可正常运行；</li>
<li>要保证手机于开发项目的电脑处于同一个WIFI环境中，也就是说手机可以访问到 电脑的 IP</li>
<li>打开自己项目的package.json文件，添加 –host指令，把当前电脑的WIFI IP地址设置为 –host 的指令值<ol>
<li>通过cmd终端运行 ‘ipconfig’ ,乍看 无线网的 ip 地址。</li>
</ol>
</li>
</ol>
<h6 id="使用邮箱发送短信"><a href="#使用邮箱发送短信" class="headerlink" title="使用邮箱发送短信"></a>使用邮箱发送短信</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cnpm i nodemailer -D</span><br><span class="line"></span><br><span class="line">const nodemailer = require(&apos;nodemailer&apos;);</span><br><span class="line">async function main()&#123;</span><br><span class="line">	let testAccount = await nodemailer.createTestAcount();</span><br><span class="line">	let transporter = nodemailer.createTransport(&#123;</span><br><span class="line">		host: &quot;smtp.qq.com&quot;,   //在node_modues-&gt; lib -&gt; well-known -&gt; services.json 中找</span><br><span class="line">		port: 465,</span><br><span class="line">		secure:true,</span><br><span class="line">		auth: &#123;</span><br><span class="line">			auth: &#123;</span><br><span class="line">              user: &apos;3511564414@qq.com&apos;, // 发送给哪个邮箱</span><br><span class="line">              pass: &apos;kzqknaxbiearcife&apos; // 在qq邮箱中 -&gt; 设置 -&gt; 账户 -&gt;  开启POP3/SMTP服务</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	  let sendObj = &#123;</span><br><span class="line">        from: &apos;&quot;Fred Foo 👻&quot; &lt;3511564414@qq.com&gt;&apos;, // sender address</span><br><span class="line">        to: &quot;3511564414@qq.com&quot;, // list of receivers</span><br><span class="line">        subject: &quot;Hello ✔&quot;, // Subject line</span><br><span class="line">        text: &quot;Hello world?&quot;, // plain text body</span><br><span class="line">        // html: &quot;&lt;b&gt;Hello world?&lt;/b&gt;&quot; // html body</span><br><span class="line">      &#125;;</span><br><span class="line">      let info = await transporter.sendMail(sendObj);</span><br><span class="line">&#125;</span><br><span class="line">main().catch(console.error);</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-webpack学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/12/27/webpack学习/" class="article-date">
      <time datetime="2019-12-27T01:01:57.000Z" itemprop="datePublished">2019-12-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/27/webpack学习/">webpack学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="npm相关"><a href="#npm相关" class="headerlink" title="npm相关"></a>npm相关</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack --save-dev      开发环境下的依赖</span><br></pre></td></tr></table></figure>

<h4 id="运行cnpm-run-dev自动打开"><a href="#运行cnpm-run-dev自动打开" class="headerlink" title="运行cnpm run dev自动打开"></a>运行cnpm run dev自动打开</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//package.json文件</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">	&quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --hot&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="webpack功能"><a href="#webpack功能" class="headerlink" title="webpack功能"></a>webpack功能</h4><ul>
<li>代码转换</li>
<li>文件优化</li>
<li>代码分割</li>
<li>模块合并</li>
<li>自动刷新</li>
<li>代码校验</li>
<li>自动发布</li>
</ul>
<h6 id="loader功能"><a href="#loader功能" class="headerlink" title="loader功能"></a>loader功能</h6><p>loader让webpack能够去处理那些非js文件，（webpack自身只能理解js）。loader能让所有类型的文件转换为webpack能够处理的有效模块，然后就可利用webpack的打包能力对其进行处理。</p>
<p>loader的两大目标：</p>
<ol>
<li>test属性，用于标识出应该被对应的loader进行转换的某个文件。</li>
<li>use属性，表示在转换时，应使用哪个loader。</li>
</ol>
<h4 id="webpack使用"><a href="#webpack使用" class="headerlink" title="webpack使用"></a>webpack使用</h4><ul>
<li>webpack默认只支持js文件</li>
<li>node webpack</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//安装本地的webpack</span><br><span class="line">cnpm i webpack webpack-cli -D</span><br><span class="line">//表示开发依赖</span><br><span class="line">//在命令行上输入webpack即可将入口文件打包</span><br><span class="line">//webpack可以进行0配置</span><br></pre></td></tr></table></figure>

<h6 id="手动配置webpack文件"><a href="#手动配置webpack文件" class="headerlink" title="手动配置webpack文件"></a>手动配置webpack文件</h6><p>webpack配置文件<strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">	mode: &apos;development&apos;,//模式默认两种，production  development</span><br><span class="line">	entry: path.join(__dirname,&apos;./src/main.js&apos;),</span><br><span class="line">	output: &#123;</span><br><span class="line">		path: path.resolve(__dirname,&apos;dist&apos;),//路径必须是一个绝对路径</span><br><span class="line">		filename: &apos;bundle.js&apos;,//打包后的文件名</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>production：开发的未压缩的文件</p>
<p>development：开发的压缩的文件</p>
<h6 id="更改配置文件名字"><a href="#更改配置文件名字" class="headerlink" title="更改配置文件名字"></a>更改配置文件名字</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在package.json文件中的script对象上</span><br><span class="line">scripts:&#123;</span><br><span class="line">	&quot;builder&quot;: &quot;webpack --config webpack.configmy.js&quot;</span><br><span class="line">&#125;</span><br><span class="line">//命令行上运行 cnpm run builder即可</span><br></pre></td></tr></table></figure>

<h6 id="webpack以本地形式打开文件"><a href="#webpack以本地形式打开文件" class="headerlink" title="webpack以本地形式打开文件"></a>webpack以本地形式打开文件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cnpm i webpack-dev-server -D</span><br><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	devServer:&#123; //开发服务器配置</span><br><span class="line">		port: 3000,  //在3000端口打开</span><br><span class="line">		progress: true,  //显示进度条</span><br><span class="line">		contentBase: &apos;./build&apos;,  //以当前目录运行程序</span><br><span class="line">		compress: true  //启动压缩</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//package.json文件</span><br><span class="line">scripts:&#123;</span><br><span class="line">	&quot;dev&quot;: &quot;webpack-dev-server&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="webpack解析html模块"><a href="#webpack解析html模块" class="headerlink" title="webpack解析html模块"></a>webpack解析html模块</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cnpm i html-webpack-plugin -D</span><br><span class="line">//webpack.config.js</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	output: &#123;</span><br><span class="line">		path: path.resove(__dirname,&apos;./dist&apos;),</span><br><span class="line">		filename: &apos;bundle.[hash].js&apos;,  //每次输出的文件都不同</span><br><span class="line">		//filename: &apos;bundle.[hash:8].js&apos;,  只显示8位hash值 </span><br><span class="line">	&#125;</span><br><span class="line">	plugins: [  //数组 放着所有的webpack插件</span><br><span class="line">		new HtmlWebpackPlugin(&#123;</span><br><span class="line">			template: &apos;./src/index.html&apos;  //以index.html文件为模板</span><br><span class="line">			filename: &apos;index.html&apos;, //打包后的文件名</span><br><span class="line">			minify: &#123;</span><br><span class="line">				removeAttributeQuotes:true,  //压缩时，删除属性中的双引号</span><br><span class="line">				collapseWhiteSpace: true,  //折叠空行，将html文件打包成一行</span><br><span class="line">				</span><br><span class="line">			&#125;,</span><br><span class="line">			hash: true,  //添加哈希戳</span><br><span class="line">		&#125;)</span><br><span class="line">	</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="webpack解析css模块"><a href="#webpack解析css模块" class="headerlink" title="webpack解析css模块"></a>webpack解析css模块</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cnpm i style-loader css-loader -D  //处理css文件</span><br><span class="line">cnpm i less less-loader -D   //less-loader会调用less进行解析</span><br><span class="line">cnpm i node-sass sass-loader -D   //处理sass和scss文件</span><br><span class="line">cnpm i stylus stylus-loader -D   //处理stylus文件</span><br><span class="line"></span><br><span class="line">//main.js文件导入css文件</span><br><span class="line">require(&apos;./index.css&apos;);</span><br><span class="line"></span><br><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	module: &#123; //模块</span><br><span class="line">		rules: [  //规则  css-loader 处理@import这种语法的，将多个css文件合并为一个css文件</span><br><span class="line">		  //style-loader 他是把css插入到head的标签中</span><br><span class="line">		  //loader特点：希望一个loader处理一个功能</span><br><span class="line">		  //只用一个loader用字符串，多个loader用数组,当有参数时可写成对象方式</span><br><span class="line">		  //loader顺序:默认从右向左执行</span><br><span class="line">		  &#123; </span><br><span class="line">		      test: /\.css$/,</span><br><span class="line">              use: [</span><br><span class="line">               &#123;</span><br><span class="line">		  		 loader:&apos;style-loader&apos;,</span><br><span class="line">		  		 options: &#123;</span><br><span class="line">		  		 	insertAt: &apos;top&apos;  //将样式插到head顶部</span><br><span class="line">		  		 &#125;</span><br><span class="line">		 	   &#125;,</span><br><span class="line">		 	   &apos;css-loader&apos;</span><br><span class="line">		 	  ]</span><br><span class="line">		 &#125;,</span><br><span class="line">		 &#123; test: /\.less$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;] &#125;</span><br><span class="line">		]</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="抽离文件的插件"><a href="#抽离文件的插件" class="headerlink" title="抽离文件的插件"></a>抽离文件的插件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cnpm i mini-css-extract-plugin -D</span><br><span class="line">//专门用于抽离css样式的插件</span><br><span class="line"></span><br><span class="line">//webpack.config.js</span><br><span class="line">let MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line">plugins: [</span><br><span class="line">	new HtmlWebpackPlugin(&#123;</span><br><span class="line">		template: &apos;./src/index.html&apos;,</span><br><span class="line">		filename: &apos;index.html&apos;</span><br><span class="line">	&#125;),</span><br><span class="line">	new MiniCssExtractPlugin(&#123;</span><br><span class="line">		filenmae: &apos;main.css&apos;   //抽离出的名字叫main.css</span><br><span class="line">	&#125;)</span><br><span class="line">],</span><br><span class="line">module: &#123;</span><br><span class="line">	rules:[</span><br><span class="line">		&#123;</span><br><span class="line">		  test:/\.css$/,</span><br><span class="line">		  use: [</span><br><span class="line">		    MiniCssExtractPlugin.loader,</span><br><span class="line">		    &apos;css-loader&apos;    //先解析成css样式，然后使用MiniCssExtractPlugin这个插件的加载器将样式分离成一个main.css文件</span><br><span class="line">		  ]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="自动加前缀的插件"><a href="#自动加前缀的插件" class="headerlink" title="自动加前缀的插件"></a>自动加前缀的插件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cnpm i postcss-loader autoprefixer </span><br><span class="line"></span><br><span class="line">module: &#123;</span><br><span class="line">	rules: [</span><br><span class="line">		&#123;</span><br><span class="line">            test: /\.less$/,</span><br><span class="line">            use:[</span><br><span class="line">				MiniCssExtractPlugin.loader,</span><br><span class="line">				&apos;css-loader&apos;,</span><br><span class="line">				&apos;postcss-loader&apos;,</span><br><span class="line">				&apos;less-loader&apos;</span><br><span class="line">            ]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//新建一个postcss.config.js文件</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	plugins: [require(&apos;autoprefixer&apos;)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="webpack中处理js模块"><a href="#webpack中处理js模块" class="headerlink" title="webpack中处理js模块"></a>webpack中处理js模块</h6><ul>
<li>将es6转为es5</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">cnpm i babel-loader @babel/core @babel/preset-env -D</span><br><span class="line">// @babel/core是babel的核心模块，@babel/preset-env 将高级语法转为低级语法</span><br><span class="line">cnpm i eslint eslint-loader -D  //语法检查</span><br><span class="line"></span><br><span class="line">cnpm i @babel/plugin-proposal-class-properties -D  //像class类这些高级语法</span><br><span class="line"></span><br><span class="line">cnpm i @babel/runtime  @babel/plugin-transform-runtime -D @babel/runtime   //像generator遍历器,在plugins中配置</span><br><span class="line"></span><br><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	module: &#123;</span><br><span class="line">		noParse: /jquery/,  //不去解析jquery中的依赖库</span><br><span class="line">		rules: [</span><br><span class="line">			&#123; test: /\.js$/,</span><br><span class="line">			  use: &#123;</span><br><span class="line">			  	&#123;</span><br><span class="line">                    loader:&apos;babel-loader&apos;,  //用该模块将es6转为es5</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets: [&apos;@babel/preset-env&apos;],</span><br><span class="line">                        plugins: [&apos;@babel/plugin-proposal-class-properties&apos;,&apos;@babel/plugin-transform-runtime&apos;]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      loader: &apos;eslint-loader&apos;, //校验es语法规范</span><br><span class="line">                      options: &#123;</span><br><span class="line">                        enforce: &apos;pre&apos;  //强制先执行，因为loader默认是从下往上执行</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">			  	&#125;</span><br><span class="line">			  &#125;,</span><br><span class="line">			  exclude: /node_modules/,   //不去node_module中找</span><br><span class="line">			  include: path.resolve(__dirname,&apos;src&apos;)  //去src文件夹下找</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="webpack第三方模块的使用"><a href="#webpack第三方模块的使用" class="headerlink" title="webpack第三方模块的使用"></a>webpack第三方模块的使用</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">	resolve: &#123;  //解析第三方包 common</span><br><span class="line">		modules: [path.resolve(&apos;node_modules&apos;)],  //解析时先到该目录下寻找</span><br><span class="line">		alias:&#123; //别名 vue vue.runtime</span><br><span class="line">			bootstrap: &apos;bootstrap/dist/css/bootstrap.css&apos;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cnpm i jquery </span><br><span class="line">cnpm i expose-loader</span><br><span class="line"></span><br><span class="line">//main.js文件</span><br><span class="line">import $ from &apos;jquery&apos;;  //此$不是window上的的$</span><br><span class="line">window.$   //undefined</span><br><span class="line"></span><br><span class="line">import $ from &apos;expose-loader?$!jquery&apos;;</span><br><span class="line">//expose-loader 暴露 全局的loader  内联的loader</span><br><span class="line">//pre 前面执行的loader   normal  普通loader  内联loader  后置 postloader</span><br></pre></td></tr></table></figure>

<p><strong>将$暴露给window的另一种方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cnpm i jquery </span><br><span class="line">cnpm i expose-loader</span><br><span class="line"></span><br><span class="line">//main.js文件</span><br><span class="line">import $ from &apos;jquery&apos;;</span><br><span class="line"></span><br><span class="line">//webpack.config.js文件</span><br><span class="line">module: &#123;</span><br><span class="line">	rules: [</span><br><span class="line">		&#123;</span><br><span class="line">			test:require.resolve(&apos;jquery&apos;),</span><br><span class="line">			use: &apos;expose-loader?$!jquery&apos;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在每个模块中注入$对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js文件</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	plugins: [</span><br><span class="line">		new HtmlWebpackPlugin(&#123;</span><br><span class="line">			template: &apos;./src/index.html&apos;,</span><br><span class="line">			filename: &apos;index.html&apos;</span><br><span class="line">		&#125;),</span><br><span class="line">		new Webpack.ProvidePlugin(&#123;  //在每个模块中注入$</span><br><span class="line">			$: &apos;jquery&apos;</span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//main.js文件</span><br><span class="line">import $ from &apos;jquery&apos;   //运行npm run build时会将jquery打包</span><br><span class="line"></span><br><span class="line">//不像将jquery打包，只需在webpack.config.js文件中</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	externals: &#123;</span><br><span class="line">		jquery: &apos;$&apos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="webpack打包图片"><a href="#webpack打包图片" class="headerlink" title="webpack打包图片"></a>webpack打包图片</h6><ol>
<li>在js中创建图片</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cnpm i file-loader -D  </span><br><span class="line">//file-loader默认会在内部生成一张图片到dist文件夹下，并把生成的图片的名字返回回来</span><br><span class="line"></span><br><span class="line">//main.js文件</span><br><span class="line">import logo from &apos;./logo.png&apos;;</span><br><span class="line">//把图片引入，返回结果是一个新的图片地址</span><br><span class="line">let image = new Image();</span><br><span class="line">image.src = logo;  //就是一个普通的字符串</span><br><span class="line">document.body.appendChildren(image)</span><br><span class="line"></span><br><span class="line">//webpack.config.js文件</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	module: &#123;</span><br><span class="line">		rules: [</span><br><span class="line">			&#123; test: /\.(png|jpg|gif)$/, use: &apos;fle-loader&apos; &#125;,</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在css引入background(‘url’)</p>
</li>
<li><p>使用标签<img src alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cnpm i html-withimg-loader -D</span><br><span class="line">cnpm i url-loader -D</span><br><span class="line">//在html文件中引入image，但是路径不在打包目录中的路径中</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	module: &#123;</span><br><span class="line">		rules: [</span><br><span class="line">			&#123;test: /\.html$/, use: &apos;html-withimg-loader&apos;&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				test: /\.(png|jpg|gif)$/,</span><br><span class="line">				//做一个限制，当图片小于多少k时用base64来转化</span><br><span class="line">				//否则用file-loader产生真实的图片</span><br><span class="line">				use: &#123;</span><br><span class="line">					loader: &apos;url-loader&apos;,</span><br><span class="line">					options: &#123;</span><br><span class="line">						limit: 200*1024,</span><br><span class="line">						outputPath: &apos;/img/&apos;  //输出路径放置在img目录下</span><br><span class="line">						publicPath: &apos;http://www.chenchuyin.com&apos;  //统一给图片加上该域名</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="webpack有多入口文件"><a href="#webpack有多入口文件" class="headerlink" title="webpack有多入口文件"></a>webpack有多入口文件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cnpm i html-webpack-plugin - D</span><br><span class="line">cnpm i @babel/core @babel/preset-dev @babel-loadedr @webpack-dev-server -D</span><br><span class="line">//webpack.config.js文件</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	//源码映射  会单独生成一个sourcemap文件，出错了胡hi标识当前出错的列和行</span><br><span class="line">	devtool: &apos;source-map&apos;,  //增加映射文件 可以帮我们调试源代码</span><br><span class="line">	//多入口</span><br><span class="line">	entry: &#123;</span><br><span class="line">		home: &apos;./src/index.js&apos;,</span><br><span class="line">		other: &apos;./src/other.js&apos;</span><br><span class="line">	&#125;,</span><br><span class="line">	output: &#123;</span><br><span class="line">		//[name]表示 home 和 other  [hash]添加哈希戳</span><br><span class="line">		filename: &apos;[name].[hash].js&apos;,</span><br><span class="line">		path: path.resolve(__dirname,&apos;dist&apos;)</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		//若无chunks，会把两个js文件都引入到index.html和other.html文件中</span><br><span class="line">		new HtmlWebpackPlugin(&#123;</span><br><span class="line">			tempalte: &apos;./index.html&apos;,</span><br><span class="line">			filename: &apos;index.html&apos;,</span><br><span class="line">			chunks: [&apos;index&apos;]  //index.html文件引入index.js文件</span><br><span class="line">		&#125;),</span><br><span class="line">		new HtmlWebpackPlugin(&#123;</span><br><span class="line">			tempalte: &apos;./other.html&apos;,</span><br><span class="line">			filename: &apos;other.html&apos;,</span><br><span class="line">			chunks: [&apos;other&apos;，&apos;index&apos;]   //other.html文件引入other.js和index.js文件</span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>不会产生单独文件，但是可以显示行和列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtol:&apos;eval-source-map&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不会产生列，但是是一个单独的映射文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtoole: &apos;cheap-module-source-map&apos;  //产生后你可以保存起来</span><br></pre></td></tr></table></figure>
</li>
<li><p>不会产生文件，集成在打包后的文件中，不会产生列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtoole: &apos;cheap-module-eval-source-map&apos;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="自动打包出实体文件"><a href="#自动打包出实体文件" class="headerlink" title="自动打包出实体文件"></a>自动打包出实体文件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">	watch: true,  //监听文件，只要文件有所修改便直接生成新的实体文件</span><br><span class="line">	watchOptions:&#123;  //监控选项</span><br><span class="line">		poll: 1000,  //每秒 查看文件是否更改 1000次</span><br><span class="line">		aggreatement: 500,  //防抖 如果一直输入代码，则每过500次再生成实体文件</span><br><span class="line">		ignored: /node_modules/  //不需要进行监控的文件</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="webpack小插件"><a href="#webpack小插件" class="headerlink" title="webpack小插件"></a>webpack小插件</h6><ol>
<li>cleanWebpackPlugin</li>
<li>copyWebpackPlugin</li>
<li>bannerPlugin（内置的，不需要安装该模块）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cnpm i clean-webpack-plugin copy-webpack-plugin webpack -D</span><br><span class="line"></span><br><span class="line">const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)</span><br><span class="line">const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line">plugins: [</span><br><span class="line">	new CleanWebpackPlugin(&apos;./dist&apos;),   //打包之前先将dist目录清除</span><br><span class="line">	new CopyWebpackPlugin(</span><br><span class="line">		&#123;from: &apos;doc&apos;, to: &apos;./&apos;&#125;  //将doc.txt文件复制到输出的根目录下</span><br><span class="line">	),</span><br><span class="line">	new webpack.BannerPlugin(&apos;make 2019 by chenchuyin&apos;)</span><br><span class="line">	//会将这句话插入到出口js文件的开头部分</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h6 id="webpack实现跨域功能"><a href="#webpack实现跨域功能" class="headerlink" title="webpack实现跨域功能"></a>webpack实现跨域功能</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//webpack-dev-server默认打开localhost:8080,若想访问3000端口，可使用代理</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	devServer:&#123;</span><br><span class="line">		proxy: &#123;  //重写的方式 把请求代理到express服务器上</span><br><span class="line">			//  &apos;/api&apos;: &apos;http://localhost:3000&apos;,   //配置了一个代理</span><br><span class="line">			&apos;api&apos;: &#123;</span><br><span class="line">				target: &apos;http://localhost:3000&apos;,</span><br><span class="line">				pathRewrute: &#123;&apos;api&apos;: &apos;&apos;&#125;  </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//server.js文件</span><br><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line">let app = express();</span><br><span class="line">app.get(&apos;/user&apos;, (req,res) =&gt; &#123;</span><br><span class="line">	res.json(&#123;name:&apos;陈楚吟&apos;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000);</span><br><span class="line"></span><br><span class="line">//index.js文件</span><br><span class="line">let xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;GET&apos;,&apos;/api/user&apos;,true);  //请求还是有api目录，显示时将其删除</span><br><span class="line">xhr.onload = function()&#123;</span><br><span class="line">	console.log(xhr.response);</span><br><span class="line">&#125;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line"> //我们前端只想单纯模拟数据</span><br><span class="line"> before(app)&#123;</span><br><span class="line"> 	app.get(&apos;/user&apos;, (req,res) =&gt; &#123;</span><br><span class="line"> 		res.json(&#123;name: &apos;陈楚吟&apos;&#125;)</span><br><span class="line"> 	&#125;)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//server.js文件</span><br><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line">let app = express();</span><br><span class="line">app.listen(3000);</span><br><span class="line"></span><br><span class="line">//index.js文件</span><br><span class="line">let xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;GET&apos;,&apos;/api/user&apos;,true);  //请求还是有api目录，显示时将其删除</span><br><span class="line">xhr.onload = function()&#123;</span><br><span class="line">	console.log(xhr.response);</span><br><span class="line">&#125;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cnpm i webpack-dev-middleware -D</span><br><span class="line"></span><br><span class="line">devServer:&#123;</span><br><span class="line"> //有服务端，不用代理来处理，在服务端中启动webpack端口用服务端端口（即前端页面和服务器在同一个端口）</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//server.js文件</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">//中间件</span><br><span class="line">let middle = require(&apos;webpack-dev-middleware&apos;);</span><br><span class="line">let config = require(&apos;./webpack.config.js&apos;);</span><br><span class="line">let compiler = webpack(config);</span><br><span class="line">app.use(middle(compiler));</span><br><span class="line">app.get(&apos;/user&apos;, (req,res) =&gt; &#123;</span><br><span class="line">	res.json(&#123;name:&apos;陈楚吟&apos;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>

<h6 id="实现多线程打包"><a href="#实现多线程打包" class="headerlink" title="实现多线程打包"></a>实现多线程打包</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">cnpm i happypack</span><br><span class="line">//模块happypack可以实现多线程来打包进程</span><br><span class="line">let Happypack = require(&apos;happypack&apos;)</span><br><span class="line">module: &#123;</span><br><span class="line">	rules: [</span><br><span class="line">		&#123;</span><br><span class="line">			test: /\.js$/,</span><br><span class="line">			exclude: /node_modules/,</span><br><span class="line">			include: &apos;src&apos;,</span><br><span class="line">			use: &apos;Happypack/loader?id=js&apos;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			test: /\.css$/,</span><br><span class="line">			use: &apos;Happypack/loader?id=css&apos;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;,</span><br><span class="line">palugins: [</span><br><span class="line">	new Happypack(&#123;</span><br><span class="line">		id: &apos;css&apos;,</span><br><span class="line">		use: [&apos;style-loader&apos;,&apos;css-loader&apos;]</span><br><span class="line">	&#125;)</span><br><span class="line">	new Happypack(&#123;</span><br><span class="line">		id: &apos;js&apos;,</span><br><span class="line">		use: [&#123;</span><br><span class="line">			loader:&apos;babel-loader&apos;,</span><br><span class="line">			options: &#123;</span><br><span class="line">				presets: [</span><br><span class="line">					&apos;@babel/preset-env&apos;,</span><br><span class="line">					&apos;@babel/preset-react&apos;</span><br><span class="line">				]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h6 id="webpack自带优化"><a href="#webpack自带优化" class="headerlink" title="webpack自带优化"></a>webpack自带优化</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//import 在生成环境下会自动去除没用的代码</span><br><span class="line">//因tree-shaking方法会将没用到的代码自动删除掉·</span><br><span class="line"></span><br><span class="line">//require（es6）模块会把结果都放到default上</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123; </span><br><span class="line">	optimization: &#123;  //将公共部分抽离出来</span><br><span class="line">		splitChunks: &#123;   //分割代码块</span><br><span class="line">			cacheGrounps:&#123; //缓存组</span><br><span class="line">				common:&#123; //公共的模块</span><br><span class="line">					chunks: &apos;initial&apos;,  //代码在刚开始时就被抽离出</span><br><span class="line">					minSize: 0,  //代码有多少字节才被抽离</span><br><span class="line">					minChunks: 2   //代码块被使用多少次才被抽离</span><br><span class="line">				&#125;,</span><br><span class="line">				vendor:&#123;</span><br><span class="line">					priority: 1,  //抽离权重，较大的先抽离</span><br><span class="line">					test: /node_modules/,  //将第三方模块抽离出来</span><br><span class="line">					chunks: &apos;initial&apos;,  </span><br><span class="line">                    minSize: 0,  </span><br><span class="line">                     minChunks: 2 </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="webpack懒加载"><a href="#webpack懒加载" class="headerlink" title="webpack懒加载"></a>webpack懒加载</h6><ul>
<li>vue和react的懒加载其实都是通过import实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">let button = document.createElement(&apos;button&apos;)</span><br><span class="line">button.innerHTML = &apos;hello&apos;;</span><br><span class="line">button.addEventListener(&apos;click&apos;,function()&#123;</span><br><span class="line">	//import 是草案中的语法，由jsonp实现动态加载文件</span><br><span class="line">	//返回值是一个1promise对象</span><br><span class="line">	import(&apos;./source.js&apos;).then(data =&gt; &#123;</span><br><span class="line">		console.log(data.default);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="webpack热更新"><a href="#webpack热更新" class="headerlink" title="webpack热更新"></a>webpack热更新</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">	devServer: &#123;</span><br><span class="line">		hot: true,  //启动热更新操作</span><br><span class="line">		port: 3000</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		new webpack.NameModulesPlugin(),  //告诉我们哪个模块热更新</span><br><span class="line">		new webpack.HotModuleReplacementPlugin()  //热更新插件</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//index.js文件</span><br><span class="line">import str from &apos;./source&apos;;</span><br><span class="line">if(module.hot)&#123;</span><br><span class="line">	module.hot.accept(&apos;./source&apos;, () =&gt; &#123;</span><br><span class="line">		require(&apos;./source&apos;);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h6><ul>
<li>webpack本质上是一种事件流机制，它的工作流程是将各个插件串联起来，而实现这一切的核心是Tapable，Tapable是有点类似于nodeJs的events库，核心原理也是依赖于发布订阅模式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="webpack中使用vue"><a href="#webpack中使用vue" class="headerlink" title="webpack中使用vue"></a>webpack中使用vue</h6><p><strong>在普通网页中使用vue</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//1.使用script标签，引入vue的包   (此包功能较全)</span><br><span class="line">&lt;scrpit src=&quot;./lib/vue.js&quot;&gt;&lt;/srcipt&gt;</span><br><span class="line"></span><br><span class="line">//2.在index页面中，创建一个id为app的div容器</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//3.通过new Vue得到一个vm实例</span><br><span class="line">let vm = new Vue(&#123;</span><br><span class="line">	el: &apos;#app&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>在webpack中尝试使用vue</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//注意：在webpack中，使用import Vue from &apos;vue&apos; 导入的Vue构造函数功能不完整，只提供了runtime-only的形式，并无提供像网页中那样的使用方式；</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">let vm = new Vue(&#123;</span><br><span class="line">	el: &apos;#app&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">解决：指定完整vue.js文件的路径</span><br><span class="line">方式一：import Vue from &apos;./node_modules/vue/dist/vue.js&apos;;</span><br><span class="line">方式二：import vue from &apos;vue&apos;</span><br><span class="line">在webpack.config.js文件中</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	resolve: &#123;</span><br><span class="line">		alias: &#123;  //修改vue时被导入时包的路径</span><br><span class="line">			&quot;vue$&quot;: &quot;vue/dist/vue.js&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cnpm i vue -S</span><br><span class="line">cnpm i vue-loader vue-template-compiler -D</span><br><span class="line"></span><br><span class="line">//webpack.config.js文件</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &quot;development&quot;,</span><br><span class="line">    entry: &apos;./src/index.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname,&apos;./dist&apos;),</span><br><span class="line">        filename: &apos;bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;./src/index.html&apos;,</span><br><span class="line">            filename: &apos;index.html&apos;</span><br><span class="line">        &#125;),</span><br><span class="line">        new VueLoaderPlugin()</span><br><span class="line">    ],</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123; test: /\.css/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;] &#125;,</span><br><span class="line">            &#123; test: /\.vue/, use: &apos;vue-loader&apos; &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.安装 vue 包，cnpm i vue -S</span><br><span class="line">2.由于在webpack中推荐使用vue组件模板文件定义组件，故需要安装能解析这种文件的loader    cnpm i vue-loader vue-template-compiler -D</span><br><span class="line">3.在main.js中导入vue模块， import Vue from &apos;vue&apos;</span><br><span class="line">4.定义.vue结尾的组件，由三部分组成：template script  style</span><br><span class="line">5.使用import login from &apos;./login.vue&apos;导入这个组件</span><br><span class="line">6.创建vm实例 let vm = new Vue(&#123; el: &apos;#app&apos;, render: c =&gt; c(login) &#125;)</span><br><span class="line">7.在页面创建一个id为app的div元素，作为我们vm实例要控制的区域；</span><br></pre></td></tr></table></figure>

<p>注意：App这个组件是通过vm实例的render函数渲染出来的，render函数如果要渲染组件，渲染出来的组件只能放到el：‘#app’ 所指定的元素中。</p>
<p>Account和Goodlist组件是通过路由配置监听到的，所以这两个组件只能展示到属于路由的<router-view></router-view>中去。</p>
<h6 id="包的查找规则"><a href="#包的查找规则" class="headerlink" title="包的查找规则"></a>包的查找规则</h6><p><strong>找vue文件</strong></p>
<ol>
<li>找项目根目录中有没有 node_modules 的文件夹</li>
<li>在node_modules中根据包名找对应的vue文件夹</li>
<li>在vue文件夹中，找一个叫package.json 的包配置文件</li>
<li>在 package.json 文件中，查找一个main 属性【main属性指定了这个包在被加载时的入口文件】</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//sf-pack.js文件</span><br><span class="line">//需要找到当前执行命令的路径，拿到webpack.config.json</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">//config配置文件</span><br><span class="line">let config = require(path.resolve(&apos;webpack.config.js&apos;));</span><br><span class="line"></span><br><span class="line">let Compiler = require(&apos;../lib/Compiler.js&apos;);</span><br><span class="line">let compiler = new Compiler(config);</span><br><span class="line">//标识运行编译</span><br><span class="line">compiler.run();</span><br><span class="line"></span><br><span class="line">//Compiler.js文件</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">class Compiler&#123;</span><br><span class="line">	constructor(config)&#123;</span><br><span class="line">		//entry  output</span><br><span class="line">		this.config = config;</span><br><span class="line">		//需要保存入口文件的路径</span><br><span class="line">		this.entryId;    //&apos;./src/index.js&apos;</span><br><span class="line">		//需要保存所有模块依赖</span><br><span class="line">		this.modules = &#123;&#125;;</span><br><span class="line">		this.entry = config.entry;  //入口路径</span><br><span class="line">		//工作路径</span><br><span class="line">		this.root = process.cwd();</span><br><span class="line">	&#125;</span><br><span class="line">	getSource(modulePath)&#123;</span><br><span class="line">		let content = fs.readFileSync(modulePath,&apos;utf-8&apos;);</span><br><span class="line">		return content;</span><br><span class="line">	&#125;</span><br><span class="line">	//构建模块</span><br><span class="line">	buildModule(modulePath,isEntry)&#123;</span><br><span class="line">		//拿到模块内容</span><br><span class="line">		let source = this.getSource(modulePath);</span><br><span class="line">		//模块id  modulePath = modulePath - this.root;</span><br><span class="line">		let modulePath = &apos;./&apos; +  path.relative(this.root,modulePath);</span><br><span class="line">	&#125;</span><br><span class="line">	run()&#123;</span><br><span class="line">		//执行并且创建模块的依赖关系</span><br><span class="line">		this.buildModule(path.resolve(this.root,this.entry),true);</span><br><span class="line">		//true表示为主模块</span><br><span class="line">		//发射一个文件，该文件即为打包后的文件</span><br><span class="line">		this.emitFile();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = Compiler</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-攻克object对象" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/15/攻克object对象/" class="article-date">
      <time datetime="2019-11-15T13:32:33.000Z" itemprop="datePublished">2019-11-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/15/攻克object对象/">攻克object对象</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><ul>
<li>Object构造函数创建一个对象包装器。如果给定值是null或undefined，将返回一个空对象</li>
</ul>
<h4 id="改变原型链的方法"><a href="#改变原型链的方法" class="headerlink" title="改变原型链的方法"></a>改变原型链的方法</h4><p>几乎所有的js对象都是Object的实例；一个典型的对象继承Object.prototype的属性及方法。改变Object原型会通过原型链改变所有对象。</p>
<ul>
<li>Object.create(null)创建的对象</li>
<li>Object.setPrototypeOf()</li>
<li><code>obj.__proto__</code> = 原型对象</li>
</ul>
<h4 id="Object构造函数的属性"><a href="#Object构造函数的属性" class="headerlink" title="Object构造函数的属性"></a>Object构造函数的属性</h4><ul>
<li><p>Object.length         //值为1</p>
</li>
<li><p>Object.prototype ：可以为所有Object类型的对象添加属性（现在一般用class类代替）</p>
<ul>
<li><strong>Object.prototype.constructor</strong><ul>
<li>返回创建实例对象的Object构造函数的引用（new 关键字后面的值）；注意，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。对原始类型来说，如<code>1</code>，<code>true</code>和<code>&quot;test&quot;</code>，该值只可读。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">arr.constructor  //Array</span><br><span class="line">var obj = new zhuTou()    </span><br><span class="line">obj.constrctor    //zhuTou</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="Object构造函数的方法"><a href="#Object构造函数的方法" class="headerlink" title="Object构造函数的方法"></a>Object构造函数的方法</h4><h6 id="Object-assign-复制"><a href="#Object-assign-复制" class="headerlink" title="Object.assign()复制"></a>Object.assign()复制</h6><p><strong>Object.assign( targetObj, obj1,obj2,…)</strong></p>
<ul>
<li>将obj1，obj2等对象里的自身属性且为可枚举属性复制到targetObj对象上，属于浅拷贝。</li>
<li>若有相同属性，则targetObj里的属性会被覆盖。</li>
<li>返回值是一个与targetObj一样的对象，两者绝对相等。</li>
<li>Deep Clone  <code>let obj3 = JSON.parse(JSON.stringify(obj1));</code>   obj1与obj3更改属性值互不影响。</li>
<li>可拷贝symbol类型属性，继承属性和不可枚举属性不能被拷贝。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let targetObj = &#123;name:&apos;targetObj&apos;&#125;</span><br><span class="line">let obj1 = Object.create(&#123;foo:1&#125;,&#123;</span><br><span class="line">    bar1:&#123;</span><br><span class="line">   	 value:1   //bar是一个不可枚举属性</span><br><span class="line">    &#125;，</span><br><span class="line">    bar2:&#123;</span><br><span class="line">    	value:2,</span><br><span class="line">    	enumerable:true  //bar2是个自身可枚举属性</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">let obj2 = &#123; [Symbol(&apos;foo&apos;)]:2,name:&apos;obj1&apos; &#125;;</span><br><span class="line">let </span><br><span class="line">let obj = Object.assign(targetObject,obj1,obj2)</span><br><span class="line">&#123;</span><br><span class="line">	name:&apos;obj1&apos;,     //后来居上，覆盖targetObj里的值</span><br><span class="line">	[Symbol(&apos;foo&apos;)]:2,   //可拷贝symbol类型属性</span><br><span class="line">	bar2 : 2,        //bar1不可枚举，bar2指定可枚举</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原始类型会被包装成对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const v1 = &quot;abc&quot;;</span><br><span class="line">const v2 = true;</span><br><span class="line">const v3 = 10;</span><br><span class="line">const v4 = Symbol(&quot;foo&quot;)</span><br><span class="line"></span><br><span class="line">const obj = Object.assign(&#123;&#125;, v1, null, v2, undefined, v3, v4); </span><br><span class="line">// 原始类型会被包装，null 和 undefined 会被忽略。</span><br><span class="line">// 注意，只有字符串的包装对象才可能有自身可枚举属性。</span><br><span class="line">console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>异常会打断后续拷贝任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const target = Object.defineProperty(&#123;&#125;, &quot;foo&quot;, &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    writable: false</span><br><span class="line">&#125;); // target 的 foo 属性是个只读属性。</span><br><span class="line"></span><br><span class="line">Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);</span><br><span class="line">// TypeError: &quot;foo&quot; is read-only</span><br><span class="line">// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</span><br><span class="line"></span><br><span class="line">console.log(target.bar);  // 2，说明第一个源对象拷贝成功了。</span><br><span class="line">console.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。</span><br><span class="line">console.log(target.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span><br><span class="line">console.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span><br><span class="line">console.log(target.baz);  // undefined，第三个源对象更是不会被拷贝到的。</span><br></pre></td></tr></table></figure>

<ul>
<li>异常会打断后续拷贝任务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//以下函数会拷贝所有自有属性的属性描述符</span><br><span class="line">function completeAssign(target,...sources)&#123;</span><br><span class="line">	sources.forEach(source =&gt; &#123;</span><br><span class="line">		let descritors = Object.keys(source).reduce( (descriptors,key) =&gt; &#123;</span><br><span class="line">			descriptors[key] = Object.getOwnPropertyDescriptor(source,key);</span><br><span class="line">			return descriptors;</span><br><span class="line">		&#125;,&#123;&#125;);</span><br><span class="line">		//Object.assign默认也会拷贝可枚举的Symbols</span><br><span class="line">		object.getOwnPropertySymbols(source).forEach( sym =&gt; &#123;</span><br><span class="line">		  let descriptor = Object.getOwnPropertyDescriptor(source,sym);</span><br><span class="line">		  if(descriptor.enumerable)&#123;</span><br><span class="line">		  	descriptors[sym] = descriptor;</span><br><span class="line">		  &#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Object.defineProperties(target,descriptors);</span><br><span class="line">	&#125;);</span><br><span class="line">	return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>此<a href="https://developer.mozilla.org/en-US/docs/Glossary/Polyfill" target="_blank" rel="noopener">polyfill</a>不支持 symbol 属性，因为ES5 中根本没有 symbol ：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">if (typeof Object.assign != &apos;function&apos;) &#123;</span><br><span class="line">  // Must be writable: true, enumerable: false, configurable: true</span><br><span class="line">  Object.defineProperty(Object, &quot;assign&quot;, &#123;</span><br><span class="line">    value: function assign(target, varArgs) &#123; // .length of function is 2</span><br><span class="line">      &apos;use strict&apos;;</span><br><span class="line">      if (target == null) &#123; // TypeError if undefined or null</span><br><span class="line">        throw new TypeError(&apos;Cannot convert undefined or null to object&apos;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      let to = Object(target);</span><br><span class="line"></span><br><span class="line">      for (var index = 1; index &lt; arguments.length; index++) &#123;</span><br><span class="line">        var nextSource = arguments[index];</span><br><span class="line"></span><br><span class="line">        if (nextSource != null) &#123; // Skip over if undefined or null</span><br><span class="line">          for (let nextKey in nextSource) &#123;</span><br><span class="line">            // Avoid bugs when hasOwnProperty is shadowed</span><br><span class="line">            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) &#123;</span><br><span class="line">              to[nextKey] = nextSource[nextKey];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return to;</span><br><span class="line">    &#125;,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Object-create-继承"><a href="#Object-create-继承" class="headerlink" title="Object.create()继承"></a>Object.create()继承</h6><ul>
<li><p>Object(proto[,propertiesObject])：实现类式继承</p>
<ul>
<li>proto：新创建的原型对象。</li>
<li>propertiesObject：未指定为undefined，要添加到新创建对象的可枚举属性（不是其原型链上的枚举属性，而是自定义属性）对象的属性描述符以及相应的属性名称。若为null或非原始包装对象抛出TypeError异常。</li>
<li>返回一个带着指定原型对象和属性的新对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Shape()&#123;	//父类</span><br><span class="line">  this.x = 0;</span><br><span class="line">  this.y = 0;</span><br><span class="line">&#125;</span><br><span class="line">Shape.prototype.move = function(x,y)&#123;</span><br><span class="line">  this.x += x;</span><br><span class="line">  this.y += y;</span><br><span class="line">  console.log(this,&apos;shape moved&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">function Rectangle()&#123;</span><br><span class="line">  Shape.call(this);</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype = Object.create(Shape.prototype);</span><br><span class="line">Rectangle.prototype.constructor = Rectangle;//没有这句，输出的this指向父类Shape</span><br><span class="line">var rect = new Rectangle();</span><br><span class="line">console.log(rect instanceof Rectangle);</span><br><span class="line">console.log(rect instanceof Shape);</span><br><span class="line">rect.move();</span><br><span class="line">//true</span><br><span class="line">//true</span><br><span class="line">//Rectangle &#123; x: NaN, y: NaN &#125; &apos;shape moved&apos;</span><br></pre></td></tr></table></figure>

<ul>
<li>继承多个对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function MyClass()&#123;</span><br><span class="line">	SuperClass.call(this);</span><br><span class="line">	otherSuperClass.call(this);</span><br><span class="line">&#125;</span><br><span class="line">//继承一个类</span><br><span class="line">MyClass.prototype = Object.create(SuperClass.prototype);</span><br><span class="line">//混合其他</span><br><span class="line">Object.assign(MyClass.prototype,OtherSuperclass.prototype);</span><br><span class="line">//重新指定constructor</span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">var o;</span><br><span class="line">// 创建一个原型为null的空对象</span><br><span class="line">o = Object.create(null);</span><br><span class="line"></span><br><span class="line">o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 以字面量方式创建的空对象就相当于:</span><br><span class="line">o = Object.create(Object.prototype);</span><br><span class="line">o = Object.create(Object.prototype, &#123;</span><br><span class="line">  // foo会成为所创建对象的数据属性</span><br><span class="line">  foo: &#123; </span><br><span class="line">    writable:true,</span><br><span class="line">    configurable:true,</span><br><span class="line">    value: &quot;hello&quot; </span><br><span class="line">  &#125;,</span><br><span class="line">  // bar会成为所创建对象的访问器属性</span><br><span class="line">  bar: &#123;</span><br><span class="line">    configurable: false,</span><br><span class="line">    get: function() &#123; return 10 &#125;,</span><br><span class="line">    set: function(value) &#123;</span><br><span class="line">      console.log(&quot;Setting `o.bar` to&quot;, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Constructor()&#123;&#125;</span><br><span class="line">o = new Constructor();</span><br><span class="line">// 上面的一句就相当于:</span><br><span class="line">o = Object.create(Constructor.prototype);</span><br><span class="line">// 当然,如果在Constructor函数中有一些初始化代码,Object.create不能执行那些代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 创建一个以另一个空对象为原型,且拥有一个属性p的对象</span><br><span class="line">o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;)</span><br><span class="line"></span><br><span class="line">// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:</span><br><span class="line">o.p = 24</span><br><span class="line">o.p</span><br><span class="line">//42</span><br><span class="line"></span><br><span class="line">o.q = 12</span><br><span class="line">for (var prop in o) &#123;</span><br><span class="line">   console.log(prop)</span><br><span class="line">&#125;</span><br><span class="line">//&quot;q&quot;</span><br><span class="line"></span><br><span class="line">delete o.p</span><br><span class="line">//false</span><br><span class="line"></span><br><span class="line">//创建一个可写的,可枚举的,可配置的属性p</span><br><span class="line">o2 = Object.create(&#123;&#125;, &#123;</span><br><span class="line">  p: &#123;</span><br><span class="line">    value: 42, </span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true </span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties()"></a>Object.defineProperties()</h6><ul>
<li>Object.defineProperties(obj,props):在对象obj上定义或修改现有属性，并返回该对象obj</li>
<li>props：要定义的其可枚举属性或修改的属性描述符对象。对象上存在的属性描述符主要有两种：数据描述符（有值的属性，该值可写，也可能不可写）和访问器描述符。描述符具有以下键：<ul>
<li>configurable：默认为false。描述属性能否被修改或删除，一旦定义值后不可修改，否则会抛出错误。但是删除configurable属性值为false的属性值nothing happen，也不会报错。</li>
<li>enumerable：默认为false。能否使用<strong>for…in循环和Object.keys()</strong>，是否可枚举。</li>
<li>value：默认undefined。可为任何有效js值。</li>
<li>writable：默认false。是否可重写。</li>
<li>get：默认undefined。作为函数的getter函数，若无getter函数则为undefined。</li>
<li>set：与get同理。</li>
</ul>
</li>
</ul>
<h6 id="object-defineProperty"><a href="#object-defineProperty" class="headerlink" title="object.defineProperty()"></a>object.defineProperty()</h6><ul>
<li>Object.defineProperty(obj,prop,descriptor):返回被传递给函数的对象，即obj，该方法式定义key为Symbol的属性的方法之一。</li>
<li>通过简单赋值操作的普通属性可delete，<strong>通过该方法定义的属性值不能修改</strong>。</li>
<li>如果一个描述符不具有value,writable,get 和 set 任意一个关键字，那么它将被认为是一个数据描述符。如果一个描述符同时有(value或writable)和(get或set)关键字，将会产生一个异常。</li>
<li>如果某些属性是继承来的，需要先冻结Object.prototype，明确指定所有属性，或通过Object.create(nill)将<code>__proto__</code>属性指向null。var des</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//使用__proto__</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var descriptor = Object.create(null);//没有继承的属性</span><br><span class="line">//默认没有enumerable，没有configurable，没有writable</span><br><span class="line">descriptor.value=&quot;static&quot;;</span><br><span class="line">Object.defineProperty(obj,&quot;key&quot;,descriptor);</span><br><span class="line"></span><br><span class="line">//显式定义</span><br><span class="line">Object.defineProperty(obj,&quot;key&quot;,&#123;</span><br><span class="line">	enumerable:false,</span><br><span class="line">	confingurable:false,</span><br><span class="line">	writable:false,</span><br><span class="line">	value:&apos;static&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//循环使用同一个对象</span><br><span class="line">function withValue(value)&#123;</span><br><span class="line">	var d = withValue.d || (</span><br><span class="line">		withValue.d = &#123;</span><br><span class="line">			enumerable:false,</span><br><span class="line">			configurable:false,</span><br><span class="line">			writable:false,</span><br><span class="line">			value:null</span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line">	d.value = value;</span><br><span class="line">	return d;</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(obj,&quot;key&quot;,withValue(&quot;static&quot;));</span><br><span class="line"></span><br><span class="line">//如果freeze可用，防止代码添加或删除对象圆形的属性</span><br><span class="line">(Object.freeze || object)(Object.prototype);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果对象中不存在指定的属性，<code>Object.defineProperty()</code>就创建这个属性。当描述符中省略某些字段时，这些字段将使用它们的默认值。拥有布尔值的字段的默认值都是<code>false</code>。<code>value</code>，<code>get</code>和<code>set</code>字段的默认值为<code>undefined</code>。一个没有<code>get/set/value/writable</code>定义的属性被称为“通用的”，并被“键入”为一个数据描述符。</li>
<li>如果访问者的属性是被继承的，它的get和set方法会在子对象的属性被修改或访问时调用。如果这些方法用一个变量存值，该值会被所有对象共享。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function myClass()&#123;&#125;</span><br><span class="line">var value;</span><br><span class="line">myClass.prototype.x = 2;</span><br><span class="line">Object.defineProperty(myClass.prototype,&quot;x&quot;,&#123;</span><br><span class="line">	get()&#123; return value; &#125;,</span><br><span class="line">	set(x)&#123; value = x; &#125;</span><br><span class="line">&#125;);</span><br><span class="line">var a = new myClass();</span><br><span class="line">var b = new myClass();</span><br><span class="line">a.x = 1;</span><br><span class="line">b.x   //1</span><br><span class="line">myClass.prototype.x   //2   实例上的x与原型上的x不同，更改实例上的值不影响原型上的值</span><br></pre></td></tr></table></figure>

<ul>
<li>这可通过将值存入另一个属性中解决，在get或set中，this指向某个被访问的被访问和修改属性的对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function myClass()&#123;&#125;</span><br><span class="line">Object.defineProperty(myClass.prototype,&quot;x&quot;,&#123;</span><br><span class="line">	get()&#123; return this.stored_x; &#125;,</span><br><span class="line">	set(x)&#123; this._stored_x = x; &#125;</span><br><span class="line">&#125;);</span><br><span class="line">myClass.prototype.x = 1;</span><br><span class="line">Object.defineProperty(myClass.prototype,&quot;y&quot;,&#123;</span><br><span class="line">	writable:false,</span><br><span class="line">	value:&quot;y&quot;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var a = new myClass();</span><br><span class="line">var b = new myClass();</span><br><span class="line">a.x = 2;</span><br><span class="line">b.x    //undefined</span><br></pre></td></tr></table></figure>

<h6 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h6><ul>
<li>Object.entries(obj)：返回一个给定对象<strong>自身可枚举属性的键值对数组</strong>，其排列顺序与<strong>for…in循环（会遍历原型链上的可枚举属性</strong>）返回顺序相同。如果是类数组则按数字键从小到大排列。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;</span><br><span class="line">console.log(Object.entries(obj)); // [ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42] ]</span><br><span class="line"></span><br><span class="line">// array like object</span><br><span class="line">const obj = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; &#125;;</span><br><span class="line">console.log(Object.entries(obj)); // [ [&apos;0&apos;, &apos;a&apos;], [&apos;1&apos;, &apos;b&apos;], [&apos;2&apos;, &apos;c&apos;] ]</span><br><span class="line"></span><br><span class="line">// array like object with random key ordering</span><br><span class="line">const anObj = &#123; 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; &#125;;</span><br><span class="line">console.log(Object.entries(anObj)); // [ [&apos;2&apos;, &apos;b&apos;], [&apos;7&apos;, &apos;c&apos;], [&apos;100&apos;, &apos;a&apos;] ]</span><br><span class="line"></span><br><span class="line">// getFoo is property which isn&apos;t enumerable</span><br><span class="line">const myObj = Object.create(&#123;&#125;, &#123; getFoo: &#123; value() &#123; return this.foo; &#125; &#125; &#125;);</span><br><span class="line">myObj.foo = &apos;bar&apos;;</span><br><span class="line">console.log(Object.entries(myObj)); // [ [&apos;foo&apos;, &apos;bar&apos;] ]</span><br><span class="line"></span><br><span class="line">// non-object argument will be coerced to an object</span><br><span class="line">console.log(Object.entries(&apos;foo&apos;)); // [ [&apos;0&apos;, &apos;f&apos;], [&apos;1&apos;, &apos;o&apos;], [&apos;2&apos;, &apos;o&apos;] ]</span><br><span class="line"></span><br><span class="line">// iterate through key-value gracefully</span><br><span class="line">const obj = &#123; a: 5, b: 7, c: 9 &#125;;</span><br><span class="line">for (const [key, value] of Object.entries(obj)) &#123;</span><br><span class="line">  console.log(`$&#123;key&#125; $&#123;value&#125;`); // &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Or, using array extras</span><br><span class="line">Object.entries(obj).forEach(([key, value]) =&gt; &#123;</span><br><span class="line">console.log(`$&#123;key&#125; $&#123;value&#125;`); // &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h6><ul>
<li>Object.freeze(obj)：将obj对象冻结，不能对其自身属性进行任何操作，同时该对象的原型也不能修改。如果一个属性的值是个对象，则这个对象中的属性是可以修改的，除非它也是个冻结对象。数组作为一种对象，被冻结，其元素不能被修改。没有数组元素可以被添加或移除。</li>
<li>这个方法返回传递的对象obj，而不是创建一个被冻结的副本。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//浅冻结</span><br><span class="line">obj1 = &#123; name:&apos;nikita&apos;, internal:&#123;&#125; &#125;;</span><br><span class="line">Object.freeze(obj1);</span><br><span class="line">obj1.name = &apos;hello&apos;</span><br><span class="line">obj1.internal.a = 1;</span><br><span class="line">obj1     //&#123;name: &quot;nikita&quot;, internal: &#123;a:1&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归冻结每个对象属性，即深度冻结</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function deepFreeze(obj)&#123;</span><br><span class="line">	//取回定义在obj上的属性名</span><br><span class="line">	var propNames = object.getPropertyName(obj);</span><br><span class="line">	//在冻结对象之前冻结属性</span><br><span class="line">	propNames.forEach(function(name)&#123;</span><br><span class="line">		var prop = obj[name];</span><br><span class="line">		if(typeof prop == &apos;object&apos; &amp;&amp; prop !== null)&#123;</span><br><span class="line">			deepFreeze(prop);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	//冻结自身</span><br><span class="line">	return Object.freeze(obj);</span><br><span class="line">&#125;</span><br><span class="line">obj2 = &#123;</span><br><span class="line">  internal: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">deepFreeze(obj2);</span><br><span class="line">obj2.internal.a = &apos;anotherValue&apos;;</span><br><span class="line">obj2.internal.a; // undefined</span><br></pre></td></tr></table></figure>

<h6 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h6><ul>
<li>Object.getOwnPropertyDescriptor(obj,prop)：返回指定对象自身属性的属性描述符。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o, d;</span><br><span class="line"></span><br><span class="line">o = &#123; get foo() &#123; return 17; &#125; &#125;;</span><br><span class="line">d = Object.getOwnPropertyDescriptor(o, &quot;foo&quot;);</span><br><span class="line">// d &#123;</span><br><span class="line">//   configurable: true,</span><br><span class="line">//   enumerable: true,</span><br><span class="line">//   get: /*the getter function*/,</span><br><span class="line">//   set: undefined</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>若第一个参数不是对象，ES5报错，ES6强制转换为对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor(&apos;foo&apos;, 0);</span><br><span class="line">// 类型错误: &quot;foo&quot; 不是一个对象  // ES5 code</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(&apos;foo&apos;, 0);</span><br><span class="line">// Object returned by ES2015 code: &#123;</span><br><span class="line">//   configurable: false,</span><br><span class="line">//   enumerable: true,</span><br><span class="line">//   value: &quot;f&quot;,</span><br><span class="line">//   writable: false</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Object.getOwnPropertyDescriptors()</code> 方法用来获取一个对象的所有自身属性的描述符。</li>
<li>浅拷贝一个对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.create(</span><br><span class="line">	Object.getPrototypeOf(obj),</span><br><span class="line">	Object.getownpropertyDescriptors(obj)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>创建子类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function superClass()&#123;&#125;</span><br><span class="line">superClass.prototype=&#123;&#125;</span><br><span class="line">function subClass = &#123;&#125;</span><br><span class="line">subClass.prototype = Object.create(superClass.prototype,Object.getOwnpropertyDescriptors(&#123;&#125;));</span><br></pre></td></tr></table></figure>

<h6 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h6><ul>
<li>返回一个包含所有属性名（<strong>包括不可枚举属性但不包括Symbol值作为名称的属性</strong>）组成的<strong>数组</strong>。</li>
</ul>
<h6 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h6><ul>
<li>返回自身属性的字符串数组</li>
</ul>
<h6 id="Object-values-obj"><a href="#Object-values-obj" class="headerlink" title="Object.values(obj)"></a>Object.values(obj)</h6><ul>
<li>返回给定对象自身的所有可枚举属性值的数组。</li>
</ul>
<h6 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h6><p>object.is(val1,val2)：判断两个值是否是相同的值，作用与”==”相似，只不过Object.is()不会隐式类型转换，返回boolean值。</p>
<p><strong>注意相等的几种情况</strong>：</p>
<ul>
<li>两个值都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a></li>
<li>两个值都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null" target="_blank" rel="noopener"><code>null</code></a></li>
<li>两个值都是 <code>true</code> 或者都是 <code>false</code></li>
<li>两个值是由相同个数的字符按照相同的顺序组成的字符串</li>
<li>两个值指向同一个对象</li>
<li>两个值都是数字并且<ul>
<li>都是正零 <code>+0</code></li>
<li>都是负零 <code>-0</code></li>
<li>都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN" target="_blank" rel="noopener"><code>NaN</code></a></li>
<li>都是除零和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN" target="_blank" rel="noopener"><code>NaN</code></a> 外的其它同一个数字</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 特例</span><br><span class="line">Object.is(0, -0);            // false</span><br><span class="line">Object.is(0, +0);            // true</span><br><span class="line">Object.is(-0, -0);           // true</span><br><span class="line">Object.is(NaN, 0/0);         // true</span><br></pre></td></tr></table></figure>

<h6 id="Object-isExtensible-obj"><a href="#Object-isExtensible-obj" class="headerlink" title="Object.isExtensible(obj)"></a>Object.isExtensible(obj)</h6><ul>
<li>检测对象obj是否可扩展（能否加新的属性），返回boolean值。</li>
<li>默认是可扩展的，即可为他们添加新的属性。以及他们的<code>__prop__</code>属性也是可被更改的。Object.preventExtensions,Object.seal或Object.freeze方法都可使对象obj变成不可扩展。</li>
<li>若参数不是object类型，ES5会报错，ES6会将其转为不可扩展的普通对象.</li>
</ul>
<h6 id="Object-isFrozen-obj"><a href="#Object-isFrozen-obj" class="headerlink" title="Object.isFrozen(obj)"></a>Object.isFrozen(obj)</h6><ul>
<li>判断对象obj是否被冻结，冻结指它不可扩展，所有属性所有属性都是不可配置的，且所有数据属性（即没有getter或setter组件的访问器）都是不可写的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var oneProp = &#123;p:42&#125;</span><br><span class="line">// 让这个对象变的不可扩展,并不意味着这个对象变成了冻结对象,</span><br><span class="line">// 因为p属性仍然是可以配置的(而且可写的).</span><br><span class="line">Object.preventExtensions(oneProp);</span><br><span class="line">Object.isFrozen(oneProp) //=== false</span><br><span class="line">//此时如果删除了这个属性，则它会变成一个冻结对象</span><br><span class="line">delete oneProp.p;</span><br><span class="line">Object.isFrozen(oneProp) //===true</span><br><span class="line">//一个不可扩展的对象，拥有一个不可写但可配置的属性，则它仍是不可冻结的</span><br><span class="line">var nonWritable = &#123;e:&apos;plep&apos;&#125;;</span><br><span class="line">Object.preventExtensions(nonWritable);</span><br><span class="line">Object.defineProperty(noWritable,&apos;e&apos;,&#123;writable:false&#125;);</span><br><span class="line">Object.isFrozen(nonWritable)  //===false</span><br><span class="line">//将该属性变为不可配置则可让其变为冻结对象</span><br><span class="line">Object.defineProperty(noWritable,&apos;e&apos;,&#123;configurable:false&#125;);</span><br><span class="line">Object.isFrozen(nonWritable)  //===true</span><br></pre></td></tr></table></figure>

<ul>
<li>如果参数不是对象类型，ES5报错。ES6将其视为一个冻结的普通对象。</li>
</ul>
<h6 id="Object-isSealed-obj"><a href="#Object-isSealed-obj" class="headerlink" title="Object.isSealed(obj)"></a>Object.isSealed(obj)</h6><ul>
<li>判断一个对象是否被密封，返回boolean值。密封对象是指那些不可扩展且所有自身属性都不可配置且不可删除（但不一定是不可写的）的对象。</li>
</ul>
<h6 id="Object-hasOwnProperty-str-symbol"><a href="#Object-hasOwnProperty-str-symbol" class="headerlink" title="Object.hasOwnProperty(str/symbol)"></a>Object.hasOwnProperty(str/symbol)</h6><ul>
<li>判断某个属性是否为对象自身属性，与in不同，该方法会忽略掉从原型链上继承来的属性。即使属性值为null或undefined，只要属性存在都返回true</li>
</ul>
<h6 id="Object-toString"><a href="#Object-toString" class="headerlink" title="Object.toString()"></a>Object.toString()</h6><ul>
<li>返回【Object  type】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var toString = Object.prototype.toString;</span><br><span class="line"></span><br><span class="line">toString.call(new Date); // [object Date]</span><br><span class="line">toString.call(new String); // [object String]</span><br><span class="line">toString.call(Math); // [object Math]</span><br><span class="line"></span><br><span class="line">//Since JavaScript 1.8.5</span><br><span class="line">toString.call(undefined); // [object Undefined]</span><br><span class="line">toString.call(null); // [object Null]</span><br></pre></td></tr></table></figure>

<h6 id="obj-valueOf"><a href="#obj-valueOf" class="headerlink" title="obj.valueOf()"></a>obj.valueOf()</h6><ul>
<li>返回指定对象的原始值</li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong>对象</strong></th>
<th align="left"><strong>返回值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Array</td>
<td align="left">返回数组对象本身。</td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">布尔值。</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。</td>
</tr>
<tr>
<td align="left">Function</td>
<td align="left">函数本身。</td>
</tr>
<tr>
<td align="left">Number</td>
<td align="left">数字值。</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="left">对象本身。这是默认情况。</td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">字符串值。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Math 和 Error 对象没有 valueOf 方法。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>字符串上下文中的对象通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString" target="_blank" rel="noopener"><code>toString()</code></a>方法转换，这与使用<code>valueOf</code>转换为原始字符串的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String" target="_blank" rel="noopener"><code>String</code></a>对象不同。所有对象都能转换成一个“<code>[object *类型*]</code>”这种格式的字符串。但是很多对象不能转换为数字，布尔或函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// new一个Boolean对象</span><br><span class="line">var newBool = new Boolean(true);</span><br><span class="line">// valueOf()返回的是true，两者的值相等</span><br><span class="line">console.log(newBool.valueOf() == newBool);   // true</span><br><span class="line">// 但是不全等，两者类型不相等，前者是boolean类型，后者是object类型</span><br><span class="line">console.log(newBool.valueOf() === newBool);   // false</span><br></pre></td></tr></table></figure>

<h6 id="Object-seal-prop"><a href="#Object-seal-prop" class="headerlink" title="Object.seal(prop)"></a>Object.seal(prop)</h6><p><code>**Object.seal()**</code>方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-qq小程序天坑之旅" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/15/qq小程序天坑之旅/" class="article-date">
      <time datetime="2019-11-15T13:18:47.000Z" itemprop="datePublished">2019-11-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/15/qq小程序天坑之旅/">qq小程序天坑之旅</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="qq小程序"><a href="#qq小程序" class="headerlink" title="qq小程序"></a>qq小程序</h4><h6 id="吐槽qq小程序开发者工具"><a href="#吐槽qq小程序开发者工具" class="headerlink" title="吐槽qq小程序开发者工具"></a>吐槽qq小程序开发者工具</h6><ul>
<li>不能通过uni-app打开。</li>
<li>项目文件间互相引用问题颇多。</li>
<li>开发工具容易崩溃。</li>
<li>文档不够详尽。</li>
</ul>
<h6 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h6><ul>
<li>在组件qss中不应使用id，属性，标签选择器，最好用类选择器。</li>
<li>qml文件标签名只能是小写字母，中划线，下划线的组合，所以自定义组件的标签名也只能包含这些字符。</li>
<li>自定义组件也是可以引用自定义组件，引用方法类似于页面引用自定义组件的方式<code>usingComponent</code>字段</li>
<li>自定义组件和页面所在项根目录名不能以qq-为前缀，否则会报错。</li>
<li>是否在页面文件中使用 <code>usingComponents</code> 会使得页面的 <code>this</code> 对象的原型稍有差异，包括：<ul>
<li>使用 <code>usingComponents</code> 页面的原型与不使用时不一致，即 <code>Object.getPrototypeOf(this)</code> 结果不同。</li>
<li>使用 <code>usingComponents</code> 时会多一些方法，如 <code>selectComponent</code> 。</li>
<li>出于性能考虑，使用 <code>usingComponents</code> 时， <code>setData</code> 内容不会被直接深复制，即 <code>this.setData({ field: obj })</code> 后 <code>this.data.field === obj</code>。（深复制会在这个值被组件间传递时发生。）</li>
</ul>
</li>
<li><strong><em>直接修改this.data而不调用this.setData是无法改变页面的状态的，还会造成数据不一致</em></strong></li>
<li>不要将data里的任何一项的value设为undefined，否则这一项将不被设置并可能会存在一些潜在问题。</li>
<li><strong>navigateTo，redirectTo</strong>只能打开非tabBar页面，<strong>switchtab</strong>只能打开tabBar的页面。<strong>reLaunch</strong>可打开任意页面。调用页面路由带的参数可以在目标页面的onLoad中获取。</li>
<li>通过全局函数getApp（）可以获取全局的应用实例，如果需要全局的数据可以在App（）中获取。</li>
<li>require只支持相对路径，不支持绝对路径。</li>
<li>约定以on开头的API用来监听某个时间是否发生，当事件触发时会调用这个回调函数并将相关数据以参数的形式传入。</li>
<li>除继承样式外，app.qss中的样式，组将所在页面的样式对自定义组件无效。组件可以指定他所在节点的默认样式，使用:host选择器。</li>
</ul>
<h6 id="使用自定义组件"><a href="#使用自定义组件" class="headerlink" title="使用自定义组件"></a>使用自定义组件</h6><ol>
<li>在自定义组件中的json文件定义<code>{&quot;component&quot;:true}</code></li>
<li>在自定义组件中的qml编写组件模板（同index.qml写的相同），qss中加样式。（在组件qss中不应使用id，属性，标签选择器，最好用类选择器）</li>
<li>在自定义组件的 <code>js</code> 文件中，需要使用 <code>Component()</code> 来注册组件，并提供组件的属性定义、内部数据和自定义方法。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  properties: &#123;</span><br><span class="line">    // 这里定义了innerText属性，属性值可以在组件使用时指定</span><br><span class="line">    innerText: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      value: &apos;default value&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    // 这里是一些组件内部数据</span><br><span class="line">    someData: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 这里是一个自定义方法</span><br><span class="line">    customMethod() &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  externalClasses:[&apos;my-class&apos;]//从index页面中传过来的类</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在index.json文件中引用声明。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;usingComponents&quot;: &#123;</span><br><span class="line">    &quot;component-tag-name&quot;: &quot;path/to/the/custom/component&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//路径是相对于index文件夹的</span><br><span class="line">//component-tag-name是在页面中使用的组件名</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>index页面中使用组件。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;!-- 以下是对一个自定义组件的引用 --&gt;</span><br><span class="line">  &lt;component-tag-name inner-text=&quot;Some text&quot; class=&quot;my-class&quot;&gt;&lt;/component-tag-name&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<h6 id="父子组件间传值"><a href="#父子组件间传值" class="headerlink" title="父子组件间传值"></a>父子组件间传值</h6><p>注：设index页面是引用页面，component为组件，便于理解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;component-tag-name prop-a=&quot;&#123;&#123;dataFieldA&#125;&#125;&quot; prop-b=&quot;&#123;&#123;dataFieldB&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;!-- 这部分内容将被放置在组件 &lt;slot&gt; 的位置上 --&gt;</span><br><span class="line">    &lt;view&gt;这里是插入到组件slot中的内容&lt;/view&gt;</span><br><span class="line">  &lt;/component-tag-name&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;!-- 在引用组件中的js文件中定义dataFiledA，并通过属性propA传给组件 --&gt;</span><br><span class="line">&lt;!-- 标签中中划线连接者，在组件中都需要将其转为驼峰式 --&gt;</span><br></pre></td></tr></table></figure>

<p><strong>在组件的js文件中通过properties进行接收</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">	properties:&#123;</span><br><span class="line">		propA:Object //注名类型</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在组件的qml文件中引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;view&gt;这是组件内部的节点&lt;/view&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &#123;&#123;propA.name&#125;&#125;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<h6 id="组件中使用多slot"><a href="#组件中使用多slot" class="headerlink" title="组件中使用多slot"></a>组件中使用多slot</h6><ul>
<li>默认情况下，一个组件只能使用一个slot。需要使用多slot时，可以在组件js中声明启用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">	options:&#123;</span><br><span class="line">		multipleSlots:true</span><br><span class="line">	&#125;,</span><br><span class="line">	properties:&#123;&#125;,</span><br><span class="line">	data:&#123;&#125;,</span><br><span class="line">	methods:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>在组件模板component.qml使用多个slot，以不同name值区分</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;wrapper&quot;&gt;</span><br><span class="line">	&lt;slot name = &quot;before&quot;&gt;&lt;/slot&gt;</span><br><span class="line">	&lt;view&gt;这里是组件的内部细节&lt;/view&gt;</span><br><span class="line">	&lt;slot name=&quot;after&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在index.qml中使用时，用 <code>slot</code> 属性来将节点插入到不同的slot上。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;!-- 这部分内容将被放置在组件 &lt;slot name=&quot;before&quot;&gt; 的位置上 --&gt;</span><br><span class="line">    &lt;view slot=&quot;before&quot;&gt;这里是插入到组件slot name=&quot;before&quot;中的内容&lt;/view&gt;</span><br><span class="line">    &lt;!-- 这部分内容将被放置在组件 &lt;slot name=&quot;after&quot;&gt; 的位置上 --&gt;</span><br><span class="line">    &lt;view slot=&quot;after&quot;&gt;这里是插入到组件slot name=&quot;after&quot;中的内容&lt;/view&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<h6 id="导入模板"><a href="#导入模板" class="headerlink" title="导入模板"></a>导入模板</h6><ul>
<li>定义模板template.qml及其样式文件template.qss</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- template.qml --&gt;</span><br><span class="line">&lt;template name=&quot;navigation&quot;&gt;</span><br><span class="line">    &lt;view class=&quot;navigation_grounp&quot;&gt;</span><br><span class="line">        &lt;view class=&quot;navigation&quot; hover-class=&quot;none&quot; hover-stop-propagation=&quot;false&quot;&gt;</span><br><span class="line">            &lt;block wx:if=&quot;&#123;&#123;true&#125;&#125;&quot;&gt;</span><br><span class="line">                &lt;text class=&quot;nav_search&quot;&gt;返回&lt;/text&gt;</span><br><span class="line">            &lt;/block&gt;</span><br><span class="line">            &lt;text class=&quot;nav_title&quot;&gt;nija&lt;/text&gt;</span><br><span class="line">        &lt;/view&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> /* template.qss */</span><br><span class="line">.navigation_grounp&#123;</span><br><span class="line">     position: flexed;</span><br><span class="line">     top: 0;</span><br><span class="line">     width: 100%;</span><br><span class="line"> &#125;</span><br><span class="line"> .navigation_grounp &gt; .navigation&#123;</span><br><span class="line">     display: flex;</span><br><span class="line">     align-items: center;</span><br><span class="line">     justify-content: center;</span><br><span class="line">     box-sizing: border-box;</span><br><span class="line">     padding: 0 15px;</span><br><span class="line">     background-color: green; </span><br><span class="line">     height: 44px;</span><br><span class="line">     color:red;</span><br><span class="line"> &#125;</span><br><span class="line"> .navigation .nav_search&#123;</span><br><span class="line">     width: 33.3%;</span><br><span class="line">     overflow: hidden;</span><br><span class="line"> &#125;</span><br><span class="line">  .navigation .nav_title&#123;</span><br><span class="line">        width: 33.3%;</span><br><span class="line">        text-align: center;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        text-overflow:ellipsis;</span><br><span class="line">        white-space: nowrap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在index文件中导入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- index.qml --&gt;</span><br><span class="line">&lt;import src=&quot;./../template/template&quot; /&gt;</span><br><span class="line">&lt;template is=&quot;navigation&quot;&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* index.qss，没导入该文件，其样式不会在index中显示 */</span><br><span class="line">@import &apos;./../template/template.qss&apos;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-proto" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/10/27/proto/" class="article-date">
      <time datetime="2019-10-27T05:45:18.000Z" itemprop="datePublished">2019-10-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/27/proto/">proto</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="类的prototype属性和-proto-属性"><a href="#类的prototype属性和-proto-属性" class="headerlink" title="类的prototype属性和__proto__属性"></a>类的prototype属性和<code>__proto__</code>属性</h4><ul>
<li>每个对象都有<code>__proto__</code>属性，指向对应的构造函数的prototype属性。</li>
<li><strong>子类的<code>__proto__</code>属性表示构造函数的继承，总是指向父类。</strong></li>
<li><strong>子类的prototype属性的<code>__proto__</code>属性表示方法的继承，总是指向父类的prototype属性。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">class B extends A&#123;&#125;</span><br><span class="line">B.__proto__ === A  //true</span><br><span class="line">B.prototype.__proto__  === A.prototype  //true</span><br><span class="line"></span><br><span class="line">//B的实例继承A的实例</span><br><span class="line">Object.setPrototypeOf(B.prototype,A.prototype);</span><br><span class="line">//B继承A的静态属性</span><br><span class="line">Object.setPrototypeOf(B,A);</span><br><span class="line"></span><br><span class="line">//Object.setPrototypeOf方法实现</span><br><span class="line">Object.setPrototypeOf = function(obj,proto)&#123;</span><br><span class="line">	obj.__proto__ = proto;</span><br><span class="line">	return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</p>
<p>上面代码的<code>A</code>，只要是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p>
<h6 id="以下两种特殊情况"><a href="#以下两种特殊情况" class="headerlink" title="以下两种特殊情况"></a>以下两种特殊情况</h6><ul>
<li>子类继承Object类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A extends Object&#123;&#125;</span><br><span class="line">A.__proto__ === Object  //true</span><br><span class="line">A.prototype.__proto__ === Object.prototype  //true</span><br><span class="line">//A其实就是构造函数Object的复制，A的实例就是Object的实例</span><br></pre></td></tr></table></figure>

<ul>
<li>不存在任何继承</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">A.__proto__ === Function.prototype   //true</span><br><span class="line">A.prototype.__proto__ === Object.prototype   //true</span><br></pre></td></tr></table></figure>

<p>A作为一个基类，即不存在任何继承，就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象即object实例，所以<code>A.prototype.__proto__</code>指向构造函数Object的prototype属性。</p>
<h6 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的 proto 属性"></a>实例的 <strong>proto</strong> 属性</h6><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123; /* ... */ &#125;</span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    super(x, y); // 调用父类的constructor(x, y)</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p1 = new Point(2, 3);</span><br><span class="line">var p2 = new ColorPoint(2, 3, &apos;red&apos;);</span><br><span class="line"></span><br><span class="line">p2.__proto__ === p1.__proto__ // false</span><br><span class="line">p2.__proto__.__proto__ === p1.__proto__ // true</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型。</p>
<p>因此，通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p2.__proto__.__proto__.printName = function () &#123;</span><br><span class="line">  console.log(&apos;Ha&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() // &quot;Ha&quot;</span><br></pre></td></tr></table></figure>

<h6 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h6><ul>
<li><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。一般不能继承，有以下九种：</p>
<p><code>Boolean(),Number(),String(),Array(),Date(),Function(),RegExp(),Error(),Object()</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function MyArray() &#123;</span><br><span class="line">  Array.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyArray.prototype = Object.create(Array.prototype, &#123;</span><br><span class="line">  constructor: &#123;</span><br><span class="line">    value: MyArray,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    enumerable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">var colors = new MyArray();</span><br><span class="line">colors[0] = &quot;red&quot;;</span><br><span class="line">colors.length  // 0</span><br><span class="line"></span><br><span class="line">colors.length = 0;</span><br><span class="line">colors[0]  // &quot;red&quot;</span><br></pre></td></tr></table></figure>

<p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过<code>Array.apply()</code>或者分配给原型对象都不行。原生构造函数会忽略<code>apply</code>方法传入的<code>this</code>，也就是说，原生构造函数的<code>this</code>无法绑定，导致拿不到内部属性。</p>
<p>ES5 是先新建子类的实例对象<code>this</code>，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，<code>Array</code>构造函数有一个内部属性<code>[[DefineOwnProperty]]</code>，用来定义新属性时，更新<code>length</code>属性，这个内部属性无法在子类获取，导致子类的<code>length</code>属性行为不正常。</p>
<p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。下面是一个继承<code>Array</code>的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyArray extends Array &#123;</span><br><span class="line">  constructor(...args) &#123;</span><br><span class="line">    super(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = new MyArray();</span><br><span class="line">arr[0] = 12;</span><br><span class="line">arr.length // 1</span><br><span class="line"></span><br><span class="line">arr.length = 0;</span><br><span class="line">arr[0] // undefined</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-项目开发流程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/26/项目开发流程/" class="article-date">
      <time datetime="2019-09-25T23:40:32.000Z" itemprop="datePublished">2019-09-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/26/项目开发流程/">项目开发流程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="WEB前端项目开发流程"><a href="#WEB前端项目开发流程" class="headerlink" title="WEB前端项目开发流程"></a>WEB前端项目开发流程</h1><h3 id="项目需求分析"><a href="#项目需求分析" class="headerlink" title="项目需求分析"></a>项目需求分析</h3><p>这个环节是由设计师完成，设计师首先和客户进行交流，了解客户的需求，然后分析项目的可行性，如果项目可以被实现，设计师直接进行设计开发。</p>
<h3 id="页面设计"><a href="#页面设计" class="headerlink" title="页面设计"></a>页面设计</h3><p>这个环节主要是UI设计师参与，UI设计师根据产品需求分析文档，对产品的整体美术风格、交互设计、界面结构、操作流程等做出设计。负责项目中各种交互界面、图标、LOGO、按钮等相关元素的设计与制作。最后设计出一份设计稿并交由程序员进行下一步开发。程序员拿到设计稿交流完需求后公司方需要支付3成定金。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>这个部分由程序员来实现。（程序员分为WEB前端开发工程师和后台开发工程师。前端开发人员主要根据原型图用代码写出我们可以在网页上看的见的页面，途中一些问题也需要同设计师直接交流，后台就做一些我们看不见的管理系统以及功能的实现。）程序员根据UI设计师的设计，用编码来完成整个项目的各个功能。</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>由程序员部署到服务器上。</p>
<h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>程序的维护是整个项目的最后一个阶段，但也是耗时最多，成本最高最高的的一个阶段。程序的维护是由程序员免费维护半年。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-事件机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/25/事件机制/" class="article-date">
      <time datetime="2019-09-25T13:25:10.000Z" itemprop="datePublished">2019-09-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/25/事件机制/">事件机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="事件机制之冒泡、传播、委托"><a href="#事件机制之冒泡、传播、委托" class="headerlink" title="事件机制之冒泡、传播、委托"></a>事件机制之冒泡、传播、委托</h2><p>DOM事件流（event flow）存在三个阶段：<strong>事件捕获阶段，处于目标阶段，事件冒泡阶段</strong>。</p>
<h5 id="事件捕获阶段（event-capuring）"><a href="#事件捕获阶段（event-capuring）" class="headerlink" title="事件捕获阶段（event  capuring）"></a>事件捕获阶段（event  capuring）</h5><p>通俗理解就是，当鼠标点击或触发dom事件时，浏览器会从根节点<strong>由外往内</strong>进行事件传播，即点击了子元素，如果父元素通过事件捕获注册了对应的事件的话，会先触发父元素绑定的的事件。</p>
<h5 id="事件冒泡（dubbed-bubbling）"><a href="#事件冒泡（dubbed-bubbling）" class="headerlink" title="事件冒泡（dubbed bubbling）"></a>事件冒泡（dubbed bubbling）</h5><p>与事件捕获相反，事件冒泡是从目标元素<strong>由内往外</strong>进行事件传播，直到根节点。</p>
<p>无论是事件冒泡还是事件捕获，都有一个共同点就是事件传播，她就像一根引线，只有通过引线才能将绑在引线上的鞭炮（事件监听器）引爆，试想一下，如果引线不导火了，那鞭炮就只有一响了！</p>
<p>dom事件标准事件流的触发先后顺序是：<strong>先捕获后冒泡</strong>，即当触发dom事件时，会进行事件捕获，捕获到事件源后通过事件传播进行事件冒泡。不同浏览器对此有不同的实现，IE10及以下不支持捕获型事件，所以就少了一个时间捕获阶段，IE11,Chrome，Firefox，Safari等浏览器则同时存在。</p>
<h5 id="事件绑定的方法"><a href="#事件绑定的方法" class="headerlink" title="事件绑定的方法"></a>事件绑定的方法</h5><h6 id="addEventlistener-event-listener-useCapture"><a href="#addEventlistener-event-listener-useCapture" class="headerlink" title="addEventlistener(event,listener,useCapture)"></a>addEventlistener(event,listener,useCapture)</h6><p>参数定义：event——（事件名称：如click，不带on）</p>
<p>listener——事件监听函数，</p>
<p>useCapture——是否采用事件捕获进行事件捕获，默认为false，即采用事件冒泡方式。</p>
<p>addEventListener在IE11，Chrome，Firefox，Safari等浏览器都得到支持。</p>
<h6 id="attachEvent（event，listener）"><a href="#attachEvent（event，listener）" class="headerlink" title="attachEvent（event，listener）"></a>attachEvent（event，listener）</h6><p>参数定义：event—（事件名称，如onclick，带on），</p>
<p>listener—事件监听函数。</p>
<p>attachEvent主要用于IE浏览器，并且仅在IE10及以下才支持，IE11已经废了这个方法了</p>
<h6 id="事件冒泡例子"><a href="#事件冒泡例子" class="headerlink" title="事件冒泡例子"></a>事件冒泡例子</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">    #parent&#123;width:200px;height:200px;background:yellow;margin:10px auto;border:1px solid black;&#125;</span><br><span class="line">    #children&#123;width:50px;height:50px;background:pink;margin:80px auto;&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;children&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var children = document.getElementById(&apos;children&apos;);</span><br><span class="line">    var parent = document.getElementById(&apos;parent&apos;);</span><br><span class="line">    document.body.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;body&apos;)&#125;,false);</span><br><span class="line">    parent.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;parent&apos;)&#125;,false);</span><br><span class="line">    children.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;children&apos;);</span><br><span class="line">    //event.stopProparation;</span><br><span class="line">    //可停止事件传播&#125;,false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当点击子盒子时，打印结果依次为children——parent——body</p>
<p>事件触发的顺序是由内到外的，这就是事件冒泡，虽然只点击了子元素，但是他的父元素也会触发相应的事件，其实这也是合理的，因为父元素里面，点击了子元素不就相当于变相的点击了父元素。</p>
<p>若不想触发父元素可停止事件传播只需在子元素中添加<strong>event.stopProparation;</strong>即可。</p>
<h6 id="事件捕获例子"><a href="#事件捕获例子" class="headerlink" title="事件捕获例子"></a>事件捕获例子</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">    body&#123;background: green;&#125;</span><br><span class="line">    #parent&#123;width:200px;height:200px;background:yellow;margin:10px auto;border:1px solid black;&#125;</span><br><span class="line">    #children&#123;width:50px;height:50px;background:pink;margin:80px auto;&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;children&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var children = document.getElementById(&apos;children&apos;);</span><br><span class="line">    var parent = document.getElementById(&apos;parent&apos;);</span><br><span class="line">    document.body.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;body&apos;)&#125;,true);</span><br><span class="line">    parent.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;parent&apos;)&#125;,true);</span><br><span class="line">    children.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;children&apos;)&#125;,true);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>点击children方块，打印body——parent——childre</p>
<p>点击parent方块，打印body——parent</p>
<p>点击body区域，打印body</p>
<p>事件通过事件捕获的方式注册了click事件，所以在事件捕获阶段就会触发，先是触发最外围注册了事件捕获的body，而后触发事件捕获的parent，最后触发事件源。这就是事件的时间流程。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 陈楚吟
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="陈楚吟">


    
    


<meta name="description" content="将学习技术点汇总">
<meta name="keywords" content="write myBlog">
<meta property="og:type" content="website">
<meta property="og:title" content="Nikita">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Nikita">
<meta property="og:description" content="将学习技术点汇总">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nikita">
<meta name="twitter:description" content="将学习技术点汇总">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Nikita" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Nikita</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">陈楚吟</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不负韶华</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">陈楚吟</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">陈楚吟</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不负韶华</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-node进阶" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/30/node进阶/" class="article-date">
      <time datetime="2020-04-30T02:30:22.000Z" itemprop="datePublished">2020-04-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/30/node进阶/">node进阶</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="单线程的弱点"><a href="#单线程的弱点" class="headerlink" title="单线程的弱点"></a>单线程的弱点</h4><ol>
<li>无法利用多核CPU。</li>
<li>错误会引起整个应用退出，应用的健壮性值得考虑。</li>
<li>大量计算占用CPU导致无法继续调用异步I/O。</li>
</ol>
<p>像浏览器中JavaScript与UI共用一个线程一样，JavaScript长时间执行会导致UI渲染和响应被中断。在Node中，长时间的CPU占用也会导致后续异步I/O发不出调用，已完成的异步I/O的回调函数也会得不到及时执行。</p>
<p>Node采用了与Web Workers相同的思路来解决单线程中大计算量的问题：child_process。</p>
<p>子进程的出现，意味着Node可以从容地应对单线程在健壮性和无法利用多核CPU方面的问题。通过计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好的保持应用模型的简单和地低依赖。通过Master-Worker的管理方式，也可以很好地管理各个工作进程，以达到更高的的健壮性。</p>
<h4 id="node简介"><a href="#node简介" class="headerlink" title="node简介"></a>node简介</h4><ul>
<li>Node.js是一个js运行环境，实际上它是对Google v8引擎的封装。V8引擎执行js的速度快，性能好。node.js对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境上运行的更好。</li>
<li>node.js是一个基于chrome javascript运行建立的平台，用于方便的搭建响应速度快，易于拓展的网络应用。node.js使用事件驱动，非阻塞I/O模型得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。</li>
<li>node采用一系列“非阻塞”库来支持事件循环的方式。本质上就是为文件系统，数据库之类的资源提供接口。向文件系统发送一个请求时，无需等待硬盘（寻址并检索文件），硬盘准备好的时候非阻塞接口会通知node。该模型以可拓展的方式简化了对慢资源的访问，直观易懂。</li>
<li>node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理——node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，因此，我们应该要充分的利用这一点——尽可能地避免阻塞操作</li>
</ul>
<h4 id="node-js组成部分"><a href="#node-js组成部分" class="headerlink" title="node.js组成部分"></a>node.js组成部分</h4><ul>
<li>引入required模块：我们可使用required指令载入node.js模块   var http = require(“http”);</li>
<li>创建服务器：服务器可监听客户端请求，类似于Apache，Nginx等http服务器 。使用http.createServer()方法创建服务器，并使用listen方法绑定端口。</li>
<li>接收请求和响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送http请求，服务器接收请求并返回响应数据。使用request和response参数来接收和响应数据。</li>
</ul>
<h4 id="npm包管理器"><a href="#npm包管理器" class="headerlink" title="npm包管理器"></a>npm包管理器</h4><ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用</li>
</ul>
<h4 id="NPM常用命令"><a href="#NPM常用命令" class="headerlink" title="NPM常用命令"></a>NPM常用命令</h4><p>NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。</p>
<ul>
<li><p>NPM提供了很多命令，例如<code>install</code>和<code>publish</code>，使用<code>npm help</code>可查看所有命令。</p>
</li>
<li><p>使用<code>npm help &lt;command&gt;</code>可查看某条命令的详细帮助，例如<code>npm help install</code>。</p>
</li>
<li><p>在<code>package.json</code>所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</p>
</li>
<li><p>使用<code>npm update &lt;package&gt;</code>可以把当前目录下<code>node_modules</code>子目录里边的对应模块更新至最新版本。</p>
</li>
<li><p>使用<code>npm update &lt;package&gt; -g</code>可以把全局安装的对应命令行程序更新至最新版。</p>
</li>
<li><p>使用<code>npm cache clear</code>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</p>
</li>
<li><p>使用<code>npm unpublish &lt;package&gt;@&lt;version&gt;</code>可以撤销发布自己发布过的某个版本代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm -v  						查看版本</span><br><span class="line">npm version  					查看所有模块的版本</span><br><span class="line">npm search 包名/部分包名			 搜索包</span><br><span class="line">npm init   						初始化package.json文件</span><br><span class="line">npm install/i 安装包     </span><br><span class="line">npm remove/r包名					删除包</span><br><span class="line">npm install/i 包名 --save 		安装包并添加到依赖中</span><br><span class="line">npm install 					根据package.json下载当前项目所依赖的包</span><br><span class="line">npm install 包名 -g				全局安装包，用于一些编译根据，比如：gulp，webpack</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>注意：如果想在页面中引入node_module中某个模块，优先从当前目录引入，如果没有，则从上一级目录中找，直到根目录。</li>
</ul>
<h4 id="REPL交互式解释器"><a href="#REPL交互式解释器" class="headerlink" title="REPL交互式解释器"></a>REPL交互式解释器</h4><ul>
<li>REPL(Read Eval Print Loop:交互式解释器)表示一个电脑的环境，类似于终端，可接受系统的响应。node自带了交互式解释器，可执行以下任务<ul>
<li>读取，读取用户输入，解析输入js数据结构并存储于内存中。</li>
<li>执行，执行输入的数据结构。</li>
<li>打印，输出结果。</li>
<li>循环，循环操作以上步骤直到用户两次按下ctrl+c按钮退出。</li>
</ul>
</li>
</ul>
<h4 id="node知识"><a href="#node知识" class="headerlink" title="node知识"></a>node知识</h4><h6 id="node-js与其它语言的区别"><a href="#node-js与其它语言的区别" class="headerlink" title="node.js与其它语言的区别"></a>node.js与其它语言的区别</h6><ul>
<li><p>node.js不是一门独立的语言。php，jsp即使语言，又是平台。node.js用js进行编程，运行平台是封装后的js引擎V8</p>
</li>
<li><p>轻量级架构</p>
<ul>
<li>java，php，net，需要运行在服务器上，apache，tomcat</li>
<li>node.js不用架设在任何服务器软件之上。</li>
<li>用最低的硬件成本，达到更高的开发，更优的处理函数。</li>
</ul>
</li>
<li><p>node.js没有web容器，就是安装配置完成之后，没有根目录（php的根目录是www）</p>
</li>
</ul>
<h6 id="node-js的特点（追求极致性能）"><a href="#node-js的特点（追求极致性能）" class="headerlink" title="node.js的特点（追求极致性能）"></a>node.js的特点（追求极致性能）</h6><ul>
<li>单线程<ul>
<li>优势：减少内存消耗（操作系统不再有创建线程，销毁线程的开销。<ul>
<li>在php，jsp等服务器语言中，会为每个用户创建一个线程，而每个线程大约需要2M内存，每创建一个线程就要占用内存空间。</li>
<li>当有客户链接时，就会触发一个内部事件，通过非阻塞I/O，事件驱动机制，让node.js宏观上是并发的。可同时处理4万用户的请求。即当张三连接着时，李四请求连接，引擎就会停止张三语法的执行，转而将李四加入到时间栈中。</li>
<li>node.js不为每个用户创建一个线程，仅仅使用同一个线程。</li>
</ul>
</li>
<li>劣势：<ul>
<li>如果线程遭遇I/O阻塞，整个线程便阻塞了。</li>
<li>如果有人将node.js搞崩溃了，则会全部奔溃。</li>
</ul>
</li>
</ul>
</li>
<li>非阻塞<ul>
<li>node.js采用非阻塞I/O机制，因此在执行完访问数据库操作后，会立即执行后面的代码（其他非阻塞事件不会，他们会等数据库操作完毕并返回结果才执行后面的代码），把数据库的处理代码放入回调函数中，从而提高效率。</li>
<li>当某个I/O执行完毕后，将以事件的形式通过执行I/O操作的线程，线程执行完这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断检查有没有未处理的事件，并依次予以处理。</li>
<li>阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远执行计算操作，这个线程的CPU核心利用率永远是100%；</li>
</ul>
</li>
<li>事件驱动<ul>
<li>不管用户的请求，还是老用户的I/O完成，都将以事件的形式加入事件环，等待调度。</li>
</ul>
</li>
<li>node.js的iI/O都是异步的，都是回调函数调回调函数</li>
</ul>
<h6 id="node事件触发"><a href="#node事件触发" class="headerlink" title="node事件触发"></a>node事件触发</h6><ul>
<li>继承EventEmitter，大多数情况下不会直接使用EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</li>
<li>原因：<ul>
<li>具有某个实体功能的对象实现时间符合语义，事件的监听和发射应该是一个对象的方法。</li>
<li>js对象是基于原型的，支持多重继承，继承EventEmitter不会打乱对象原有的继承关系。</li>
</ul>
</li>
</ul>
<h6 id="node-js应用方向"><a href="#node-js应用方向" class="headerlink" title="node.js应用方向"></a>node.js应用方向</h6><ol>
<li>特点<ul>
<li>善于I/O，不善于计算。<ul>
<li>因为node.js最擅长任务的调度，如果你的任务有很多CPU计算，实际上相当于这个计算阻塞了这个单线程，就不适合node开发。</li>
<li>当应用程序需要处理大量并发的I/O，而在向客户端发出响应后，应用程序内部并不需要进行复杂的处理时，node也非常适合与websocket配合，开发长连接的实时交互应用程序。</li>
</ul>
</li>
<li>天生异步<ul>
<li>callback，trunk（参数的求值策略），promise，generator（es6的生成器，用于计算），asynac函数</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="node模块化"><a href="#node模块化" class="headerlink" title="node模块化"></a>node模块化</h4><ul>
<li>CommonJS规范为JS能够在任何地方执行，这是一个愿景。</li>
<li>从文件角度看，每个JS文件就是一个个模块，从结构上看，多个JS文件之间可以相互require共同实现一个功能，这整体功能就是一个模块。</li>
<li>在node.js中，一个模块定义的变量只能在该文件中使用，当需要另一文件中的变量时，需使用exports进行暴漏，然后使用require引入。</li>
<li>引入模块时，如果是非核心模块，且在同级目录时，require需要加上<code>./</code>，核心模块则不需要，直接写名字即可</li>
</ul>
<h6 id="node核心模块"><a href="#node核心模块" class="headerlink" title="node核心模块"></a>node核心模块</h6><ul>
<li><p>全局变量是global。</p>
</li>
<li><p>每个node都在外面给我们套了一个函数。</p>
<p><code>function(exports,require,module,_filename,_dirname){//里面是你写的内容}</code></p>
<ul>
<li>exports：该对象用来将函数内部的局部函数暴漏到外部函数中。</li>
<li>require：用来引入外部模块。</li>
<li>module：代表当前模块本身，exports就是module的属性。我们可以使用exports或modile.exports导出。</li>
<li>_filename:当前模块的完整路径</li>
<li>_dirname:当前模块所在的文件的完整路径。</li>
</ul>
</li>
<li><p>exports与module.exports的区别</p>
</li>
<li><p>json文件不能加注释。</p>
</li>
</ul>
<h4 id="Buffer缓存区"><a href="#Buffer缓存区" class="headerlink" title="Buffer缓存区"></a>Buffer缓存区</h4><ul>
<li>可以理解为是一个存放二进制的容器，专门用于数据的存放。</li>
<li>node自带的，不需要引入就可使用。一个字节占8bit</li>
<li>8bit = 1B       1024B  = 1KB      1024KB = 1MKB      1GB=1024KB     1TB=1024GB</li>
<li>Buffer.from(str,编码格式);</li>
<li>Buffer.alloc(size[,fill[,encoding]])<ul>
<li>size:新建的Buffer期望的长度，不能动态改变，溢出的数据不做处理。int值</li>
<li>fill：用来预填充新建的Buffer的值，默认为0.     String   Buffer    int</li>
<li>encoding:如果fill为字符串，则该值就是它的字符编码，默认为“utf-8”</li>
</ul>
</li>
</ul>
<h4 id="fs文件处理"><a href="#fs文件处理" class="headerlink" title="fs文件处理"></a>fs文件处理</h4><ul>
<li><p>fs.open(path,flag[,mode],callback)打开文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//1.引入模块</span><br><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">//2.创建写入流，相当于在it666.txt与服务器之间建立一个通道，使数据可以源源不断从it666.txt中上传至服务器中</span><br><span class="line">let ws = fs.createWriteStream(&quot;it666.txt&quot;);</span><br><span class="line">//3.打开通道，监听打开事件，有on，once等方法，因只需监听一次，故用once</span><br><span class="line">stream.once(&apos;open&apos;,() =&gt; &#123;</span><br><span class="line">    console.log(&apos;通道已经打开&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">stream.once(&apos;close&apos;, ()=&gt; &#123;</span><br><span class="line">    console.log(&apos;通道已经关闭&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">//写入东西</span><br><span class="line">stream.write(&apos;dfsadc&apos;);</span><br><span class="line">stream.write(&apos;dfsadc&apos;);</span><br><span class="line">//关闭通道，当发现还有东西未写入时，不会关闭</span><br><span class="line">stream.end()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">let ws = fs.createWriteStream(&quot;it666.txt&quot;);</span><br><span class="line">let rs = fs.createReadStream(&quot;sp.mp4&quot;);</span><br><span class="line">//创建管道，该语句就会自动将数据存入sp.mp4中，同时监听打开关闭等事件</span><br><span class="line">rs.pipe(ws);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul>
<li>数据库就是按照一定的数据结构来组织，存储和管理数据的仓库。</li>
<li>我们写的程序都是在计算机上运行的，一旦计算机断电或程序运行完毕，程序数据就会全部丢失，所以我们需要将一些程序运行的数据持久性保存到硬盘中，以确保数据的安全性。</li>
<li>选择数据库的原因：<ul>
<li>数据库是有结构的，数据与数据之间可以建立各种关系，类似于网状拓扑图。</li>
<li>数据库提供各种接口，让各种操作（增删改查）变得快捷简单。</li>
<li>给个种语言（php，jsp，java）提供了完善的接口。</li>
</ul>
</li>
<li>数据库分类<ul>
<li>RDBMS(关系型数据库)：MySQL，SQL Server，ORACLE,DB2….</li>
<li>NoSQL（非关系型数据库 Not only SQL）:MongoDB,CouchDB,HBase,Redis…<ul>
<li>没有行列的概念，用JSON来存储数据，集合就相当于“表”，文档就相当于“行”。</li>
<li>非关系型数据库为非标准化的数据库。</li>
<li>特征：键值存储数据库，列存储数据库，文档存储数据库，图形数据库。</li>
</ul>
</li>
<li>两者区别：关系型数据库比较结构化，操作不是很灵活；非关系型数据库操作灵活，但不适合大型数据存储，比较适合微架构….两者相辅相成。</li>
</ul>
</li>
</ul>
<h6 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h6><ul>
<li>MongoDB是为快速开发互联网Web应用而设计的数据库系统。他的数据类型是面向文档的，类似于JSON的结构。</li>
<li>基本组成<ul>
<li>数据库（database）：数据库是一个仓库，在仓库中可以存放集合。</li>
<li>集合（collection）：集合类似于数组，在集合中可以存放文档。</li>
<li>文档（document）：文档数据库中的最小单位，我们存储和操作的内容都是文档。</li>
</ul>
</li>
<li>mongoDB的基本指令:<ul>
<li>show dbs    ：显示当前所有的数据库</li>
<li>use 数据库名        ：进入到指定的数据库中</li>
<li>db     ：显示当前数据库</li>
<li>show  collections        ：显示数据库中的所有集合</li>
</ul>
</li>
<li>命令进行CRUD<ul>
<li>插入：db.<collection>.insert(doc);      如：db.student.insert({id:001,name:’nikita’});</collection></li>
<li>查询：db.<collection>.find();</collection></li>
</ul>
</li>
</ul>
<h4 id="同步与异步，阻塞与非阻塞"><a href="#同步与异步，阻塞与非阻塞" class="headerlink" title="同步与异步，阻塞与非阻塞"></a>同步与异步，阻塞与非阻塞</h4><ul>
<li><p>同步，当发起一个调用时，在没有获取结果前，调用不会返回，直到获取结果。事一件一件做，做完一件在做一件。</p>
</li>
<li><p>异步：当发起一个调用时，在没有获取结果之前，调用就返回了，调用者并不会立即得到结果，而是被调用者通知调用调用者，通过回调函数处理结果。</p>
</li>
<li><p>阻塞，在等待结果时，不能干其他事，线程被挂起，直到结果返回。</p>
</li>
<li><p>非阻塞：在等待结果中，还能干其他事，线程不会被阻塞。</p>
</li>
</ul>
<h4 id="url相关操作"><a href="#url相关操作" class="headerlink" title="url相关操作"></a>url相关操作</h4><ul>
<li>将url解析为一个url对象：url.parse(urlString[,parseQueryString[,slashDenotHost]])</li>
<li>将一个url对象反解析为一个url地址：url.format(urlObject)</li>
<li>将部分url拼接为一个完整url地址url.resolve(from,to)</li>
<li>response对象有一个方法：write可以用来给客户端发送响应数据。write可以使用多次，但最后需要用end来结束响应，否则客户端会一直等待</li>
<li>req.url是地址栏中localhost后面的所有内容，除了hash的内容。</li>
<li>querystring.parse将字符串转为一个对象。</li>
</ul>
<h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><h6 id="使用第三方插件"><a href="#使用第三方插件" class="headerlink" title="使用第三方插件"></a>使用第三方插件</h6><p>需要先安装formidable包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let http = require(&apos;http&apos;);</span><br><span class="line">let url = require(&apos;url&apos;);</span><br><span class="line">let formidable = require(&apos;formidable&apos;);</span><br><span class="line">let util = require(&apos;util&apos;);//用于将object转为字符串</span><br><span class="line"> http.createServer((req,res) =&gt; &#123;</span><br><span class="line"> 	if(req.url === &apos;/postmsg&apos; &amp;&amp; req.methods.tolowerCase() === &quot;post&quot;)&#123;</span><br><span class="line"> 		//实例化对象</span><br><span class="line"> 		let form = new formidable.IncomingForm();</span><br><span class="line"> 		//设置上传文件路径</span><br><span class="line"> 		form.uploadDir = &apos;./uploads&apos;;</span><br><span class="line"> 		//获取表单内容</span><br><span class="line"> 		form.parse(req,(err,fileds,files) =&gt; &#123;</span><br><span class="line"> 			res.writeHead(200,&#123;&quot;content-Type&quot;:&quot;text/plain;charset=UTF-8&quot;&#125;);</span><br><span class="line"> 			res.end(util.inspect(&#123;fields:fields,files:files&#125;));</span><br><span class="line"> 		&#125;)</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;).listen(80,&apos;127.0.0.1&apos;);</span><br></pre></td></tr></table></figure>

<h4 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h4><p>在Node中，每个文件模块都是一个对象，它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Module(id, parent)&#123;</span><br><span class="line">	this.id = id;</span><br><span class="line">	this.exports = &#123;&#125;;</span><br><span class="line">	this.parent = parent;</span><br><span class="line">	if(parent &amp;&amp; parent.children)&#123;</span><br><span class="line">		parent.children.push(this);</span><br><span class="line">	&#125;</span><br><span class="line">	this.filename = null;</span><br><span class="line">	this.loaded = false;</span><br><span class="line">	this.children = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译和执行是引入文件模块的最后一个阶段。定位到具体文件后，Node会新建一个模块对象，然后通过路径载入并编译。对于不同的文件扩展名，其载入的方式也有所不同，具体如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.js文件。通过fs模块同步读取文件后编译执行。</span><br><span class="line"></span><br><span class="line">.node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后的编译生成的文件。</span><br><span class="line"></span><br><span class="line">.json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。</span><br><span class="line"></span><br><span class="line">其余扩展名文件。它们都被当作.js文件解析。(因为node只能解析js文件，其他文件最后都会被转化成js文件，故当其余扩展名文件出现时，node无法识别，故将其认为是默认扩展名进行解析，即.js)</span><br></pre></td></tr></table></figure>

<p>每一个编译成功的模块都会将文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。</p>
<p>根据不同文件扩展名，node会调用不同的读取方式，如：.json文件调用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Module._extensions[&apos;.json&apos;] = function(module,filename)&#123;</span><br><span class="line">	var content = NativeModule.require(&apos;fs&apos;).readFileSync(filename,&apos;utf8&apos;);</span><br><span class="line">	try&#123;</span><br><span class="line">		module.exports = JSON.parse(strinpBOM(cntent));</span><br><span class="line">	&#125;catch(err)&#123;</span><br><span class="line">		err.message = filename + &apos;:&apos; + err.message;</span><br><span class="line">		throw err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，Module._extensions会被赋值给 require() 的extensions属性，所以通过在代码中访问require.extensions可知道系统中已有的加载方式。编写代码测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//新建index.js文件</span><br><span class="line">console.log(require.extensions);</span><br><span class="line">//运行node index.js,输出</span><br><span class="line">//[Object: null prototype] &#123; &apos;.js&apos;: [Function], &apos;.json&apos;: [Function], &apos;.node&apos;: [Function] &#125;</span><br></pre></td></tr></table></figure>

<p>如果想对自定义的扩展名进行特殊的加载，可以通过类似require.extensions[‘.ext’]的方式实现。早期的CoffeeScript文件就是通过添加require.extensions[‘.coffee’]扩展方式来加载的。但是从v0.10.6版本开始，官方不鼓励通过这种方式进行自定义扩展名的加载，而是期望先将其它语言或文件先编译成js文件后再进行加载，这样做的好处是不将繁琐的编译加载等过程引入node的执行过程。</p>
<p>在确定文件的扩展名后，node将调用具体的编译方式来将文件执行后返回给调用者。</p>
<p>注：我们都知道CommonJS模块规范中，每个模块文件都存在<code>require、exports、module、_filename、_dirname</code>这5个变量却不知其从何而来。若是把直接定义模块的过程放在浏览器端，势必会存在污染全局变量的情况，故其不可能。</p>
<p>事实上，在编译过程中，node会对获取的js文件内容进行包装，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function(require、exports、module、_filename、_dirname)&#123;</span><br><span class="line">	var math = require(&apos;math&apos;);</span><br><span class="line">	exports.area = function(radius)&#123;</span><br><span class="line">		return Math.PI * radius * radius;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样每个模块文件之间都进行了作用于隔离。包装之后的代码会通过vm原生模块的runInThisContext() 方法执行，类似于eval，只是具有明确上下文，不污染全局，返回一个体的function对象。最后，将当前模块对象的exports属性，require()方法，module(模块对象本身)，以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。</p>
<p>这就是为什么这些变量并没有在每个模块声明却可以使用的原因。在执行后，模块的exports属性被返回给了调用方。exports属性上的任何方法都可以被外部调用到，但是模块中的其余变量和属性则不可直接被调用。</p>
<p>至此，require、exports、module的流程已经完整，这就是Node对CommonJS模块规范的实现。</p>
<p><strong>JSON文件的编译</strong></p>
<p>json文件的编译是三种编译方式中最简单的。Node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse（）方法得到对象，然后将它赋给模块对象的exports，以供外部调用。</p>
<p>JSON文件在用作项目的配置文件时比较有用。如果你定义了JSON文件作为配置，那就不用调用fs模块去异步读取和解析，直接调用require（）引入即可。此外，你还可以享受到模块缓存的便利，并且二次引入时也没有性能影响。</p>
<p>这里我们提到的模块编译都是指文件编译，即用户自己编写的模块。</p>
<h6 id="内建模块"><a href="#内建模块" class="headerlink" title="内建模块"></a>内建模块</h6><p>内建模块的优势在于：首先，他们本身由C/C++编写，性能上优于脚本语言；其次，其次，在进行文件编译时，他们会被编译进二进制文件。一旦node开始执行，他们会被直接加载进内存中，无需再次坐标识符定位、文件定位、编译等过程，直接就可执行。</p>
<p>Node在启动时，会生成一个全局变量process，并提供Binding()方法来协助加载内建模块。</p>
<p>在加载内建模块时，我们会先创建一个exports空对象，然后调用get_builtin_module（）方法取出内建模块对象，通过执行register_func()填充exports对象，最后将exports对象按模块名缓存，并返回给调用方完成导出。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-http进阶" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/30/http进阶/" class="article-date">
      <time datetime="2020-04-29T23:40:38.000Z" itemprop="datePublished">2020-04-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/30/http进阶/">http进阶</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h6 id="Telnet实例"><a href="#Telnet实例" class="headerlink" title="Telnet实例"></a>Telnet实例</h6><p>由于Http使用的是TCP/IP传输协议，而且它是基于文本的，没有使用哪些难以理解的二进制格式，因此很容易直接1与Web服务器进行对话。</p>
<p>Telnet程序可以将键盘连接到某个目标TCP端口，并将此TCP端口的输出回送到显示屏上。Telnet常用于远程终端会话，但它几乎可以连接所有的TCP服务器，包括HTTP服务器。</p>
<h4 id="Web结构组件"><a href="#Web结构组件" class="headerlink" title="Web结构组件"></a>Web结构组件</h4><ol>
<li>代理：位于客户端和服务器之间的HTTP中间实体。</li>
<li>缓存：HTTP的仓库，是常用页面的副本可以存在离客户端更近的地方。</li>
<li>网关：连接应用程序的特殊Web服务器。</li>
<li>隧道：对HTTP通信报文进行盲转发的特殊代理。</li>
<li>Agent代理：发起自动HTTP请求的半智能Web客户端。</li>
</ol>
<h6 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h6><p>HTTP代理服务器是Web安全，应用集成以及性能优化的重要组成模块。</p>
<p>代理位于客户端与服务器之间，接收所有客户端的HTTP请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。</p>
<p>出于安全考虑，通常会将代理作为转发所有Web流量的可信任中间节点使用。代理还可以对请求和响应进行过滤。比如，在企业中对下载的应用程序进行病毒检测，或者对小学生屏蔽一些成人才能看的内容。</p>
<h6 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h6><p>WEb缓存（Web cache）或代理缓存（proxy cache）是一种特殊的HTTP代理服务器，可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了。</p>
<h6 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h6><p>网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用，通常用于将HTTP流量转换成其他的协议。网关接受时就好像自己是咨议员的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。</p>
<p>如：一个HTTP/FTP网关会通过HTTP请求接受对FTP URI的请求，但通过FTP协议来获取文档。得到的文档会被封装成一条HTTP报文发给客户端。</p>
<h6 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h6><p>隧道（tunnel）是建立起来之后就会在两条连接之间对原始数据进行盲转发的HTTP应用程序。HTTP隧道通常用来在一条或多条HTTP连接上进行转发非HTTP数据，转发时不会窥探数据。</p>
<p>HTTP隧道的一种常见用途是通过HTTP连接承载加密的安全套接字层（SSL,Secure Socket Layout)流量，这样ssl流量就可以穿过只允许Web流量通过的防火墙了。</p>
<p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E9%9A%A7%E9%81%93.png" alt="隧道"></p>
<p>如：HTTP/SSL隧道收到一条HTTP请求，要求建立一条到目的的地址和端口的输出连接，然后在HTTP信道上通过隧道传输加密的SSL流量，这样就可以将其转发到目的服务器上。</p>
<h6 id="Agent代理"><a href="#Agent代理" class="headerlink" title="Agent代理"></a>Agent代理</h6><p>用户代理是代表用户发起HTTP请求的客户端程序。所有发布Web请求的应用程序都是HTTP Agent代理。到目前为止，我们只提过一种HTTP Agent代理：WEb浏览器，但用户Agent代理还有很多类型。</p>
<p>如：有些自己会在Web上闲逛的自动用户Agent代理，可以在无人监视的情况下发布HTTP事务并获取内容。这些自动代理的名字很生动，比如“网络蜘蛛”或“web机器人”。网络蜘蛛会在WEb上闲逛，搜集信息以构建有效的Web内容档案，比如一个搜索引擎的数据库或者为比较购物机器人生成的产品目录。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200430094207000.png" alt="image-20200430094207000"></p>
<h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><p>请求报文格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;method&gt;     &lt;request-URL&gt;  &lt;version&gt;</span><br><span class="line">&lt;headers&gt; </span><br><span class="line">&lt;entrity-body&gt;</span><br></pre></td></tr></table></figure>

<p>响应报文</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;version&gt;   &lt;status&gt;   &lt;response-phrase&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line">&lt;entrity-body&gt;</span><br></pre></td></tr></table></figure>

<h6 id="方法（method）"><a href="#方法（method）" class="headerlink" title="方法（method）"></a>方法（method）</h6><p>客户端希望服务器对资源执行的动作，是一个单独的词，比如GET,HEAD或POST.</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>是否包含主体</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>从服务器获取一份文档</td>
<td>否</td>
</tr>
<tr>
<td>HEAD</td>
<td>只从服务器获取文档的首部</td>
<td>否</td>
</tr>
<tr>
<td>POST</td>
<td>向服务器发送需要处理的数据</td>
<td>是</td>
</tr>
<tr>
<td>PUT</td>
<td>将请求的主体部分存储在服务器上</td>
<td>是</td>
</tr>
<tr>
<td>TRACE</td>
<td>对可能经过代理服务器传送到服务器上去的报文进行追踪</td>
<td>否</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>决定可以在服务器上执行哪些方法</td>
<td>否</td>
</tr>
<tr>
<td>DELETE</td>
<td>从服务器上删除一份文档</td>
<td>否</td>
</tr>
</tbody></table>
<p><strong>扩展方法</strong>：指的是没有在HTTP/1.1规范中定义的方法，服务器会为它所管理的资源实现一些二HTTP服务，这些方法为开发者提供了一种扩展这些HTTP服务能力的手段。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LOCK</td>
<td>允许用户“锁定”资源——比如，可以在编辑某个资源的时候将其锁定，以防别人对其进行修改。</td>
</tr>
<tr>
<td>MKCOL</td>
<td>允许用户创建资源</td>
</tr>
<tr>
<td>COPY</td>
<td>便于在服务器上复制资源</td>
</tr>
<tr>
<td>MOVE</td>
<td>在服务器上移动资源</td>
</tr>
</tbody></table>
<p>惯例：对所发送的内容要求严一点，对接收的内容宽容一些处理扩展方法。</p>
<ol start="2">
<li><p>请求URL(request-URL)</p>
<p>命名了所有请求资源，或者URL路径组件的完整URL。如果直接与服务器进行对话，只要URL的路径组件是资源的绝对路径，通常就不会有什么问题——服务器可以假定自己是URL的主机/端口。</p>
</li>
<li><p>版本（version）</p>
</li>
<li><p>状态码（status-code）</p>
<p>这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般类型（“成功”、“出错”）。</p>
<p><strong>状态码分类</strong></p>
<table>
<thead>
<tr>
<th>整体范围</th>
<th>已定义范围</th>
<th>分类</th>
</tr>
</thead>
<tbody><tr>
<td>100-199</td>
<td>100-101</td>
<td>信息提示</td>
</tr>
<tr>
<td>200-299</td>
<td>200-206</td>
<td>成功</td>
</tr>
<tr>
<td>300-399</td>
<td>300-305</td>
<td>重定向</td>
</tr>
<tr>
<td>400-499</td>
<td>400-415</td>
<td>客户端错误</td>
</tr>
<tr>
<td>500-599</td>
<td>500-505</td>
<td>服务器错误</td>
</tr>
</tbody></table>
<p><strong>常见状态码</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>成功。请求的所有数据都在响应主体中。</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized（未授权）</td>
<td>需要输入用户名和密码</td>
</tr>
<tr>
<td>404</td>
<td>Not Found（未找到）</td>
<td>服务器无法找到所请求URL对应的资源</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented（无法实现）</td>
<td></td>
</tr>
</tbody></table>
<p><strong>信息性状态码</strong>‘</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue</td>
<td>说明受到了请求的初始部分，请客户端继续，发送了这个状态码后，服务器在收到请求后必须进行响应。</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td>说明服务器正在根据客户端的指定，将协议切换成Update’首部所列的协议。</td>
</tr>
</tbody></table>
<p>100 Continue是一种优化，客户端应用程序只有在避免向服务器发送一个服务器无法处理或使用的大实体时才会使用100 Continue。当服务端超时一定时间后，客户端直接将实体发出去。</p>
<p><strong>成功状态码</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>请求没问题，实体的主体部分包含了所请求的资源</td>
<td>OK</td>
</tr>
<tr>
<td>201</td>
<td>用于创建对象的请求（PUT)。响应的主体部分包含各种已创建资源的URL，location首部包含则是最具体的引用。</td>
<td>Created</td>
</tr>
<tr>
<td>202</td>
<td>请求已被接受，但服务器还未对其执行任何动作，不能保证服务器会完成这个请求。</td>
<td>Accepted</td>
</tr>
<tr>
<td>203</td>
<td>实体部分包含的资源不是来自源服务器，而是来自资源的一份副本。如果中间节点上有一份资源副本，但无法对它所发送的与资源有关的元信息（首部）进行验证，就会出现这种情况。</td>
<td>Non-Authoritative-Information</td>
</tr>
<tr>
<td>204</td>
<td>响应报文中包含若干首部和一个状态行，但没有实体部分，主要用于在浏览器不转为显示新文档的情况下，对其将进行更新（如刷新一个表单页面）</td>
<td>No Content</td>
</tr>
<tr>
<td>205</td>
<td>另一个主要用于浏览器的代码，负责告诉浏览器清除当前页面中所有HTML表单元素。</td>
<td>Reset Content</td>
</tr>
<tr>
<td>206</td>
<td>成功执行一部分请求。稍后会看到，客户端可以通过一些特殊的首部来获取部分或某个范围内的文档——这个状态码就说明请求成功了。</td>
<td>Partial Content</td>
</tr>
</tbody></table>
<p><strong>重定向状态码</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>300</td>
<td>Multiple Choices</td>
<td>客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如服务器上有某个HTML文档的英语和法语版本。返回这个代码时会带有一个选项列表，这样用户就可以选择他希望使用的那一项了。有多个版本1可用时，客户端需要沟通解决。</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permananently</td>
<td>在请求的URL已被移除时使用。响应的Location首部中应该包含资源现在所处的URL。</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>与301状态码相似，但是客户端应该使用Location首部给出的URL来临时定位资源。将来的请求仍应使用老的URL。</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的Location首部。其主要目的是允许POST请求的响应将客户端定向到某个资源上去。</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>客户端可以通过所包含的请求首部，使其请求变成有条件的。如果客户端发起一个GET请求，而最近资源未被修改，就可用这个状态码来说明资源未被修改，带有这个状态吗的响应不应该包含实体的主体部分。</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>用来说明必须通过一个代理来访问资源，代理的位置由Location首部给出。很重要一点是，客户端是相对某个特定资源来解析这个响应的，不能假定所有请求，甚至所有对持有所请求资源的服务器的请求都通过这个代理进行。如果客户端错误的让代理介入了某条请求，可能会引发破环性的行为，而且会造成安全漏洞。</td>
</tr>
<tr>
<td>306</td>
<td>（未使用）</td>
<td>当前未使用</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>与301状态码相似，但是客户端应该使用Location首部给出的URL来临时定位资源。将来的请求仍应使用老的URL。</td>
</tr>
</tbody></table>
<p><strong>客户端错误</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>Bad Request</td>
<td>用于告诉客户端他发送了一个错误的请求</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>与适当的首部一同返回，在这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证。</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>现在这个状态码还未使用，但已经被保留，以作未来之用。</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>用以说明请求被服务器拒绝了，如果服务器想说明为什么拒绝请求，可以包含实体的主体部分来对原因进行描述。但这个状态通常是在服务器不想说明拒绝原因的时候使用的。</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>用于说明服务器无法找到所请求的URL。通常会包含一个实体以便客户端应用程序显示给用户看。</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>发起的请求中带所请求的URL不支持的方法时，使用此状态码。应该在响应中包含Allow首部，以告知客户端对请求的资源可以使用哪些方法。</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>客户端可以指定参数来说明他们愿意接受什么类型的实体。服务器没有与客户端可接受的URL相匹配的资源时，使用此代码。通常，服务器会包含一些首部以便客户端弄清楚为什么请求无法满足。</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>与401状态码类似，但用于要求对资源进行认证的代理服务器。</td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout</td>
<td>如果客户端完成请求所花的时间太长，服务器可以回送此状态码，并关闭连接。超时时长随服务器的不同而不同，但通常对所有合法请求来说都是够长的。</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>用于说明请求可能在资源上引发的一些冲突，服务器担心请求会引发冲突时可发送此状态码。响应中应该包含描述冲突的主体。</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>与404相似，只要服务曾经拥有过此资源。主要用于Web站点的维护，这样服务器的管理者就可以在资源被移除的情况下通知客户端了。</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>服务器要求在请求报文中包含Content-Length首部时使用。</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>客户端发起了条件请求且其中一个条件失败时使用。</td>
</tr>
<tr>
<td>413</td>
<td>Request Entrity Too Large</td>
<td>客户端发送实体主体部分比服务器能够或希望处理的要大时发送此状态码。</td>
</tr>
<tr>
<td>414</td>
<td>Request URL Too Long</td>
<td>客户端发送请求中的URL比服务器希望处理的要大时发送此状态码。</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器无法理解或无法支持客户端所发送实体的内容类型时</td>
</tr>
<tr>
<td>416</td>
<td>Unsupported Media Type</td>
<td>请求报文所请求的是指定资源的某个范围，而此范围无效或无法满足时使用此状态码。</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>请求的Expect请求首部包含了一个期望，但服务器无法满足此期望时，使用此状态码。如果代理或其他中间应用程序与确切证据说明源端服务器会为某请求产生一个失败的期望就可发送此状态码。</td>
</tr>
</tbody></table>
<p><strong>服务器错误</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器遇到一个妨碍它为请求提供服务的错误时使用此状态码。</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>客户端发起的请求超出服务器的能力范围。</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应（如，他无法链接到其父网关时）。</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>用来说明服务器现在不能为请求提供服务，但将来可以。如果服务器知道什么时候资源会变为可用的，可在响应中包含一个Retry-After首部。</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout</td>
<td>与状态码408相似，只是这里的响应来自一个网关或代理，他们在等待另一服务器对其请求进行响应时超时了。</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version Not Supported</td>
<td>服务器收到的请求使用了它无法或不愿支持的协议版本。有些服务器应用程序会选择不支持协议的早期版本。</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="5">
<li><p>原因短语（reason-phrase）</p>
<p>数字状态码的可读版本，包含行终止序列的所有文本。</p>
</li>
<li><p>首部（header）</p>
<p>可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号，然后是一个可选的空格，接着是一个值，最后是一个CRLF。首部是由一个空行结束的，表示了首部列表的结束和实体主体部分的开始。</p>
<p><strong>首部分类</strong></p>
<ul>
<li>通用首部：既可以出现在请求报文中，又可以出现在响应报文中。</li>
<li>请求首部：提供更多有关请求的信息。</li>
<li>响应首部：提供更多有关响应的信息。</li>
<li>实体首部：描述主体的长度和内容，或者资源自身。</li>
<li>扩展首部：规范中没有定义的新首部。</li>
</ul>
<p><strong>常见首部实例</strong></p>
<table>
<thead>
<tr>
<th>首部实例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Date：Tue,3 Oct 1997  02:16:03  GMT</td>
<td>服务器产生响应的日期</td>
</tr>
<tr>
<td>Content-length:15040</td>
<td>实体的主体部分包含了</td>
</tr>
<tr>
<td>Content-type:image/gif</td>
<td>实体的主体部分是一个GIF图片</td>
</tr>
<tr>
<td>Accept:image/gif, image/jpeg, text/html</td>
<td>客户端可以接收</td>
</tr>
<tr>
<td>Connection</td>
<td>允许客户端和服务器指定与请求或响应连接有关的选项。</td>
</tr>
<tr>
<td>MIME-Version</td>
<td>给定发送端使用的MIME版本。</td>
</tr>
<tr>
<td>Trailer</td>
<td>如果报文采用了分块传输编码（chunked transfer encoding）方式就可以用这个首部列出位于报文拖挂（trailer）部分的首部集合。</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>告知接收端为了保证报文可靠传输，对报文采取什么编码方式。</td>
</tr>
<tr>
<td>Update</td>
<td>给出了发送端可能想要“升级”使用的新版本或协议。</td>
</tr>
<tr>
<td>Via</td>
<td>显示了报文经过的中间节点（代理，网关）</td>
</tr>
</tbody></table>
</li>
<li><p>实体的主体部分（entrity-body）</p>
<p>实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分。</p>
</li>
</ol>
<h6 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h6><p>通用缓存首部：HTTP/1.0引入了第一个允许HTTP应用程序缓存对象本地副本的首部，这样就不需要总是直接从源端服务器获取了。</p>
<table>
<thead>
<tr>
<th>首部</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>用于随报文传送缓存指示。</td>
</tr>
<tr>
<td>Pragma</td>
<td>另一种随报文传送指示的方式，但并不专用于缓存。</td>
</tr>
</tbody></table>
<p><strong>请求首部</strong>：是只在请求报文中有意义的首部，用于说明是谁或什么在发送请求，请求源自何处，或者客户端的喜好和能力。服务器可以根据请求首部给出的客户端信息，试着为客户端提供更好的响应。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502215359440.png" alt="image-20200502215359440"></p>
<p><strong>Accept首部</strong>为客户端提供一种将其喜好和能力告知服务器的方式，包括它们想要什么，可以使用什么，以及最重要的，他们不想要什么，这样，服务器可以根据这些额外的信息，对要发送的内容做出更明智的决定。Accept首部会使连接的两端都受益。客户端会得到它们想要的内容，服务器则不会浪费时间和带宽来发送客户端无法使用的东西。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502220337984.png" alt="image-20200502220337984"></p>
<p><strong>条件请求首部</strong>：有时客户端希望为请求加上某些限制。比如，如果客户端已经有了一份文件副本就希望只在服务器上的文档与客户端拥有的副本有所区别时才请求服务器传输文档。通过条件请求首部，客户端就可以为请求加上这种限制，要求服务器在对请求进行响应前，确保某个条件为真。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502220845355.png" alt="image-20200502220845355"></p>
<p><strong>安全请求首部</strong></p>
<p>HTTP本身就支持一种简单的机制，可以对请求进行质询/响应认证。这种机制要求客户端在获取特定资源之前，先对自身进行认证，这样就可以使事务稍微安全一些。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502221420633.png" alt="image-20200502221420633"></p>
<p><strong>代理请求首部</strong></p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502221552479.png" alt="image-20200502221552479"></p>
<h6 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h6><p>响应报文有自己的响应首部集。响应首部为客户端提供了一些额外信息，比如谁发送响应，响应者的功能，甚至与响应相关的一些特殊指令，这些首部有助于客户端处理响应，并在将来发起更好的请求。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200503080735091.png" alt="image-20200503080735091"></p>
<p><strong>协商首部</strong></p>
<p>如果资源有多种表示方法——如，若服务器上有某文档的法语和德语译稿，HTTP/1.1可以为服务器和客户端提供对资源进行协商的能力。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200503082210004.png" alt="image-20200503082210004"></p>
<p><strong>安全响应首部</strong></p>
<table>
<thead>
<tr>
<th>首部</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Proxy-Authenticate</td>
<td>来自代理的对客户端的质询列表</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>不是真正的安全首部，但隐含有安全功能，可以在客户端设置一个令牌，以便服务器对客户端进行标识。</td>
</tr>
<tr>
<td>Set-Cookie2</td>
<td>与Set-Cookie类似</td>
</tr>
<tr>
<td>www-Authenticate</td>
<td>来自服务器的对客户端的质询列表</td>
</tr>
</tbody></table>
<h6 id="HTTP事务产生时延的原因"><a href="#HTTP事务产生时延的原因" class="headerlink" title="HTTP事务产生时延的原因"></a>HTTP事务产生时延的原因</h6><ol>
<li>客户端首先需要根据URI确定Web服务器的IP地址和端口号。如果最近没有对URI中的主机名进行访问，通过DNS解析系统将URI中的主机名转换成一个IP地址可能要花费数十秒的时间。</li>
<li>接下来，客户端会向服务器发送一条TCP连接请求，并等待服务器回送一个请求经接受应答。每条新的TCP连接都会有连接建立时延。这个值通常最多只有一两秒钟，但如果有数百个HTTP事务的话，这个值就会快速叠加上去。</li>
<li>一旦连接建立起来，客户端就会通过新建立的TCP管道来发送HTTP请求。数据到达时，Web服务器会从TCP链接中读取请求报文，并对请求进行处理。因特网传输请求报文，以及服务器请求报文都需要时间。</li>
<li>然后，Web服务器会回送HTTP响应，这也需要花费时间。</li>
</ol>
<p>注：大多数HTTP客户端都有一个小的DNS缓存,用来保存近期所访问站点的IP地址。如果已经在本地“缓存”了IP地址，查询就可立即完成，因为大多数Web浏览器浏览的是少数常用站点，所以通常可以很快将主机名解析出来。</p>
<p>TCP网络时延的大小取决于硬件速度，网络和服务器的负载，请求和响应报文的尺寸，以及客户端和服务器之间的距离。</p>
<h6 id="TCP连接握手步骤"><a href="#TCP连接握手步骤" class="headerlink" title="TCP连接握手步骤"></a>TCP连接握手步骤</h6><ol>
<li>请求新的TCP连接时，客户端要向服务器发送一个小的TCP分组（通常是40-60字节）。这个分组中设置了一个特殊的SYN标记，说明这是一个连接请求。</li>
<li>如果服务器接受了连接，就会对连接参数进行计算，并向客户端回送一个TCP分组，这个分组中的SYN和ACK标记都被置位，说明连接请求已被接受。</li>
<li>最后，客户端向服务器回送一条确认消息，通知他连接已成功建立，现代的TCP栈都允许客户端在这个确认分组中发送消息。</li>
</ol>
<p>小的HTTP事务可能会在TCP建立上花费50%，或更多的时间</p>
<h6 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h6><p>由于因特网自身无法确保可靠的分组传输（因特网路由器超负荷的话，可以随意丢弃分组），所以TCP实现了自己的确认机制来确保数据的成功传输。</p>
<p>每个TCP段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段时，都会向发送者回送小的确认分组。如果发送者，欸有在指定的窗口时间内收到确认信息，发送者就会认为分组已被破环或损毁，并重发数据。</p>
<p>由于u企鹅人保温很小，所以TCP允许在发往相同方向的输出数据分组中对其进行“捎带”。TCP将将返回的确认信息与输出的数据分组结合在一起，可以更有效利用网络。为了增加确认报文找到同向传输数据分组的可能性，很多TCP栈都实现了一种延迟确认算法。延迟确认算法会在一个特定的窗口时间内将输出确认缓存放在缓存区中，以寻找能够捎带他的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。</p>
<p>但是，HTTP具有双峰特征的请求——应答行为就降低了捎带信息的可能。当希望有相反方向回传分组的时候，偏偏没有那么多。通常，延迟确认算法会引起相当大的时延。根据所使用的操作系统的不同，可以调整或禁止延迟确认算法。</p>
<p>在对TCP栈的任何参数进行修改之前，一定要对袭击在做什么会有清晰的了解。TCP中引入这些算法的目的是为了防止设计欠佳的应用程序对因特网造成破环。对TCP配置进行任意修改都要绝对确保应用程序不会引发这些i算法所要避免的问题。</p>
<h6 id="TCP慢启动"><a href="#TCP慢启动" class="headerlink" title="TCP慢启动"></a>TCP慢启动</h6><p>TCP数据传输的性能还取决于TCP连接的使用期。TCP连接会随着时间进行自我“调谐”，起初还会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度，这种调谐被称为TCP慢启动，用于防止因特网的突然过载和拥塞。</p>
<p>TCP慢启动限制了一个TCP端点在任意时刻可以传输的分组数。简单来讲是每成功接收一个分组，发送端就有了发送另外两个分组的权限。如果某个HTTP事务有大量的数据要发送，是不能依次将所有分组都发送出去的，必须发送一个分组，确认后才可以再发。这种方式是”打开拥塞窗口“。</p>
<p>由于存在这种拥塞控制特性，所以新连接的传输速度会比已经交换过一定数据量的，“已调谐”连接慢一些。由于已调谐连接要更快一些，所以HTTP中有一些可以重用现存连接的工具。即HTTP“持久连接”。</p>
<h6 id="提高HTTP连接性能的四类方法"><a href="#提高HTTP连接性能的四类方法" class="headerlink" title="提高HTTP连接性能的四类方法"></a>提高HTTP连接性能的四类方法</h6><ol>
<li>并行连接</li>
<li>持久连接</li>
<li>管道化连接</li>
<li>复用连接</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ES6的学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/28/ES6的学习/" class="article-date">
      <time datetime="2020-04-28T06:51:11.000Z" itemprop="datePublished">2020-04-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/ES6的学习/">ES6的学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="ES6变量声明"><a href="#ES6变量声明" class="headerlink" title="ES6变量声明"></a>ES6变量声明</h4><h6 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h6><ul>
<li>声明变量，只在所在的代码块有效，处于暂时性死区</li>
<li><code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</li>
<li>变量不提升，不允许重复声明</li>
<li>允许在块级作用域内声明函数，函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</li>
</ul>
<h6 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h6><ul>
<li><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。且必须立即初始化，不能留到以后赋值。只声明不赋值，就会报错。</li>
<li><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</li>
</ul>
<h6 id="将对象彻底冻结"><a href="#将对象彻底冻结" class="headerlink" title="将对象彻底冻结"></a>将对象彻底冻结</h6><ul>
<li><p>简单冻结 ：const   foo = Object.freeze({});</p>
</li>
<li><p>对象及属性都冻结：</p>
<p>var  constantize = (obj) =&gt; {</p>
<p>Object.freeze(obj);</p>
<p>Object.keys(obj).forEach((key,i) =&gt;{</p>
<p>if( typeof  obj[key] === ‘object’) {</p>
<p>constantize(obj[key]);}</p>
<p>});};</p>
</li>
</ul>
<h6 id="import命令"><a href="#import命令" class="headerlink" title="import命令"></a>import命令</h6><h6 id="class命令"><a href="#class命令" class="headerlink" title="class命令"></a>class命令</h6><h6 id="顶层对象"><a href="#顶层对象" class="headerlink" title="顶层对象"></a>顶层对象</h6><ul>
<li>浏览器环境中的顶层对象指window对象，node指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。<ul>
<li>浏览器里面，顶层对象是<code>window</code>，但 Node 和 Web Worker 没有<code>window</code>。</li>
<li>浏览器和 Web Worker 里面，<code>self</code>也指向顶层对象，但是 Node 没有<code>self</code>。</li>
<li>Node 里面，顶层对象是<code>global</code>，但其他环境都不支持。</li>
</ul>
</li>
<li>一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。</li>
<li>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用<code>this</code>变量，但是有局限性。<ul>
<li>全局环境中，<code>this</code>会返回顶层对象。但是，Node 模块和 ES6 模块中，<code>this</code>返回的是当前模块。</li>
<li>函数里面的<code>this</code>，如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这时<code>this</code>会返回<code>undefined</code>。</li>
<li>不管是严格模式，还是普通模式，<code>new Function(&#39;return this&#39;)()</code>，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么<code>eval</code>、<code>new Function</code>这些方法都可能无法使用。</li>
</ul>
</li>
</ul>
<h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><ul>
<li>只需模式匹配即可用数组方式为各种数据类型赋值</li>
<li>解构赋值允许指定默认值。只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。</li>
</ul>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ul>
<li>全局环境中，this会返回顶层对象（浏览器是window，Node是global）。但是，Node模块和ES6模块中，this返回当前块</li>
<li>函数里面的this，如果函数不是作为对象的方法执行，而是单纯作为函数运行，this会指向顶层对象。但是在严格模式下，这时的this会返回undefined</li>
<li>不管是严格模式还是普通模式，new   Function（‘return  this’）（），总是返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全策略），那么eval，new  Function这些方法都可能不能使用。</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul>
<li><p>字符串的遍历器接口</p>
<ul>
<li><p>for（let   变量名   of  ‘遍历对象’）{}使得字符串如字符串数组般被遍历。</p>
</li>
<li><p>除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点</p>
<blockquote>
<p>let  text = String.fromCodePoint(0x20BB7);</p>
<p>for(let i = 0;i &lt; text.length; i++){</p>
<p>​    console.log(text[i]);  </p>
<p>}</p>
<p>//“ “</p>
<p>// ” “</p>
<p>//for循环认为其包含两个字符</p>
<p>for（let i  of  text）{</p>
<p>​    console.log(text[i]);  </p>
<p>}</p>
<p>//”吉“</p>
<p>//for…of循环会正确识别出这一个字符</p>
</blockquote>
</li>
</ul>
</li>
<li><p>为了确保返回的是合法的 UTF-8 字符，<a href="https://github.com/tc39/proposal-well-formed-stringify" target="_blank" rel="noopener">ES2019</a> 改变了<code>JSON.stringify()</code>的行为。如果遇到<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(&apos;\u&#123;D834&#125;&apos;) // &quot;&quot;\\uD834&quot;&quot;</span><br><span class="line">JSON.stringify(&apos;\uDF06\uD834&apos;) // &quot;&quot;\\udf06\\ud834&quot;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板字符串</p>
<ul>
<li><p>模板字符串（template string）是增强版的字符串，用反引号（~）标识。他可以当作普通字符串使用，也可以用来定义多行字符串，或在字符串中嵌入变量。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; $(<span class="string">'#result'</span>).append(</span><br><span class="line">&gt; <span class="string">'There are &lt;b&gt;'</span> + basket.count + <span class="string">'&lt;/b&gt; '</span> +</span><br><span class="line">&gt; <span class="string">'items in your basket, '</span> +</span><br><span class="line">&gt; <span class="string">'&lt;em&gt;'</span> + basket.onSale +</span><br><span class="line">&gt; <span class="string">'&lt;/em&gt; are on sale!'</span></span><br><span class="line">&gt; );</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// 普通字符串</span></span><br><span class="line">&gt; <span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// 多行字符串</span></span><br><span class="line">&gt; <span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string">&gt; not legal.`</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">&gt; string text line 2`</span>);</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// 字符串中嵌入变量</span></span><br><span class="line">&gt; <span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line">&gt; <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>上面的代码都是用反引号表示，如果在模板字符串中需要使用反引号，则前面要用反斜杠转义</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> greeting = <span class="string">`\`Yo\` World!`</span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>如果使用模板字符串表示多行字符串，所有空格和缩进都会被保留在输出之中。如不想这个换行，可使用trim方法消除他。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; $(<span class="string">'#list'</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&gt; &lt;ul&gt;</span></span><br><span class="line"><span class="string">&gt; &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">&gt; &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&gt; &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&gt; `</span>.trim());</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>模板字符串嵌入变量，需要将变量名写在${}之中。还可以调用函数大括号内部可以放入任意的js表达式，可进行运算，以及引用对象属性。</p>
</li>
<li><p>如果大括号内的值不是字符串，将按照一般规则转为字符串。若是字符串则会调用对象的toString方法。若模板字符串的变量没有声明，将会报错。</p>
</li>
</ul>
</li>
<li><p>标签模板</p>
<ul>
<li><p>它可紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert `123`</span><br><span class="line">//等价于</span><br><span class="line">alert(123);</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板字符串里面如果有变量，就不是简单调用，而是将模板字符串先处理成多个参数，在调用函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = 5;</span><br><span class="line">let b = 10;</span><br><span class="line"></span><br><span class="line">tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;</span><br><span class="line">// 等同于</span><br><span class="line">tag([&apos;Hello &apos;, &apos; world &apos;, &apos;&apos;], 15, 50);</span><br><span class="line">function tag(stringArr, ...values)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="字符串新增方法"><a href="#字符串新增方法" class="headerlink" title="字符串新增方法"></a>字符串新增方法</h4><ul>
<li><p>String.fromCodePoint()</p>
<ul>
<li>可以识别大于<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode()</code>方法的不足。</li>
</ul>
</li>
<li><p>String.raw()</p>
<ul>
<li>该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</li>
</ul>
</li>
<li><p>codePointAt()</p>
</li>
<li><p>normalize()</p>
<ul>
<li>用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</li>
</ul>
</li>
</ul>
<h6 id="确定一个字符串是否包含在另一个字符串中"><a href="#确定一个字符串是否包含在另一个字符串中" class="headerlink" title="确定一个字符串是否包含在另一个字符串中"></a>确定一个字符串是否包含在另一个字符串中</h6><ul>
<li><p><strong>indexof（）</strong></p>
</li>
<li><p><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</p>
</li>
<li><p><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的头部。</p>
</li>
<li><p><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的尾部。</p>
</li>
<li><h6 id="repeat-：返回一个新字符串，表示将原字符串重复n次。"><a href="#repeat-：返回一个新字符串，表示将原字符串重复n次。" class="headerlink" title="repeat()：返回一个新字符串，表示将原字符串重复n次。"></a>repeat()：返回一个新字符串，表示将原字符串重复<code>n</code>次。</h6><ul>
<li>其参数会先进行往0方向取整再代值，如是负数或Infinity会报错。参数<code>NaN</code>等同于 0</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>) <span class="comment">// "xxx"</span></span><br><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">0</span>) <span class="comment">// ""</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。如果某个字符串不够指定长度，会在头部或尾部补全。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>trimStart()</code>和<code>trimEnd()</code>这两个方法。它们的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</li>
<li><code>matchAll()</code>方法返回一个正则表达式在当前字符串的所有匹配</li>
</ul>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><ul>
<li><p>如果正则构造函数的第一个参数是一个正则对象，那么就可以使用第二个参数指定修饰符。且返回的正则表达式会忽略原有的正则表达式修饰符，只使用新指定的修饰符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new RegExp(/abc/ig,&apos;i&apos;).flags</span><br><span class="line">//&quot;i&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串对象共有 4 个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p>
<p>ES6 将这 4 个方法，在语言内部全部调用<code>RegExp</code>的实例方法，从而做到所有与正则相关的方法，全都定义在<code>RegExp</code>对象上。</p>
<ul>
<li><code>String.prototype.match</code> 调用 <code>RegExp.prototype[Symbol.match]</code></li>
<li><code>String.prototype.replace</code> 调用 <code>RegExp.prototype[Symbol.replace]</code></li>
<li><code>String.prototype.search</code> 调用 <code>RegExp.prototype[Symbol.search]</code></li>
<li><code>String.prototype.split</code> 调用 <code>RegExp.prototype[Symbol.split]</code></li>
</ul>
</li>
</ul>
<h6 id="具名组匹配"><a href="#具名组匹配" class="headerlink" title="具名组匹配"></a>具名组匹配</h6><blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> RE_DATE = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line">&gt; <span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line">&gt; <span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line">&gt; <span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>允许为每一个组匹配指定一个名字。模式的头部添加“问号 + 尖括号 + 组名”，然后就可以在<code>exec</code>方法返回结果的<code>groups</code>属性上引用该组名。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> RE_DATE = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line">&gt; <span class="keyword">const</span> year = matchObj.groups.year; <span class="comment">// 1999</span></span><br><span class="line">&gt; <span class="keyword">const</span> month = matchObj.groups.month; <span class="comment">// 12</span></span><br><span class="line">&gt; <span class="keyword">const</span> day = matchObj.groups.day; <span class="comment">// 31</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>RegExp.prototype.flags 属性返回正则表达式的修饰符。</p>
</li>
</ul>
<h6 id="先行断言"><a href="#先行断言" class="headerlink" title="先行断言"></a>先行断言</h6><p>“先行断言”指的是，<code>x</code>只有在<code>y</code>前面才匹配，必须写成<code>/x(?=y)/</code>。比如，只匹配百分号之前的数字，要写成<code>/\d+(?=%)/</code>。“先行否定断言”指的是，<code>x</code>只有不在<code>y</code>前面才匹配，必须写成<code>/x(?!y)/</code>。比如，只匹配不在百分号之前的数字，要写成<code>/\d+(?!%)/</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\d+(?=%)/.exec(&apos;100% of US presidents have been male&apos;)  // [&quot;100&quot;]</span><br><span class="line">/\d+(?!%)/.exec(&apos;that’s all 44 of them&apos;)                 // [&quot;44&quot;]</span><br></pre></td></tr></table></figure>

<h6 id="后行断言"><a href="#后行断言" class="headerlink" title="后行断言"></a>后行断言</h6><p>“后行断言”正好与“先行断言”相反，<code>x</code>只有在<code>y</code>后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。比如，只匹配美元符号之后的数字，要写成<code>/(?&lt;=\$)\d+/</code>。“后行否定断言”则与“先行否定断言”相反，<code>x</code>只有不在<code>y</code>后面才匹配，必须写成<code>/(?&lt;!y)x/</code>。比如，只匹配不在美元符号后面的数字，要写成<code>/(?&lt;!\$)\d+/</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=\$)\d+/.exec(&apos;Benjamin Franklin is on the $100 bill&apos;)  // [&quot;100&quot;]</span><br><span class="line">/(?&lt;!\$)\d+/.exec(&apos;it’s is worth about €90&apos;)                // [&quot;90&quot;]</span><br></pre></td></tr></table></figure>

<h6 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h6><ul>
<li>RegExp.prototype.unicode属性表示是否设置了u修饰符。</li>
<li>y修饰符隐含了头部匹配的标志^</li>
</ul>
<h4 id="函数的拓展"><a href="#函数的拓展" class="headerlink" title="函数的拓展"></a>函数的拓展</h4><ul>
<li><p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面</p>
<blockquote>
<p>function  log(x,y=’world’){</p>
<p>​    console.log(x,y);</p>
<p>}</p>
</blockquote>
<ul>
<li><p>好处：阅读代码的人可立即意识到哪些参数可以省略，不用查看函数体或文档。其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数也不会导致以前的代码无法运行</p>
</li>
<li><p>参数变量是默认声明的，故不能用let和const再次声明。否则会报错</p>
</li>
<li><p>使用参数默认值时，函数不能有同名参数</p>
</li>
<li><p>参数默认值不是传值的，而是每次都重新计算默认值表达式的值，即参数默认值是惰性求值的。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">&gt; <span class="built_in">console</span>.log(p);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; foo() <span class="comment">// 100</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; x = <span class="number">100</span>;</span><br><span class="line">&gt; foo() <span class="comment">// 101</span></span><br><span class="line">&gt; <span class="comment">//参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>函数与解构默认值结合使用</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">&gt; <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; foo(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">&gt; foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line">&gt; foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line">&gt; foo() <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值就可避免这种情况。</p>
<blockquote>
<p>function   foo({x,y=5} = {}){</p>
<p>​    console.log(x,y);</p>
<p>}</p>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// 函数没有参数的情况</span></span><br><span class="line">&gt; m1() <span class="comment">// [0, 0]</span></span><br><span class="line">&gt; m2() <span class="comment">// [0, 0]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// x 和 y 都有值的情况</span></span><br><span class="line">&gt; m1(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line">&gt; m2(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// x 有值，y 无值的情况</span></span><br><span class="line">&gt; m1(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, 0]</span></span><br><span class="line">&gt; m2(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, undefined]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// x 和 y 都无值的情况</span></span><br><span class="line">&gt; m1(&#123;&#125;) <span class="comment">// [0, 0];</span></span><br><span class="line">&gt; m2(&#123;&#125;) <span class="comment">// [undefined, undefined]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; m1(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [0, 0]</span></span><br><span class="line">&gt; m2(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [undefined, undefined]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>参数默认值一般是尾参数。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">5</span>, z</span>) </span>&#123;</span><br><span class="line">&gt; <span class="keyword">return</span> [x, y, z];</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; f() <span class="comment">// [undefined, 5, undefined]</span></span><br><span class="line">&gt; f(<span class="number">1</span>) <span class="comment">// [1, 5, undefined]</span></span><br><span class="line">&gt; f(<span class="number">1</span>, ,<span class="number">2</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt; f(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>) <span class="comment">// [1, 5, 2]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>函数的length属性</p>
<ul>
<li><p>指定了默认值后，函数的length属性将返回没有指定默认值的参数个数。也就是说指定了默认值后，length属性将失真。</p>
</li>
<li><p>length属性的含义是该函数预期传入的参数个数，某个指定了默认之后，预期传入的参数个数就不包括这个参数了。</p>
</li>
<li><p>如果设置默认值的参数不是尾参数，那么length属性将不再计入后面的参数了。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;&#125;).length  <span class="comment">//1</span></span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">a=<span class="number">5</span></span>)</span>&#123;&#125;).length  <span class="comment">//0</span></span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c=<span class="number">9</span></span>)</span>&#123;&#125;).length  <span class="comment">//2</span></span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;&#125;).length   <span class="comment">//0</span></span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">a=<span class="number">0</span>,b,c</span>)</span>&#123;&#125;).length   <span class="comment">//0</span></span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">a,b=<span class="number">2</span>,c</span>)</span>&#123;&#125;).length  <span class="comment">//1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>作用域</p>
<ul>
<li><p>一旦设置了参数默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用于就会消失。这种情况在没有默认参数值是不会出现的。</p>
<blockquote>
<p>var  x = 1;</p>
<p>function   f(x, y = x){</p>
<p>​    console.log(y);</p>
<p>}</p>
<p>f(2)  //2</p>
<p>//上面代码中，参数y的默认值等于变量x。调用函数时，参数会形成一个单独的作用域。在这个作用域里，默认变量x指向第一个参数x，而不是全局变量x，所以输出的是2</p>
</blockquote>
<blockquote>
<p>let  x = 1;</p>
<p>function  f(y=x){</p>
<p>​    let x = 2;</p>
<p>​    console.log(y);</p>
<p>}</p>
<p>f()   //1</p>
<p>//函数<code>f</code>调用时，参数<code>y = x</code>形成一个单独的作用域。这个作用域里面，变量<code>x</code>本身没有定义，所以指向外层的全局变量<code>x</code>。函数调用时，函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code>。若全局变量<code>x</code>不存在，就会报错。</p>
</blockquote>
</li>
<li><p>参数<code>x = x</code>形成一个单独作用域。实际执行的是<code>let x = x</code>，由于暂时性死区的原因，这行代码会报错”x 未定义“。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = x</span>) </span>&#123;</span><br><span class="line">&gt; <span class="comment">// ...</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; foo() <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>函数的参数默认值是一个匿名函数，当函数参数形成的单独作用域里面并没有定义该变量时，该变量就会指向外层的全局变量。若函数外层并无该变量，则会报错。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>) </span>&#123; x = <span class="number">2</span>; &#125;) &#123;</span><br><span class="line">&gt; <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">&gt; y();</span><br><span class="line">&gt; <span class="built_in">console</span>.log(x);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; foo() <span class="comment">// 3</span></span><br><span class="line">&gt; x <span class="comment">// 1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>rest参数</p>
<p>​    function   函数名(…变量名){}</p>
<ul>
<li>rest参数搭配的变量是一个数组，该变量会将多余的参数放入数组中。</li>
<li>与arguments对象不同，arguments对象是一个类数组。</li>
<li>rest参数之后不能有其他参数（及只能是是最后一个参数），否则会报错。当然，函数的length属性也不包括rest参数。</li>
</ul>
</li>
<li><p>严格模式下函数参数不能使用默认值，解构赋值或拓展运算符。两种解决方法：</p>
<ul>
<li><p>设定全局式的严格模式。</p>
<blockquote>
<p>‘use strict’;</p>
<p>function (a,b=a){</p>
<p>//code</p>
<p>}</p>
</blockquote>
</li>
<li><p>把函数包在一个无参数的立即执行函数中。</p>
<blockquote>
<p>const doSomething = (function(){</p>
<p>‘use strict’;</p>
<p>return function(value = 42){</p>
<p>​    return value;</p>
<p>};</p>
<p>}())；</p>
</blockquote>
</li>
</ul>
</li>
<li><p>name属性返回函数的函数名</p>
<ul>
<li><p>如果将一个匿名函数赋值给一个变量，Es5的name属性会返回空字符串，ES6返回实际函数名。</p>
</li>
<li><p>如果将一个具名函数赋值给一个变量，两者都返回这个具名函数原本的名字。</p>
<blockquote>
<p>const  bar = function baz(){};</p>
<p>//ES5</p>
<p>bar.name        //“baz”</p>
<p>//ES6</p>
<p>bar.name     //“baz”</p>
</blockquote>
</li>
<li><p>Function构造函数返回的函数实例，name属性的值为anonymous</p>
<blockquote>
<p>(new Function).name    //“anonymous”</p>
</blockquote>
</li>
<li><p>bind返回的函数，name属性值会加上bound前缀</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&gt; foo.bind(&#123;&#125;).name <span class="comment">// "bound foo"</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name <span class="comment">// "bound "</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
</ul>
<h6 id="箭头函数（-gt-）"><a href="#箭头函数（-gt-）" class="headerlink" title="箭头函数（=&gt;）"></a>箭头函数（=&gt;）</h6><blockquote>
<p>var  f= v =&gt; v;</p>
<p>//等同于</p>
<p>var   f = function(v){</p>
<p>return   v;</p>
<p>};</p>
</blockquote>
<ul>
<li><p>由于大括号被解释为代码块，故如果箭头函数直接返回一个对象会报错，必须在对象外面加上括号；</p>
<blockquote>
<p>//报错</p>
<p>let  gettempItem = id =&gt; { id: id, name: “temp” };</p>
<p>//不报错</p>
<p>let  gettempItem = id =&gt; ({ id: id, name: “temp”})</p>
</blockquote>
</li>
<li><p>使用箭头函数注意点</p>
<ul>
<li>函数体内的this对象，也就是定义时所在的对象，而不是使用是所在的对象。this对象的指向在js中是可变的。但在箭头函数中则是固定的。</li>
<li>不可以当作构造函数，即不可使用new命令，否则会抛出一个错误。</li>
<li>不可使用arguments对象，该对象在函数体内不存在。如果要用，可用rest参数替换。也没有super，new.target</li>
<li>不可使用yield命令，因此箭头函数不能用作Generator函数。</li>
</ul>
</li>
<li><p>this指向的固定化，并不是因为内部有绑定this机制，实际原因是箭头函数没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</p>
</li>
<li><p>箭头函数不适用场景</p>
<ul>
<li><p>定义对象的方法，且该方法内部包含this。调用<code>cat.jumps()</code>时，如果是普通函数，该方法内部的<code>this</code>指向<code>cat</code>；如果写成上面那样的箭头函数，使得<code>this</code>指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致<code>jumps</code>箭头函数定义时的作用域就是全局作用域。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> cat = &#123;</span><br><span class="line">&gt; lives: <span class="number">9</span>,</span><br><span class="line">&gt; jumps: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">&gt;  <span class="keyword">this</span>.lives--;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="comment">//上面的this指向的是全局作用域，不是cat</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>需要动态this时也不应使用箭头函数。下面代码运行时，点击按钮会报错，因为<code>button</code>的监听函数是一个箭头函数，导致里面的<code>this</code>就是全局对象。如果改成普通函数，<code>this</code>就会动态指向被点击的按钮对象。</p>
<blockquote>
<p>var button = document.getElementById(‘press’);</p>
<p>button.addEventListener(‘click’,()=&gt;{</p>
<p>​    this.classList.toggle(‘on’);</p>
<p>});</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h6 id="尾调用（Tail-Call）"><a href="#尾调用（Tail-Call）" class="headerlink" title="尾调用（Tail Call）"></a>尾调用（Tail Call）</h6><ul>
<li><p>尾调用优化只在严格模式下开启，正常模式是无效的，因为正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>
<ul>
<li><p>func.arguments:返回调用时函数的那个参数。</p>
</li>
<li><p>func.caller:返回调用函数当前函数的那个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restricted</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  restricted.caller;    <span class="comment">// 报错</span></span><br><span class="line">  restricted.arguments; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line">restricted();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>尾调用是函数式编程的一个重要概念。指某个函数的最后一步是调用另一个函数。</p>
</li>
<li><p>尾调用之所以与其他调用不同就在于其调用位置。我们知道，函数调用会在内存中形成一个”调用记录“，又称“调用帧”，保存调用的位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方还会形成B的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>
</li>
<li><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
</li>
<li><p>尾调用优化，即只保留内层函数的调用帧。如果所有函数都是尾调用，就可以完全做到每次执行一次时，调用帧只有一项，这将大大节省内存。注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>
</li>
</ul>
<h6 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h6><ul>
<li><p>尾部调用自身即为尾递归。</p>
</li>
<li><p>递归是非常耗内存的，因为需要同时保存成千上万个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<blockquote>
<p>function  factorial(n,total){</p>
<p>​    if(n === 1)    return  total;</p>
<p>​    return factorial(n-1,n*total);</p>
<p>}</p>
</blockquote>
</li>
<li><p>尾调用优化的Fibonacci数列</p>
<blockquote>
<p>function  Fibonacci2(n,ac1 = 1, ac2 = 1){</p>
<p>​    if(n&lt;=1) {return   ac2};</p>
<p>​    return  Fibonacci2(n-1,ac2,ac1+ac2);</p>
<p>}</p>
</blockquote>
</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><p>Array.from()将两类对象（类数组和可便利的对象）转为真正的数组。</p>
<ul>
<li>只要是部署了Iterator接口的数据结构，Array.from就都可以将其转为真正的数组。</li>
<li>扩展运算符背后调用的是遍历器接口（Symbol.iterator),如果一个对象没有部署这个对象就无法转换。</li>
<li>类数组对象本质是有length属性，即只要有length属性的对象都可以通过Array.from方法转为数组。</li>
</ul>
<blockquote>
<p>//es5</p>
<p>var arr1 = [].slice.call(arrayLike);</p>
<p>//es6</p>
<p>let  arr2 = Array.from(arrayLike);</p>
<p>//NodeList对象</p>
<p>let  ps = document.querySelectorAll(‘p’);</p>
<p>Array.from(ps).filter(p =&gt; {</p>
<p>​    return p.textContent.length.length &gt;100;</p>
<p>});</p>
<p>//arguments对象</p>
<p>function  foo(){</p>
<p>var  args = Array.from(arguments);</p>
<p>}</p>
</blockquote>
<ul>
<li><p>对于没有部署该方法的浏览器可使用Array.prototype.slice方法替换。</p>
<blockquote>
<p>const  toArray = ( () =&gt;</p>
<p>​    Array.from ? Array.from : obj =&gt; [].slice.call(obj);</p>
<p>)( );</p>
</blockquote>
</li>
<li><p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<blockquote>
<p>Array.from(arrayLike,x =&gt; x * x);</p>
<p>Array.from(arrayLike).map( x=&gt; x*x);</p>
<p>//两者等价</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Array.of()用于将一组值转换为数组。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line">&gt; <span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line">&gt; <span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>下面代码中，<code>Array</code>方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line">&gt; <span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line">&gt; <span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>Array.prototype.copyWithin(target,stsart=0,end=this.length)</p>
<ul>
<li>数组实例的<code>copyWithin()</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</li>
</ul>
</li>
<li><p>查找</p>
<ul>
<li><p>find（）：用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找到第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。回调函数可接受三个参数，依次为当前的值，当前的位置和原数组。</p>
<blockquote>
<p>[1,2,3,10,15].find(function(value,index,arr){</p>
<p>​    return value &gt; 9;</p>
<p>})    //10</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>findIndex():返回第一个符合条件的数组成员的位置，如果都不符合则返回-1；</p>
</li>
<li><p>这两个方法都可以接受第二个参数，<strong>用于绑定回调函数的this对象。</strong></p>
<blockquote>
<p>function  f(v){</p>
<p>​    return  v &gt; this.age;</p>
<p>}</p>
<p>let  person = {name:’john’,age:20};</p>
<p>[12,15,26,42].find(f,person);     //26</p>
</blockquote>
</li>
<li><p>都可发现NaN，弥补数组中indexOf方法的不足。<code>indexOf</code>方法无法识别数组的<code>NaN</code>成员，但是<code>findIndex</code>方法可以借助<code>Object.is</code>方法做到。</p>
<blockquote>
<p>[NaN].indexOf(NaN)</p>
<p>//-1</p>
<p>[NaN].findIndex(y =&gt; Object.is(NaN,y))</p>
<p>//0</p>
</blockquote>
</li>
</ul>
</li>
<li><p>fill()使用给定值进行数组填充</p>
<ul>
<li>如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</li>
<li>fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</li>
<li>fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</li>
</ul>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>)</span><br><span class="line">&gt; <span class="comment">// [7, 7, 7]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)</span><br><span class="line">&gt; <span class="comment">// [7, 7, 7]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&gt; <span class="comment">// ['a', 7, 'c']</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>遍历数组</p>
<ul>
<li><p><code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对像，可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>
</li>
<li><p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">&gt; <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="comment">// 0 "a"</span></span><br><span class="line">&gt; <span class="comment">// 1 "b"</span></span><br><span class="line">&gt; <span class="keyword">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">&gt; <span class="keyword">let</span> entries = letter.entries();</span><br><span class="line">&gt; <span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, 'a']</span></span><br><span class="line">&gt; <span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, 'b']</span></span><br><span class="line">&gt; <span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, 'c']</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>includes()</p>
<ul>
<li><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似</p>
</li>
<li><p>该方法的第二个参数表示搜索的起始位置，默认为<code>0</code>。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为<code>-4</code>，但数组长度为<code>3</code>），则会重置为从<code>0</code>开始。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>);  <span class="comment">// false</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">-1</span>); <span class="comment">// true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>没有该方法之前，我们通常使用数组的<code>indexOf</code>方法，检查是否包含某个值.</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span> (arr.indexOf(el) !== <span class="number">-1</span>) &#123;</span><br><span class="line">&gt; <span class="comment">// ...</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; [<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line">&gt; <span class="comment">// -1</span></span><br><span class="line">&gt; [<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>)</span><br><span class="line">&gt; <span class="comment">// true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>indexOf</code>方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于<code>-1</code>，表达起来不够直观。二是，它内部使用严格相等运算符（<code>===</code>）进行判断，这会导致对<code>NaN</code>的误判。</li>
</ul>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> contains = <span class="function">(<span class="params">(</span>) =&gt;</span></span><br><span class="line">&gt; <span class="built_in">Array</span>.prototype.includes</span><br><span class="line">&gt;  ? <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.includes(value)</span><br><span class="line">&gt;  : <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.some(<span class="function"><span class="params">el</span> =&gt;</span> el === value)</span><br><span class="line">&gt; )();</span><br><span class="line">&gt; contains([<span class="string">'foo'</span>, <span class="string">'bar'</span>], <span class="string">'baz'</span>); <span class="comment">// =&gt; false</span></span><br><span class="line">&gt; <span class="comment">//简易的替代版本。</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>另外，Map 和 Set 数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p>
<ul>
<li>Map 结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li>
<li>Set 结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>flat()和flatMap（）</p>
<ul>
<li><p>数组的成员有时还是数组，<code>Array.prototype.flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p>
</li>
<li><p><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为</p>
</li>
<li><p>可以用<code>Infinity</code>关键字作为参数。</p>
</li>
<li><p>如果原数组有空位，<code>flat()</code>方法会跳过空位。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].flat()</span><br><span class="line">&gt; <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>)</span><br><span class="line">&gt; <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">&gt; [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="literal">Infinity</span>)</span><br><span class="line">&gt; <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>].flat()</span><br><span class="line">&gt; <span class="comment">// [1, 2, 4, 5]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>flatMap()</code>方法对原数组的每个成员执行一个函数（相当于执行<code>Array.prototype.map()</code>），然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组。<code>flatMap()</code>只能展开一层数组。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">&gt; [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line">&gt; <span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br><span class="line">&gt; <span class="comment">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]])</span><br><span class="line">&gt; <span class="comment">// [[2], [4], [6], [8]]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>flatMap()</code>方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。<code>flatMap()</code>方法还可以有第二个参数，用来绑定遍历函数里面的<code>this</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; arr.flatMap(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>) </span>&#123;</span><br><span class="line">&gt; <span class="comment">// ...</span></span><br><span class="line">&gt; &#125;[, thisArg])</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>数组中的空位</p>
<ul>
<li><p>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p>
</li>
<li><blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>] <span class="comment">// true</span></span><br><span class="line">&gt; <span class="number">0</span> <span class="keyword">in</span> [, , ,] <span class="comment">// false</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位.</p>
<ul>
<li><code>forEach()</code>, <code>filter()</code>, <code>reduce()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位。</li>
<li><code>map()</code>会跳过空位，但会保留这个值</li>
<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li>
</ul>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// forEach方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].forEach(<span class="function">(<span class="params">x,i</span>) =&gt;</span> <span class="built_in">console</span>.log(i)); <span class="comment">// 1</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// filter方法</span></span><br><span class="line">&gt; [<span class="string">'a'</span>,,<span class="string">'b'</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// ['a','b']</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// every方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x===<span class="string">'a'</span>) <span class="comment">// true</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// reduce方法</span></span><br><span class="line">&gt; [<span class="number">1</span>,,<span class="number">2</span>].reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y) <span class="comment">// 3</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// some方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].some(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">'a'</span>) <span class="comment">// false</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// map方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [,1]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// join方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].join(<span class="string">'#'</span>) <span class="comment">// "#a##"</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// toString方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].toString() <span class="comment">// ",a,,"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p>
</li>
<li><p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p>
</li>
<li><p><code>copyWithin()</code>会连空位一起拷贝。</p>
</li>
<li><p><code>fill()</code>会将空位视为正常的数组位置。</p>
</li>
<li><p><code>for...of</code>循环也会遍历空位.</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Array</span>.from([<span class="string">'a'</span>,,<span class="string">'b'</span>])</span><br><span class="line">&gt; <span class="comment">// [ "a", undefined, "b" ]</span></span><br><span class="line">&gt; [...[<span class="string">'a'</span>,,<span class="string">'b'</span>]]</span><br><span class="line">&gt; <span class="comment">// [ "a", undefined, "b" ]</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>,<span class="string">'b'</span>,,].copyWithin(<span class="number">2</span>,<span class="number">0</span>) <span class="comment">// [,"a",,"a"]</span></span><br><span class="line">&gt; <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">'a'</span>) <span class="comment">// ["a","a","a"]</span></span><br><span class="line">&gt; <span class="keyword">let</span> arr = [, ,];</span><br><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">&gt; <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="comment">// 1</span></span><br><span class="line">&gt; <span class="comment">// 1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// entries()</span></span><br><span class="line">&gt; [...[,<span class="string">'a'</span>].entries()] <span class="comment">// [[0,undefined], [1,"a"]]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// keys()</span></span><br><span class="line">&gt; [...[,<span class="string">'a'</span>].keys()] <span class="comment">// [0,1]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// values()</span></span><br><span class="line">&gt; [...[,<span class="string">'a'</span>].values()] <span class="comment">// [undefined,"a"]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// find()</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].find(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// undefined</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// findIndex()</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// 0</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h4><h6 id="属性遍历"><a href="#属性遍历" class="headerlink" title="属性遍历"></a>属性遍历</h6><ul>
<li><p><strong>for…in</strong>:遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
</li>
<li><p><strong>Object.keys(obj)</strong>：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
</li>
<li><p><strong>Object.getOwnPropertyNames(obj)</strong>：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
</li>
<li><p><strong>Object.getOwnPropertySymbols(obj)</strong>：返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
</li>
<li><p><strong>Reflect.ownKeys(obj)</strong>：返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
</li>
<li><p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>
</ul>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Reflect</span>.ownKeys(&#123; [<span class="built_in">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span> &#125;)</span><br><span class="line">&gt; <span class="comment">// ['2', '10', 'b', 'a', Symbol()]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h6 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h6><ul>
<li><p>this关键字总是指向函数所在的当前对象，关键字super则是指向当前对象的原型对象，super只能用在对象的方法中，用在其他地方会报错。</p>
</li>
<li><p>JavaScript 引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。</p>
<blockquote>
<p>const  proto ={foo:’hello’};</p>
<p>const obj = {</p>
<p>​    foo:’world’,</p>
<p>​    find(){</p>
<p>​    return super.foo;</p>
<p>​    }</p>
<p>}</p>
<p>Object.setPrototypeOf(obj,proto);</p>
<p>obj.find();    //“hello”</p>
<p>//报错</p>
<p>const  obj = {foo:super.foo;    //对象的属性}</p>
<p>//只有对象方法的简写式才可以被js引擎确认定义的是对象的方法。</p>
<p>//以下两种都报错报错</p>
<p>const   obj = {</p>
<p>​    foo:() =&gt; super.foo</p>
<p>}</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> obj = &#123;</span><br><span class="line">&gt; foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;  <span class="keyword">return</span> <span class="keyword">super</span>.foo</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  x: <span class="string">'hello'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  x: <span class="string">'world'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// "world"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code>。</p>
<h6 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h6><ul>
<li>扩展运算符的解构赋值，不能复制继承自原型对象的属性。</li>
</ul>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">&gt; <span class="keyword">let</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&gt; o2.__proto__ = o1;</span><br><span class="line">&gt; <span class="keyword">let</span> &#123; ...o3 &#125; = o2;</span><br><span class="line">&gt; o3 <span class="comment">// &#123; b: 2 &#125;</span></span><br><span class="line">&gt; o3.a <span class="comment">// undefined</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="对象新增方法"><a href="#对象新增方法" class="headerlink" title="对象新增方法"></a>对象新增方法</h4><ul>
<li><p>Object.is():在所有环境中，只要两个值是一样的，他们就相等</p>
<ul>
<li><p>与严格相等（===）功能差不多，但是弥补了NaN不等于自身的缺陷。</p>
</li>
<li><p>+0不等于-0</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Object</span>.is(<span class="string">'foo'</span>, <span class="string">'foo'</span>)</span><br><span class="line">&gt; <span class="comment">// true</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)</span><br><span class="line">&gt; <span class="comment">// false</span></span><br><span class="line">&gt; +<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></span><br><span class="line">&gt; <span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>Object.assign()用于对象的合并，将源对象的所有可枚举属性，复制到目标对象。</p>
<ul>
<li><p><code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p>
</li>
<li><p>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
</li>
<li><p>如果只有一个参数，<code>Object.assign</code>会直接返回该参数。</p>
</li>
<li><p>如果该参数不是对象，则会先转成对象，然后返回。由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。</p>
</li>
<li><blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&gt; <span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">&gt; target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(obj) === obj <span class="comment">// true</span></span><br><span class="line">&gt; <span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">2</span>) <span class="comment">// "object"</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(<span class="literal">undefined</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(<span class="literal">null</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。因为只有字符串的包装对象，会产生可枚举属性。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(obj, <span class="literal">undefined</span>) === obj <span class="comment">// true</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(obj, <span class="literal">null</span>) === obj <span class="comment">// true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> v1 = <span class="string">'abc'</span>;</span><br><span class="line">&gt; <span class="keyword">const</span> v2 = <span class="literal">true</span>;</span><br><span class="line">&gt; <span class="keyword">const</span> v3 = <span class="number">10</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">const</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, v2, v3);</span><br><span class="line">&gt; <span class="built_in">console</span>.log(obj); <span class="comment">// &#123; "0": "a", "1": "b", "2": "c" &#125;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="数组中的遍历"><a href="#数组中的遍历" class="headerlink" title="数组中的遍历"></a>数组中的遍历</h4><ul>
<li><p>reduce求和,求平均值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce((tmp,item,index) =&gt; &#123; </span><br><span class="line">	//tmp是一个前一次的总和</span><br><span class="line">	//item是第几个数的值</span><br><span class="line">	//index是下标值，因第一个tmp是第一个arr[0],所以index是从1开始</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>map  映射</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.map((item) =&gt; &#123;</span><br><span class="line">	//item是第几个数的值</span><br><span class="line">	return item*2;</span><br><span class="line">&#125;);</span><br><span class="line">arr.map(item =&gt; item*2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>filter过滤器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr.filter(item =&gt; &#123;</span><br><span class="line">	//返回true者留下，返回false消失</span><br><span class="line">	if(item % 3 == 0)&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">//相当于</span><br><span class="line">arr.filter(item =&gt; item%3 == 0);</span><br></pre></td></tr></table></figure>
</li>
<li><p>forEach   循环迭代</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach( (item,index) =&gt; &#123;</span><br><span class="line">	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="字符串新增方法-1"><a href="#字符串新增方法-1" class="headerlink" title="字符串新增方法"></a>字符串新增方法</h4><ul>
<li>startsWith:检测str是否以某些字符的开头</li>
<li>endsWith：检测str是否以某个字符的结尾</li>
<li>字符串模板 ：${变量}</li>
</ul>
<h4 id="面向对象class类"><a href="#面向对象class类" class="headerlink" title="面向对象class类"></a>面向对象class类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class User&#123;</span><br><span class="line">	constructor(name,pass)&#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.pass = pass;</span><br><span class="line">	&#125;</span><br><span class="line">	showName()&#123;</span><br><span class="line">		alert(this.name);//不可以使用function，不用加逗号，表示属性，而非方法</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>class关键字，构造器和类分开</p>
</li>
<li><p>class里面直接加方法</p>
</li>
</ol>
<h6 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h6><p>老版写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function User(name,pass)&#123;</span><br><span class="line">           this.name = name;</span><br><span class="line">           this.pass = pass;</span><br><span class="line">       &#125; </span><br><span class="line">       User.prototype.showName = function()&#123;</span><br><span class="line">           alert(this.name);</span><br><span class="line">       &#125;</span><br><span class="line">       User.prototype.showPass = function()&#123;</span><br><span class="line">           alert(this.pass);</span><br><span class="line">       &#125;</span><br><span class="line">       function vipUser(name,pass,level)&#123;</span><br><span class="line">           User.call(this,name,pass);</span><br><span class="line">           this.level = level;</span><br><span class="line">       &#125;</span><br><span class="line">      vipUser.prototype = new User();</span><br><span class="line">      vipUser.prototype.constructor = vipUser;</span><br><span class="line">       vipUser.prototype.showlevel = function()&#123;</span><br><span class="line">           alert(this.level);</span><br><span class="line">       &#125;;</span><br><span class="line">       var v1 = new vipUser(&apos;blue&apos;,&apos;12345&apos;,10);</span><br><span class="line">       v1.showName();</span><br><span class="line">       v1.showlevel();</span><br></pre></td></tr></table></figure>

<p>super——超类，就相当于父类</p>
<p>extends——继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class User&#123;</span><br><span class="line">     constructor(name,pass)&#123;</span><br><span class="line">         this.name = name;</span><br><span class="line">         this.pass = pass;</span><br><span class="line">     &#125;</span><br><span class="line">     showName()&#123;</span><br><span class="line">         alert(this.name);</span><br><span class="line">     &#125;</span><br><span class="line">     showPass()&#123;</span><br><span class="line">         alert(this.pass);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> class VipUser extends User&#123;</span><br><span class="line">     constructor(name,pass,level)&#123;</span><br><span class="line">         super(name,pass);</span><br><span class="line">         this.level = level;</span><br><span class="line">     &#125;</span><br><span class="line">     showLevel()&#123;</span><br><span class="line">         alert(this.level);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> var v1 = new VipUser(&apos;nikita&apos;,&apos;15243&apos;,10);</span><br><span class="line"> v1.showName();</span><br><span class="line"> v1.showLevel();</span><br></pre></td></tr></table></figure>

<h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><h6 id="标准写法："><a href="#标准写法：" class="headerlink" title="标准写法："></a>标准写法：</h6><ul>
<li>只能用双引号。</li>
<li>所有名字都必须用引号包起来。</li>
</ul>
<h6 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h6><ul>
<li><p>字符串化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(&#123;&quot;a&quot;:12,&quot;name&quot;:&quot;nikita&quot;&#125;);</span><br><span class="line">//&quot;&#123;&quot;a&quot;:12,&quot;name&quot;:&quot;nikita&quot;&#125;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解析为一个json对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(&#123;&quot;a&quot;:12,&quot;name&quot;:&quot;nikita&quot;&#125;)；</span><br><span class="line">//&#123;name: &quot;nikita&quot;, age: 12&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Promise（消除异步操作）"><a href="#Promise（消除异步操作）" class="headerlink" title="Promise（消除异步操作）"></a>Promise（消除异步操作）</h4><ul>
<li><p>Promise对象只有三种状态：peding(进行中)，fulfilled（已成功），rejected（已失败）。</p>
</li>
<li><p>Promise实例具有then方法，then返回一个新的Promise实例。Promise对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch</code>方法指定的回调函数，处理这个错误。另外，<code>then</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch</code>方法捕获。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))</span><br><span class="line">  .catch((err) =&gt; console.log(&apos;rejected&apos;, err));</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))</span><br><span class="line">  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));</span><br></pre></td></tr></table></figure>
</li>
<li><p>用同步一样的方式来书写异步代码。接收一个含resolve和reject的函数参数。</p>
</li>
<li><p>resolve——解决，即成功    reject——拒绝，即失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise(function(resolve,reject)&#123;</span><br><span class="line">	//异步代码</span><br><span class="line">	$.ajax(&#123;</span><br><span class="line">		url:&apos;arr.txt&apos;,</span><br><span class="line">		dataType:&apos;json&apos;,</span><br><span class="line">		success(arr)&#123;</span><br><span class="line">			resolve(arr);</span><br><span class="line">		&#125;,</span><br><span class="line">		error(err)&#123;</span><br><span class="line">			reject(err);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;);</span><br><span class="line">//then函数有两个参数，一个是成功的回调函数，一个是失败的回调函数</span><br><span class="line">p.then(function()&#123;</span><br><span class="line">	alert(&apos;成功了&apos;);</span><br><span class="line">&#125;,function()&#123;</span><br><span class="line">	alert(&apos;失败了&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//若有两个Promise对象，可使用Promise.all进行全部处理</span><br><span class="line">//其中的arr是p1和p2中的数据</span><br><span class="line">function createPromise(url)&#123;</span><br><span class="line">	return new Promise(function(resolve,reject)&#123;</span><br><span class="line">		$.ajax(&#123;</span><br><span class="line">		url,</span><br><span class="line">		dataType:&apos;json&apos;,</span><br><span class="line">		 success(arr)&#123;</span><br><span class="line">			resolve(arr);</span><br><span class="line">		 &#125;,</span><br><span class="line">		 error(err)&#123;</span><br><span class="line">		 	reject(err);</span><br><span class="line">		 &#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">Promise.all([</span><br><span class="line">	createPromise(&apos;data/arr.txt&apos;),</span><br><span class="line">	createPromise(&apos;data/json.txt&apos;)</span><br><span class="line">]).then(function(arr)&#123;</span><br><span class="line">	//解构赋值</span><br><span class="line">	let [res1,res2] = arr;</span><br><span class="line">	alert(&apos;全部成功&apos;)</span><br><span class="line">&#125;,function()&#123;</span><br><span class="line">	alert(&apos;至少有一个失败&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>高版本jquery也封装了promise对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([</span><br><span class="line">	$.ajax(&#123;url:&apos;data/arr.txt&apos;,dataType:&apos;json&apos;&#125;),</span><br><span class="line">	$.ajax(&#123;url:&apos;data/json.txt&apos;,dataType:&apos;json&apos;&#125;)</span><br><span class="line">]).then(function(results)&#123;</span><br><span class="line">	let [arr,json] = results;</span><br><span class="line">	alert(&apos;成功了&apos;);</span><br><span class="line">&#125;,function(err)&#123;</span><br><span class="line">	alert(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise.race        竞速，即先到先执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Promise.race([</span><br><span class="line">	$.ajax(&#123;url:&apos;http://a2.taobai.com/data/users&apos;&#125;)</span><br><span class="line">	$.ajax(&#123;ur4:&apos;http://a2.taobai.com/data/users&apos;&#125;)</span><br><span class="line">	$.ajax(&#123;ur7:&apos;http://a2.taobai.com/data/users&apos;&#125;)</span><br><span class="line">	$.ajax(&#123;ur2:&apos;http://a2.taobai.com/data/users&apos;&#125;)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h6><ul>
<li>该方法为不管Promise对象最后如何，都会执行的代码。</li>
</ul>
<p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.listen(port)</span><br><span class="line">  .then(function () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure>

<h6 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h6><ul>
<li><p>用于将多个Promise实力包装为一个新的Promise实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>

<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>
<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>
<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 生成一个Promise对象的数组</span><br><span class="line">const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123;</span><br><span class="line">  return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all(promises).then(function (posts) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;).catch(function(reason)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="Fetch-API是js接口"><a href="#Fetch-API是js接口" class="headerlink" title="Fetch API是js接口"></a>Fetch API是js接口</h6><ul>
<li>用于访问和操作HTTP管道的部分，例如请求和响应。</li>
</ul>
<h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><ul>
<li><p>是ES6提供的一种异步编程解决方案，是一个状态机，封装了很多内部状态。执行Generator函数会返回一个遍历器对象，说明Generator函数同时还是一个遍历器对象生成函数，返回的遍历器对象可以一次遍历每个状态。</p>
</li>
<li><p>特征           *             yield</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function* test(value1)&#123;</span><br><span class="line">	let value2 = yield value1;   </span><br><span class="line">	let value3 = yield value2;</span><br><span class="line">	return value3;</span><br><span class="line">&#125;</span><br><span class="line">//第一个yield后的值是传入的参数，第二个是第二个next方法传入的...</span><br><span class="line">var hw = test(1);</span><br><span class="line">hw.next(5);</span><br><span class="line">//第一个next传入的参数无效，不管test有无传参</span><br><span class="line">//&#123;value:1,done:false&#125;</span><br><span class="line">hw.next(7)</span><br><span class="line">//&#123;value:7,done:false&#125;</span><br><span class="line">hw.next(9)</span><br><span class="line">//&#123;value:9,done:true&#125;</span><br></pre></td></tr></table></figure>

<p>调用test函数时，该函数并未执行，而是返回一个指向内部状态的指针对象。而调用该函数的next方法则是将指针移向下一个状态，next有位置记忆功能，故每次调用next方法时，都从上一次停下来的地方执行，直到下一个yield或return为止。return与yield功能相似，但return无位置记忆功能，且每个函数只能有一个return语句。且将return语句后面的表达式作为对象的value属性值，若无return，则返回undefined</p>
<p>当Generator函数运行完毕，但还使用next方法时，返回{value:undefined,done:true},便是遍历已结束。</p>
</li>
<li><p>next的参数表示上一个yield表达式的返回值，所以第一个next传递参数是无效的。</p>
</li>
<li><p>yield表达式若用在另一表达式中，必须放在圆括号内。</p>
</li>
<li><p>yield若用作函数参数或放在赋值表达式的右边，可不加括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;hello&apos; + (yield 123));</span><br><span class="line">function* demo()&#123;</span><br><span class="line">foo(yield &apos;a&apos;,yield &apos;b&apos;);</span><br><span class="line">let input = yield;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="与Symbol-iterator的关系"><a href="#与Symbol-iterator的关系" class="headerlink" title="与Symbol.iterator的关系"></a>与Symbol.iterator的关系</h6><ul>
<li>任意一个对象的Symbol.iterator方法等同于该对象的遍历器生成函数。把Generator赋值给对象的Symbol.iterator属性，可使该对象具有Iterator接口。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var myIterable = &#123;&#125;;</span><br><span class="line">myIterable[Symbol.iterator] = function* ()&#123;</span><br><span class="line">	yield 1;</span><br><span class="line">	yield 2;</span><br><span class="line">&#125;</span><br><span class="line">[...myIterable]   //1,2</span><br></pre></td></tr></table></figure>

<ul>
<li>Generator函数执行后返回一个遍历器对象，该对象本身具有iterator接口，执行后返回自身。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function* gen()&#123;&#125;</span><br><span class="line">var g = gen();</span><br><span class="line">g[Symbol.iterator] === g</span><br><span class="line">//true</span><br></pre></td></tr></table></figure>

<h6 id="原生js对象添加Iterator接口的方法"><a href="#原生js对象添加Iterator接口的方法" class="headerlink" title="原生js对象添加Iterator接口的方法"></a>原生js对象添加Iterator接口的方法</h6><ul>
<li><p>除了<code>for...of</code>循环以外，扩展运算符（<code>...</code>）、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。</p>
</li>
<li><p>原生js对象没有遍历接口，无法使用for…of循环，可通过generator函数为其加上接口便可使用。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function* objectEntries(obj)&#123;</span><br><span class="line">	let propKeys = Reflect.ownKeys(obj);//将obj对象转为数组</span><br><span class="line">	for(let propKey of propKeys)&#123;</span><br><span class="line">		yield [propkey,obj[propKey]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let jane = &#123; first: &apos;Jane&apos;, last: &apos;Doe&apos; &#125;;</span><br><span class="line"></span><br><span class="line">for (let [key, value] of objectEntries(jane)) &#123;</span><br><span class="line">  console.log(`$&#123;key&#125;: $&#123;value&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">// first: Jane</span><br><span class="line">// last: Doe</span><br></pre></td></tr></table></figure>

<ul>
<li>将Generator函数加到对象的symbol.irerator属性上。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* objectEntries() &#123;</span><br><span class="line">  let propKeys = Object.keys(this);</span><br><span class="line"></span><br><span class="line">  for (let propKey of propKeys) &#123;</span><br><span class="line">    yield [propKey, this[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let jane = &#123; first: &apos;Jane&apos;, last: &apos;Doe&apos; &#125;;</span><br><span class="line"></span><br><span class="line">jane[Symbol.iterator] = objectEntries;</span><br><span class="line"></span><br><span class="line">for (let [key, value] of jane) &#123;</span><br><span class="line">  console.log(`$&#123;key&#125;: $&#123;value&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">// first: Jane</span><br><span class="line">// last: Doe</span><br></pre></td></tr></table></figure>

<h6 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw"></a>Generator.prototype.throw</h6><ul>
<li>Generator函数返回的遍历器对象都有一个throw方法，可在函数体外抛出错误，然后在Generator函数体内捕获。</li>
</ul>
<h6 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return"></a>Generator.prototype.return</h6><ul>
<li>Generator 函数返回的遍历器对象，还有一个<code>return</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。</li>
<li>如果 Generator 函数内部有<code>try...finally</code>代码块，且正在执行<code>try</code>代码块，那么<code>return</code>方法会导致立刻进入<code>finally</code>代码块，执行完以后，整个函数才会结束。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* numbers () &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  try &#123;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield 3;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    yield 4;</span><br><span class="line">    yield 5;</span><br><span class="line">  &#125;</span><br><span class="line">  yield 6;</span><br><span class="line">&#125;</span><br><span class="line">var g = numbers();</span><br><span class="line">g.next() // &#123; value: 1, done: false &#125;</span><br><span class="line">g.next() // &#123; value: 2, done: false &#125;</span><br><span class="line">g.return(7) // &#123; value: 4, done: false &#125;</span><br><span class="line">g.next() // &#123; value: 5, done: false &#125;</span><br><span class="line">g.next() // &#123; value: 7, done: true &#125;</span><br></pre></td></tr></table></figure>

<h6 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield*表达式"></a>yield*表达式</h6><ul>
<li><p>yield*表达式返回一个表遍历器对象。</p>
</li>
<li><p>如果Generator函数内部调用另一个Generator函数需要在前者函数体内，利用for..of手动完成遍历。若不想手动，则可利用yield*</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function* bar() &#123;</span><br><span class="line">  yield &apos;x&apos;;</span><br><span class="line">  yield* foo();</span><br><span class="line">  yield &apos;y&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function* bar() &#123;</span><br><span class="line">  yield &apos;x&apos;;</span><br><span class="line">  yield &apos;a&apos;;</span><br><span class="line">  yield &apos;b&apos;;</span><br><span class="line">  yield &apos;y&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function* bar() &#123;</span><br><span class="line">  yield &apos;x&apos;;</span><br><span class="line">  for (let v of foo()) &#123;</span><br><span class="line">    yield v;</span><br><span class="line">  &#125;</span><br><span class="line">  yield &apos;y&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let v of bar())&#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;x&quot;</span><br><span class="line">// &quot;a&quot;</span><br><span class="line">// &quot;b&quot;</span><br><span class="line">// &quot;y&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>yield和yield*都只能放在Generator函数中，不能放在普通函数里。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//遍历嵌套数组</span><br><span class="line">var arr = [1,[[2,3],4],[5,6]];</span><br><span class="line">var flag = function* (a)&#123;</span><br><span class="line">    var length = a.length;</span><br><span class="line">    for(let i = 0;i &lt; length;i++)&#123;</span><br><span class="line">        var item = a[i];</span><br><span class="line">        if(typeof item != &apos;number&apos;)&#123;</span><br><span class="line">            yield* flag(item);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            yield item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(var f of flag(arr))&#123;</span><br><span class="line">    console.log(f);</span><br><span class="line">&#125;</span><br><span class="line">// 1, 2, 3, 4, 5, 6</span><br></pre></td></tr></table></figure>

<h6 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h6><ul>
<li>传统的编程语言早就有异步编程的解决方案，即多任务的解决方案。其中一种就是协程，意思是多个线程相互协作，完成异步操作。<ul>
<li>第一步，协程<code>A</code>开始执行。</li>
<li>第二步，协程<code>A</code>执行到一半，进入暂停，执行权转移到协程<code>B</code>。</li>
<li>第三步，（一段时间后）协程<code>B</code>交还执行权。</li>
<li>第四步，协程<code>A</code>恢复执行。</li>
</ul>
</li>
<li>异步任务的封装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var fetch = require(&apos;node-fetch&apos;);</span><br><span class="line">function* gen()&#123;</span><br><span class="line">    var url = &apos;http://api.github.com/users/github&apos;;</span><br><span class="line">    var result = yield fetch(url);</span><br><span class="line">    console.log(result.bio);</span><br><span class="line">&#125;</span><br><span class="line">var g = gen();</span><br><span class="line">var result = g.next();</span><br><span class="line">result.value.then(function(data)&#123;</span><br><span class="line">  return data.json();</span><br><span class="line">&#125;).then(function(data)&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br><span class="line">//How people build software.</span><br></pre></td></tr></table></figure>

<h6 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h6><ul>
<li>Thunk函数时自动执行Generator函数的一种方法。</li>
<li>参数求值策略有“传值调用”和”传名调用”两种，Thunk函。编译器的“传名调用”实现，往往是将参数放到一个临时函数中，再将这个临时函数传入函数体中，这个函数体即为Thunk函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function f(m)&#123;return m*2;&#125;</span><br><span class="line">f(x+5);</span><br><span class="line">//等同于</span><br><span class="line">vat thunk = function()&#123; return x+5; &#125;</span><br><span class="line">function f(thunk)&#123; return thunk()*2; &#125;</span><br><span class="line"></span><br><span class="line">//Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</span><br><span class="line">// 正常版本的readFile（多参数版本）</span><br><span class="line">fs.readFile(fileName, callback);</span><br><span class="line"></span><br><span class="line">// Thunk版本的readFile（单参数版本）</span><br><span class="line">var Thunk = function (fileName) &#123;</span><br><span class="line">  return function (callback) &#123;</span><br><span class="line">    return fs.readFile(fileName, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var readFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br></pre></td></tr></table></figure>

<h6 id="Thunkify模块"><a href="#Thunkify模块" class="headerlink" title="Thunkify模块"></a>Thunkify模块</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const thunkify = require(&apos;thunkify&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">let read = thunkify(fs.readFile);</span><br><span class="line">read(&apos;package.json&apos;)(function(err,data)&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="co模块"><a href="#co模块" class="headerlink" title="co模块"></a>co模块</h6><ul>
<li><p>co模块让你不用编写Generator函数的执行器，Generator函数只要传入co函数即可执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var co = require(&apos;co&apos;);</span><br><span class="line">co(generator);//返回一个promise对象，故可用then方法添加回调函数</span><br><span class="line">co.then(function()&#123;&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>co模块的原理</strong></p>
<p>为什么 co 可以自动执行 Generator 函数？</p>
<p>前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>
<p>两种方法可以做到这一点。</p>
<p>（1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</p>
<p>（2）Promise 对象。将异步操作包装成 Promise 对象，用<code>then</code>方法交回执行权。</p>
<p>co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的<code>yield</code>命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co。</p>
<p><strong>基于Promise对象的自动执行</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">let readFile = function (fileName)&#123;</span><br><span class="line">    return new Promise(function (resolve,reject)&#123;</span><br><span class="line">        fs.readFile(fileName,function(err,data)&#123;</span><br><span class="line">            if(err) return reject(err);</span><br><span class="line">            return resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">var gen = function* ()&#123;</span><br><span class="line">    let f1 = yield readFile(&apos;1.txt&apos;);</span><br><span class="line">    let f2 = yield readFile(&apos;2.txt&apos;);</span><br><span class="line">    console.log(f1.toString());</span><br><span class="line">    console.log(f2.toString());</span><br><span class="line">&#125;</span><br><span class="line">function run(gen)&#123;</span><br><span class="line">    var g = gen();</span><br><span class="line">    function next(data)&#123;</span><br><span class="line">        var result = g.next(data);</span><br><span class="line">        if(result.done) return result.value;</span><br><span class="line">        result.value.then(function(data)&#123;</span><br><span class="line">            next(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>

<h4 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h4><ul>
<li>引入async函数，使异步操作更方便。跟Generator函数类似，只需将*改为ansyc，yield改为await。</li>
<li><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</li>
</ul>
<h6 id="ansyc较Generator函数的优点"><a href="#ansyc较Generator函数的优点" class="headerlink" title="ansyc较Generator函数的优点"></a>ansyc较Generator函数的优点</h6><ul>
<li>内置执行器。Generator函数的执行必须靠执行器，才co模块，而async函数自带执行器。即async函数的执行与普通函数一样，使用函数名调用即可。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">let readFile = function (fileName)&#123;</span><br><span class="line">    return new Promise(function (resolve,reject)&#123;</span><br><span class="line">        fs.readFile(fileName,function(err,data)&#123;</span><br><span class="line">            if(err) return reject(err);</span><br><span class="line">            return resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//generator函数需要再封装一个run函数自执行</span><br><span class="line">// var gen = function* ()&#123;</span><br><span class="line">//     let f1 = yield readFile(&apos;1.txt&apos;);</span><br><span class="line">//     let f2 = yield readFile(&apos;2.txt&apos;);</span><br><span class="line">//     console.log(f1.toString());</span><br><span class="line">//     console.log(f2.toString());</span><br><span class="line">// &#125;</span><br><span class="line">// function run(gen)&#123;</span><br><span class="line">//     var g = gen();</span><br><span class="line">//     function next(data)&#123;</span><br><span class="line">//         var result = g.next(data);</span><br><span class="line">//         if(result.done) return result.value;</span><br><span class="line">//         result.value.then(function(data)&#123;</span><br><span class="line">//             next(data);</span><br><span class="line">//         &#125;)</span><br><span class="line">//     &#125;</span><br><span class="line">//     next();</span><br><span class="line">// &#125;</span><br><span class="line">// run(gen)</span><br><span class="line"></span><br><span class="line">//async函数有内置执行器</span><br><span class="line">const asyncReadFile = async function()&#123;</span><br><span class="line">    const f1 = await readFile(&apos;1.txt&apos;);</span><br><span class="line">    const f2 = await readFile(&apos;2.txt&apos;);</span><br><span class="line">    console.log(f1.toString());</span><br><span class="line">    console.log(f2.toString());</span><br><span class="line">&#125;</span><br><span class="line">asyncReadFile()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>更好的语义    </p>
<ul>
<li>async：异步</li>
<li>await表示紧跟在后面的表达式需要等待结果</li>
</ul>
</li>
<li><p>更广的适应性。</p>
<ul>
<li>co模块约定，yield命令后面只能是Thunk函数或Promise’对象，而async函数的await命令后面可以是Promise对象和原始类型的值（number，string，boolean，但这时会转为立即resolved的promise对象）。</li>
</ul>
</li>
<li><p>返回值是 Promise。</p>
<p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>
<p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p>
</li>
</ul>
<h6 id="async使用形式"><a href="#async使用形式" class="headerlink" title="async使用形式"></a>async使用形式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">async function foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">const foo = async function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 对象的方法</span><br><span class="line">let obj = &#123; async foo() &#123;&#125; &#125;;</span><br><span class="line">obj.foo().then(...)</span><br><span class="line"></span><br><span class="line">// Class 的方法</span><br><span class="line">class Storage &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.cachePromise = caches.open(&apos;avatars&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async getAvatar(name) &#123;</span><br><span class="line">    const cache = await this.cachePromise;</span><br><span class="line">    return cache.match(`/avatars/$&#123;name&#125;.jpg`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const storage = new Storage();</span><br><span class="line">storage.getAvatar(&apos;jake&apos;).then(…);</span><br><span class="line"></span><br><span class="line">// 箭头函数</span><br><span class="line">const foo = async () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>async函数内部return语句返回的值会成为then方法回调函数的参数。</strong></p>
<p><strong>async函数抛出的错误会导致返回的Promise对象变为reject状态。抛出的错误会被catch方法回调函数接收到。</strong>‘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function f(flag)&#123;</span><br><span class="line">    if(flag) throw new Error(&apos;出错了&apos;);</span><br><span class="line">    return &apos;hello&apos;;</span><br><span class="line">&#125;</span><br><span class="line">f(false).then(</span><br><span class="line">    v =&gt; console.log(v),</span><br><span class="line">    e =&gt; console.log(e)</span><br><span class="line">)</span><br><span class="line">//hello</span><br><span class="line">//当flag为true时，返回’出错了‘</span><br></pre></td></tr></table></figure>

<ul>
<li>async函数返回的Promise对象必须等到内部所有await命令后面的Promise对象执行完毕才会发生状态改变，除非遇到return语句或抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</li>
</ul>
<h6 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h6><ul>
<li><p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p>
</li>
<li><p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p>
</li>
<li><p>任何一个await语句后面的Promise对象变为reject状态，那么整个async函数就都会中断执行。</p>
<ul>
<li>要想不中断，可将其放入try…catch结构中。</li>
<li>或者在await后面的Promise对象再跟一个catch方法，处理前面可能出现的错误。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">async function f()&#123;</span><br><span class="line">	try&#123;</span><br><span class="line">		await Promise.reject(&apos;出错了&apos;);</span><br><span class="line">	&#125;catch(e)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	return await Promise.resolve(&apos;hello&apos;);</span><br><span class="line">&#125;</span><br><span class="line">f().then(v =&gt; &#123; console.log(v)&#125;);//hello</span><br><span class="line"></span><br><span class="line">async function f()&#123;</span><br><span class="line">	await Promise.reject(&apos;出错了&apos;)</span><br><span class="line">	.catch(e =&gt; &#123;console.log(e);&#125;);</span><br><span class="line">	return await Promise.resolve(&apos;hello&apos;)</span><br><span class="line">&#125;</span><br><span class="line">f().then(v =&gt; &#123; console.log(v)&#125;);</span><br><span class="line">//出错了</span><br><span class="line">//hello</span><br><span class="line"></span><br><span class="line">async function f() &#123;</span><br><span class="line">  await new Promise(function (resolve, reject) &#123;</span><br><span class="line">    throw new Error(&apos;出错了&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(v =&gt; console.log(v))</span><br><span class="line">.catch(e =&gt; console.log(e))</span><br><span class="line">// Error：出错了</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h4><ul>
<li>生成实例对象的传统方法是通过构造函数，引入class类概念，利用constructor构造方法创建实例，类中方法不需要加function，毗邻方法间不许用逗号相隔，加了会报错。在类实例上调用方法其实就是调用原型上的方法。</li>
<li>prototype对象的constructor属性，直接指向类本身，与ES5相似。constructor是类的默认方法，无显式指定时会模认自动生成。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class B&#123;</span><br><span class="line">	constructor()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">let b = new B();</span><br><span class="line">b.constructor === B.prototype.constructor  //true</span><br><span class="line">B.prototype.constructor === B    //true</span><br></pre></td></tr></table></figure>

<ul>
<li>由于类的方法都定义在prototype对象上，故类的新方法可添加在prototype对象上。Object.assign可一次添加多个方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(Point.prototype,&#123;</span><br><span class="line">	toString()&#123;&#125;,</span><br><span class="line">	toValue()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>类内部定义的方法都不可枚举。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(Point.prototype)</span><br><span class="line">//Object.keys()返回可枚举的键名</span><br><span class="line">//[]  </span><br><span class="line">Object.getOwnPropertyNames(Point.prototype)</span><br><span class="line">//[&quot;constructor&quot;,&quot;toString&quot;]</span><br><span class="line">//返回自身全部属性方法名（包括不可枚举属性）</span><br></pre></td></tr></table></figure>

<ul>
<li>constructor方法默认返回实例对象（即this），可指定返回另外一个对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">	constructor()&#123; return Object.create(null); &#125;</span><br><span class="line">&#125;</span><br><span class="line">new Foo() instanceof Foo</span><br></pre></td></tr></table></figure>

<h6 id="类的几种表示法"><a href="#类的几种表示法" class="headerlink" title="类的几种表示法"></a>类的几种表示法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class B&#123;&#125;</span><br><span class="line">let b = new B();</span><br><span class="line"></span><br><span class="line">const MyClass = class Me&#123;&#125;; //Me可省略，只能在内部使用</span><br><span class="line">let inst = new MyClass();//外部使用类只能用MyClass</span><br><span class="line"> </span><br><span class="line">//立即执行的类</span><br><span class="line">let person = new class&#123;</span><br><span class="line">	constructor(name)&#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	sayName()&#123;</span><br><span class="line">		console.log(this.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;(&apos;张三&apos;)</span><br><span class="line">person.sayName(); //“张三”</span><br></pre></td></tr></table></figure>

<h6 id="noticePoint"><a href="#noticePoint" class="headerlink" title="noticePoint"></a>noticePoint</h6><ul>
<li><p>类和模块默认就是严格模式。</p>
</li>
<li><p>类不存在变量提升，类使用在前，定义在后会报错。</p>
</li>
<li><p>name属性。ES6的类只是ES5的构造函数的一层包装，故函数的许多特性都被Class继承，包括name属性，name属性总是返回紧跟在class关键字后面的类名。</p>
</li>
<li><p>如果类的Symbol.iterator方法前有一星号，就是Generator方法。该方法会返回类的默认遍历器，for…of循环自动调用这个遍历器。</p>
</li>
<li><p>类内部如果有this默认指向类的实例。<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是<code>undefined</code>），从而导致找不到<code>print</code>方法而报错。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">  printName(name = &apos;there&apos;) &#123;</span><br><span class="line">    this.print(`Hello $&#123;name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print(text) &#123;</span><br><span class="line">    console.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const logger = new Logger();</span><br><span class="line">const &#123; printName &#125; = logger;</span><br><span class="line">printName(); // TypeError: Cannot read property &apos;print&apos; of undefined</span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//1.给构造函数绑定this</span><br><span class="line">class Logger&#123;</span><br><span class="line">	constructor()&#123;</span><br><span class="line">		this.printName = this.printName.bind(this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2.使用箭头函数</span><br><span class="line">class Obj&#123;</span><br><span class="line">	constructor()&#123;</span><br><span class="line">		this.getThis = () =&gt; this;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">const myObj = new Obj();</span><br><span class="line">myObj.getThis() === myobj  //true</span><br><span class="line"></span><br><span class="line">//3.使用Proxy，获取方法时自动绑定this</span><br><span class="line">function selfish(target)&#123;</span><br><span class="line">	const cache = new WeakMap();</span><br><span class="line">	const handler = &#123;</span><br><span class="line">		get(target,key)&#123;</span><br><span class="line">			const value = Reflect.get(target,key);</span><br><span class="line">			if(typeof value !== &apos;function&apos;)&#123;</span><br><span class="line">				return value;</span><br><span class="line">			&#125;</span><br><span class="line">			if(!cache.has(value))&#123;</span><br><span class="line">				cache.set(value,value.bind(target));</span><br><span class="line">			&#125;</span><br><span class="line">			return cache.get(value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	const proxy = new Proxy(target,handle);</span><br><span class="line">	return proxy;</span><br><span class="line">&#125;</span><br><span class="line">const logger = selfish(new Logger());</span><br></pre></td></tr></table></figure>

<ul>
<li>类中的方法前加上static关键字，该不会被实例继承，调用只能通过累来调用，称为静态方法。如果静态方法上包含this关键字，这个this指的是类，而不是实例。故静态方法可与非静态方法重名。</li>
<li>父类的静态方法可被子类继承，并可通过super对象屌用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">	static bar()&#123;this.baz();&#125;</span><br><span class="line">	static baz()&#123;console.log(&apos;helloBar&apos;);&#125;</span><br><span class="line">	static classMethod()&#123;return &apos;hello&apos;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.classMethod()  //‘hello&apos;</span><br><span class="line">Foo.bar()    //&apos;helloBar&apos;</span><br><span class="line">var foo = new Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line">//TypeError:foo.classMethod is not a function</span><br><span class="line"></span><br><span class="line">class Bar extends Foo&#123;</span><br><span class="line">	static sonMethod()&#123;</span><br><span class="line">		return super.classMethod() + &apos;,too&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Bar.classMethod()   //&apos;hello&apos;</span><br><span class="line">Bar.sonMethods()      //&apos;hello,too&apos;</span><br></pre></td></tr></table></figure>

<ul>
<li>实例属性<code>this._count</code>定义在<code>constructor()</code>方法里面，可将属性也可以定义在类的最顶层，其他都不变。实例属性<code>_count</code>与取值函数<code>value()</code>和<code>increment()</code>方法，处于同一个层级。这时，不需要在实例属性前面加上<code>this</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class IncreasingCounter &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this._count = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  get value() &#123;</span><br><span class="line">    console.log(&apos;Getting the current value!&apos;);</span><br><span class="line">    return this._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    this._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class IncreasingCounter &#123;</span><br><span class="line">  _count = 0;</span><br><span class="line">  get value() &#123;</span><br><span class="line">    console.log(&apos;Getting the current value!&apos;);</span><br><span class="line">    return this._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    this._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态属性即Class本身属性，必须在前面加上static关键字。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">calss Foo&#123;</span><br><span class="line">	static prop = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>子类继承父类，除了使用extends外，必须在子类的constructor上调用super对象，否则new实例时会报错。这是因为子类自己的this对象必须经过父类的构造函数完成塑造，得到与父类同样的实例属性和方法再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。如果在调用super之前使用this会报错。</p>
</li>
<li><p>Object.getPrototypeOf()用于在子类中获取父类，可用该方法判断一个类是否继承了另一个类。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(ColorPoint) === Point</span><br><span class="line">//true</span><br></pre></td></tr></table></figure>

<h6 id="super"><a href="#super" class="headerlink" title="super"></a>super</h6><ul>
<li>既可当函数调用，也可当对象使用。</li>
<li>super作为函数调用时，代表父类的构造函数。ES6规定，子类的constructor函数必须执行一次super()，且super()函数只能用在子类的构造函数内，用在其他地方会报错。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">	constructor()&#123;</span><br><span class="line">		console.log(new.target.name);//new.target指向当前正在执行的函数</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">	constructor()&#123;</span><br><span class="line">		super();   //等价于A.prototype.constructor.call(this)</span><br><span class="line">		//super内部的this指向子类的实例</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">new A() //A</span><br><span class="line">new B() //B</span><br></pre></td></tr></table></figure>

<ul>
<li>super作为对象时，在普通方法中，指向父类的原型对象；静态方法中，指向父类。这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.p = 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.x = 3;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  get m() &#123;</span><br><span class="line">    return super.p;</span><br><span class="line">  &#125;</span><br><span class="line">  get x()&#123;</span><br><span class="line">  	return super.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B();</span><br><span class="line">b.m // undefined</span><br><span class="line">b.x //3</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.x = 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x = 2;</span><br><span class="line">    super.x = 3;</span><br><span class="line">    console.log(super.x); // undefined</span><br><span class="line">    console.log(this.x); // 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p>
<ul>
<li>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</li>
<li>在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">  	this.x = &apos;实例的x&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  static print()&#123;</span><br><span class="line">  	console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">  static myMethod(msg) &#123;</span><br><span class="line">    console.log(&apos;static&apos;, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    console.log(&apos;instance&apos;, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">  static m()&#123;</span><br><span class="line">  	super.print();</span><br><span class="line">  &#125;</span><br><span class="line">  static myMethod(msg) &#123;</span><br><span class="line">    super.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    super.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.myMethod(1); // static 1</span><br><span class="line"></span><br><span class="line">var child = new Child();</span><br><span class="line">child.myMethod(2); // instance 2</span><br><span class="line"></span><br><span class="line">Child.x = &apos;这是类的x&apos;;</span><br><span class="line">Child.m() //&apos;这是类的x&apos;</span><br></pre></td></tr></table></figure>

<h6 id="类的prototype属性和-proto-属性"><a href="#类的prototype属性和-proto-属性" class="headerlink" title="类的prototype属性和__proto__属性"></a>类的prototype属性和<code>__proto__</code>属性</h6><ul>
<li>每个对象都有<code>__proto__</code>属性，指向对应的构造函数的prototype属性。</li>
<li><strong>子类的<code>__proto__</code>属性表示构造函数的继承，总是指向父类。</strong></li>
<li><strong>子类的prototype属性的<code>__proto__</code>属性表示方法的继承，总是指向父类的prototype属性。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">class B extends A&#123;&#125;</span><br><span class="line">B.__proto__ === A  //true</span><br><span class="line">B.prototype.__proto__  === A.prototype  //true</span><br><span class="line"></span><br><span class="line">//B的实例继承A的实例</span><br><span class="line">Object.setPrototypeOf(B.prototype,A.prototype);</span><br><span class="line">//B继承A的静态属性</span><br><span class="line">Object.setPrototypeOf(B,A);</span><br><span class="line"></span><br><span class="line">//Object.setPrototypeOf方法实现</span><br><span class="line">Object.setPrototypeOf = function(obj,proto)&#123;</span><br><span class="line">	obj.__proto__ = proto;</span><br><span class="line">	return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</p>
<p>上面代码的<code>A</code>，只要是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p>
<p>以下两种特殊情况</p>
<ul>
<li>子类继承Object类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A extends Object&#123;&#125;</span><br><span class="line">A.__proto__ === Object  //true</span><br><span class="line">A.prototype.__proto__ === Object.prototype  //true</span><br><span class="line">//A其实就是构造函数Object的复制，A的实例就是Object的实例</span><br></pre></td></tr></table></figure>

<ul>
<li>不存在任何继承</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">A.__proto__ === Function.prototype   //true</span><br><span class="line">A.prototype.__proto__ === Object.prototype   //true</span><br></pre></td></tr></table></figure>

<p>A作为一个基类，即不存在任何继承，就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象即object实例，所以<code>A.prototype.__proto__</code>指向构造函数Object的prototype属性。</p>
<h4 id="module模块"><a href="#module模块" class="headerlink" title="module模块"></a>module模块</h4><ul>
<li>ES6之前，社区制定了一些模块加载方案。主要是CommonJS——服务器，AMD——浏览器。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// CommonJS模块,运行时加载，无法做到“运行时加载”</span><br><span class="line">let &#123; stat, exists, readFile &#125; = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">let _fs = require(&apos;fs&apos;);</span><br><span class="line">let stat = _fs.stat;</span><br><span class="line">let exists = _fs.exists;</span><br><span class="line">let readfile = _fs.readfile;</span><br></pre></td></tr></table></figure>

<ul>
<li>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ES6模块</span><br><span class="line">import &#123; stat, exists, readFile &#125; from &apos;fs&apos;;</span><br></pre></td></tr></table></figure>

<p>上面代码的实质是从<code>fs</code>模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>
<p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p>
<ul>
<li>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li>
<li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li>
<li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li>
</ul>
<p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p>
<h6 id="严格模式主要有以下限制。"><a href="#严格模式主要有以下限制。" class="headerlink" title="严格模式主要有以下限制。"></a>严格模式主要有以下限制。</h6><ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用<code>with</code>语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀 0 表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li>
<li><code>eval</code>不会在它的外层作用域引入变量</li>
<li><code>eval</code>和<code>arguments</code>不能被重新赋值</li>
<li><code>arguments</code>不会自动反映函数参数的变化</li>
<li>不能使用<code>arguments.callee</code></li>
<li>不能使用<code>arguments.caller</code></li>
<li>禁止<code>this</code>指向全局对象</li>
<li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li>
<li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li>
</ul>
<p>其中，尤其需要注意<code>this</code>的限制。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code></p>
<h6 id="exprot与import"><a href="#exprot与import" class="headerlink" title="exprot与import"></a>exprot与import</h6><ul>
<li>export写法：必须提供对外的接口。实质是在接口名与模块内部变量之间建立一一对应的关系。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">export 1;</span><br><span class="line">// 报错</span><br><span class="line">var m = 1; </span><br><span class="line">export m;</span><br><span class="line"></span><br><span class="line">// 写法一</span><br><span class="line">export var m = 1;</span><br><span class="line">// 写法二</span><br><span class="line">var m = 1;</span><br><span class="line">export &#123;m&#125;;</span><br><span class="line">// 写法三</span><br><span class="line">var n = 1;</span><br><span class="line">export &#123;n as m&#125;;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">export f;</span><br><span class="line">// 正确</span><br><span class="line">export function f() &#123;&#125;;</span><br><span class="line">// 正确</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">export &#123;f&#125;;</span><br></pre></td></tr></table></figure>

<p><code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p>
<ul>
<li><code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。<code>import</code>命令是编译阶段执行的，在代码运行之前。</li>
<li>使用export  default 时，对应的import语句不需要使用大括号；使用export时，对应的import语句需要使用大括号。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default function crc32()&#123;&#125;</span><br><span class="line">import crc32 from &apos;crc32&apos;;</span><br><span class="line"></span><br><span class="line">export function crc32()&#123;&#125;</span><br><span class="line">import &#123;crc32&#125; from &apos;crc32&apos;;</span><br></pre></td></tr></table></figure>

<p>export  default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export  default命令只能使用一次。故import后面才不用加大括号，因为只可能唯一对应export  default命令。</p>
<p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// modules.js</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x * y;</span><br><span class="line">&#125;</span><br><span class="line">export &#123;add as default&#125;;</span><br><span class="line">// 等同于</span><br><span class="line">// export default add;</span><br><span class="line"></span><br><span class="line">// app.js</span><br><span class="line">import &#123; default as foo &#125; from &apos;modules&apos;;</span><br><span class="line">// 等同于</span><br><span class="line">// import foo from &apos;modules&apos;;</span><br></pre></td></tr></table></figure>

<h6 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h6><ul>
<li>浏览器异步加载js脚本的方法。<code>&lt;script&gt;</code>标签遇到defer或async属性，脚本就会异步加载，渲染引擎遇到这一命令就会开始下载外部脚本，但不会等他下载和执行，而是直接执行后面的命令。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;&quot;  defer&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;&quot;  async&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>defer与async的区别</strong></p>
<p>defer要等到整个页面在内存中正常渲染结束（DOM结构完全生成，以及脚本执行），才会执行。<strong>渲染完再执行</strong>，若有多个defer脚本，则按顺序加载。</p>
<p>async是<strong>下载后执行</strong>，即一旦下载完成，渲染引擎就会中断渲染执行这个脚本后再继续渲染。故不能保证加载顺序。</p>
<ul>
<li>加载ES6模块,对于带有<code>type=&quot;module&quot;</code>的脚本都是异步加载，相当于默认是defer属性，<strong>渲染完再加载</strong>，可设为async属性。</li>
</ul>
<p><code>&lt;script type=&quot;module&quot; src=&quot;&quot;&gt;&lt;/script&gt;</code></p>
<ul>
<li>外部脚本注意事项：<ul>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>
<li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li>
<li>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li>
<li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li>
<li>同一个模块如果加载多次，将只执行一次。</li>
</ul>
</li>
</ul>
<h6 id="ES6模块与CommonJS模块的差异"><a href="#ES6模块与CommonJS模块的差异" class="headerlink" title="ES6模块与CommonJS模块的差异"></a>ES6模块与CommonJS模块的差异</h6><ul>
<li>commonJS模块输出的是一个值的拷贝，且运行时加载。<ul>
<li>值拷贝表明一旦输出后，内部值的改变不影响这个值。</li>
</ul>
</li>
<li>ES6模块输出的是值的引用，编译时输出接口。<ul>
<li>JS引擎对脚本静态分析时，遇到模块加载命令import就会生成一个只读引用，等到脚本真正执行时再根据这个只读引用到被加载模块取值。</li>
</ul>
</li>
</ul>
<h6 id="CommonJS加载原理"><a href="#CommonJS加载原理" class="headerlink" title="CommonJS加载原理"></a>CommonJS加载原理</h6><ul>
<li>CommonJS（加载时执行）的一个模块就是一个脚本文件，require命令第一次加载该脚本就会执行整个脚本，然后在内存生成一个对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	//node内部加载模块完成后生成的对象</span><br><span class="line">	id:&apos;...&apos;,	//模块名</span><br><span class="line">	exports:&#123;...&#125;,	//模块输出的各个接口</span><br><span class="line">	loaded:true,	//该模块脚本是否执行完毕</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以后用到这个模块时就回到exports属性上取值，即使再执行require也不会再次执行该模块而是到缓存中取值，即CommonJS无论加载多少次都只在第一次加载时运行一次，以后再加载只会返回第一次加载的结果，除非手动清除缓存。</p>
<h6 id="ES6模块转码"><a href="#ES6模块转码" class="headerlink" title="ES6模块转码"></a>ES6模块转码</h6><ul>
<li>Babel</li>
<li>转码器：ES6 module transpiler（将es6转为CommonJS或AMD模块）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm i -g es6-module-transpiler</span><br><span class="line">//转码</span><br><span class="line">compile-modules convert file1.js file2.js</span><br><span class="line">//-o指定转码后的文件名</span><br><span class="line">compile-modules convert -o out.js file1.js</span><br></pre></td></tr></table></figure>

<ul>
<li>在网页中导入system.js文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;system.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	//使用System.import加载模块文件,返回Promise对象</span><br><span class="line">	System.import(&apos;./模块文件&apos;).then(function()&#123;&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h4><ul>
<li>注意区分Object与Map，只有模拟现实世界的实体对象时才使用Object。如果只是需要key：value的数据结构，使用Map结构，因其有内建的遍历机制。</li>
<li>总是用class代替prototype操作。使用extends实现继承，不会破环instanceof运算的危险。</li>
<li>模块默认输出一个函数，函数名首字母应该小写，默认输出对象时，对象名首字母大写。</li>
</ul>
<h4 id="异步遍历器"><a href="#异步遍历器" class="headerlink" title="异步遍历器"></a>异步遍历器</h4><ul>
<li>Iterator接口是一种数据遍历的协议，只要调用遍历器对象的next方法就会得到一个对象，表示当前遍历指针所在的那个位置的信息。next方法必须是同步的，返回value和done两个属性值。</li>
<li>若next方法是一个异步操作，可将异步操作包装成Thunk函数或Promise对象，即next方法的返回值的value属性是一个Thunk函数或Promise对象，等待以后返回真正的值，而done则还是同步操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function idMaker()&#123;</span><br><span class="line">	let index = 0;</span><br><span class="line">	return &#123;</span><br><span class="line">		next:function()&#123;</span><br><span class="line">			return&#123;</span><br><span class="line">				value:new Promise(resolve =&gt; setTimeOut(() =&gt; resolve(index++),1000)),</span><br><span class="line">				done:false</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">const it = idMaker();</span><br><span class="line">it.next().value.then(o =&gt; console.log(o))  //1</span><br><span class="line">it.next().value.then(o =&gt; console.log(o))  //2</span><br></pre></td></tr></table></figure>

<ul>
<li>一个对象的同步遍历器的接口部署在Symbol.iterator属性上。</li>
<li>for…of遍历同步的iterator接口，<code>for await...of</code>循环遍历异步的Iterator接口。createAsyncIterable()返回一个拥有一部遍历器接口的对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function f()&#123;</span><br><span class="line">	for await (const x of createAsyncIterable([&apos;a&apos;,&apos;b&apos;]))&#123;</span><br><span class="line">		console.log(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//a   b</span><br></pre></td></tr></table></figure>

<ul>
<li>异步Generator函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async function* map()&#123; yield &apos;hello&apos;; &#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-vue学习中的问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/28/vue学习中的问题/" class="article-date">
      <time datetime="2020-04-28T04:47:51.000Z" itemprop="datePublished">2020-04-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/vue学习中的问题/">vue学习中的问题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h6 id="登陆切换input复用问题"><a href="#登陆切换input复用问题" class="headerlink" title="登陆切换input复用问题"></a>登陆切换input复用问题</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;span v-if=&quot;isUser&quot;&gt;</span><br><span class="line">            &lt;label for=&quot;userName&quot;&gt;用户账号&lt;/label&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; id=&quot;userName&quot; placeholder=&quot;用户账号&quot; key=&quot;name&quot;&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &lt;span v-else&gt;</span><br><span class="line">            &lt;label for=&quot;email&quot;&gt;用户账号&lt;/label&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; id=&quot;email&quot; placeholder=&quot;用户邮箱&quot; key=&quot;email&quot;&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &lt;button @click=&quot;isUser = !isUser&quot;&gt;切换&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>如果我们在输入内容的情况下切换了类型，我们会发现文字依然显示之前的输入内容。按道理来讲，我们应该切换到另外一个input元素中，在另外这个元素中，我们并没有输入内容，所以应该是空的才对？</p>
<p>这是因为Vue在进行DOM渲染时，出于性能考虑，会尽可能的复用已经存在的元素，而不是重新创建新的元素。</p>
<p>解决：</p>
<p>给对应的input添加不同的key，当进行DOM渲染时，就会识别为不同的元素。</p>
<h6 id="vue管道机制部署"><a href="#vue管道机制部署" class="headerlink" title="vue管道机制部署"></a>vue管道机制部署</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 即前一个函数的输出是后一个函数的输入</span><br><span class="line">const pipeline = (...func) =&gt; val =&gt; func.reduce((a,b) =&gt; b(a),val);</span><br></pre></td></tr></table></figure>

<h6 id="尾调用解决递归"><a href="#尾调用解决递归" class="headerlink" title="尾调用解决递归"></a>尾调用解决递归</h6><p>函数调用自身称为递归。若尾调用自己就称为尾递归。</p>
<p>递归非常耗内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误，但对于尾调用则不会。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 递归</span><br><span class="line">function factorial(n)&#123;</span><br><span class="line">	if(n === 1)  return 1;</span><br><span class="line">	return n*factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 尾调用</span><br><span class="line">function factorial(n,total)&#123;</span><br><span class="line">	if(n === 1)  return total;</span><br><span class="line">	return factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归复杂度为O(n),尾递归的复杂度为O(1)。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-计算机网络" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/27/计算机网络/" class="article-date">
      <time datetime="2020-04-27T12:38:05.000Z" itemprop="datePublished">2020-04-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/27/计算机网络/">计算机网络</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><h6 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h6><p>应用层：所有能产生网络流量的程序，如qq，需要联网才能正常操作，是网络服务与用户的一个接口。</p>
<p>协议有：HTTP   FTP   TFTP   SMTP    SNMP    DNS   TELNET   HTTPS    POP3     DHCP。</p>
<p>应用层安全</p>
<ol>
<li>开发的应用程序没有漏洞。</li>
</ol>
<h6 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h6><p>表示层：在传输之前是否进行加密或压缩处理，以及数据在传输的时候是以ASCII码形式传输还是二进制形式传输。一般如果编码格式不对，页面就不能正常加载，会出现乱码现象。（如我传输过来的是utf-8，却以unicode格式来解析网页，势必会出现乱码现象）。</p>
<p>格式有： JPEG       ASCII     EBCDIC       加密格式等。</p>
<h6 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h6><p>cmd命令行中运行netstat -n可查看会话连接情况，状态为<code>ESTABISHED</code>表示已经建立的会话，<code>TIME_WAIT</code>表示这些会话快释放了。</p>
<p>会话层可用于查木马（盗号木马，如qq被盗，别人就可以给你邮箱发一些东西。远程登录木马，就可以远程登录你的电脑），因为木马总是要和外面建立会话，故可以通过<code>netstat -nb</code>查看建立会话的程序是谁，如果是木马就可以发现了。</p>
<p>建立，管理，终止会话，在五层模型中已经合并到应用层。</p>
<p>对应主机进程，指本地主机与远程主机正在进行会话。</p>
<h6 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h6><p>传输层可进行可靠或不可靠的传输，以及流量控制。定义传输数据的协议端口号，以及流控和差错校验。</p>
<p>协议有：TCP,UDP，数据包一旦离开网卡即进入网络传输层。</p>
<h6 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h6><p>网络层负责选择最佳路径以及规划IP地址（IPv4变为IPv6，只改变网络层）。划分局域段，这是网络层的升级。进行逻辑地址寻址，实现不同网络之间的路径选择。</p>
<p>协议有：ICMP  IGMP  IP(IPv4   IPv4)。</p>
<p>网络层故障：</p>
<ol>
<li>配置错误的IP地址，子网掩码。</li>
<li>配置错误的网关（网关是网络的出口）。</li>
<li>路由器没有配置到达目标网络的路由。</li>
</ol>
<p>网络层安全</p>
<ol>
<li>在路由器上使用ACL控制数据包流量。</li>
</ol>
<h6 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h6><p>数据链路层可以标识帧的开始和结尾（特殊符号标识开始和结尾），透明传输（如果中间内容有与标识结尾的标识符相同，会在该内容前加上某些字符告知交换机此处不是结尾），差错校验（会在后面加上一些字符作为校验位）。交换机中将光纤由百兆升级为千兆，这是数据链路层的知识。</p>
<p>建立逻辑连接，进行硬件地址寻址，差错校验等功能，由底层网络定义协议。将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</p>
<p>数据链路层故障：</p>
<ol>
<li>MAC地址冲突，我们知道一般MAC地址都是唯一的，电脑生产时就已经定义好每台电脑对应的MAC地址，但是我们设置电脑的MAC地址为某台电脑的MAC地址，这样就可能造成MAC地址冲突。</li>
<li>当ADSL欠费，电信就会阻断通信。</li>
<li>网速没办法协商也会出现，服务器规定网速为千兆，而电脑网速为百兆。</li>
<li>计算机连接到错误的VLAN。</li>
</ol>
<p>网络安全</p>
<ol>
<li>ADSL需要输入账号密码。</li>
<li>VLAN交换机端口绑定MAC地址。</li>
</ol>
<h6 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h6><p>规范了一些接口标准（比如各个公司生产的网卡固定了几根线），电器标准（例如0V代表低电平0，5V代表高电平1）以及规定如何在物理链路上传输更快的速度。更换通信介质，更换通信设备是物理层。</p>
<p>建立，维护，断开物理连接，由底层网络定义协议。</p>
<p>物理层故障，在控制面板——&gt; 所有控制面板项——&gt; 网络和共享中心——&gt; 找到已连接网络，点击查看WLAN状态，如果数据包发送不为0，但接收为0，表示是物理层故障，需要检查线是否完好，或重新接好线。</p>
<h4 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h4><p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E6%A8%A1%E5%9E%8B.png" alt="模型"></p>
<p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E4%BC%A0%E8%BE%93.PNG" alt="传输"></p>
<p>FCS:校验位。</p>
<h6 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h6><p>TCP提供了</p>
<ol>
<li>无差错的数据传输。</li>
<li>按序传输（数据总是会按照发送的顺序到达）。</li>
<li>未分段数据流（可以在任意时刻以任意尺寸将数据发送出去）。</li>
<li></li>
</ol>
<h4 id="网络的性能"><a href="#网络的性能" class="headerlink" title="网络的性能"></a>网络的性能</h4><h6 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h6><p>连接在计算机网络上的主机在数字信道上传送数据位数的速率，也称为data rate或bit rate。单位是b/s,  kb/s,  Mb/s,  Gb/s。</p>
<h6 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h6><p>数据通信领域中，数字信道所能传送的最高数据率。</p>
<h6 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h6><p>在单位时间内通过某个网络的数据量。</p>
<h6 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h6><ol>
<li><p>发送时延</p>
<p>发送时延 = 数据块长度（比特）/ 信道带宽（比特/秒）</p>
</li>
<li><p>传播时延</p>
</li>
<li><p>处理时延</p>
</li>
<li><p>排队时延</p>
</li>
</ol>
<h6 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h6><h6 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h6><h6 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h6><ol>
<li>信道利用率：有数据通过时间 / （有+无）数据通过时间</li>
<li>网络利用率：信道利用率加权平均值</li>
</ol>
<p>D = D0 / 1-U</p>
<p>D0 :表示网络空闲时的时延</p>
<p>D：表示信道利用率</p>
<p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1.PNG" alt="数据通信"></p>
<h4 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h4><h6 id="数据通信的术语"><a href="#数据通信的术语" class="headerlink" title="数据通信的术语"></a>数据通信的术语</h6><p>通信的目的是传送消息。</p>
<p>数据（data）—— 运送消息的实体。</p>
<p>信号（signal）——数据的消息或电磁的表现。</p>
<p>“模拟信号” —— 代表消息的参数的取值是连续的。</p>
<p>“数字信号” —— 代表消息的参数的取值是离散的。</p>
<p>码元（code）—— 在使用时间域的波形表示数字信号时，则代表不同离散数值的基本波形就成为码元。</p>
<p>在数字通信中常常使用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元。而这个间隔被称为码元长度。1码元可以携带nbit的信息量。</p>
<h6 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h6><p>信道一般表示向一个方向传送信息的媒体，所以我们说平常的通信线路往往包含一条发送信息的信道和一条接收信息的通道。</p>
<p><strong>单向通信</strong>（单工通信）——只能有一个方向的通信而没有反方向的交互。</p>
<p><strong>双向交替通信</strong>（半双工通信）——通信双方都可以发送信息，但不能双方同时发送/接收。</p>
<p><strong>双向同时通信</strong>（全双工通信）——通信双方可以同时发送或接收信息。</p>
<h6 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h6><p><strong>基带信号</strong>（即基本频带信号）——来自信源的信号。像计算机输出的表示各种文字或图像文件的数据信号都属于基带信号，比如我们说话的声带就是基带信号。</p>
<p><strong>带通信号</strong>——把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。</p>
<p>因此在传输距离较近时，计算机网络都采用基带传输方式，由于近距离范围内基带信号的衰减不大，从而信号内容不会发生变化，因此在传输距离较近时，计算机网络采用基带传输方式。如从计算机到监视器，打印机等外设的信号就是基带传输的。</p>
<p><strong>调幅（AM）</strong>：载波的振幅随基带数字信号而变化。</p>
<p><strong>调频（FM)</strong>：载波的频率随基带数字信号而变化。</p>
<p><strong>调相（PM)</strong>:载波的初始相位随基带数字信号而变化。</p>
<p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E8%B0%83%E9%A2%91.PNG" alt="调频"></p>
<h6 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h6><p>物理层设备集线器的工作特点是在网络中只起到信号放大和重发作用，其目的是扩大网络的传输范围，而不具备信号的定向传送能力。它是一个大的冲突域，因为当一台电脑发送给集线器后，集线器会把该内容转发给连接在集线器上的其他电脑，当其他电脑接收到内容后先对比该内容的MAC地址与自己电脑的MAC地址，相同则进行处理，不同者不做处理，但是我们可以把数据爬出来。</p>
<h6 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h6><p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8.PNG" alt="信道复用">**</p>
<p><strong>频分复用技术FDM(Frequency  Division  Multiplexing)</strong>：用户在分配到一定的频带后在通信过程中自始自终都占用这个频带。频分复用的所有用户在相同时间内占用不同的带宽资源，请注意，这里的“带宽”是频率带宽而不是数据的发送速率。</p>
<p><strong>时分复用技术TDM(Time Division Multiplexing)</strong>是将时间划分为一段段等长的时分复用帧，每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，在不同时间内占用相同的频带宽度。<img src="C:%5CUsers%5CCCY%5CDesktop%5C%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8.PNG" alt="时分复用"></p>
<p>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</p>
<p><strong>统计时分复用</strong>：通过标记是哪个VLAN。</p>
<h6 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h6><p>xDSL(用数字技术对现有的模拟电话用户线进行改造)</p>
<p>标准模拟电话信号的频带被限制在300<del>3400Hz的范围内，但用户线本身实际可通过的信号频率仍然超过1MHz。xDSL技术把0</del>4kHz低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。</p>
<h4 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>数据链路层使用的信道主要有以下两种类型：</p>
<ol>
<li>点对点信道。这种信道使用一对一的点对点通信方式。</li>
<li>广播通信。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。</li>
</ol>
<h6 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h6><p>链路（link）是一条点到点的物理路线，中间没有任何其他的交换结点，一条链路只是一条通路的组成部分。</p>
<p>数据链路（data  link）除了物理线路外，还必须有通信协议来控制这些数据的传输，若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p>
<p>现最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。</p>
<p>一般的适配器都包括了数据链路层和物理层这两层的功能。</p>
<h6 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h6><p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93.PNG" alt="透明传输"></p>
<h6 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h6><p>传输过程中可能会产生比特差错，1可能变成0而0也可能变成1.在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER(Bit  Error  Rate)。</p>
<p>误码率与信噪比有很大的关系，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采取各种差错检测措施。</p>
<h6 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h6><p>现在全世界使用最多的数据链路层协议是点对点协议PPP(Point-to-Point Protocol)。</p>
<p>用户使用拨号电话线接入因特网时一般都是使用PPP协议。</p>
<p>PPP协议应该满足的要求：</p>
<ol>
<li>简单——这是首要的要求</li>
<li>封装成帧。</li>
<li>透明性。</li>
<li>多种网络层协议。</li>
<li>差错检测。</li>
<li>检测连接状态。</li>
<li>最大传送单元。</li>
<li>网络层地址协商。</li>
<li>数据压缩协商。</li>
</ol>
<p>PPP协议不满足的要求：</p>
<ol>
<li>纠错。</li>
<li>流量控制。</li>
<li>序号。</li>
<li>多点线路。</li>
<li>半双工或单工链路。</li>
</ol>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200429135924281.png" alt="image-20200429135924281"></p>
<p>7E是结束和开头标志，FCS用于差错校验。</p>
<p><strong>PPP协议工作状态</strong>：当用户拨号接入ISP时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。PC机向路由器发送一系列的LCP分组（封装成多个PPP帧），这些分组及其响应选择一些PPP参数，和进行网络层配置，NCP给新接入的PC机分配一个临时的IP地址，使PC机成为因特网上的一个主机。通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。接着，LCP释放数据链路层连接，最后释放的是物理层的连接。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-数据结构与算法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/27/数据结构与算法/" class="article-date">
      <time datetime="2020-04-27T12:36:59.000Z" itemprop="datePublished">2020-04-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/27/数据结构与算法/">数据结构与算法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><img src="https://user-gold-cdn.xitu.io/2019/8/28/16cd6d6deb3a6f8f?imageView2/0/w/1280/h/960/ignore-error/1" alt="数组方法大全"></p>
<h6 id="数组解构赋值应用"><a href="#数组解构赋值应用" class="headerlink" title="数组解构赋值应用"></a>数组解构赋值应用</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 交换变量</span><br><span class="line">[a, b] = [b, a]</span><br><span class="line">[o.a, o.b] = [o.b, o.a]</span><br><span class="line">// 生成剩余数组</span><br><span class="line">const [a, ...rest] = [...&apos;asdf&apos;] // a：&apos;a&apos;，rest: [&quot;s&quot;, &quot;d&quot;, &quot;f&quot;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h6 id="数组浅拷贝"><a href="#数组浅拷贝" class="headerlink" title="数组浅拷贝"></a>数组浅拷贝</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3]</span><br><span class="line">const arrClone = [...arr]</span><br><span class="line">// 对象也可以这样浅拷贝</span><br><span class="line">const obj = &#123; a: 1 &#125;</span><br><span class="line">const objClone = &#123; ...obj &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>浅拷贝方法有很多如<code>arr.slice(0, arr.length)/Arror.from(arr)</code>等，但是用了<code>...</code>操作符之后就不会再想用其他的了~</p>
<h6 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [1, 2, 3]</span><br><span class="line">const arr2 = [4, 5, 6]</span><br><span class="line">const arr3 = [7, 8, 9]</span><br><span class="line">const arr = [...arr1, ...arr2, ...arr3]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>arr1.concat(arr2, arr3)</code>同样可以实现合并，但是用了<code>...</code>操作符之后就不会再想用其他的了~</p>
<h6 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 1, 2, 2, 3, 4, 5, 5]</span><br><span class="line">const newArr = [...new Set(arr)]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>new Set(arr)</code>接受一个数组参数并生成一个set结构的数据类型。set数据类型的元素不会重复且是<code>Array Iterator</code>，所以可以利用这个特性来去重。</p>
<h6 id="数组取交集"><a href="#数组取交集" class="headerlink" title="数组取交集"></a>数组取交集</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a = [0, 1, 2, 3, 4, 5]</span><br><span class="line">const b = [3, 4, 5, 6, 7, 8]</span><br><span class="line">const duplicatedValues = [...new Set(a)].filter(item =&gt; b.includes(item))</span><br><span class="line">duplicatedValues // [3, 4, 5]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h6 id="数组取差集"><a href="#数组取差集" class="headerlink" title="数组取差集"></a>数组取差集</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = [0, 1, 2, 3, 4, 5]</span><br><span class="line">const b = [3, 4, 5, 6, 7, 8]</span><br><span class="line">const diffValues = [...new Set([...a, ...b])].filter(item =&gt; !b.includes(item) || !a.includes(item)) // [0, 1, 2, 6, 7, 8]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h6 id="数组转对象"><a href="#数组转对象" class="headerlink" title="数组转对象"></a>数组转对象</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4]</span><br><span class="line">const newObj = &#123;...arr&#125; // &#123;0: 1, 1: 2, 2: 3, 3: 4&#125;</span><br><span class="line">const obj = &#123;0: 0, 1: 1, 2: 2, length: 3&#125;</span><br><span class="line">// 对象转数组不能用展开操作符，因为展开操作符必须用在可迭代对象上</span><br><span class="line">let newArr = [...obj] // Uncaught TypeError: object is not iterable...</span><br><span class="line">// 可以使用Array.form()将类数组对象转为数组</span><br><span class="line">let newArr = Array.from(obj) // [0, 1, 2]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h6 id="数组摊平"><a href="#数组摊平" class="headerlink" title="数组摊平"></a>数组摊平</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;a: &apos;群主&apos;, b: &apos;男群友&apos;, c: &apos;女裙友&apos;, d: &apos;未知性别&apos;&#125;</span><br><span class="line">const getName = function (item) &#123; return item.includes(&apos;群&apos;)&#125;</span><br><span class="line">// 方法1</span><br><span class="line">const flatArr = Object.values(obj).flat().filter(item =&gt; getName(item))</span><br><span class="line">// 经大佬指点，更加简化（发现自己的抽象能力真的差~）</span><br><span class="line">const flatArr = Object.values(obj).flat().filter(getName)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>二维数组用<code>array.flat()</code>，三维及以上用<code>array.flatMap()</code>。</p>
<h6 id="数组常用遍历"><a href="#数组常用遍历" class="headerlink" title="数组常用遍历"></a>数组常用遍历</h6><p>数组常用遍历有 <code>forEach、every、some、filter、map、reduce、reduceRight、find、findIndex</code> 等方法，很多方法都可以达到同样的效果。数组方法不仅要会用，而且要用好。要用好就要知道什么时候用什么方法。</p>
<h6 id="遍历的混合使用"><a href="#遍历的混合使用" class="headerlink" title="遍历的混合使用"></a>遍历的混合使用</h6><p><code>filter</code>、<code>map</code>方法返回值仍旧是一个数组，所以可以搭配其他数组遍历方法混合使用。注意遍历越多效率越低~</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> value = arr</span><br><span class="line">    .map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">3</span>)</span><br><span class="line">    .filter(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">item</span> =&gt;</span> item + <span class="number">1</span>)</span><br><span class="line">    .reduce(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> prev + curr, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h6 id="检测数组所有元素是否都符合判断条件"><a href="#检测数组所有元素是否都符合判断条件" class="headerlink" title="检测数组所有元素是否都符合判断条件"></a>检测数组所有元素是否都符合判断条件</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> isAllNum = arr.every(<span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">typeof</span> item === <span class="string">'number'</span>)</span><br></pre></td></tr></table></figure>

<h6 id="检测数组是否有元素符合判断条件"><a href="#检测数组是否有元素符合判断条件" class="headerlink" title="检测数组是否有元素符合判断条件"></a>检测数组是否有元素符合判断条件</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> hasNum = arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">typeof</span> item === <span class="string">'number'</span>)</span><br></pre></td></tr></table></figure>

<h6 id="找到第一个符合条件的元素-下标"><a href="#找到第一个符合条件的元素-下标" class="headerlink" title="找到第一个符合条件的元素/下标"></a>找到第一个符合条件的元素/下标</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> findItem = arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="number">3</span>) <span class="comment">// 返回子项</span></span><br><span class="line"><span class="keyword">const</span> findIndex = arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="number">3</span>) <span class="comment">// 返回子项的下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> findIndex</span><br><span class="line">arr.find(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item === <span class="number">3</span>) &#123;</span><br><span class="line">        findIndex = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="数组使用误区"><a href="#数组使用误区" class="headerlink" title="数组使用误区"></a>数组使用误区</h6><p>数组的方法很多，很多方法都可以达到同样的效果，所以在使用时要根据需求使用合适的方法。</p>
<p>垃圾代码产生的很大原因就是数组常用方法使用不当，这里有以下需要注意的点：</p>
<p><strong>array.includes() 和 array.indexOf()</strong></p>
<p><code>array.includes()</code> 返回布尔值，<code>array.indexOf()</code> 返回数组子项的索引。<code>indexOf</code> 一定要在需要索引值的情况下使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用indexOf，需要用到索引值</span></span><br><span class="line"><span class="keyword">const</span> index = arr.indexOf(<span class="number">1</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">if</span> (~index) &#123; <span class="comment">// 若index === -1，~index得到0，判断不成立；若index不为-1，则~index得到非0，判断成立。</span></span><br><span class="line">    arr.spilce(index, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用includes，不需要用到索引值</span></span><br><span class="line"><span class="comment">// 此时若用indexOf会造成上下文上的阅读负担：到底其他地方有没有用到这个index?</span></span><br><span class="line"><span class="keyword">const</span> isExist = arr.includes(<span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (!isExist) &#123;</span><br><span class="line">    arr.push(<span class="number">6</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外评论区大佬指出，<code>array.indexOf()</code>找 <code>NaN</code> 会找不到，返回<code>-1</code>，<code>array.includes()</code>能找到，返回<code>true</code>~</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p><strong>array.find() 、 array.findIndex() 和 array.some()</strong></p>
<p><code>array.find()</code>返回值是第一个符合条件的数组子项，<code>array.findIndex()</code> 返回第一个符合条件的数组子项的下标，<code>array.some()</code> 返回有无复合条件的子项，如有返回<code>true</code>，若无返回<code>false</code>。注意这三个都是短路操作，即找到符合条件的之后就不在继续遍历。</p>
<p>在需要数组的子项的时候使用<code>array.find()</code> ；需要子项的索引值的时候使用 <code>array.findIndex()</code> ；而若只需要知道有无符合条件的子项，则用 <code>array.some()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [&#123;<span class="attr">label</span>: <span class="string">'男'</span>, <span class="attr">value</span>: <span class="number">0</span>&#125;, &#123;<span class="attr">label</span>: <span class="string">'女'</span>, <span class="attr">value</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">label</span>: <span class="string">'不男不女'</span>, <span class="attr">value</span>: <span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用some</span></span><br><span class="line"><span class="keyword">const</span> isExist = arr.some(<span class="function"><span class="params">item</span> =&gt;</span> item.value === <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> (isExist) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'哈哈哈找到了'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用find</span></span><br><span class="line"><span class="keyword">const</span> item = arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item.value === <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> (item) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item.label)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用findIndex</span></span><br><span class="line"><span class="keyword">const</span> index = arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item.value === <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> (~index) &#123;</span><br><span class="line">    <span class="keyword">const</span> delItem = arr[index]</span><br><span class="line">    arr.splice(index, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`你删除了<span class="subst">$&#123;delItem.label&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议在只需要布尔值的时候和数组子项是字符串或数字的时候使用 <code>array.some()</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当子包含数字0的时候可能出错</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> isExist = arr.some(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (isExist) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'存在要找的子项，很舒服~'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">const</span> isExist = arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (isExist) &#123; <span class="comment">// isExist此时是0，隐式转换为布尔值后是false</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行不到这里~'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当子项包含空字符串的时候也可能出错</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">''</span>, <span class="string">'asdf'</span>, <span class="string">'qwer'</span>, <span class="string">'...'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> isExist = arr.some(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="string">''</span>)</span><br><span class="line"><span class="keyword">if</span> (isExist) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'存在要找的子项，很舒服~'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">const</span> isExist = arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="string">''</span>)</span><br><span class="line"><span class="keyword">if</span> (isExist) &#123; <span class="comment">// isExist此时是''，隐式转换为布尔值后是false</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行不到这里~'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>array.find() 和 array.filter()</strong></p>
<p>只需要知道 <code>array.filter()</code> 返回的是所有符合条件的子项组成的数组，会遍历所有数组；而 <code>array.find()</code> 只返回第一个符合条件的子项，是短路操作。</p>
<h6 id="合理使用-Set-数据结构"><a href="#合理使用-Set-数据结构" class="headerlink" title="合理使用 Set 数据结构"></a>合理使用 Set 数据结构</h6><p>由于 es6 原生提供了 <code>Set</code> 数据结构，而 <code>Set</code> 可以保证子项不重复，且和数组转换十分方便，所以在一些可能会涉及重复添加的场景下可以直接使用 <code>Set</code> 代替 <code>Array</code>，避免了多个地方重复判断是否已经存在该子项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"><span class="keyword">set</span>.add(1)</span><br><span class="line"><span class="keyword">set</span>.add(1)</span><br><span class="line"><span class="keyword">set</span>.add(1)</span><br><span class="line"><span class="keyword">set</span>.size // 1</span><br><span class="line">const arr = [...<span class="keyword">set</span>] // arr: [1]</span><br></pre></td></tr></table></figure>

<h6 id="强大的reduce"><a href="#强大的reduce" class="headerlink" title="强大的reduce"></a>强大的reduce</h6><p><code>array.reduce</code> 遍历并将当前次回调函数的返回值作为下一次回调函数执行的第一个参数。</p>
<p>利用 <code>array.reduce</code> 替代一些需要多次遍历的场景，可以极大提高代码运行效率。</p>
<ol>
<li>利用<code>reduce</code> 输出一个数字/字符串</li>
</ol>
<p>假如有如下每个元素都由字母’s’加数字组成的数组<code>arr</code>，现在找出其中最大的数字：（<code>arr</code>不为空）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'s0'</span>, <span class="string">'s4'</span>, <span class="string">'s1'</span>, <span class="string">'s2'</span>, <span class="string">'s8'</span>, <span class="string">'s3'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1  进行了多次遍历，低效</span></span><br><span class="line"><span class="keyword">const</span> newArr = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item.substring(<span class="number">1</span>)).map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Number</span>(item))</span><br><span class="line"><span class="keyword">const</span> maxS = <span class="built_in">Math</span>.max(...newArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2  一次遍历</span></span><br><span class="line"><span class="keyword">const</span> maxS = arr.reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> curIndex = <span class="built_in">Number</span>(cur.replace(<span class="string">'s'</span>, <span class="string">''</span>))</span><br><span class="line">  <span class="keyword">return</span> curIndex &gt; prev ? curIndex : prev</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>利用<code>reduce</code> 输出一个数组/对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 方法1  遍历了两次，效率低</span></span><br><span class="line"><span class="keyword">const</span> value = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> (&#123; <span class="attr">value</span>: item &#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1  一次遍历，效率高</span></span><br><span class="line"><span class="keyword">const</span> value = arr.reduce(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> curr % <span class="number">2</span> === <span class="number">0</span> ? [...prev, curr] : prev</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>

<p>掌握了上面两种用法，结合实际需要，就可以用 <code>reduce/reduceRight</code> 实现各种奇巧淫技了。</p>
<p>实例：利用 <code>reduce</code> 做下面这样的处理来生成想要的 html 字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后端返回数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  <span class="string">'if _ then s9'</span>: [</span><br><span class="line">    <span class="string">'作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生'</span>,</span><br><span class="line">    <span class="string">'作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生'</span>,</span><br><span class="line">    <span class="string">'作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生'</span></span><br><span class="line">    ],</span><br><span class="line">  <span class="string">'if C then s4'</span>: [</span><br><span class="line">    <span class="string">'当有条件时时,结构构件满足要求,要求属于安全性、适用性和耐久性'</span>,</span><br><span class="line">    <span class="string">'当有条件时时,住宅结构满足要求,要求属于安全性、适用性和耐久性'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ifthens = <span class="built_in">Object</span>.entries(data).reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> values = cur[<span class="number">1</span>].reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;prev&#125;</span>&lt;p&gt;<span class="subst">$&#123;cur&#125;</span>&lt;/p&gt;`</span>, <span class="string">''</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;prev&#125;</span></span></span><br><span class="line"><span class="string">    &lt;li&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;<span class="subst">$&#123;cur[<span class="number">0</span>]&#125;</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;values&#125;</span></span></span><br><span class="line"><span class="string">    &lt;/li&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;ul class="nlp-notify-body"&gt;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;ifthens&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>生成的 html 结构如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">"nlp-notify-body"</span>&gt;            </span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;p&gt;<span class="keyword">if</span> _ then s9&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生&lt;/</span>p&gt;</span><br><span class="line">    &lt;p&gt;作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生&lt;/</span>p&gt;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;if C then s4&lt;/</span>p&gt;</span><br><span class="line">    &lt;p&gt;当有条件时时,结构构件满足要求,要求属于安全性、适用性和耐久性&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;当有条件时时,住宅结构满足要求,要求属于安全性、适用性和耐久性&lt;/</span>p&gt;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>

<p>这里还有一个替代 <code>reverse</code> 函数的技巧</p>
<p>由于 <code>array.reverse()</code> 函数会改变原数组自身，这样就限制了一些使用场景。如果我想要一个不会改变数组自身的 <code>reverse</code> 函数呢？拿走！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myReverse = <span class="function">(<span class="params">arr = []</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>  arr.reduceRight(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> [...prev, cur], []) <span class="comment">// 也可以返回逗号表达式 (prev.push(cur), prev)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><h6 id="用JavaScript封装栈"><a href="#用JavaScript封装栈" class="headerlink" title="用JavaScript封装栈"></a>用JavaScript封装栈</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 封装栈</span><br><span class="line">   function Stack()&#123;</span><br><span class="line">       // 栈中的属性</span><br><span class="line">       this.items = [];</span><br><span class="line">       // 栈中的相关操作</span><br><span class="line">       // 1.将元素压入栈中</span><br><span class="line">       Stack.prototype.push = function(element)&#123;</span><br><span class="line">		this.items.push(element);</span><br><span class="line">       &#125;;</span><br><span class="line">       // 2.将元素弹出栈中</span><br><span class="line">       Stack.prototype.pop = function()&#123;</span><br><span class="line">		return	this.items.pop();</span><br><span class="line">       &#125;;</span><br><span class="line">       // 3.查看一下栈顶元素</span><br><span class="line">       Stack.prototype.check = function()&#123;</span><br><span class="line">		return this.items[this.items.length - 1];</span><br><span class="line">       &#125;;</span><br><span class="line">       // 4.判断栈中是否有元素</span><br><span class="line">       Stack.prototype.isEmpty = function()&#123;</span><br><span class="line">		return this.items.length == 0;</span><br><span class="line">       &#125;;</span><br><span class="line">       // 5.获取栈中的元素的个数</span><br><span class="line">       Stack.prototype.size = function()&#123;</span><br><span class="line">		return this.items.length;</span><br><span class="line">       &#125;;</span><br><span class="line">       // 6.toString方法</span><br><span class="line">       Stack.prototype.toString = function()&#123;</span><br><span class="line">           // 方法一：</span><br><span class="line">           // var resultString = &apos;&apos;;</span><br><span class="line">           // for(var i = 0; i &lt; this.items.length; i ++)&#123;</span><br><span class="line">           // 	resultString += this.items[i] + &apos; &apos;;</span><br><span class="line">           // &#125;</span><br><span class="line">           // return resultString;</span><br><span class="line">           // 方法二：</span><br><span class="line">           return this.items.join(&apos; &apos;);</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>之所以不使用<code>this.push=function(){}</code>，而是采用原型的方法，是因为通过prototype原型的方法相当于给整个类添加了方法，而this.push方式则仅是给某个实例添加方法。</p>
<h6 id="用栈将十进制转为二进制"><a href="#用栈将十进制转为二进制" class="headerlink" title="用栈将十进制转为二进制"></a>用栈将十进制转为二进制</h6><ul>
<li>因为我们习惯使用十进制，而计算机里面的所有内容都是用二进制数字表示的（0和1）</li>
<li>可采用对十进制的数字进行除二取余法，将十进制转为二进制。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//函数：将十进制转为二进制</span><br><span class="line">function dec2bin(decNumber)&#123;</span><br><span class="line">    // 1.定义栈对象</span><br><span class="line">    var stack = new Stack();</span><br><span class="line">    while(decNumber &gt; 0)&#123;</span><br><span class="line">        stack.push(decNumber % 2);</span><br><span class="line">        decNumber = Math.floor(decNumber / 2);</span><br><span class="line">        console.log(decNumber)</span><br><span class="line">    &#125;</span><br><span class="line">    var binaryString = &apos;&apos;;</span><br><span class="line">    while(!stack.isEmpty())&#123;</span><br><span class="line">        binaryString += stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return binaryString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h6 id="队列结构"><a href="#队列结构" class="headerlink" title="队列结构"></a>队列结构</h6><ul>
<li><p>队列是一种受限的数据结构，可解决某些特定的问题。它的受限之处在于他只允许在表的前端（font）进行删除操作，而在表的后端（rear）进行插入操作。</p>
</li>
<li><p>队列的实现和栈一样有两种方案：</p>
<ul>
<li>基于数组实现</li>
<li>基于链表实现</li>
</ul>
</li>
<li><p>队列常见的操作</p>
<ul>
<li>enqueue(element)：向队列尾部添加一个或多个新的项。</li>
<li>dequeue（）：移除队列的第一（即排在队列最前面的）项，并返回移除的元素；</li>
<li>front（）：返回队列中第一个元素。</li>
<li>isEmpty（）：判断队列中是否含有元素。</li>
<li>size（）：返回队列中的元素个数。</li>
<li>toString（）：将队列中的内容转为字符串形式</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 用数组封装队列</span><br><span class="line">function Queue()&#123;</span><br><span class="line">this.item = [];</span><br><span class="line"></span><br><span class="line">// 1.添加元素</span><br><span class="line">Queue.prototype.enqueue = function(element)&#123;</span><br><span class="line">    this.item.push(element);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">// 2.移除元素</span><br><span class="line">Queue.prototype.dequeue = function()&#123;</span><br><span class="line">    return this.item.shift();</span><br><span class="line">&#125;;</span><br><span class="line">// 3.查看队列中第一个元素</span><br><span class="line">Queue.prototype.front = function()&#123;</span><br><span class="line">    return this.item[0];</span><br><span class="line">&#125;;</span><br><span class="line">// 4.判断元素是否为空</span><br><span class="line">Queue.prototype.isEmpty = function()&#123;</span><br><span class="line">    return this.item.length == 0;</span><br><span class="line">&#125;;</span><br><span class="line">// 5.队列中的元素个数</span><br><span class="line">Queue.prototype.size = function()&#123;</span><br><span class="line">    return this.item.length;</span><br><span class="line">&#125;;</span><br><span class="line">// 6.将队列中的内容转为字符串</span><br><span class="line">Queue.prototype.toString = function()&#123;</span><br><span class="line">    return this.item.join(&apos; &apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="队列击鼓传花"><a href="#队列击鼓传花" class="headerlink" title="队列击鼓传花"></a>队列击鼓传花</h6><ul>
<li>参数：所有参与人的性名，基于此的数字</li>
<li>结果：最终剩下的一人的姓名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> // 击鼓传花</span><br><span class="line">    function passGame(nameList, num) &#123;</span><br><span class="line">        //创建一个队列</span><br><span class="line">        var queue = new Queue();</span><br><span class="line">        // 将所有人加入队列中</span><br><span class="line">        for(var i = 0; i &lt; nameList.length; i++)&#123;</span><br><span class="line">            queue.enqueue(nameList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        // 不是num，重新加入队列末尾</span><br><span class="line">        // 是num时，从队列中删除并把不是num的值重新放入队列中</span><br><span class="line">        // 当队列中只剩下一人退出循环</span><br><span class="line">        while (queue.size() &gt; 1) &#123;</span><br><span class="line">            for (var i = 0; i &lt; num - 1; i++) &#123;</span><br><span class="line">                queue.enqueue(queue.dequeue());</span><br><span class="line">            &#125;</span><br><span class="line">            queue.dequeue();</span><br><span class="line">        &#125;</span><br><span class="line">        var index = nameList.indexOf(queue.front());</span><br><span class="line">        return queue.front();</span><br><span class="line">    &#125;// 击鼓传花</span><br><span class="line">function passGame(nameList, num) &#123;</span><br><span class="line">    //创建一个队列</span><br><span class="line">    var queue = new Queue();</span><br><span class="line">    // 将所有人加入队列中</span><br><span class="line">    for(var i = 0; i &lt; nameList.length; i++)&#123;</span><br><span class="line">        queue.enqueue(nameList[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    // 不是num，重新加入队列末尾</span><br><span class="line">    // 是num时，从队列中删除并把不是num的值重新放入队列中</span><br><span class="line">    // 当队列中只剩下一人退出循环</span><br><span class="line">    while (queue.size() &gt; 1) &#123;</span><br><span class="line">        for (var i = 0; i &lt; num - 1; i++) &#123;</span><br><span class="line">            queue.enqueue(queue.dequeue());</span><br><span class="line">        &#125;</span><br><span class="line">        queue.dequeue();</span><br><span class="line">    &#125;</span><br><span class="line">    var index = nameList.indexOf(queue.front());</span><br><span class="line">    return queue.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h6><ul>
<li>普通的队列插入一个元素，数据就会被放入后端，并且需要前面的所有元素处理完后才会处理前面的数据。但是优先级队列，在插入一个元素的的时候会考虑该数据的优先级。</li>
<li>和其他数据优先级进行比较，比较完成后可得出这个元素在队列中正确的位置。</li>
<li>优先级队列主要考虑的问题：<ul>
<li>每个元素不再只是一个数据，且包含数据的优先级。</li>
<li>在添加方式中，根据优先级放入正确的位置。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// 封装优先级队列</span><br><span class="line">function PriorityQueue() &#123;</span><br><span class="line">    // 内部类</span><br><span class="line">    function QueueElement(element, priority) &#123;</span><br><span class="line">        this.element = element;</span><br><span class="line">        this.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    // 封装属性</span><br><span class="line">    this.item = [];</span><br><span class="line">    // 实现插入方法</span><br><span class="line">    PriorityQueue.prototype.enqueue = function (element, priority) &#123;</span><br><span class="line">        // 创建QueueElement对象</span><br><span class="line">        var queueElement = new QueueElement(element, priority);</span><br><span class="line">        if (this.item.length == 0) &#123;</span><br><span class="line">            this.item.push(queueElement);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            let flag = false;</span><br><span class="line">            for (let i = 0; i &lt; this.item.length; i++) &#123;</span><br><span class="line">                if (queueElement.priority &lt; this.item[i].priority) &#123;</span><br><span class="line">                    this.item.splice(i, 0, queueElement);</span><br><span class="line">                    flag = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!flag) &#123;</span><br><span class="line">                this.item.push(queueElement);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.移除元素</span><br><span class="line">    PriorityQueue.prototype.dequeue = function () &#123;</span><br><span class="line">        return this.item.shift();</span><br><span class="line">    &#125;;</span><br><span class="line">    // 3.查看队列中第一个元素</span><br><span class="line">    PriorityQueue.prototype.front = function () &#123;</span><br><span class="line">        return this.item[0];</span><br><span class="line">    &#125;;</span><br><span class="line">    // 4.判断元素是否为空</span><br><span class="line">    PriorityQueue.prototype.isEmpty = function () &#123;</span><br><span class="line">        return this.item.length == 0;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 5.队列中的元素个数</span><br><span class="line">    PriorityQueue.prototype.size = function () &#123;</span><br><span class="line">        return this.item.length;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 6.将队列中的内容转为字符串</span><br><span class="line">    PriorityQueue.prototype.toString = function () &#123;</span><br><span class="line">       let result = &apos;&apos;;</span><br><span class="line">       for(let i = 0; i &lt; this.item.length; i++)&#123;</span><br><span class="line">           result += this.item[i].priority + &apos; &apos; + this.item[i].element + &apos; &apos;;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var priorityQueue = new PriorityQueue();</span><br><span class="line">priorityQueue.enqueue(&apos;nikita&apos;,10);</span><br><span class="line">priorityQueue.enqueue(&apos;nikita1&apos;,110);</span><br><span class="line">priorityQueue.enqueue(&apos;nikit2a&apos;,101);</span><br><span class="line">priorityQueue.enqueue(&apos;nikitak&apos;,210);</span><br><span class="line">console.log(priorityQueue.toString());</span><br></pre></td></tr></table></figure>

<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h6 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h6><p>要存储多个元素，有两个选择：数组和链表。</p>
<p>但不同于数组，链表中的元素在内存中不必是连续的空间，链表的每一个元素由一个存储元素本身的节点和指向下一个元素的引用（即指针）组成。</p>
<p>相对于数组，链表优势：</p>
<ol>
<li>内存不必连续，可充分利用计算机的内存，实现灵活的内存动态管理。</li>
<li>链表不必在创建时就确定大小，并且大小可以无限的延伸下去。</li>
<li>链表在插入和删除操作时，时间复杂度可达O（1），相对数组效率高很多。</li>
</ol>
<p>劣势：</p>
<ol>
<li>链表访问任何一个位置的元素都必须从头开始。（无法跳过第一个元素访问任何一个元素）。</li>
<li>无法通过下标直接访问元素，必须从头开始，直到找到元素。</li>
</ol>
<p>![1 (3)](C:\Users\CCY\Desktop\1 (3).png)</p>
<p>常见操作：</p>
<ol>
<li>append（element）：向链表尾部添加一个新的项。</li>
<li>insert（position,element）：向特定位置添加一个项</li>
<li>get（position）</li>
<li>indexOf（element）</li>
<li>update（position）：修改某个位置的元素</li>
<li>removeAt（position）</li>
<li>remove（element）</li>
<li>isEmpty()</li>
<li>size()</li>
<li>toString()</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">![4](C:\Users\CCY\Desktop\4.png)// 封装单向链表</span><br><span class="line">function LinkedList()&#123;</span><br><span class="line">    // 内部类，节点类</span><br><span class="line">    function Node(data)&#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.next = null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 定义属性</span><br><span class="line">    this.head = null;</span><br><span class="line">    this.length = 0;</span><br><span class="line"></span><br><span class="line">    // 追加append方法</span><br><span class="line">    LinkedList.prototype.append = function(data)&#123;</span><br><span class="line">        let newNode = new Node(data);</span><br><span class="line">        if(this.length == 0)&#123;</span><br><span class="line">            this.head = newNode;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let current = this.head;</span><br><span class="line">            while(current.next)&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        this.length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // toString方法</span><br><span class="line">    LinkedList.prototype.toString = function()&#123;</span><br><span class="line">        let resultString = &apos;&apos;;</span><br><span class="line">        let current = this.head;</span><br><span class="line">        while(current)&#123;</span><br><span class="line">            resultString += current.data + &apos; &apos;;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在任意位置加元素</span><br><span class="line">    LinkedList.prototype.insert = function(position,data)&#123;</span><br><span class="line">        // 对position进行边界判断</span><br><span class="line">        if(position &lt; 0 || position &gt; this.length)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let newNode = new Node(data);</span><br><span class="line">            let index = 0;</span><br><span class="line">            let previous = null;</span><br><span class="line">            let current = this.head;</span><br><span class="line">            while(index++ &lt; position)&#123;</span><br><span class="line">                previous = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            previous.next = newNode;</span><br><span class="line">            newNode.next = current;</span><br><span class="line">        &#125;</span><br><span class="line">        this.length++;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取对应位置的值</span><br><span class="line">    LinkedList.prototype.get = function(position)&#123;</span><br><span class="line">        // 对position边界判断</span><br><span class="line">        if(position &lt; 0 || position &gt;= this.length)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let current = this.head;</span><br><span class="line">            let index = 0;</span><br><span class="line">            while(index++ &lt; position)&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return current.data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回元素索引值indexOf，没有返回-1</span><br><span class="line">    LinkedList.prototype.indexOf = function(value)&#123;</span><br><span class="line">        let current = this.head;</span><br><span class="line">        let index = 0;</span><br><span class="line">        while(current)&#123;</span><br><span class="line">            if(current.data == value)&#123;</span><br><span class="line">                return index;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // update方法</span><br><span class="line">    LinkedList.prototype.update = function(position,value)&#123;</span><br><span class="line">        // 对position边界判断</span><br><span class="line">        if(position &lt; 0 || position &gt;= this.length)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let current = this.head;</span><br><span class="line">            let index = 0;</span><br><span class="line">            while(index++ &lt; position)&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.data = value;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在特定位置删除数据</span><br><span class="line">    LinkedList.prototype.removeAt = function(position)&#123;</span><br><span class="line">        // 方便后续返回里面的值</span><br><span class="line">        let current = this.head;</span><br><span class="line">        // 对position边界判断</span><br><span class="line">        if(position &lt; 0 || position &gt;= this.length)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let index = 0;</span><br><span class="line">            let previous = null;</span><br><span class="line">            while(index++ &lt; position)&#123;</span><br><span class="line">                previous = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = previous.next;</span><br><span class="line">        &#125;</span><br><span class="line">        this.length -= 1;</span><br><span class="line">        return current.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在列表中删除某个值</span><br><span class="line">    LinkedList.prototype.remove = function(value)&#123;</span><br><span class="line">        // 获取data在列表中的位置</span><br><span class="line">        let position = this.indexOf(value);</span><br><span class="line"></span><br><span class="line">        return this.removeAt(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 是否为空</span><br><span class="line">    LinkedList.prototype.isEmpty = function()&#123;</span><br><span class="line">        return !this.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 元素个数</span><br><span class="line">    LinkedList.prototype.size = function()&#123;</span><br><span class="line">        return this.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h6><p>既可以从头遍历到尾，又可以从尾遍历到头。</p>
<p>实现原理是：一个节点既有向前连接的引用，也有一个向后连接的引用。</p>
<p>但有以下缺点：</p>
<p>每次插入删除某个节点时，需要处理四个引用，而不是两个，也就是实现起来更困难一些。并且相当于单向链表，必然占用内存空间更大些。<img src="C:%5CUsers%5CCCY%5CDesktop%5C4.png" alt="4"></p>
<p>特点：</p>
<ol>
<li>可以使用一个head和一个tail分别指向头部和尾部的节点。</li>
<li>每个节点由三部分组成：前一个节点的指针（prev）/保存的元素（item）/后一个节点的指针（next）。</li>
<li>双向链表的第一个节点的prev是null，最后一个节点的next为null。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">// 封装双向链表</span><br><span class="line">function DoubleLinkedList()&#123;</span><br><span class="line">    // 内部节点类</span><br><span class="line">    function Node(data)&#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.prev = null;</span><br><span class="line">        this.next = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 内部属性</span><br><span class="line">    this.head = null;</span><br><span class="line">    this.tail = null;</span><br><span class="line">    this.length = 0;</span><br><span class="line"></span><br><span class="line">    // append追加方法</span><br><span class="line">    DoubleLinkedList.prototype.append = function(data)&#123;</span><br><span class="line">        let newNode = new Node(data);</span><br><span class="line">        if(this.length == 0)&#123;</span><br><span class="line">            this.head = newNode;</span><br><span class="line">            this.tail = newNode;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            newNode.prev = this.tail;</span><br><span class="line">            this.tail.next = newNode;</span><br><span class="line">            this.tail = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        this.length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 任意位置插入值</span><br><span class="line">    DoubleLinkedList.prototype.insert = function(position,value)&#123;</span><br><span class="line">        if(position &lt; 0 || position &gt;= this.length) return false;</span><br><span class="line">        let newNode = new Node(value);</span><br><span class="line">        // 原链表为空</span><br><span class="line">        if(this.length == 0)&#123;</span><br><span class="line">            this.prev = newNode;</span><br><span class="line">            this.tail = newNode;</span><br><span class="line">        &#125;else if(position == 0)&#123;</span><br><span class="line">            this.head.prev = newNode;</span><br><span class="line">            newNode.next = this.head;</span><br><span class="line">            this.head = newNode;</span><br><span class="line">        &#125;else if(position == this.length)&#123;</span><br><span class="line">            newNode.prev = this.tail;</span><br><span class="line">            this.tail.next = newNode;</span><br><span class="line">            this.tail = newNode;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let index = 0;</span><br><span class="line">            let current = this.head;</span><br><span class="line">            while(index++ &lt; position)&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            newNode.next = current;</span><br><span class="line">            newNode.prev = current.prev;</span><br><span class="line">            current.prev.next = newNode;</span><br><span class="line">            current.prev = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // get方法</span><br><span class="line">    DoubleLinkedList.prototype.get = function(position)&#123;</span><br><span class="line">        if(position &lt; 0 || position &gt;= this.length) return null;</span><br><span class="line">        let index = 0;</span><br><span class="line">        let current = this.head;</span><br><span class="line">        while(index++ &lt; position)&#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return current.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // indexOf方法</span><br><span class="line">    DoubleLinkedList.prototype.indexOf = function(value)&#123;</span><br><span class="line">        let index = 0;</span><br><span class="line">        let current = this.head;</span><br><span class="line">        while(current)&#123;</span><br><span class="line">            if(current.data == value)&#123;</span><br><span class="line">                return index;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // update方法</span><br><span class="line">    DoubleLinkedList.prototype.update = function(position,newValue)&#123;</span><br><span class="line">        if(position &lt; 0 || position &gt;= this.length) return false;</span><br><span class="line">        let current = this.head;</span><br><span class="line">        let index = 0;</span><br><span class="line">        while(index++ &lt; position)&#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.data = newValue;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 移除数据</span><br><span class="line">    DoubleLinkedList.prototype.removeAt = function(position)&#123;</span><br><span class="line">        if(position &lt; 0 || position &gt;= this.length) return null;</span><br><span class="line">        let current = this.head;</span><br><span class="line">        if(position == 0)&#123;</span><br><span class="line">            this.head.next.prev = null;</span><br><span class="line">            this.head = this.head.next;</span><br><span class="line">        &#125;else if(position == this.length - 1)&#123;</span><br><span class="line">            current = this.tail;</span><br><span class="line">            this.tail.prev.next = null;</span><br><span class="line">            this.tail = this.tail.prev;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let index = 0;</span><br><span class="line">            while(index++ &lt; position)&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.prev.next = current.next;</span><br><span class="line">            current.next.prev = current.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        this.length -= 1;</span><br><span class="line">        return current.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // remove方法</span><br><span class="line">    DoubleLinkedList.prototype.remove = function(value)&#123;</span><br><span class="line">        let position = this.indexOf(value);</span><br><span class="line">        return this.removeAt(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // isEmpty方法</span><br><span class="line">    DoubleLinkedList.prototype.isEmpty = function()&#123;</span><br><span class="line">        return !this.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // size方法</span><br><span class="line">    DoubleLinkedList.prototype.size = function()&#123;</span><br><span class="line">        return this.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DoubleLinkedList.prototype.getHead = function()&#123;</span><br><span class="line">        return this.head.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DoubleLinkedList.prototype.getTail = function()&#123;</span><br><span class="line">        return this.tail.data;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将链表转成字符串</span><br><span class="line">    DoubleLinkedList.prototype.toString = function()&#123;</span><br><span class="line">        return this.backwardString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DoubleLinkedList.prototype.forwardString = function()&#123;</span><br><span class="line">        let current = this.tail;</span><br><span class="line">        let resultString = &apos;&apos;;</span><br><span class="line">        while(current)&#123;</span><br><span class="line">            resultString += current.data + &apos; &apos;;</span><br><span class="line">            current = current.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从前向后遍历</span><br><span class="line">    DoubleLinkedList.prototype.backwardString = function()&#123;</span><br><span class="line">        let current = this.head;</span><br><span class="line">        let resultString = &apos;&apos;;</span><br><span class="line">        while(current)&#123;</span><br><span class="line">            resultString += current.data + &apos; &apos;;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>几乎每种编程语言中，都有集合结构，比较常见的实现方式是哈希表。</p>
<p>集合通常是由一组<strong>无序的，不能重复的</strong>元素组成与数学中的集合不同，计算机中的集合表示的结构中元素是不允许重复的。ES6中的Set类就是一种集合类。</p>
<h6 id="集合常见操作："><a href="#集合常见操作：" class="headerlink" title="集合常见操作："></a>集合常见操作：</h6><ol>
<li>add（value）向集合添加一个新的项。</li>
<li>remove（value）：从集合中一个数</li>
<li>has（value）：值是否在集合中，有返回true，没有返回false</li>
<li>clear（）：移除集合所有项。</li>
<li>size（）：length属性</li>
<li>values（）：返回所有值的数组。</li>
</ol>
<h6 id="集合间的操作"><a href="#集合间的操作" class="headerlink" title="集合间的操作"></a>集合间的操作</h6><p><strong>并集</strong></p>
<p><strong>交集</strong></p>
<p><strong>差集</strong></p>
<p><strong>子集</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">// 封装集合</span><br><span class="line">function Set()&#123;</span><br><span class="line">    // 属性</span><br><span class="line">    this.item = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // add方法</span><br><span class="line">    Set.prototype.add = function(value)&#123;</span><br><span class="line">        // 先判断是否有该值</span><br><span class="line">        if(this.has(value))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.item[value] = value;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set.prototype.has = function(value)&#123;</span><br><span class="line">        return this.item.hasOwnProperty(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set.prototype.remove = function(value)&#123;</span><br><span class="line">        // 判断有无该值</span><br><span class="line">        if(!this.has(value))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        delete this.item[value];</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set.prototype.clear = function()&#123;</span><br><span class="line">        this.item = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set.prototype.size = function()&#123;</span><br><span class="line">        return Object.keys(this.item).length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set.prototype.values = function()&#123;</span><br><span class="line">        return Object.keys(this.item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 并集</span><br><span class="line">    Set.prototype.union = function(otherSet)&#123;</span><br><span class="line">        // this: 集合对象A</span><br><span class="line">        // otherSet：集合对象B</span><br><span class="line">        let unionSet = new Set();</span><br><span class="line">        let value = this.values();</span><br><span class="line">        for(let i = 0; i &lt; value.length;i++)&#123;</span><br><span class="line">            unionSet.add(value[i])</span><br><span class="line">        &#125;</span><br><span class="line">        // 去除B集合中的元素，判断是否需要添加到新的集合</span><br><span class="line">        value = otherSet.values();</span><br><span class="line">        for(let i = 0; i &lt; value.length;i++)&#123;</span><br><span class="line">            unionSet.add(value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return unionSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 交集</span><br><span class="line">    Set.prototype.intersection = function(otherSet)&#123;</span><br><span class="line">        let intersection = new Set();</span><br><span class="line">        let value = this.values();</span><br><span class="line">        for(let i = 0; i &lt; value.length;i++)&#123;</span><br><span class="line">            if(otherSet.has(value[i]))&#123;</span><br><span class="line">                intersection.add(value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return intersection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 差集</span><br><span class="line">    Set.prototype.differce = function(otherSet)&#123;</span><br><span class="line">        let differce = new Set();</span><br><span class="line">        let value = this.values();</span><br><span class="line">        for(let i = 0; i &lt; value.length;i++)&#123;</span><br><span class="line">            if(!otherSet.has(value[i]))&#123;</span><br><span class="line">                differce.add(value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return differce;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 子集：集合A是否为集合B的子集</span><br><span class="line">    Set.prototype.subSet = function(otherSet)&#123;</span><br><span class="line">        let value = this.values();</span><br><span class="line">        for(let i = 0; i &lt; value.length;i++)&#123;</span><br><span class="line">            if(!otherSet.has(value[i]))&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表无论多少条数据，插入删除值需要接近常量的时间：即O（1）的时间级。实际上，只需要几个机器指令即可完成。</p>
<p>哈希表的速度比树快，基本可在瞬间找到想要的元素，且哈希表相对于树来说编码要容易得多。哈希表基于数组，但效率比数组高。</p>
<p>哈希表相对于数组：</p>
<ol>
<li>哈希表中的数据没有顺序，所以不能以一种固定的方式，比如从小到大来遍历其中的元素。</li>
<li>哈希表中的key不允许重复，不能放置相同的key用于保存不同的元素。</li>
</ol>
<h6 id="字母转数字"><a href="#字母转数字" class="headerlink" title="字母转数字"></a>字母转数字</h6><p>方案一：把数字相加求和产生的数组下标太少。</p>
<p>方案二：与27的幂相乘求和产生的数组下标又太多。</p>
<h6 id="哈希化"><a href="#哈希化" class="headerlink" title="哈希化"></a>哈希化</h6><p><strong>哈希化</strong>：将大数字转化为数组范围内下标的过程，我们称之为哈希化。</p>
<p><strong>哈希函数</strong>：通常我们将单词转为大数字，大数字在进行哈希化的代码实现放在一个函数中，这就是哈希函数。</p>
<p><strong>哈希表</strong>：最终将数据插入到这个数组，对整个结构的封装，我们就称之为哈希表。</p>
<p>哈希化后的下标值仍可能会重复，解决方案有二：</p>
<h6 id="1-链地址法"><a href="#1-链地址法" class="headerlink" title="1.链地址法"></a>1.链地址法</h6><p>链地址解决冲突的办法是每个数组单元中存放的不再是单个数据，而是一个链条（数组和链表），当发现重复时，便把重复的元素插入到链表的首端或末端即可。当查询时，先根据哈希化后的下标值找到对应的位置，再取出链表，依次查询寻找的数据。</p>
<p>一般哈希化的index找出这个链表或数组时，通常就会使用线性查找，这时数组和链表的效率是差不多的。</p>
<p>但若是需要将新插入的数据放在数组或链表的最前面，因为觉得新插入的数据用于取出的可能性更大，这种情况最好采用链表，因为数组在首位插入数据时需要其他项后移，链表则没有此问题。<img src="C:%5CUsers%5CCCY%5CDesktop%5C5.png" alt="5"></p>
<h6 id="2-开放地址法"><a href="#2-开放地址法" class="headerlink" title="2.开放地址法"></a>2.开放地址法</h6><p>开放地址法的主要工作方式是寻找空白的单元格来添加重复的数据。</p>
<p><img src="C:%5CUsers%5CCCY%5CDesktop%5C6.png" alt="6"></p>
<h6 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a><strong>线性探测</strong></h6><p>线性的查找空白的单元。</p>
<p>插值：当我们通过哈希化找到下标值时，发现该位置已经有值了，下标值就自加1开始一点一点查找合适的位置（空的位置）</p>
<p>查询：首先经过哈希化得到下标值，比较该下标值的结果与查询的数值是否相同，相同则返回，不同则线性查找（下标值加1），查到空位置即停止。因为插值时不可能跳过空位置去其他位置。</p>
<p>删除：删除一个数据项时，不可以将这个位置下标的内容设置为null，因为将它设置为null可能影响我们之后查询其他操作，所以通常删除一个位置的数据项时，需将其进行特殊处理（比如设置为-1）。</p>
<p>当我们之后看到-1位置的数据项时就知道查询时要继续查询，但是插入该位置可放置数据。</p>
<p>线性探测有一个较严重的问题就是聚集（连续填充单位），它会影响哈希表的性能，无论删除/插入/删除都会影响。</p>
<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><ol>
<li>节点的度（degree）：节点的子树个数。</li>
<li>树的度：树的所有节点中最大的度数。</li>
<li>叶节点（leaf）：度为0的节点（也称为叶子节点）。</li>
<li>父节点（parent）：有子树的节点是其树的根节点的父节点。</li>
<li>子节点（child）</li>
<li>兄弟节点路径和路径长度：一个节点序列的父节点，路径所包含的边的个数为路径的长度。</li>
<li>节点的层次（level）：规定根节点在1层，其他节点的层数是其父节点的层数加1.</li>
<li>树的深度（depth）：树中所有节点中的最大层次是这棵树的深度。</li>
</ol>
<h6 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h6><ol>
<li>一个二叉树第i层的最大节点数为<code>2^(i-1),i&gt;=1</code>;</li>
<li>深度为k的二叉树有最大的节点总数为：<code>2^k-1,k&gt;=1</code>;</li>
<li>对任何非空二叉树T，若n0表示叶结点的个数，n2是度为2的非叶节点个数，则两者关系n0 = n2 + 1。</li>
</ol>
<h6 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h6><p>二叉搜索树（BST ,Binary Search Tree)，也称二叉排序树或二叉查找树。二叉搜索树是一颗二叉树，可以为空；二分查找法其实就是利用的二叉搜索树。</p>
<p>如果不为空，满足以下性质：</p>
<ol>
<li>非空左子树的所有键值小于其根节点的键值。</li>
<li>非空右节点的所有键值大于其根节点的键值。</li>
<li>左，右子树本身也都是二叉树。</li>
</ol>
<p>常见操作：</p>
<ol>
<li><p>insert（key）：向树中插入一个新的键</p>
</li>
<li><p>search（key）：树中查找键</p>
</li>
<li><p>inOrderTraverse：通过中序遍历所有节点。</p>
</li>
<li><p>preOrderTraverse：先序</p>
</li>
<li><p>postOrderTraverse：后序</p>
</li>
<li><p>min</p>
</li>
<li><p>max</p>
</li>
<li><p>remove（key）</p>
<p>如果我们要删除的节点current有两个子节点，甚至子节点还有子节点，这种情况下就需要从current下面所有节点中找到一个最接近current的节点来替换current。</p>
<p>最接近curren的节点必定是比current小一点点的节点（它必是current左子树中的最大值，叫做<strong>前驱</strong>）和比current大一点点的节点（current右子树的最小值，叫做<strong>后继</strong>）</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line">function BinarySearchTree() &#123;</span><br><span class="line">    function Node(key) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.left = null;</span><br><span class="line">        this.right = null;</span><br><span class="line">    &#125;</span><br><span class="line">    this.root = null;</span><br><span class="line">    // insert方法:对外给用户调用的方法</span><br><span class="line">    BinarySearchTree.prototype.insert = function (key) &#123;</span><br><span class="line">        // 根据key值创建节点</span><br><span class="line">        let newNode = new Node(key);</span><br><span class="line">        // 判断根节点是否为空，空节点直接将新节点赋给根节点</span><br><span class="line">        // 非空节点则调用内部insertNode方法</span><br><span class="line">        if (this.root == null) &#123;</span><br><span class="line">            this.root = newNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.insertNode(this.root, newNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BinarySearchTree.prototype.insertNode = function (node, newNode) &#123;</span><br><span class="line">        if (newNode.key &lt; node.key) &#123; //向左查找</span><br><span class="line">            if (node.left == null) &#123;</span><br><span class="line">                node.left = newNode;</span><br><span class="line">            &#125; else &#123; //向右查找</span><br><span class="line">                this.insertNode(node.left, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (node.right == null) &#123;</span><br><span class="line">                node.right = newNode;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.insertNode(node.right, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 树的遍历</span><br><span class="line">    // 1.先序遍历</span><br><span class="line">    BinarySearchTree.prototype.preOrderTraversal = function (handler) &#123;</span><br><span class="line">        this.preOrderTraversalNode(this.root, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    BinarySearchTree.prototype.preOrderTraversalNode = function (node, handler) &#123;</span><br><span class="line">        if (node != null) &#123;</span><br><span class="line">            // 先序就是先处理遍历来的数</span><br><span class="line">            handler(node.key);</span><br><span class="line">            // 处理经过节点的左子节点</span><br><span class="line">            this.preOrderTraversalNode(node.left, handler);</span><br><span class="line">            // 处理经过节点的右子节点</span><br><span class="line">            this.preOrderTraversalNode(node.right, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 中序遍历</span><br><span class="line">    BinarySearchTree.prototype.midOrderTraversal = function (handler) &#123;</span><br><span class="line">        this.midOrderTraversalNode(this.root, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    BinarySearchTree.prototype.midOrderTraversalNode = function (node, handler) &#123;</span><br><span class="line">        if (node != null) &#123;</span><br><span class="line">            this.midOrderTraversalNode(node.left, handler);</span><br><span class="line">            handler(node.key);</span><br><span class="line">            this.midOrderTraversalNode(node.right, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 右序遍历</span><br><span class="line">    BinarySearchTree.prototype.postOrderTraversal = function (handler) &#123;</span><br><span class="line">        this.postOrderTraversalNode(this.root, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    BinarySearchTree.prototype.postOrderTraversalNode = function (node, handler) &#123;</span><br><span class="line">        if (node != null) &#123;</span><br><span class="line">            this.postOrderTraversalNode(node.left);</span><br><span class="line">            this.postOrderTraversalNode(node.right);</span><br><span class="line">            handler(node.key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     //层序遍历</span><br><span class="line">    BinarySearchTree.prototype.levelOrderTraversal = function()&#123;</span><br><span class="line">        if(!this.root) return false;   //头节点为空返回false</span><br><span class="line">        let result = [];   //创建一个数组存放结果</span><br><span class="line">        let tree = [];    //创建一个数组存放二叉树</span><br><span class="line">        tree.push(this.root);    //先传入头节点</span><br><span class="line">        while(tree.length)&#123;       //当tree数组长度不为空</span><br><span class="line">            let node = tree.shift();     //将数组中的第一个节点放到node中</span><br><span class="line">            result.push(node.key);         // 将node节点的值放入result中</span><br><span class="line">            if(node.left)&#123;                 //如果node的左节点不为空，就将左节点压入tree数组中</span><br><span class="line">                tree.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if(node.right)&#123;                //如果node的右节点不为空，就将左节点压入tree数组中</span><br><span class="line">                tree.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // 找最小值，在最左边位置</span><br><span class="line">    BinarySearchTree.prototype.min = function () &#123;</span><br><span class="line">        let node = this.root;</span><br><span class="line">        while (node.left) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        return node.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // max</span><br><span class="line">    BinarySearchTree.prototype.max = function () &#123;</span><br><span class="line">        let node = this.root;</span><br><span class="line">        while (node.right) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return node.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // search搜索特定的值</span><br><span class="line">    // 递归搜索</span><br><span class="line">    // BinarySearchTree.prototype.search = function (key) &#123;</span><br><span class="line">    //     return this.searchNode(this.root, key);</span><br><span class="line">    // &#125;</span><br><span class="line">    // BinarySearchTree.prototype.searchNode = function (node, key) &#123;</span><br><span class="line">    //     if (node == null) &#123;</span><br><span class="line">    //         return false;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     if (key &lt; node.key) &#123;</span><br><span class="line">    //        return this.searchNode(node.left, key);</span><br><span class="line">    //     &#125; else if (key &gt; node.key) &#123;</span><br><span class="line">    //         return this.searchNode(node.right, key);</span><br><span class="line">    //     &#125; else &#123;</span><br><span class="line">    //         return true;</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;</span><br><span class="line">    // 循环搜索</span><br><span class="line">    BinarySearchTree.prototype.search = function(key)&#123;</span><br><span class="line">        let node = this.root;</span><br><span class="line">        while(node)&#123;</span><br><span class="line">            if(key &lt; node.key)&#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;else if(key &gt; node.key)&#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除节点</span><br><span class="line">    BinarySearchTree.prototype.remove = function(key)&#123;</span><br><span class="line">        // 寻找要删除的节点，定义变量，保存一些信息</span><br><span class="line">        let parent = null;</span><br><span class="line">        let current = this.root;</span><br><span class="line">        let isLeftChild = true;</span><br><span class="line"></span><br><span class="line">        // 开始寻找删除的节点</span><br><span class="line">        while(current.key != key)&#123;</span><br><span class="line">            parent = current;</span><br><span class="line">            if(key &lt; current.key)&#123;</span><br><span class="line">                isLeftChild = true;</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                isLeftChild = false;</span><br><span class="line">                current = current.right;</span><br><span class="line">            &#125;</span><br><span class="line">            // 若已经找到最后的节点，依然没找到等于key的节点</span><br><span class="line">            if(current == null)   return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 找到了要删除的节点</span><br><span class="line">        // 1.是一个叶节点</span><br><span class="line">        if(current.left == null &amp;&amp; current.right == null)&#123;</span><br><span class="line">            if(isLeftChild)&#123;</span><br><span class="line">                parent.left = null;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                parent.right = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.删除节点有一个子节点</span><br><span class="line">        else if(current.right == null)&#123;</span><br><span class="line">            if(current == this.root)&#123;</span><br><span class="line">                this.root = current.left;</span><br><span class="line">            &#125;else if(isLeftChild)&#123;</span><br><span class="line">                parent.left = current.left;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                parent.right = current.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(current.left == null)&#123;</span><br><span class="line">            if(current == this.root)&#123;</span><br><span class="line">                this.root = current.right;</span><br><span class="line">            &#125;else if(isLeftChild)&#123;</span><br><span class="line">                parent.left = current.right;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                parent.right = current.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 3.删除的节点上有两个节点</span><br><span class="line">        else&#123;</span><br><span class="line">            // 找到后继</span><br><span class="line">            let successor = this.getSuccessor(current);</span><br><span class="line">            if(current == this.root)&#123;</span><br><span class="line">                this.root = successor;</span><br><span class="line">            &#125;else if(isLeftChild)&#123;</span><br><span class="line">                parent.left = successor;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                parent.right = successor;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 将删除节点的左子树</span><br><span class="line">            successor.left = current.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 找后继的方法</span><br><span class="line">    BinarySearchTree.prototype.getSuccessor = function(delNode)&#123;</span><br><span class="line">        // 定义变量，保存找到的后继</span><br><span class="line">        let successor = delNode;</span><br><span class="line">        let current = delNode.right;</span><br><span class="line">        let successorParent = delNode.parent;</span><br><span class="line"></span><br><span class="line">        // 循环查找</span><br><span class="line">        while(current != null)&#123;</span><br><span class="line">            successorParent = successor;</span><br><span class="line">            successor = current;</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        // 判断寻找的后继节点是否直接就是delNode的right节点</span><br><span class="line">        if(successor != delNode.right)&#123;</span><br><span class="line">            successorParent.left = successor.right;</span><br><span class="line">            successor.right = delNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return successor;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let bst = new BinarySearchTree();</span><br><span class="line">bst.insert(11);</span><br><span class="line">bst.insert(7);</span><br><span class="line">bst.insert(15);</span><br><span class="line">bst.insert(42);</span><br><span class="line">bst.insert(5);</span><br><span class="line">bst.insert(8);</span><br><span class="line">let resultStr = &apos;&apos;;</span><br><span class="line">bst.preOrderTraversal(function (key) &#123;</span><br><span class="line">    resultStr += key + &apos; &apos;;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(resultStr);</span><br><span class="line">bst.remove(11);</span><br><span class="line">resultStr = &apos;&apos;;</span><br><span class="line">bst.midOrderTraversal(function (key) &#123;</span><br><span class="line">    resultStr += key + &apos; &apos;;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(resultStr);</span><br></pre></td></tr></table></figure>

<p>我们发现删除操作很棘手。实际上，因为它复杂，所以我们尽量避免删除操作。做法是在Node类中添加一个boolean的字段，比如isDeleted。要删除一个节点时就将该字段设为true。进行其他操作时，比如find（），在查找前会先判断这个节点是不是被标记为删除。这样比较简单，不会删除原来的树结构，但在二叉树存储中仍保留着本该被删除的节点，造成了很大的空间浪费。</p>
<p>二叉搜索树可快速找到给定关键字的数据项，并且可快速插入和删除数据项。但是当插入的数据是有序的数据时，树的深度就会变得很大，变成非平衡二叉树。</p>
<p>非平衡树：</p>
<ol>
<li>比较好的二叉搜索树数据项应该是左右分布均匀的，但是插入连续数据后，分布的不均匀即为非平衡树。</li>
<li>对于一颗平衡二叉树来说，查找和插入等操作的效率是O（logN）。</li>
<li>非平衡二叉树相当于编写了一个链表，查找效率变成了O（N）。</li>
</ol>
<p><strong>AVL树</strong></p>
<p>AVL树是最早的一种平衡树，他有办法保持树的平衡（每个节点多存储了一个额外的数据），时间复杂度为O（logN），但每次删除插入操作不及红黑树，所以整体效率不如红黑树。</p>
<h6 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h6><p>红黑树除了满足二叉搜索树的基本规则外，还有以下特性：</p>
<ol>
<li>节点都是黑色或红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点都是黑色的空节点（Null节点）。</li>
<li>每个红色节点的两个子节点都是黑色。（从每个叶子到根所有路径上不能有两个连续的红色节点）。</li>
<li>从任意节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
</ol>
<p>以上约束确保了红黑树的关键特性：</p>
<ol>
<li>从根到叶子的最长可能路径不会超过最短可能路径的两倍长。最短者的可能路径是都是黑色节点，最长的可能路径是红色和黑色交替。</li>
<li>红黑树基本是平衡的，虽然没有做到绝对的平衡，但是可以保证在最坏的情况下依然是高效的。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-前端面试" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/07/前端面试/" class="article-date">
      <time datetime="2020-04-07T14:26:30.000Z" itemprop="datePublished">2020-04-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/07/前端面试/">前端面试</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><ul>
<li>是一套包含HTMML,CSS,JS在内的技术组合，它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务。</li>
</ul>
<h3 id="优"><a href="#优" class="headerlink" title="优"></a>优</h3><ul>
<li><ol>
<li>网络标准统一，HTML5本身是由W3C推荐出来的。</li>
</ol>
</li>
<li><ol start="2">
<li>多设备，跨平台，即时更新。</li>
</ol>
</li>
<li><ol start="3">
<li>提高可用性和改进用户的友好体验。</li>
</ol>
</li>
<li><ol start="4">
<li>有几个新的标签将有利于开发者定义重要的内容。</li>
</ol>
</li>
<li><ol start="5">
<li>可以给站点带来更多的多媒体元素。</li>
</ol>
</li>
<li><ol start="6">
<li>可以很好的替代Flash和Silverlight。</li>
</ol>
</li>
<li><ol start="7">
<li>涉及到网站的抓取和索引时，对于SEO很友好。</li>
</ol>
</li>
<li><ol start="8">
<li>被大量应用于移动应用程序和游戏。</li>
</ol>
</li>
</ul>
<h3 id="缺"><a href="#缺" class="headerlink" title="缺"></a>缺</h3><ul>
<li><ol>
<li>安全性：websocket和透明代理的实现有严重安全问题，webstorage和websocket这样的功能很容易被黑客利用来盗取用户的信息与资料。</li>
</ol>
</li>
<li><ol start="2">
<li>完善性：许多特性浏览器的支持程度不一样。</li>
</ol>
</li>
<li><ol start="3">
<li>技术门槛：HTML5简化了开发者学习，像web worker、web socket、web storage等新特性，后台甚至浏览器原理的知识。</li>
</ol>
</li>
<li><ol start="4">
<li>性能：某些平台上的引擎问题导致HTML5性能低下。</li>
</ol>
</li>
<li><ol start="5">
<li>浏览器兼容性：最大缺点，IE9以下浏览器几乎全军覆没。</li>
</ol>
</li>
</ul>
<h3 id="Doctype作用"><a href="#Doctype作用" class="headerlink" title="Doctype作用"></a>Doctype作用</h3><ul>
<li><ol>
<li>声明位于文档最前面，处于标签之前，告知浏览器的解析器以何种方式解析文档。</li>
</ol>
</li>
<li><ol start="2">
<li>严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。</li>
</ol>
</li>
<li><ol start="3">
<li>在混杂模式中，页面以宽松的方式向后兼容的方式显示。模拟老式浏览器的行为防止站点无法工作。</li>
</ol>
</li>
<li><ol start="4">
<li>Doctype不存在或格式不正确会导致文档以混杂模式呈现。</li>
</ol>
</li>
</ul>
<h3 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h3><ul>
<li><ol>
<li>去掉或样式丢失的时候能让页面呈现清晰的结构</li>
</ol>
<ul>
<li>：html本身是没有表现的，我们看到例如h1是粗体，字体大小2em，加粗；strong是加粗的，不要认为这是html的表现，这些其实html默认的css样式在起作用，所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语义化的HTML结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达html的语义，可以说浏览器的默认样式和语义化的HTML结构是不可分割的。</li>
</ul>
</li>
<li><ol start="2">
<li>屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页.</li>
</ol>
<ul>
<li>例如,如果你使用的含语义的标记,屏幕阅读器就会“逐个拼出”你的单词,而不是试着去对它完整发音.</li>
</ul>
</li>
<li><ol start="3">
<li>PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）.使用语义标记可以确保这些设备以一种有意义的方式来渲染网页.理想情况下,观看设备的任务是符合设备本身的条件来渲染网页.语义标记为设备提供了所需的相关信息,就省去了你自己去考虑所有可能的显示情况（包括现有的或者将来新的设备）.</li>
</ol>
<ul>
<li>例如,一部手机可以选择使一段标记了标题的文字以粗体显示.而掌上电脑可能会以比较大的字体来显示.无论哪种方式一旦你对文本标记为标题,您就可以确信读取设备将根据其自身的条件来合适地显示页面.</li>
</ul>
</li>
<li><ol start="4">
<li>搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重.</li>
</ol>
<ul>
<li><ol start="5">
<li>你的页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记,而只注重语义标记.因此,如果页面文件的标题被标记,而不是,那么这个页面在搜索结果的位置可能会比较靠后.除了提升易用性外,语义标记有利于正确使用CSS和JavaScript,因为其本身提供了许多“钩钩”来应用页面的样式与行为.SEO主要还是靠你网站的内容和外部链接的。</li>
</ol>
</li>
</ul>
</li>
<li><ol start="6">
<li>便于团队开发和维护</li>
</ol>
</li>
<li><p>W3C给我们定了一个很好的标准，在团队中大家都遵循这个标准，可以减少很多差异化的东西，方便开发和维护，提高开发效率，甚至实现模块化开发。</p>
</li>
</ul>
<h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><ul>
<li><p>媒体查询</p>
</li>
<li><p>百分比</p>
<ul>
<li>%单位是依赖于元素的祖先元素。</li>
</ul>
</li>
<li><p>rem</p>
<ul>
<li><p>rem与em区别</p>
<ul>
<li>rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。</li>
<li>作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值设置font-size的值实现当屏幕分辨率变化时让元素也变化，以前的天猫tmall就使用这种办法</li>
<li>em是文本相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)</li>
<li>em（font size of the element）是指相对于父元素的字体大小的单位。它与rem之间其实很相似，区别在。（相对是的HTML元素的字体大，默认16px）</li>
<li><strong>em与rem的重要区别：</strong> 它们计算的规则一个是依赖父元素另一个是依赖根元素计算</li>
</ul>
</li>
<li><p>通过 rem 单位来实现适配，需要内嵌一段脚本去动态计算根元素大小。</p>
</li>
</ul>
</li>
<li><p>vw/vh</p>
<ul>
<li><p>使用纯CSS视口单位来自行自适应，虽然现在的兼容性还没法完全能够接受</p>
</li>
<li><p>依赖于视口的尺寸，根据视口尺寸的百分比来定义的</p>
<ul>
<li>vw : 1vw 等于视口宽度的1%</li>
<li>vh : 1vh 等于视口高度的1%</li>
<li>vmin : 选取 vw 和 vh 中最小的那个</li>
<li>vmax : 选取 vw 和 vh 中最大的那个</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="出现css阻塞地方"><a href="#出现css阻塞地方" class="headerlink" title="出现css阻塞地方"></a>出现css阻塞地方</h3><ul>
<li><ol>
<li>当css后面跟着嵌入的js时，该css就会出现阻塞后面资源下载的情况，而当把嵌入JS放到css前面就不会出现阻塞。</li>
</ol>
</li>
<li><ol start="2">
<li>根本原因是浏览器会维持html中css与js的顺序，样式表必须在嵌入的js执行前先加载解析完。但嵌入的js会阻塞后面资源的下载，所以就会出现上面CSS阻塞下载的情况。</li>
</ol>
</li>
</ul>
<h3 id="优化css性能"><a href="#优化css性能" class="headerlink" title="优化css性能"></a>优化css性能</h3><ul>
<li><ul>
<li>减少首次有效绘制时间，只将渲染首屏内容的关键css内联到HTML中（Github上有一个项目Critical CSS可确定哪些内容是首屏关键样式），但内联css不会进行缓存，每次需重新下载。</li>
</ul>
</li>
<li><ul>
<li>剩下的css由外部异步加载导入并启动缓存。异步加载方式：</li>
</ul>
<ul>
<li><ul>
<li>使用js动态动态创建样式表link并插入到DOM中</li>
</ul>
</li>
<li><ul>
<li>将link元素的media属性设置为用户浏览器不匹配的媒体类型。因为对浏览器来说，如果样式表不适合当前媒体类型，其优先级会被放低，会在不阻塞页面渲染情况下再进行下载，但在文件加载完成后将media的值设为screen或all  <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;mystyle.css&quot; media=&quot;noexist&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>文件压缩，只会去除无用的空格。</li>
</ul>
</li>
<li><ul>
<li>去除无用的css。编写代码时，尽量提取公共类，减少重复。</li>
</ul>
</li>
<li><ul>
<li>有选择的使用选择器</li>
</ul>
<ul>
<li>保持简单，不要嵌套过多过于复杂的选择器。</li>
<li><ul>
<li>通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。</li>
</ul>
</li>
</ul>
</li>
<li><p>减少重排和重绘</p>
<ul>
<li><ul>
<li>触发重排：font-size、font-family、元素内外边距，通过js改变css类，通过js获取DOM元素位置的相关属性、css伪类激活，滚动滚动条或改变窗口大小。   <strong>优先使用flex弹性布局</strong>。</li>
</ul>
</li>
<li><ul>
<li>触发重绘：改变元素的外观（如color，background，visibility等属性）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="css预处理"><a href="#css预处理" class="headerlink" title="css预处理"></a>css预处理</h3><ul>
<li><ul>
<li>css预处理器是一种专门的编程语言，用来为css增加一些变成特性（css本身不是编程语言）不需要考虑浏览器兼容问题，因为css预处理器最终编译和输出的仍是标准的css样式。</li>
</ul>
</li>
<li><ul>
<li>可在css预处理器中使用变量，简单逻辑判断，函数等基本编程技巧。有合理的样式复用机制。</li>
</ul>
</li>
<li>less，sass</li>
</ul>
<h3 id="浮动的原理和工作方式"><a href="#浮动的原理和工作方式" class="headerlink" title="浮动的原理和工作方式"></a>浮动的原理和工作方式</h3><ul>
<li><ul>
<li>浮动元素是脱离文档流的，不占据空间。浮动元素碰到包含他的元素的边框或其他浮动元素的边框会停下来。</li>
</ul>
</li>
<li><ul>
<li>引发问题：</li>
</ul>
<ul>
<li><ul>
<li>父元素的高度无法撑开，影响与父元素同级的元素。</li>
</ul>
</li>
<li><ul>
<li>与浮动元素同级的非浮动元素紧跟其后。</li>
</ul>
</li>
<li><ul>
<li>若非第一个元素浮动，则该元素之前的元素也需要紧跟其后，否则会影响页面的显示的结构。</li>
</ul>
</li>
</ul>
</li>
<li><p>清除浮动：</p>
<ul>
<li><ul>
<li>在所有浮动标签后面使用<strong>空标签</strong>清除浮动，定义css clear：both；弊端是增加无意义的标签。</li>
</ul>
</li>
<li><ul>
<li>给浮动元素的<strong>父标签</strong>添加css属性，overflow：auto；</li>
</ul>
</li>
<li><ul>
<li>非IE浏览器者使用<strong>伪元素</strong>清除浮动，不过要设置伪对象height：0；否则该元素高度要比实际高出若干像素。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="link与-import区别"><a href="#link与-import区别" class="headerlink" title="link与@import区别"></a>link与@import区别</h3><ul>
<li><ul>
<li>link是HTML标签无兼容问题，页面被加载时，link会同时被加载。</li>
</ul>
</li>
<li><ul>
<li>@import由css提供，但只在IE5以上才能识别，且引用的css会等到页面被加载完再加载。</li>
</ul>
</li>
</ul>
<h3 id="absolute与fixed区别"><a href="#absolute与fixed区别" class="headerlink" title="absolute与fixed区别"></a>absolute与fixed区别</h3><ul>
<li><p>共同点：</p>
<ul>
<li><ol>
<li>改变行内元素的呈现方式，display被置为inline-block；</li>
</ol>
</li>
<li><ol start="2">
<li>让元素脱离普通流，不占据空间；</li>
</ol>
</li>
<li><ol start="3">
<li>默认会覆盖到非定位元素上。</li>
</ol>
</li>
</ul>
</li>
<li><p>不同点：</p>
<ul>
<li><ol>
<li>absolute的根元素是可以设置的，而fixed的根元素固定为浏览器。</li>
</ol>
</li>
<li><ol start="2">
<li>当你滚动网页时，fixed元素与浏览器窗口之间的距离是不变的。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="src与href区别"><a href="#src与href区别" class="headerlink" title="src与href区别"></a>src与href区别</h3><ul>
<li>src用于替换当前元素，href用于在当前文档和引用资源间确立联系。</li>
<li>src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在的位置，请求src资源时会将其指向的资源下载并应用到文档中。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也是如此，类似于将所指资源嵌入当前标签内，这也是为啥要将js脚本放在底部而不是头部。</li>
<li>href指向网络资源所在的位置，建立和当前元素之间的链接，如果我们在文档中添加<code>&lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot; /&gt;</code>，那浏览器就会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css而不是使用@import方式。</li>
</ul>
<h3 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap"></a>bootstrap</h3><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="js继承及对象共享"><a href="#js继承及对象共享" class="headerlink" title="js继承及对象共享"></a>js继承及对象共享</h3><ul>
<li>1.利用原型来继承,通过增加一个空的函数来避免原型链上的对象共享</li>
<li>1.利用原型来继承,通过增加一个空的函数来避免原型链上的对象共享<pre><code>var a = {name：“小明”}；
    var b = cloneObj(a);
     function cloneObj(obj){
            var f = function(){};
            f.prototype = obj;
            return new f();
    }</code></pre></li>
</ul>
<p>2.使用extend，多用于插件封装</p>
<p>示例：</p>
<p>Var item={name:”olive”,age:23};</p>
<p>Var item1={name:”Momo”,sex:”gril”};</p>
<p>Var result=$.extend({},item,item1);</p>
<p>结果：</p>
<p>Result={name:”Momo”,age:23,sex:”gril”};</p>
<h3 id="js阻塞"><a href="#js阻塞" class="headerlink" title="js阻塞"></a>js阻塞</h3><ul>
<li><p>why</p>
<ul>
<li><ul>
<li>所有浏览器在下载JS时会阻塞一切其他活动，比如资源的下载，内容的呈现等等。直到JS下载，解析，执行完才开始继续并行下载其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载JS，但是JS下载仍会阻塞其他资源的下载，如图片或css文件。</li>
</ul>
</li>
<li><ul>
<li>由于浏览器为了防止JS修改DOM树，需要重新构建DOM树的情况，所以就会阻塞其他的下载和呈现。</li>
</ul>
</li>
<li><ul>
<li>同时嵌入的脚本会阻塞所有内容的呈现，而由外引入的脚本只会阻塞其后内容的呈现，2种方式都会阻塞其后资源的下载，但是外部引入的脚本可将引入标签写在页面最后就可避免此种情况。</li>
</ul>
</li>
</ul>
</li>
<li><p>how to do</p>
<ul>
<li><p>嵌入脚本</p>
<ul>
<li><ol>
<li>放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。</li>
</ol>
</li>
<li><ol start="2">
<li>如果嵌入JS放在head中，请把嵌入JS放在CSS头部。</li>
</ol>
</li>
<li><ol start="3">
<li>使用 defer（只支持IE）</li>
</ol>
</li>
<li><ol start="4">
<li>不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用 setTimeout 来调用</li>
</ol>
</li>
</ul>
</li>
<li><ol>
<li>将脚本放在底部。<link>还是放在head中，用以保证在js加载前，能加载出正常显示的页面。<script>标签放在</body>前。</li>
</ol>
</li>
<li><ol start="2">
<li>阻塞脚本：由于每个<script>标签下载时阻塞页面解析过程，所以限制页面的<script>总数也可以改善性能。适用于内联脚本和外部脚本。</li>
</ol>
</li>
<li><ol start="3">
<li>非阻塞脚本：等页面完成加载后，再加载js代码。也就是，在 window.onload 事件发出后开始下载代码。</li>
</ol>
</li>
<li><ol start="4">
<li>defer属性：支持IE4和fierfox3.5更高版本浏览器</li>
</ol>
</li>
<li><ol start="5">
<li>动态脚本元素：文档对象模型（DOM）允许你使用js动态创建HTML的几乎全部文档内容。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li><ul>
<li>what：闭包是可以读取其他函数内部变量的函数，本质是将函数内部和外部连接起来的一座桥梁。</li>
</ul>
</li>
<li><ul>
<li>advantage：可读取函数内部的变量，可让这些变量的值始终保持在内存中。</li>
</ul>
</li>
<li><ul>
<li>disadvantage：内存消耗大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。故在退出函数之前，将不使用的局部变量全部删除。闭包会在父函数外部改变父函数内部变量的值。</li>
</ul>
</li>
</ul>
<h3 id="AJAX（同源策略）"><a href="#AJAX（同源策略）" class="headerlink" title="AJAX（同源策略）"></a>AJAX（同源策略）</h3><ul>
<li><p>Ajax与Flash的优缺点</p>
<ul>
<li><p>AJAX</p>
<ul>
<li>优：<br>1.可搜索性 2.开放性 3.费用 4.易用性 5.易于开发。</li>
<li>缺：<br>它可能破坏浏览器的后退功能 2.使用动态页面更新使得用户难于将某个特定的状态保存到收藏夹中 ，不过这些都有相关方法解决。</li>
</ul>
</li>
<li><p>flash</p>
<ul>
<li>优势：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>1.多媒体处理 2.兼容性 3.矢量图形 4.客户端资源调度<br>        - 劣势：</p>
<p>1.二进制格式 2.格式私有 3.flash 文件经常会很大，用户第一次使用的时候需要忍耐较长的等待时间 4.性能问题</p>
<ul>
<li><p>ajax请求的过程</p>
<ul>
<li><ol>
<li>创建XMLHttpRequest对象，也就是创建一个异步调用对象。</li>
</ol>
</li>
<li><ol start="2">
<li>创建一个新的HTTP请求，并指定该HTTP请求的方法，URL及验证信息。</li>
</ol>
</li>
<li><ol start="3">
<li>设置响应HTTP请求状态变化的函数.</li>
</ol>
</li>
<li><ol start="4">
<li>发送HTTP请求。</li>
</ol>
</li>
<li><ol start="5">
<li>获取异步调用返回的数据。</li>
</ol>
</li>
<li><ol start="6">
<li>使用 JS 和 DOM 实现局部刷新。</li>
</ol>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><ol>
<li>通过异步模式提升用户体验。</li>
</ol>
</li>
<li><ol start="2">
<li>优化了浏览器与服务器之间的传输，减少不必要的数据往返，减少了带宽占用。</li>
</ol>
</li>
<li><ol start="3">
<li>Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</li>
</ol>
</li>
<li><ol start="4">
<li>Ajax可实现局部刷新，即动态不刷新。</li>
</ol>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><ol>
<li>Ajax不支持浏览器back按钮。</li>
</ol>
</li>
<li><ol start="2">
<li>安全问题：Ajax暴漏了与服务器间交互的细节。</li>
</ol>
</li>
<li><ol start="3">
<li>对搜索引擎的支持比较弱。</li>
</ol>
</li>
<li><ol start="4">
<li>破坏程序的异常机制。</li>
</ol>
</li>
<li><ol start="5">
<li>不容易调试。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h3><h3 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h3><ul>
<li><p>使用场景</p>
<ul>
<li><ol>
<li>实时应用：如在线聊天，实时通知推送等（socket.io);</li>
</ol>
</li>
<li><ol start="2">
<li>分布式应用：通过高效的并行I/O使用已有的数据；</li>
</ol>
</li>
<li><ol start="3">
<li>工具类应用：海量的工具，小到前端压缩部署（如grunt），大到桌面应用程序。</li>
</ol>
</li>
<li><ol start="4">
<li>游戏类应用：游戏对实时和并发有很高的要求；</li>
</ol>
</li>
<li><ol start="5">
<li>利用稳定接口提升web渲染能力；</li>
</ol>
</li>
<li><ol start="6">
<li>前后后端编程语言环境统一：前端人员可快速切入到服务器端的开发；</li>
</ol>
</li>
</ul>
</li>
<li><p>what</p>
<ul>
<li>NodeJS是基于Event Loop（事件循环）和Callback（回调）把单线程的效率发挥到极致（会让人感觉实现了多线程），使有限的资源（CPU,内存，网络资源）利用最大化。</li>
</ul>
</li>
<li><p>优</p>
<ul>
<li><ol>
<li>因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在node上的代理服务器相比其他技术实现的服务器表现要好得多。</li>
</ol>
</li>
<li><ol start="2">
<li>与node代理服务器交互的客户端代码是由js语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的。</li>
</ol>
</li>
</ul>
</li>
<li><p>缺</p>
<ul>
<li><ol>
<li>Node是单线程，处理CPU密集型吃力，不过可将密集拆分。</li>
</ol>
</li>
<li><ol start="2">
<li>只支持单核CPU,不能充分利用CPU。</li>
</ol>
</li>
<li><ol start="3">
<li>可靠性低，一旦代码某个环节崩溃，整个系统都崩溃。</li>
</ol>
</li>
<li><ol start="4">
<li>开源组件库质量参差不齐，更新快，向下不兼容。</li>
</ol>
</li>
<li><ol start="5">
<li>Debbug不方便，错误没有stack trace。</li>
</ol>
</li>
</ul>
</li>
<li><p>事件循环eventloop</p>
<ul>
<li>　1）所有同步任务都在主线程上执行，形成一个执行栈</li>
<li>　2）当主线程中的执行栈为空时，检查事件队列是否为空，如果为空，则继续检查；如不为空，则执行3</li>
<li>　3）取出任务队列的首部，加入执行栈</li>
<li>　4）执行任务</li>
<li>　5）检查执行栈，如果执行栈为空，则跳回第 2 步；如不为空，则继续检查</li>
</ul>
</li>
<li><p>node怎么跟MongoDB建立连接</p>
<ul>
<li>1）引入mongoose</li>
<li>2）使用mongoose.connect()方法连接到MongoDB数据库</li>
<li>3）监听连接是否成功</li>
<li>4）然后通过node，书写接口，对数据库进行增删改查</li>
</ul>
</li>
</ul>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><ul>
<li><p>增</p>
<ul>
<li>arr.unshift('字符')：向数组开头添加一个或多个元素，并返回新的长度。</li>
<li>arr.concat(arr1,arr2,...)：连接两个或更多的数组，并返回结果</li>
<li>arr.push('字符')：向数组的末尾添加一个或多个元素，并返回新的长度。</li>
<li>arr.splice(index,howmany,item1,item2,...itemX)：向数组添加或删除元素。</li>
</ul>
</li>
<li><p>删</p>
<ul>
<li>arr.pop()：删除数组中最后一个元素并返回删除的元素。</li>
<li>arr.shift()：删除数组中的第一个元素。</li>
</ul>
</li>
<li><p>改</p>
<ul>
<li>arr.sort(fn)：对数组元素进行排序。</li>
<li>arr.reverse()：翻转数组的元素的顺序。</li>
<li>arr.map(fn)：通过指定函数处理的每个数组，并返回处理后的数组。</li>
<li>arr.join('连字符')：把数组中元素放入一个字符串中。</li>
<li>arr.toString()：把数组转为字符串，并返回结果。</li>
</ul>
</li>
<li><p>查</p>
<ul>
<li><p>filter()：检测数组元素，并返回符合条件所有元素的数组。</p>
</li>
<li><p>arr.every(fn)：检测数组元素是否都符合条件，返回布尔值。</p>
</li>
<li><p>arr.slice(n1,n2)：返回n1到n2之间的数组元素，不包括n2上的元素。</p>
</li>
<li><p>arr.lastIndexOf('字符')：返回指定字符最后出现的位置的下标。</p>
</li>
<li><p>arr.indexOf(‘字符’)：搜索数组中元素，并返回它首次出现的下标。</p>
</li>
<li><p>arr.some(fn)：检测数组元素中是否有元素符合指定条件。</p>
</li>
<li><p>遍历元素</p>
<ul>
<li>array.forEach(function(currentValue, index, arr), thisValue)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul>
<li>length：字符串的长度</li>
<li>str.charAt(num)：返回在指定位置的字符。</li>
<li>str.charCodeAt(num)：返回在指定位置的Unicode编码。</li>
<li>str.concat(str1,str2)：连接两个或多个字符串，并返回新的字符串。</li>
<li>String.fromCharCode(num)：将Unicode编码转为字符。</li>
<li>str.indexOf('字符串')：返回指定字符串值在字符串中首次出现的位置的下标。</li>
<li>str.lastIndexOf('字符串')：从后向前搜索字符串</li>
<li>str.match(/ain/g)：在字符串中检索指定的值，查找一或多个正则表达式的匹配。返回包含所有结果的数组。</li>
<li>str.replace(searchValue,newValue)：在字符串中用一些字符替换另一些字符。</li>
<li>str.search('字符或正则表达式')：检索字符串中指定子字符串。返回下标值。</li>
<li>str.slice(start,end)：提取字符串的某个部分，并以新的字符串返回被提取的部分</li>
<li>str.split()：将字符串分割成字符串数组。</li>
<li>str.substr(start,length)：从start开始截length个字符，返回截取的字符串。</li>
<li>str.substring(n1,n2)：返回n1到n2的字符串，不包括n2.</li>
<li>str.toLowerCase()<br>str.toUpperCase()</li>
<li>str.trim():去掉字符串两边空白。</li>
</ul>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><ul>
<li><p>变量声明</p>
<ul>
<li><p>let</p>
<ul>
<li>暂时性死区</li>
<li>变量不提升</li>
<li>不可重复声明</li>
</ul>
</li>
<li><p>const</p>
<ul>
<li>let的所有特性</li>
<li>值不可变</li>
<li>本质：const保证的不是变量的值不可改变，而是变量指向的那个内存地址不可改变。对于简单数据，值就保存在变量指向的那个内存地址，因此等同于常量。</li>
</ul>
</li>
<li><p>var</p>
</li>
<li><p>function</p>
</li>
<li><p>class</p>
<ul>
<li>ES6的class可以看作是一个语法糖，它的绝大部分功能ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法</li>
</ul>
</li>
<li><p>import</p>
</li>
</ul>
</li>
<li><p>解构赋值（模式匹配）</p>
<ul>
<li><p>规则：只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构，都会报错。let { prop: x } = undefined或null;  //TypeError</p>
</li>
<li><p>允许指定默认值，但如果一个数组成员不严格等于undefined，默认值无效。</p>
<ul>
<li>默认值是表达式，，那这个表达式是惰性求值，只在用到时才求值。</li>
</ul>
</li>
<li><p>本质：只要数据结构具有Iterator接口，都可以采用数组形式的解构赋值。let [a,b,c] = [1,2,3]</p>
</li>
<li><p>字符串</p>
<ul>
<li>字符串被转换成一个类似数组的对象。</li>
</ul>
</li>
<li><p>对象</p>
<ul>
<li>解构失败，变量的值为undefined。let {foo} = {bar: 'baz'};  foo  //undefined</li>
<li>对象解构赋值可以很方便将现有对象的方法赋值到某个变量中。let { log, sin, cos } = Math;</li>
<li>对象解构赋值的内部机制是先找到同名属性，然后再赋给对应的变量，真正被赋值的是后者，而非前者。let {foo:baz} = {foo: 123};    //baz为123，foo会报错，foo is not defined</li>
<li>数组解构的元素是按次序排列的，变量的取值由他的位置决定；而对象的属性没有次序，变量必须与属性同名才能取到正确的值。</li>
</ul>
</li>
<li><p>数值和布尔值</p>
<ul>
<li>解构赋值时会先转为对象。</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li>function add([x,y]){}<br>函数的参数表面上是一个数组，但在传入参数时，数组参数就被解构成变量x和y。</li>
</ul>
</li>
<li><p>用途</p>
<ul>
<li><p>交换变量的值 [x,y] = [y,x]</p>
</li>
<li><p>函数返回多个值</p>
<ul>
<li>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象返回。有了解构赋值便可轻松取出这些值。function example(){return [1,2,3];}  let [a,b,c] = example();</li>
</ul>
</li>
<li><p>函数参数的定义</p>
<ul>
<li>但参数无序时，可将参数与变量名对应起来。<br>function f({x,y,z}){}  f({z: 3, y: 2, x: 1});</li>
</ul>
</li>
<li><p>提取JSON数据</p>
</li>
<li><p>函数参数的默认值</p>
</li>
<li><p>遍历Map结构</p>
<ul>
<li>任何部署了Iterator接口的对象都可以用for...of循环遍历。</li>
<li>const map = new Map();<br>map.set('first','hello');<br>map.set('last','world');<br>for(let [key,value] of map){}</li>
</ul>
</li>
<li><p>输入模块的指定方法</p>
<ul>
<li>加载模块时，指定输入哪些方法</li>
<li>const { SourceMapConsumer, SourceNode } = require("source-map");</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>babel命令行转码</p>
<ul>
<li>将es6语法转为es5</li>
</ul>
</li>
<li><p>数组</p>
<ul>
<li><p>复制</p>
<ul>
<li>[].concat(...arr)</li>
</ul>
</li>
<li><p>array.forEach((item,index,arr) =>{})</p>
</li>
<li><p>扩展运算符</p>
<ul>
<li><p>三点(...)将数组转为用逗号分隔的参数序列</p>
<ul>
<li><p>替代数组的apply方法</p>
<ul>
<li>获取数组最大值:Math.max(...arr)</li>
</ul>
</li>
</ul>
</li>
<li><p>子主题 2</p>
</li>
</ul>
</li>
<li><p>Array上的</p>
<ul>
<li><p>Array.from(likeArr,fn)</p>
<ul>
<li>用于将类数组转为数组</li>
<li>参数一：类数组<br>二：类似于map方法，对每个元素遍历处理</li>
<li>如果map函数使用了this关键值，Array.from的第三个参数用于绑定this。</li>
</ul>
</li>
<li><p>Array.of()</p>
<ul>
<li>用于将一组值转为数组</li>
</ul>
</li>
</ul>
</li>
<li><p>数组实例</p>
<ul>
<li><p>copyWithin(target，start，end)</p>
<ul>
<li>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原来成员），然后返回当前数组。（会改变原数组）</li>
<li>target（必需）：从该位置开始替换数据）。<br>start（可选）：从该位置开始读取数据，默认为0。若为0，表示负数。<br>end（可选）：到该位置停止读取数据，默认等于数组长度，若为负值，表示倒数。<br>参数都是数值，若不是，先转为数值。</li>
</ul>
</li>
<li><p>find((value,index,arr) => {})</p>
<ul>
<li>遍历数组，找出第一个为true的成员，返回该成员，若无，返回undefined</li>
<li>可接受第二个参数，用于绑定回调函数的this对象</li>
</ul>
</li>
<li><p>findIndex((value,index,arr) => {})</p>
<ul>
<li>与find相同，但返回的是下标值，无返回-1</li>
<li>可发现NaN，弥补indexOf的不足</li>
</ul>
</li>
<li><p>fill(value,start,end)</p>
<ul>
<li>用value值填充或覆盖数组成员</li>
</ul>
</li>
<li><p>entries(),keys(),values()</p>
<ul>
<li><p>for(let index of ['a',b'].keys(){}<br>for(let [index,elem]  of  ['a','b'].entries(){}</p>
</li>
<li><p>遍历数组，keys对键名的遍历，values（）对键值遍历，entries（）对键值对的遍历</p>
</li>
<li><p>如果不使用 for...of 循环，可以手动调用遍历器对象的 next 方法，进行遍历。</p>
<ul>
<li>let letter = ['a', 'b', 'c'];</li>
<li>let entries = letter.entries();</li>
<li>console.log(entries.next().value); // [0, 'a']</li>
<li>console.log(entries.next().value); // [1, 'b']</li>
<li>console.log(entries.next().value); // [2, 'c']</li>
</ul>
</li>
</ul>
</li>
<li><p>includes(value，start)</p>
<ul>
<li>返回boolean值，表示数组中是否包含value值</li>
<li>start为负值，从倒数开始，大于数组长度，重置为0</li>
</ul>
</li>
<li><p>空位</p>
<ul>
<li><p>ES5中的空位</p>
<ul>
<li><p>空位不是 undefined ，一个位置的值等于 undefined ，依然是有值的。空位是没有任何值， in 运算符可以说明这一点。</p>
<ul>
<li>0 in [undefined, undefined, undefined] // true</li>
<li>0 in [, , ,] // false</li>
<li>forEach() , filter() , every() 和 some() 都会跳过空位。</li>
<li>map() 会跳过空位，但会保留这个值</li>
<li>join() 和 toString() 会将空位视为 undefined ，而 undefined 和 null 会被处理成空字符串。</li>
</ul>
</li>
</ul>
</li>
<li><p>ES6不会忽略空位，会将空位转为undefined</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串</p>
<ul>
<li><p>字符Unicode表示法</p>
<ul>
<li><p>js提供的\uxxxx形式表示一个字符，超出\uffff的字符，必须用两个双字节表示。“\uD842\uDFB7"    "吉"</p>
</li>
<li><p>ES6只需将码点放入大括号即可正确解读该字符串。“\u{20BB7}"   "吉”</p>
</li>
<li><p>at()方法</p>
<ul>
<li>ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。‘abc'.charAt(0)  //'a'     '吉'.charAt(0)   //’\uD842'</li>
<li>at()可识别码点大于0xFFFF的字符。<br>‘abc'.at(0)     //"a"<br>'吉'.at(0)    //“吉”</li>
</ul>
</li>
</ul>
</li>
<li><p>有遍历器接口，可用for...of遍历</p>
</li>
<li><p>字符查找</p>
<ul>
<li><p>ES5(返回-1）</p>
<ul>
<li>indexOf()</li>
</ul>
</li>
<li><p>ES6（返回布尔值，第二个参数表示开始搜素位置））</p>
<ul>
<li>includes(’字符‘，num)</li>
<li>startsWith(’字符‘，num)</li>
<li>endWith(’字符‘，num)</li>
</ul>
</li>
</ul>
</li>
<li><p>增加</p>
<ul>
<li><p>repeat（）</p>
<ul>
<li><p>返回新字符串，表示将原字符串重复n次<br>'x'.repeat(3)   //"xxx"</p>
</li>
<li><p>参数</p>
<ul>
<li>参数是小数时取整。<br>参数是负数或Infinity会报错。<br>参数是0到-1之间的小数，则等同于0。‘na'.repeat(-0.9)  //""<br>参数NaN等同于0    'na'.repeat(NaN)   //""<br>参数是字符串，则先转为数字。</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串补全长度</p>
<ul>
<li><p>头部补全padStart()，<br>尾部补全padEnd()     ’xxx'.padEnd(5,'ab')   //xxxab </p>
</li>
<li><p>参数</p>
<ul>
<li><p>第一个参数用来指定字符串的最小长度（如果原字符串的长度大于或等于指定最小长度，返回原字符串），'xxx'.padStart(2,'ab')     //'xxx'</p>
<ul>
<li>补全的 + 原字符串 》 指定的最小长度，截去超出位数的补全字符串。</li>
</ul>
</li>
<li><p>第二个参数是用来补全的字符串，省略就使用空格补全长度</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>模板字符串(反引号``）标识</p>
<ul>
<li><p>变量名写在${}中</p>
</li>
<li><p>调用函数 function fn(){ return 'hello world";}<br><code>foo ${ fn() } bar</code> //foo Hello World bar</p>
</li>
<li><p>不做处理raw()方法</p>
<ul>
<li>String.raw()方法往往用来充当模板字符串的处理函数，返回一个斜杆都被转义的字符串，对应于替换变量后的模板字符串。  String.raw<code>Hi\n${2+3}!</code>;    //"Hi\n5!"</li>
<li>若斜杠已转义则不做处理<br>String.raw<code>Hi\\n${2+3}!</code>;    //"Hi\n5!"</li>
</ul>
</li>
<li><p>标签模板<br>alert `123'  =><br>alert(123)</p>
<ul>
<li>标签指的是函数，紧跟其后的模板字符串就是它的参数。该参数实际是一个数组，该数组有一个raw属性，保存的是转义后的原字符串。<br>console.lof'123'     //   ["123", raw: Array[1]];</li>
<li>应用：过滤HTML字符串，防止用户输入恶意内容。</li>
</ul>
</li>
<li><p>限制：因默认会将字符串转义，故无法嵌入其他语言。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>正则</p>
<ul>
<li><p>ES5</p>
<ul>
<li>var regex = new RegExp('xyz','i');<br>等价于 var regex = /xyz/i;<br>等价于 var  regex = new RegExp(/xyz/i);<br> //不允许使用第二个参数添加修饰符，否则报错。<br>var regex = new RegExp(/xyz/,'i');  报错</li>
</ul>
</li>
<li><p>ES6</p>
<ul>
<li><p>若RegExp构造函数第一个参数是正则对象，第二个参数指定修饰符，且返回的修饰符会覆盖原来的修饰符。<br>new RegExp(/abc/ig,'i').flags    //“i”</p>
</li>
<li><p>字符串的正则方法,做到所有与正则相关的方法，全部定义在RegExp对象上。</p>
<ul>
<li>String.prototype.match调用RegExp.prototype[Symbol.match]</li>
<li>String.prototype.replace调用RegExp.prototype[Symbol.replace]</li>
<li>String.prototype.search调用RegExp.prototype[Symbol.search]</li>
<li>String.prototype.split调用RegExp.prototype[Symbol.split]</li>
</ul>
</li>
<li><p>修饰符</p>
<ul>
<li>i：忽略大小写</li>
<li>u:用来处理大于\uFFFF的Unicode字符</li>
<li>y： 全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配即可，而y修饰符确保匹配必须从剩余的第一个位置开始。</li>
</ul>
</li>
<li><p>具名组匹配</p>
<ul>
<li><p>const  RE_DATE=  /(?<year>\d{4}-(?<month>\d{2}-(?<day>\d{2})/;<br>const matchObj = RE_DTAE.exec('1999-12-31');<br>const year = matchObj.groups.yeat;   //1999<br>const  month = matchObj.groups.month;   //12<br>const   day = matchObj.groups.day;    //31</p>
<ul>
<li>"具名组匹配“在圆括号内部，模式的头部添加”问号+尖括号+组名“（？<year>),然后就可以在exec方法返回结果的groups属性上引用该组名。若具名组as没找到匹配，则matchObj.groups.as属性值就是undefined，并且as这个键名在groups始终存在。</li>
</ul>
</li>
<li><p>字符串替换时，使用$<组名>引用具名组</p>
<ul>
<li>let re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/u;<br>'2015-01-02'.replace(re,'$<day>/$<month>/$<year>')<br>//'02/01/2015'</li>
</ul>
</li>
<li><p>正则表达式内部引用某个”具名组匹配“，可使用\k<组名>。数字引用（\1）依然有效。</p>
<ul>
<li>const  RE_TWICE = /^(?<word>[a-z]+!\k<word>$/;<br>RE_TWICE.test('abc!abc')      //true<br>RE_TWICE.test('abc!ab')    //false</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数值扩展</p>
<ul>
<li><p>Number</p>
<ul>
<li><p>Number.isFinite()</p>
<ul>
<li>只对数值有效，非数值一律返回false，它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值转为数值再进行判断。</li>
</ul>
</li>
<li><p>Number.isNaN()</p>
</li>
<li><p>将全局parseInt()和parseFloat()转移到Number上面，使语言逐渐模块化。</p>
</li>
<li><p>Number.isInteger():判断一个值是否为整数（js中浮点数与整数相同存储方式）。</p>
</li>
<li><p>Number.EPSILON：表示极小的常量</p>
</li>
</ul>
</li>
<li><p>Math</p>
<ul>
<li><p>Math.trunc():去除一个数的小数部分，<br>非数值的话会先将其转为数值，<br>控制和无法截取整数的值，返回NaN</p>
</li>
<li><p>Math.sign():判断一个数是正数，负数还是0.非数值的先转为数值。</p>
<ul>
<li>参数为正数，返回+1</li>
<li>负数，返回-1</li>
<li>0，返回0</li>
<li>-0，返回-0</li>
<li>其他值，返回NaN</li>
</ul>
</li>
<li><p>Math.cbrt():计算一个数的立方根，非数值先转为数值</p>
</li>
<li><p>Math.fround()：返回一个数的单精度浮点数形式。</p>
</li>
<li><p>Math.hypot():返回所有参数的平方和的平方根<br>Math.hypot(3,4);      //5</p>
</li>
<li><p>对数方法</p>
<ul>
<li>Math.expm1():返回e的x次方减1</li>
<li>Math.log1p(x):返回 1+x 的自然对数，即Math.log(1+x)</li>
<li>Math.log10(x):返回以10为底的x的对数，若x<0,返回NaN。</li>
<li>Math.log2(x):返回以2为底的x的对数。</li>
</ul>
</li>
<li><p>双曲函数</p>
<ul>
<li>Math.sinh(x)<br>Math.cosh(x)<br>Math.tanh(x)<br>Math.asinh(x)<br>Math.acosh(x)<br>Math.atanh(x)</li>
</ul>
</li>
<li><p>Math.signbit():判断数的正负</p>
<ul>
<li>参数是NaN,返回false，<br>-0，返回true<br>负数，返回true<br>其他情况，返回false</li>
</ul>
</li>
<li><p>指数运算符（**）</p>
<ul>
<li>2 ** 2   //4<br>a  **= 2;<br>//等价于a = a * a</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>函数扩展</p>
<ul>
<li><p>函数参数的默认值</p>
<ul>
<li>function   m1({x=0,y=0}={}){return [x,y];}<br>function   m2({x,y} = { x : 0, y: 0}){return  [x,y];}</li>
<li>位置：必须是函数的尾参数，非尾参数不可设置默认值。</li>
<li>函数的length属性，将返回没有指定默认值的参数个数。（length指该函数预期传入的参数个数，指定默认值后，预期传入的参数个数就不包括这个参数了。同理，rest参数也不会计入length属性中。）</li>
<li>作用域：一旦参数设置了默认值，函数进行生命初始化时，参数会形成一个单独的作用域，等初始化结束，这个作用域就会消失。这种语法行为在不设置参数默认值时是不会出现的。</li>
</ul>
</li>
<li><p>rest函数</p>
<ul>
<li>function  add(...values){}</li>
<li>引入rest参数，用于获取函数的多于参数，这样就不用arguments对象了。且是一个数组对象。</li>
</ul>
</li>
<li><p>严格模式</p>
<ul>
<li>ES5开始，函数内部可设定为严格模式。<br>ES6规定，只要函数参数使用默认值，解构赋值或扩展运算符，那函数内部就不能显式设定为严格模式。</li>
</ul>
</li>
<li><p>name属性</p>
<ul>
<li>返回该函数的函数名，若将一个匿名函数赋值给一个变量，ES5的name属性会返回空字符串，而ES6则返回实际的函数名。</li>
<li>Function构造函数返回的函数实例，name属性值为anonymous。<br>(new  Function).name     //"anonymous"</li>
<li>bind返回的函数，name属性值加上bound前缀。<br>（function(){}).bind({}).name   //"bound   "</li>
</ul>
</li>
<li><p>箭头函数</p>
<ul>
<li><p>注意点</p>
<ul>
<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>不可使用arguments对象，该对象在函数体内不存在。要用时可用rest替代。</li>
<li>不可用yield命令，因此箭头函数不能用作Generator函数。</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><p>无参数或多个参数，用圆括号代替参数部分</p>
</li>
<li><p>返回一个对象，必须在对象外面加上括号，否则报错。</p>
</li>
<li><p>与变量解构结合使用</p>
<ul>
<li>const full = ({first,last}) => first + last;</li>
</ul>
</li>
<li><p>与rest参数结合</p>
<ul>
<li>const  h = (head,...tail) => [head,tail];<br>h(1,2,3,4,5);<br>//[1,[2,3,4,5]]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>双冒号运算符</p>
</li>
<li><p>尾调用优化</p>
</li>
<li><p>函数参数的尾逗号</p>
</li>
<li><p>catch语句的参数</p>
</li>
</ul>
</li>
<li><p>对象的扩展</p>
<ul>
<li>属性的简写。ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。</li>
<li>方法的简写。省略冒号与function关键字。</li>
<li>Object.keys()方法，获取对象的所有属性名或方法名（不包括原形的内容），返回一个数组。</li>
<li>Object.assign ()，assign方法将多个原对象的属性和方法都合并到了目标对象上面。可以接收多个参数，第一个参数是目标对象，后面的都是源对象。</li>
</ul>
</li>
<li><p>for...of  循环</p>
</li>
<li><p>import和export</p>
<ul>
<li>import和export命令只能在模块的顶部，不能在代码块之中。</li>
</ul>
</li>
<li><p>新增数据结构</p>
<ul>
<li><p>map（数据存储）</p>
<ul>
<li>本质上是健值对的集合，类似集合</li>
<li>可以遍历，可以跟各种数据格式转换</li>
</ul>
</li>
<li><p>set（数据重组）</p>
<ul>
<li>Set数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数。</li>
<li>属性和方法：<br>size 数据的长度<br>add() 添加某个值，返回 Set 结构本身。<br>delete() 删除某个值，返回一个布尔值，表示删除是否成功。<br>has() 查找某条数据，返回一个布尔值。<br>clear() 清除所有成员，没有返回值。<br>应用：数组去重。</li>
</ul>
</li>
</ul>
</li>
<li><p>promise</p>
<ul>
<li><p>它有三种状态，分别是pending-进行中、resolved-已完成、rejected-已失败。</p>
</li>
<li><p>三个状态：</p>
<ul>
<li>pending</li>
<li>fulfilled</li>
<li>reject</li>
</ul>
</li>
<li><p>两个过程：</p>
<ul>
<li>pending -> fulfilled</li>
<li>pending -> rejectd</li>
</ul>
</li>
<li><p>当pending为rejectd时，promise会进入catch</p>
</li>
<li><p>Promise是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p>
</li>
<li><p>Promise 构造函数包含一个参数和一个带有 resolve（解析）和 reject（拒绝）两个参数的回调。在回调中执行一些操作（例如异步），如果一切都正常，则调用 resolve，否则调用 reject。对于已经实例化过的 promise 对象可以调用 promise.then() 方法，传递 resolve 和 reject 方法作为回调。then()方法接收两个参数：onResolve和onReject，分别代表当前 promise 对象在成功或失败时。</p>
</li>
<li><p>promise构造函数是同步执行的，then方法是异步执行的</p>
</li>
</ul>
</li>
<li><p>Symbol</p>
<ul>
<li>Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的</li>
</ul>
</li>
<li><p>proxy代理</p>
<ul>
<li>Proxy代理使用代理（Proxy）监听对象的操作，然后可以做一些相应事情</li>
</ul>
</li>
</ul>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h3 id="优化前端性能"><a href="#优化前端性能" class="headerlink" title="优化前端性能"></a>优化前端性能</h3><ul>
<li>用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。</li>
<li><ul>
<li>压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css</li>
</ul>
</li>
<li><ul>
<li>利用<a href="https://cloud.tencent.com/product/cdn?from=10680">CDN</a>加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径</li>
</ul>
</li>
<li><ul>
<li>删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现</li>
</ul>
</li>
<li><ul>
<li>提取公共代码。</li>
</ul>
</li>
</ul>
<h3 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h3><ul>
<li>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</li>
<li><ol>
<li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li>
</ol>
</li>
<li><ol start="2">
<li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li>
</ol>
</li>
<li><ol start="3">
<li>确定入口：根据配置中的 entry 找出所有的入口文件；</li>
</ol>
</li>
<li><ol start="4">
<li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li>
</ol>
</li>
<li><ol start="5">
<li>完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li>
</ol>
</li>
<li><ol start="6">
<li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li>
</ol>
</li>
<li><ol start="7">
<li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li>
</ol>
</li>
<li>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</li>
</ul>
<h3 id="webpack-config-js配置文件"><a href="#webpack-config-js配置文件" class="headerlink" title="webpack.config.js配置文件"></a>webpack.config.js配置文件</h3><ul>
<li><p>webpack-dev-server：webpack实时打包构建</p>
</li>
<li><p>html-webpack-plugin插件配置启动页面</p>
</li>
<li><p>热更新</p>
<ul>
<li>“dev":"webpack-dev-server  --hot  --port  端口号   --open"</li>
</ul>
</li>
<li><p>打包css，less，scss文件</p>
</li>
<li><p>使用url-loader和file-loader处理css中的路径</p>
</li>
<li><p>使用babel处理高级JS语法</p>
</li>
<li><p>配置vue组件页面的解析。</p>
</li>
</ul>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="对MVVM理解"><a href="#对MVVM理解" class="headerlink" title="对MVVM理解"></a>对MVVM理解</h3><ul>
<li><p>MVVM 是 Model-View-ViewModel 的缩写。</p>
</li>
<li><p><strong>Model</strong>代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。</p>
</li>
<li><p><strong>View</strong> 代表UI 组件，它负责将数据模型转化成UI 展现出来。</p>
</li>
<li><p><strong>ViewModel</strong> 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。</p>
</li>
<li><p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p>
</li>
<li><p><strong>ViewModel</strong> 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
</li>
<li><p>与MVC区别</p>
<ul>
<li>mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到 View 。</li>
</ul>
</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li>Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。</li>
<li><strong>beforeCreate</strong>（创建前） 在数据观测和初始化事件还未开始</li>
<li><strong>created</strong>（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来</li>
<li><strong>beforeMount</strong>（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。</li>
<li><strong>mounted</strong>（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。</li>
<li><strong>beforeUpdate</strong>（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</li>
<li><strong>updated</strong>（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li>
<li><strong>beforeDestroy</strong>（销毁前） 在实例销毁之前调用。实例仍然完全可用。</li>
<li><strong>destroyed</strong>（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</li>
</ul>
<h3 id="数据绑定原理"><a href="#数据绑定原理" class="headerlink" title="数据绑定原理"></a>数据绑定原理</h3><ul>
<li>vue实现数据双向绑定主要是：采<strong>用数据劫持结合发布者-订阅者模式</strong>的方式，通过<strong>Object.defineProperty（）</strong>来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</li>
<li>vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 ），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —>视图更新；视图交互变化（input）—>数据model变更双向绑定效果。</li>
</ul>
<h3 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h3><ul>
<li><p>父组件与子组件传值</p>
<ul>
<li>父组件传给子组件：子组件通过props方法接受数据;</li>
<li>子组件传给父组件：$emit方法传递参数</li>
</ul>
</li>
<li><p>非父子组件间的数据传递，兄弟组件传值</p>
<ul>
<li>使用vuex。</li>
</ul>
</li>
</ul>
<h3 id="路由实现"><a href="#路由实现" class="headerlink" title="路由实现"></a>路由实现</h3><ul>
<li><p>模式</p>
<ul>
<li><p>history模式</p>
<ul>
<li><strong>history模式：</strong>history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。</li>
</ul>
</li>
<li><p>hash模式</p>
<ul>
<li><strong>hash模式：</strong>在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；</li>
<li>特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。</li>
<li>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。</li>
</ul>
</li>
</ul>
</li>
<li><p>vue-router</p>
<ul>
<li><p>路由嵌套</p>
<ul>
<li>在 VueRouter 的参数中使用 children 配置，这样就可以很好的实现路由嵌套。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><ul>
<li>低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的"View"上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</li>
</ul>
</li>
<li><ul>
<li>可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。</li>
</ul>
</li>
<li><ul>
<li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用 Expression Blend 可以很容易设计界面并生成 xml 代码。</li>
</ul>
</li>
<li><ul>
<li>可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li>
</ul>
</li>
</ul>
<h3 id="vue中的data必须是函数"><a href="#vue中的data必须是函数" class="headerlink" title="vue中的data必须是函数"></a>vue中的data必须是函数</h3><ul>
<li>对象为引用类型，当重用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。</li>
</ul>
<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><ul>
<li><p>vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车<br>有 5 种属性，分别是 state、getter、mutation、action、module</p>
</li>
<li><p>store 特性</p>
<ul>
<li><p>vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 datastate 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</p>
</li>
<li><p>使用 Vuex 只需执行 Vue.use(Vuex)，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？</p>
<ul>
<li>Vue.use(Vuex) 方法执行的是 install 方法，它实现了 Vue 实例对象的 init 方法封装和注入，使传入的 store 对象被设置到 Vue 上下文环境的store中。因此在VueComponent任意地方都能够通过this.store 访问到该 store。</li>
</ul>
</li>
</ul>
</li>
<li><p>getter特性</p>
<ul>
<li>getter 可以对 state 进行计算操作，它就是 store 的计算属性虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用如果一个状态只在一个组件内使用，是可以不用 getters</li>
</ul>
</li>
<li><p>mutation特性</p>
<ul>
<li>action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态action 可以包含任意异步操作</li>
</ul>
</li>
<li><p>原理</p>
<ul>
<li>vuex 仅仅是作为 vue 的一个插件而存在，不像 Redux,MobX 等库可以应用于所有框架，vuex 只能使用在 vue 上，很大的程度是因为其高度依赖于 vue 的 computed 依赖检测系统以及其插件系统，vuex 整体思想诞生于 flux,可其的实现方式完完全全的使用了 vue 自身的响应式设计，依赖监听、依赖收集都属于 vue 对对象 Property set get 方法的代理劫持。</li>
<li>最后一句话结束 vuex 工作原理，vuex 中的 store 本质就是没有 template 的隐藏着的 vue 组件；</li>
</ul>
</li>
</ul>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li><p>vue指令</p>
<ul>
<li><p>v-cloak</p>
<ul>
<li><p v-cloak></p>
</li>
<li><p>解决插值表达式闪烁问题（即网速慢时，只显示）</p>
</li>
</ul>
</li>
<li><p>v-text</p>
<ul>
<li><p><code>&lt;h2 v-text=&quot;msg&quot;&gt;*****&lt;/h2&gt;</code></p>
</li>
<li><p>会覆盖掉****，无闪烁问题</p>
</li>
</ul>
</li>
<li><p>v-html</p>
<ul>
<li><p><code>&lt;p  v-html=&quot;msg&quot;&gt;&lt;/p&gt;</code></p>
</li>
<li><p>会解析html格式的代码</p>
</li>
</ul>
</li>
<li><p>v-bind（  :  )</p>
<ul>
<li>绑定属性</li>
</ul>
</li>
<li><p>v-on (  @  )</p>
<ul>
<li>绑定事件</li>
</ul>
</li>
<li><p>v-model</p>
<ul>
<li>双向数据绑定</li>
</ul>
</li>
<li><p>v-for：遍历属性</p>
<ul>
<li>组件中使用v-for时，key是必须的。</li>
</ul>
</li>
<li><p>v-if</p>
<ul>
<li>高切换消耗。</li>
</ul>
</li>
<li><p>v-show</p>
<ul>
<li>高初始渲染消耗。</li>
</ul>
</li>
</ul>
</li>
<li><p>事件修饰符</p>
<ul>
<li><p>.stop</p>
<ul>
<li>阻止冒泡</li>
</ul>
</li>
<li><p>.prevent</p>
<ul>
<li>阻止默认事件</li>
</ul>
</li>
<li><p>.capture</p>
<ul>
<li>阻止事件捕获</li>
</ul>
</li>
<li><p>.self</p>
<ul>
<li>只阻止该元素自身事件</li>
</ul>
</li>
<li><p>.once</p>
<ul>
<li>事件只触发一次</li>
</ul>
</li>
</ul>
</li>
<li><p>过滤器</p>
<ul>
<li><p>只能用于mustach插值和v-bind表达式</p>
</li>
<li><p>私有过滤器</p>
<ul>
<li>filters: {dataFormat(data){}}</li>
</ul>
</li>
<li><p>全局过滤器</p>
<ul>
<li>Vue.filter('dataFormat',function(data){})</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义键盘修饰符</p>
<ul>
<li>Vue.config.keyCodes.名称 = 按键值</li>
</ul>
</li>
<li><p>自定义指令</p>
<ul>
<li><p>Vue.directive('focus',{<br>bind:function(el,binding){}<br>inserted:function(el){}<br>update:function(el){}})</p>
<ul>
<li><p>注意：在每个函数中，第一个参数永远是el，表示被绑定了指令的那个元素，这个el参数是一个原生的JS对象。</p>
</li>
<li><p>bind:每当指令绑定到元素上时会立即执行这个bind函数，只执行一次。</p>
<ul>
<li>和样式相关的操作一般放在bind函数中。</li>
<li>bind函数中有binding对象（包括name，value。。。属性）</li>
<li>子主题 3</li>
</ul>
</li>
<li><p>inserted表示元素插入到DOM中的时候会执行inserted函数，只触发一次。</p>
<ul>
<li>和JS行为有关的操作最好在inserted中执行放置。</li>
</ul>
</li>
<li><p>update:当VNode更新时会执行updates，可能会触发多次。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>请求地址</p>
<ul>
<li><p>vue-resource</p>
<ul>
<li><p>实现get,post,jsonp请求</p>
</li>
<li><p>在this.$http.get/post/jsonp().then()</p>
</li>
<li><p>form表单发起post请求，默认使用application/x-www-form-urlencoded表单格式。而vue-resource则是手动发起的post请求，默认没有表单格式，所以，有的服务器处理不了。</p>
</li>
<li><p>this.$http.post()中接受三个参数：</p>
<ul>
<li>第一个参数是要请求的URL地址。</li>
<li>第二个是要提交给服务器的数据，要以对象形式提交给服务器</li>
<li>第三个是一个配置对象，要以哪种表单数据类型提交过去。{emulateJSON: true},以普通表单格式将数据提交给服务器。</li>
</ul>
</li>
<li><p>指定数据接口根域名</p>
<ul>
<li>Vue.http.options.root = 'http://***/'<br>this.$http.get('add').then()</li>
<li>如果我们通过全局配置了请求的数据接口的根域名，则在每次单独发起http请求的时候，请求的 url 路径，必须以相对路径开头，前面不能带  / ，否则不会启用根路径做拼接。</li>
</ul>
</li>
<li><p>全局启用emulateJSON选项</p>
<ul>
<li>Vue.http.options.emulateJSON = true;<br>this.$http.post(url,参数）</li>
</ul>
</li>
</ul>
</li>
<li><p>JSONP的实现原理</p>
<ul>
<li><p>由于浏览器的安全限制，不允许AJAX访问跨域请求的数据接口，浏览器认为这种访问不安全。</p>
</li>
<li><p>可以通过动态创建script标签的形式，把script标签的src属性指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式称为JSONP（注意：根据JSONP的实现原理知晓，JSONP只支持GET请求。</p>
</li>
<li><p>具体实现过程</p>
<ul>
<li>先在客户端定义一个回调方法，预定义对数据的操作；</li>
<li>再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口。</li>
<li>服务端数据接口组织好要发送给客户端的数据，再拿着客户端传过来的回调方法名称，拼接出一个回调这个方法的字符串发送给客户端去解析执行。</li>
<li>客户端拿到服务器返回的字符串后，当作script脚本去解析执行，这样就能够拿到JSONP的数据了。</li>
</ul>
</li>
</ul>
</li>
<li><p>请求方法axios</p>
<ul>
<li><p>ajax</p>
<ul>
<li>【优点：局部更新；原生支持】</li>
<li>【缺点：可能破坏浏览器后退功能；嵌套回调】</li>
</ul>
</li>
<li><p>jqueryAjax：</p>
<ul>
<li>【在原生的ajax的基础上进行了封装；支持jsonp】</li>
</ul>
</li>
<li><p>fetch：</p>
<ul>
<li>【优点：解决回调地狱】</li>
<li>【缺点：API 偏底层，需要封装;默认不带Cookie，需要手动添加; 浏览器支持情况不是很友好，需要第三方的ployfill】</li>
</ul>
</li>
<li><p>axios</p>
<ul>
<li>支持浏览器和node.js</li>
<li>支持promise</li>
<li>能拦截请求和响应</li>
<li>能转换请求和响应数据</li>
<li>能取消请求</li>
<li>自动转换JSON数据</li>
<li>浏览器端支持防止CSRF(跨站请求伪造)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用<transition name="***"  mode="out-in">包裹</p>
<ul>
<li><p>name属性指定使用对象；<br>mode属性指定模式</p>
</li>
<li><p>有v-enter-active，v-leave-active和v-enter，v-leave的样式类名。</p>
</li>
<li><p>引入animate.css动画类库</p>
<ul>
<li>注意每个类中都得加animated这个基本类，效果才会出现。</li>
</ul>
</li>
<li><p>动画钩子函数</p>
<ul>
<li><p>第一个参数都是el，表示要执行动画的那个DOM元素，是个原生的JS DOM对象，大家可以认为el是通过document.getElementById获得的。</p>
</li>
<li><p>beforeEnter(el){}</p>
<ul>
<li>表示动画入场之前，此时动画尚未开始，可在函数中设置动画起始样式。</li>
</ul>
</li>
<li><p>enter(el，done){<br>el.offsetWidth<br>el.style.transform = ''<br>done()<br>}</p>
<ul>
<li>enter表示动画开始之后的样式，这里可以设置动画完成之后的结束状态。</li>
<li>el.offsetWidth这句话没实际作用，但是不写，出不来动画效果，可认为el.offsetWidth会强制动画刷新。</li>
<li>done():done是afterEnter()函数的引用，写上即可解决需要等一下才会出现afterEnter中设置的样式。因为它被同步调用。</li>
</ul>
</li>
<li><p>afterEnetr(el){}</p>
</li>
</ul>
</li>
<li><p>transition-group</p>
<ul>
<li>要使元素都很平滑过渡，使用固定模式：<br>.v-move{ transition: all  0.6s  ease; }<br>.v-leave-active{  position: absolute;  }<br>它会在元素的改变定位过程中应用。</li>
<li>在实现列表过渡的时候，如果需要过渡的元素是通过v-for循环创建的元素不能使用transition包裹，而应该使用transition-group，其中每个v-for出来的元素需要加上：key属性。</li>
<li>给transition-group添加appear属性，实现页面刚渲染出来时有入场的效果。</li>
<li>设置tag属性指定transition-group渲染为指定为元素，如不指定，默认为span标签。</li>
</ul>
</li>
</ul>
</li>
<li><p>数据监听</p>
<ul>
<li>watch属性监听data中属性/路由对象的改变</li>
<li>computed计算属性</li>
</ul>
</li>
</ul>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ul>
<li><p>cookie</p>
<ul>
<li><p>优点：</p>
<ul>
<li><ol>
<li>通过良好的编程习惯，控制保存在cookie中的session对象的大小。</li>
</ol>
</li>
<li><ol start="2">
<li>通过加密和安全传输技术，减少cookie被破解的可能性。</li>
</ol>
</li>
<li><ol start="3">
<li>只在cookie中存放不敏感数据，即使被盗也不会有重大损失。</li>
</ol>
</li>
<li><ol start="4">
<li>控制cookie的生命周期，使之不会永远有效。偷盗者可能拿到一个过期的cookie。</li>
</ol>
</li>
<li>5.解决无状态问题。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><ol>
<li>cookie数量和长度的限制。每个域名最多有20条cookie，每个cookie长度不超过4KB，否则会被截掉。</li>
</ol>
</li>
<li><ol start="2">
<li>安全性问题。如果cookie被人拦截，那人就可以获取session信息。即使加密也于事无补，因为拦截者并不需要知道cookie的信息，他只要原样转发cookie就可达到目的。</li>
</ol>
</li>
<li><ol start="3">
<li>有些状态不可能保存在客户端。如，为了防止重复提交表单，我们需要在服务器保存一个计数器。如果我们把这个计数器保存在客户端就起不到任何作用。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>浏览器本地存储</p>
<ul>
<li><ul>
<li>在较高版本的浏览器中，js提供sessionStorage和globalStorage。而HTML5使用localStorage代替globalStorage。</li>
</ul>
</li>
<li><ul>
<li>seesionStorage用于存储一个会话（session）中的数据，这些数据只在同一个会话中的页面才能访问并当会话结束后数据也随之销毁。因此，sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。</li>
</ul>
</li>
<li><ul>
<li>而localStorage用于持久化的本地存储，除非用户主动删除，否则数据永远不会过期。</li>
</ul>
</li>
</ul>
</li>
<li><p>web storage与cookie的区别</p>
<ul>
<li><ul>
<li>webStorage的概念与cookie相似，区别是他是为了更大存储设计的。cookie的大小是受限的，并且每次你请求一个新的页面时cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需指定作用域，不可跨域调用。</li>
</ul>
</li>
<li><ul>
<li>除此以外，Web Storage拥有setitem，getitem，removeitem，clear等方法，不像cookie需要前端开发者自己封装setCookie和getCookie。</li>
</ul>
</li>
<li><ul>
<li>但Cookie却是不可或缺的，cookie的作用是与服务器交互，作为http规范的一部分存在，而Web Storage仅仅是为了在本地存储数据而生。</li>
</ul>
</li>
</ul>
</li>
<li><p>cookie与session区别</p>
<ul>
<li><ol>
<li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>
</ol>
</li>
<li><ol start="2">
<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。考虑到安全应当使用session。</li>
</ol>
</li>
<li><ol start="3">
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</li>
</ol>
</li>
<li>考虑到减轻服务器性能方面，应当使用COOKIE。</li>
<li><ol start="4">
<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul>
<li><p>同步加载</p>
<ul>
<li>请求提交 -> 等待服务器处理 -> 处理完毕返回，这个期间客户端浏览器不能干任何事</li>
<li>又称阻塞模式，会阻塞到未加载的css，html的加载和渲染。</li>
<li>流览器之所以会采用同步模式，是因为加载的js文件中有对dom的操作，重定向，输出document等默认行为，所以同步才是最安全的。通常会把要加载的js放到body结束标签之前，使得js可在页面最后加载，尽量减少阻塞页面的渲染。这样可以先让页面显示出来</li>
</ul>
</li>
<li><p>异步加载</p>
<ul>
<li>请求通过事件触发 -> 服务器·处理（这时浏览器可以做其他事） -> 处理完毕</li>
<li><ol>
<li>也叫非阻塞模式加载，浏览器在下载js的同时，同时还会执行后续的页面处理。</li>
</ol>
</li>
<li><ol start="2">
<li>异步加载的方案有：动态插入js标签；通过ajax去获取js代码，通过eval执行；添加defer或async属性；创建并插入ifram，让它异步执行js。</li>
</ol>
</li>
</ul>
</li>
<li><p>延迟加载（懒加载）</p>
<ul>
<li><ol>
<li>有些js代码并不是页面初始化时就立刻需要，而稍后才需要。</li>
</ol>
</li>
<li><ol start="2">
<li>延迟加载就是一开始并不加载这些暂时不用的js，而是在需要的时候或稍后再通过js 的控制来异步加载。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul>
<li><p>同源策略及其限制</p>
<ul>
<li>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。它的存在可以保护用户隐私信息，防止身份伪造等(读取Cookie)。</li>
<li>同源策略限制内容有：Cookie、LocalStorage、IndexedDB 等存储性内容</li>
<li>img，link，script这三个标签允许跨域</li>
</ul>
</li>
<li><p>处理跨域方法</p>
<ul>
<li><p>JSONP</p>
<ul>
<li>原理：利用script元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</li>
<li>JSONP优点：是兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性。</li>
<li>JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。</li>
<li>流程：<br>1.声明一个回调函数，其函数名(如fn)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据。<br>2.服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串。<br>3.最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（fn），对返回的数据进行操作。</li>
</ul>
</li>
<li><p>CORS</p>
<ul>
<li>原理：整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</li>
<li>优点在于功能更加强大支持各种HTTP Method，缺点是兼容性不如JSONP。</li>
</ul>
</li>
<li><p>WebSocket</p>
<ul>
<li>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</li>
<li>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</li>
</ul>
</li>
<li><p>PostMessage</p>
<ul>
<li>如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即"协议 + 域名 + 端口"。也可以设为*，表示不限制域名，向所有窗口发送。</li>
</ul>
</li>
<li><p>服务器上设置代理页面</p>
</li>
</ul>
</li>
</ul>
<h3 id="输入url。。。"><a href="#输入url。。。" class="headerlink" title="输入url。。。"></a>输入url。。。</h3><ul>
<li>输入url后，首先需要找到这个url域名的服务器ip,为了寻找这个ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存-》路由器缓存，缓存中没有则查找系统的hosts文件中是否有记录，如果没有则查询DNS服务器，得到服务器的ip地址后，浏览器根据这个ip以及相应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个http请求封装在一个tcp包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的html给浏览器，因为html是一个树形结构，浏览器根据这个html来构建DOM树，在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐JS代码应该放在html代码的后面，之后根据外部央视，内部央视，内联样式构建一个CSS对象模型树CSS树，构建完成后和DOM树合并为渲染树，这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为html文件中会含有图片，视频，音频等资源，在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。 Cache-Control和Expires的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用Cache-Control，在请求这些有设置了缓存的数据时，会先 查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了ETag值会在这次请求的时候作为If-None-Match的值交给服务器校验，如果一致，继续校验 Last-Modified，没有设置ETag则直接验证Last-Modified，再决定是否返回304。</li>
</ul>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul>
<li><ol>
<li>减少http请求次数：CSS Sprites，JS、CSS源码压缩，图片大小控制合适；网页Gzip，CDN托管，data缓存，图片服务器。</li>
</ol>
</li>
<li><ol start="2">
<li>前端模板JS + 数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数。</li>
</ol>
</li>
<li><ol start="3">
<li>用innerHTML代替DOM操作，减少DOM操作的次数，优化js性能。</li>
</ol>
</li>
<li><ol start="4">
<li>当需要设置的样式很多时设置className而不是直接操作style。</li>
</ol>
</li>
<li><ol start="5">
<li>少用全局变量，缓存DOM节点查找的结果。减少IO读取操作。</li>
</ol>
</li>
<li><ol start="6">
<li>避免使用动态属性。</li>
</ol>
</li>
<li><ol start="7">
<li>图片预加载，将样式表放在顶部，将脚本放在底部，加上时间戳。</li>
</ol>
</li>
<li>8.利用webpack优化</li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul>
<li><p>XSS</p>
<ul>
<li>XSS跨站脚本攻击指恶意攻击者往web页面插入恶意代码，当用户浏览该页时，嵌入其中的html代码会被执行，从而达到恶意用户的目的。</li>
<li>防范：XSS攻击的核心是利用脚本注入。因此我们解决方法很简单，不信任用户的输入，对特殊字符进行如 “<”，“>" 转义。</li>
</ul>
</li>
<li><p>CSRF</p>
<ul>
<li><p>CSRF跨站请求伪造核心是请求伪造，通过伪造身份提交POST和GET请求来进行跨域的攻击。常见操作如转账。</p>
</li>
<li><p>完成跨站请求伪造需要两个步骤：</p>
<ul>
<li><ol>
<li>登陆受信任的网站A，在本地生成cookie。</li>
</ol>
</li>
<li><ol start="2">
<li>在不登出网站A或cookie未过期时，访问危险网站B。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SQL注入</p>
<ul>
<li><p>SQL注入攻击指应用程序在向后台数据库传递数据时，攻击者将SQL语句插入到表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意代码的SQL命令。</p>
</li>
<li><p>防范：</p>
<ul>
<li>1、增加黑名单或者白名单验证<br>白名单验证一般指，检查用户输入是否是符合预期的类型、长度、数值范围或者其他格式标准。黑名单验证是指，若在用户输入中，包含明显的恶意内容则拒绝该条用户请求。在使用白名单验证时，一般会配合黑名单验证。</li>
<li>2、安全检测<br>在项目完成的时候，始终坚持安全检测</li>
<li>3、防止系统敏感信息泄露<br>对数据表的访问权限进行严格控制，尽量限制用户不必要的访问权限。</li>
</ul>
</li>
</ul>
</li>
<li><p>文件上传漏洞</p>
<ul>
<li><p>原理：由于文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，导致允许攻击者向某个可通过 Web 访问的目录上传任意后台文件，并能够将这些文件传递给解释器，就可以在远程服务器上执行任意后台脚本。</p>
</li>
<li><p>防范：</p>
<ul>
<li>1、检查服务器是否判断了上传文件类型及后缀。</li>
<li>2、定义上传文件类型白名单，即只允许白名单里面类型的文件上传。</li>
<li>3、文件上传目录禁止执行脚本解析，避免攻击者进行二次攻击。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><ul>
<li><p>状态码</p>
<ul>
<li>1   --   继续，一般在发送post请求，已发送了http header之后，服务器将返回此信息，表示确认，之后发送具体参数信息。</li>
<li>2   --      请求成功。</li>
<li>3   --    重定向</li>
<li>4   --    客户端错误。</li>
<li>5   --    服务端错误。</li>
</ul>
</li>
<li><p>http与https区别</p>
<ul>
<li>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。</li>
<li>主要的区别如下：</li>
<li>Https协议需要ca证书，费用较高。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
<li>在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层</li>
</ul>
</li>
<li><p>https</p>
<ul>
<li><p>工作原理</p>
<ul>
<li>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</li>
<li>客户使用https url访问服务器，则要求web 服务器建立ssl链接。</li>
<li>web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。</li>
<li>客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。</li>
<li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>
<li>web服务器通过自己的私钥解密出会话密钥。</li>
<li>web服务器通过会话密钥加密与客户端之间的通信。</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>
<li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。</li>
<li>https缓存不如http高效，会增加数据开销。</li>
<li>SSL证书也需要钱，功能越强大的证书费用越高。</li>
<li>SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。</li>
</ul>
</li>
</ul>
</li>
<li><p>http2.0</p>
<ul>
<li><ol>
<li>提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比http1.0）</li>
</ol>
</li>
<li><ol start="2">
<li>允许多路复用：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了：在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。</li>
</ol>
</li>
<li><ol start="3">
<li>二进制分帧：HTTP2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码</li>
</ol>
</li>
<li><ol start="4">
<li>首部压缩</li>
</ol>
</li>
<li><ol start="5">
<li>服务器端推送</li>
</ol>
</li>
</ul>
</li>
<li><p>http协议无状态协议</p>
<ul>
<li><p>无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，需要重传，这样可能导致每次连接传送的数据量增大。</p>
<ul>
<li>HTTP无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持HTTP连接状态的技术就应运而生了，一个是Cookie，而另一个则是Session。HTTP本身是一个无状态的连接协议，为了支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是Cookie和Session了。</li>
<li>也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。</li>
</ul>
</li>
<li><p>可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。</p>
</li>
</ul>
</li>
</ul>
<h3 id="对前端的认识和看法"><a href="#对前端的认识和看法" class="headerlink" title="对前端的认识和看法"></a>对前端的认识和看法</h3><ul>
<li><ol>
<li>前端他是一个工作，他的工作领域是浏览器，它既要与美工，设计打交道又要懂点后台代码，知道ajax怎么从后台拿数据，接口怎么调用，最主要的是把美工的图合成完成的网页呈现给用户，需要实现网页的交互效果。</li>
</ol>
</li>
<li><ol start="2">
<li>前端处于设计和后台的中间领域，起到承上启下的作用，这就要求前端工程师的知识面在横向上必须要广。服务器技术要懂，产品与交互也要懂</li>
</ol>
</li>
<li><ol start="3">
<li>它需要掌握三个基本的技能：HTML，CSS， javascript。另外还需要懂点PHP或者其他应用在Web上的编程语言。</li>
</ol>
</li>
<li>前端的未来则是：有越来越多的软件开始在浏览器里运行，随着google和火狐的webos的发展，甚至在不久的将来，浏览器的api，会替代操作系统的sdk成为软件开发的标准。随着html5的发展，浏览器里运行的早已不是简单的页面，而是复杂的web应用。前端工程师也早已不是页面制作，而是web应用工程师。而未来究竟是web时代还是app时代仍是一个难以回答的问题。</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>逻辑结构</p>
<ul>
<li><p>集合结构</p>
</li>
<li><p>线性结构</p>
<ul>
<li>栈</li>
<li>队列</li>
<li>链表</li>
</ul>
</li>
<li><p>树形结构</p>
</li>
<li><p>图形结构</p>
</li>
</ul>
</li>
<li><p>物理结构</p>
<ul>
<li>顺序存储结构</li>
<li>链式存储结构</li>
</ul>
</li>
</ul>
<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>底部导航条采用uni-app自带的的tabbar，可在pages.json配置。因为顶部导航条的样式不想采用默认样式，所以取消顶部导航栏的默认样式，使用自己写的导航条，并使用固定定位display为flexed将导航条固定在顶部，设置z-index为99，使所有内容都处于导航条下面。</p>
<h3 id="尽量使用字体图标代替图片"><a href="#尽量使用字体图标代替图片" class="headerlink" title="尽量使用字体图标代替图片"></a>尽量使用字体图标代替图片</h3><ul>
<li><ol>
<li>轻量级：一个字体图标要比一系列的图像小，一旦字体加载了，图标就会马上渲染出来，不需要下载一个个图像，这样可减少HTTP请求，而且和HTML5的离线存储配合，可以对性能做出优化。</li>
</ol>
</li>
<li><ol start="2">
<li>灵活性：不调字体可以像页面中的文字一样通过font-size属性来对其进行大小的设置，且可添加各种文字效果，如color、hover、filter、text-shadow、transform等效果。灵活的很。</li>
</ol>
</li>
<li><ol start="3">
<li>兼容性：图标字体支持现代浏览器甚至低版本的IE浏览器，可放心使用。</li>
</ol>
</li>
<li><ol start="4">
<li>相对于位图放大图片会失真，缩小会浪费像素点，图标字体不会出现这种情况。</li>
</ol>
</li>
</ul>
<p>另外，点击导航栏进行页面切换部分采用uni-app官方为我们提供的scroll-view来实现横向或竖向的滚动。其特点是可以无缝滚动，且不会出现滚动条，当想使用滚动动画时可使用scroll-with-animation，感觉比较方便。</p>
<p>图片轮播图中出现在开发者工具显示正常，在手机上右半部分出现一部分空白，只需加上一个div将其包裹起来，最后一张图片切换到第一张时给人感觉不正常，只需将两套一样的图片拼接在一起即可。还有就是</p>
<p>页面整体采用flex布局，把重复的地方抽离出来并以组件形式呈现，把字体文件和公共样式文件单独存放。</p>
<h3 id="使用swiper组件"><a href="#使用swiper组件" class="headerlink" title="使用swiper组件"></a>使用swiper组件</h3><ul>
<li><ul>
<li>决定轮播图真正的高度是swiper，在其上设置高度才有效。swiper-item宽高自动是100%；</li>
</ul>
</li>
<li><ul>
<li>最好在swiper组件外面用view包裹，不然在手机端看时，图片无法全部铺满屏宽，右边有留白。</li>
</ul>
</li>
</ul>
</script></li></ol></li></ul></li></ul>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-http的学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/06/http的学习/" class="article-date">
      <time datetime="2020-04-06T02:47:35.000Z" itemprop="datePublished">2020-04-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/http的学习/">http的学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="HTTP无状态协议"><a href="#HTTP无状态协议" class="headerlink" title="HTTP无状态协议"></a>HTTP无状态协议</h4><p>HTTP无状态协议，是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<p>客户端与服务器进行动态交互的Web应用程序出现之后，HTTP无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持HTTP连接状态的技术就应运而生了，一个是<a href="https://baike.baidu.com/item/Cookie" target="_blank" rel="noopener">Cookie</a>，而另一个则是<a href="https://baike.baidu.com/item/Session" target="_blank" rel="noopener">Session</a>。HTTP本身是一个无状态的<a href="https://baike.baidu.com/item/连接协议" target="_blank" rel="noopener">连接协议</a>，为了支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是Cookie和Session了。</p>
<p>Cookie是通过客户端保持状态的<a href="https://baike.baidu.com/item/解决/32786" target="_blank" rel="noopener">解决</a>方案。从定义上来说，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。让我们说得更具体一些：当用户使用浏览器访问一个支持<a href="https://baike.baidu.com/item/Cookie/1119" target="_blank" rel="noopener">Cookie</a>的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的<a href="https://baike.baidu.com/item/超文本" target="_blank" rel="noopener">超文本</a>的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体（Response Body）中的，而是存放于HTTP响应头（Response Header）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置，对于<a href="https://baike.baidu.com/item/Windows操作系统/852149" target="_blank" rel="noopener">Windows操作系统</a>而言，我们可以从： [<a href="https://baike.baidu.com/item/系统盘" target="_blank" rel="noopener">系统盘</a>]:\Documents and Settings[用户名]\Cookies目录中找到存储的Cookie；自此，客户端再向服务器发送请求的时候，都会把相应的<a href="https://baike.baidu.com/item/Cookie/1119" target="_blank" rel="noopener">Cookie</a>再次发回至服务器。而这次，Cookie信息则存放在<a href="https://baike.baidu.com/item/HTTP请求头/6623287" target="_blank" rel="noopener">HTTP请求头</a>（Request Header）了。</p>
<p>有了Cookie这样的技术实现，服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。通常，我们可以从很多网站的登录界面中看到“请记住我”这样的选项，如果你勾选了它之后再登录，那么在下一次访问该网站的时候就不需要进行重复而繁琐的登录动作了，而这个功能就是通过Cookie实现的。</p>
<p>与Cookie相对的一个解决方案是Session，它是通过服务器来保持状态的。由于<a href="https://baike.baidu.com/item/Session/479100" target="_blank" rel="noopener">Session</a>这个词汇包含的语义很多，因此需要在这里明确一下 Session的含义。首先，我们通常都会把Session翻译成会话，因此我们可以把客户端浏览器与服务器之间一系列交互的动作称为一个  Session。从这个语义出发，我们会提到Session持续的时间，会提到在Session过程中进行了什么操作等等；其次，Session指的是服务器端为客户端所开辟的存储空间，在其中保存的信息就是用于保持状态。从这个语义出发，我们则会提到往Session中存放什么内容，如何根据键值从 Session中获取匹配的内容等。</p>
<p>要使用Session，第一步当然是创建Session了。那么Session在何时创建呢？当然还是在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同创建Session的方法，而在<a href="https://baike.baidu.com/item/Java/85979" target="_blank" rel="noopener">Java</a>中是通过调用HttpServletRequest的getSession方法（使用true作为参数）创建的。在创建了<a href="https://baike.baidu.com/item/Session/479100" target="_blank" rel="noopener">Session</a>的同时，服务器会为该Session生成唯一的Session id，而这个Session  id在随后的请求中会被用来重新获得已经创建的Session；在Session被创建之后，就可以调用Session相关的方法往Session中增加内容了，而这些内容只会保存在服务器中，发到客户端的只有Session id；当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session  id找到相应的Session，从而再次使用之。正是这样一个过程，用户的状态也就得以保持了。</p>
<p>综上所述，HTTP本身是一个无状态的<a href="https://baike.baidu.com/item/连接协议/7768217" target="_blank" rel="noopener">连接协议</a>，为了支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是<a href="https://baike.baidu.com/item/Cookie/1119" target="_blank" rel="noopener">Cookie</a>和Session了。</p>
<h4 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h4><p>​    1. cookie数据存放在客户的浏览器上，session数据放在服务器上。<br>​    2. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。考虑到安全应当使用session。<br>​    3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>​       考虑到减轻服务器性能方面，应当使用COOKIE。<br>​    4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
<h4 id="cookie的优缺点"><a href="#cookie的优缺点" class="headerlink" title="cookie的优缺点"></a>cookie的优缺点</h4><h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><p>​        1. 通过良好的编程习惯，控制保存在cookie中的session对象的大小。<br>​        2. 通过加密和安全传输技术，减少cookie被破解的可能性。<br>​        3. 只在cookie中存放不敏感数据，即使被盗也不会有重大损失。<br>​        4. 控制cookie的生命周期，使之不会永远有效。偷盗者可能拿到一个过期的cookie。<br>​        5.解决无状态问题。</p>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><p>​        1. cookie数量和长度的限制。每个域名最多有20条cookie，每个cookie长度不超过4KB，否则会被截掉。<br>​        2. 安全性问题。如果cookie被人拦截，那人就可以获取session信息。即使加密也于事无补，因为拦截者并不需要知道cookie的信息，他只要原样转发cookie就可达到目的。<br>​        3. 有些状态不可能保存在客户端。如，为了防止重复提交表单，我们需要在服务器保存一个计数器。如果我们把这个计数器保存在客户端就起不到任何作用。</p>
<h4 id="常用的HTTP方法"><a href="#常用的HTTP方法" class="headerlink" title="常用的HTTP方法"></a>常用的HTTP方法</h4><ul>
<li>GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器</li>
<li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</li>
<li>PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。</li>
<li>HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</li>
<li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。</li>
<li>OPTIONS：查询相应URI支持的HTTP方法。</li>
</ul>
<h4 id="URL和URI区别"><a href="#URL和URI区别" class="headerlink" title="URL和URI区别"></a>URL和URI区别</h4><p><strong>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。</strong></p>
<ul>
<li>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的</li>
<li>URI一般由三部组成：</li>
<li>①访问资源的命名机制</li>
<li>②存放资源的主机名</li>
<li>③资源自身的名称，由路径表示，着重强调于资源。</li>
</ul>
<p><strong>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</strong></p>
<ul>
<li>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。</li>
<li>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：</li>
<li>①协议(或称为服务方式)</li>
<li>②存有该资源的主机IP地址(有时也包括端口号)</li>
<li>③主机资源的具体地址。如目录和文件名等</li>
</ul>
<h4 id="HTTP请求报文与响应报文格式"><a href="#HTTP请求报文与响应报文格式" class="headerlink" title="HTTP请求报文与响应报文格式"></a>HTTP请求报文与响应报文格式</h4><h6 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h6><p><img src="https://img-blog.csdn.net/20180213114347309" alt="img"></p>
<ul>
<li>a、请求行：包含请求方法、URI、HTTP版本信息</li>
<li>b、请求首部字段</li>
<li>c、请求内容实体</li>
<li>d、空行</li>
</ul>
<h6 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h6><h6 id><a href="#" class="headerlink" title></a><img src="https://img-blog.csdn.net/20180213114358760" alt="img"></h6><ul>
<li>a、状态行：包含HTTP版本、状态码、状态码的原因短语</li>
<li>b、响应首部字段</li>
<li>c、响应内容实体</li>
<li>d、空行</li>
</ul>
<h6 id="常见的首部"><a href="#常见的首部" class="headerlink" title="常见的首部"></a>常见的首部</h6><ul>
<li><strong>通用首部字段（请求报文与响应报文都会使用的首部字段）</strong><ul>
<li>Date：创建报文时间</li>
<li>Connection：连接的管理</li>
<li>Cache-Control：缓存的控制</li>
<li>Transfer-Encoding：报文主体的传输编码方式</li>
</ul>
</li>
<li><strong>请求首部字段（请求报文会使用的首部字段）</strong><ul>
<li>Host：请求资源所在服务器</li>
<li>Accept：可处理的媒体类型</li>
<li>Accept-Charset：可接收的字符集</li>
<li>Accept-Encoding：可接受的内容编码</li>
<li>Accept-Language：可接受的自然语言</li>
</ul>
</li>
<li><strong>响应首部字段（响应报文会使用的首部字段）</strong><ul>
<li>Accept-Ranges：可接受的字节范围</li>
<li>Location：令客户端重新定向到的URI</li>
<li>Server：HTTP服务器的安装信息</li>
</ul>
</li>
<li><strong>实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）</strong><ul>
<li>Allow：资源可支持的HTTP方法</li>
<li>Content-Type：实体主类的类型</li>
<li>Content-Encoding：实体主体适用的编码方式</li>
<li>Content-Language：实体主体的自然语言</li>
<li>Content-Length：实体主体的的字节数</li>
<li>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</li>
</ul>
</li>
</ul>
<h4 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h4><ul>
<li>首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；</li>
<li>客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；</li>
<li>消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；</li>
<li>发送给服务端，此时只有服务端（RSA私钥）能解密。</li>
<li>解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。</li>
</ul>
<h4 id="一次完整的HTTP请求所经历的7个步骤"><a href="#一次完整的HTTP请求所经历的7个步骤" class="headerlink" title="一次完整的HTTP请求所经历的7个步骤"></a>一次完整的HTTP请求所经历的7个步骤</h4><p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p>
<ul>
<li>建立TCP连接</li>
</ul>
<p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。<strong>HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</strong></p>
<ul>
<li>Web浏览器向Web服务器发送请求行</li>
</ul>
<p>一旦建立了TCP连接，<strong>Web浏览器就会向Web服务器发送请求命令</strong>。例如：GET /sample/hello.js HTTP/1.1。</p>
<ul>
<li>Web浏览器发送请求头<ul>
<li>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，<strong>之后浏览器发送了一空白行来通知服务器</strong>，它已经结束了该头信息的发送。</li>
</ul>
</li>
<li>Web服务器应答<ul>
<li>客户机向服务器发出请求后，服务器会客户机回送应答， <strong>HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</strong></li>
</ul>
</li>
<li>Web服务器发送应答头<ul>
<li>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</li>
</ul>
</li>
<li>Web服务器向浏览器发送数据<ul>
<li>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，<strong>它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据</strong>。</li>
</ul>
</li>
<li>Web服务器关闭TCP连接<ul>
<li>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>

<p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>
<p>建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接</p>
<h4 id="常见的HTTP相应状态码"><a href="#常见的HTTP相应状态码" class="headerlink" title="常见的HTTP相应状态码"></a>常见的HTTP相应状态码</h4><ul>
<li>200：请求被正常处理</li>
<li>204：请求被受理但没有资源可以返回</li>
<li>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</li>
<li>301：永久性重定向</li>
<li>302：临时重定向</li>
<li>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</li>
<li>304：发送附带条件的请求时，条件不满足时返回，与重定向无关</li>
<li>307：临时重定向，与302类似，只是强制要求使用POST方法</li>
<li>400：请求报文语法有误，服务器无法识别</li>
<li>401：请求需要认证</li>
<li>403：请求的对应资源禁止被访问</li>
<li>404：服务器无法找到对应资源</li>
<li>500：服务器内部错误</li>
<li>503：服务器正忙</li>
</ul>
<h4 id="HTTP1-1版本新特性"><a href="#HTTP1-1版本新特性" class="headerlink" title="HTTP1.1版本新特性"></a>HTTP1.1版本新特性</h4><ul>
<li>a、<strong>默认持久连接节省通信量</strong>，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</li>
<li>b、<strong>管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应</strong></li>
<li>c、<strong>断点续传</strong><ul>
<li><strong>实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输。</strong></li>
</ul>
</li>
</ul>
<h6 id="HTTP优化方案"><a href="#HTTP优化方案" class="headerlink" title="HTTP优化方案"></a>HTTP优化方案</h6><ul>
<li><strong>TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持。</strong></li>
<li><strong>内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。</strong></li>
<li><strong>压缩：将文本数据进行压缩，减少带宽</strong></li>
<li><strong>SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速</strong></li>
<li><strong>TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。</strong></li>
</ul>
<h4 id="Cache-control缓存控制"><a href="#Cache-control缓存控制" class="headerlink" title="Cache-control缓存控制"></a>Cache-control缓存控制</h4><p>网页的缓存是由HTTP消息头中的“Cache-control”来控制的，常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。<br>其作用根据不同的重新浏览方式分为以下几种情况：<br>（1）  打开新窗口如果指定cache-control的值为private、no-cache、must-revalidate，那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值，那么在此值内的时间里就不会重新访问服务器，例如： Cache-control: max-age=5 表示当访问此网页后的5秒内再次访问不会去服务器。<br>（2） 在地址栏回车如果值为private或must-revalidate（和网上说的不一样），则只有第一次访问时会访问服务器，以后就不再访问。如果值为no-cache，那么每次都会访问。如果值为max-age，则在过期之前不会重复访问。<br>（3） 按后退按扭如果值为private、must-revalidate、max-age，则不会重访问，而如果为no-cache，则每次都重复访问。<br>（4） 按刷新按扭无论为何值，都会重复访问  当指定Cache-control值为“no-cache”时，访问此页面不会在Internet临时文章夹留下页面备份。另外，通过指定“Expires”值也会影响到缓存。例如，指定Expires值为一个早已过去的时间，那么访问此网时若重复在地址栏按回车，那么每次都会重复访问： Expires: Fri, 31 Dec 1999 16:00:00 GMT  在ASP中，可以通过Response对象的Expires、ExpiresAbsolute属性控制Expires值；通过Response对象的CacheControl属性控制Cache-control的值，例如： Response.ExpiresAbsolute = #2000-1-1# ‘  指定绝对的过期时间，这个时间用的是服务器当地时间，会被自动转换为GMT时间 Response.Expires = 20 ‘  指定相对的过期时间，以分钟为单位，表示从当前时间起过多少分钟过期。 Response.CacheControl = “no-cache”  Expires值是可以通过在Internet临时文件夹中查看临时文件的属性看到的。                                    </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-课程表制作" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/29/课程表制作/" class="article-date">
      <time datetime="2020-03-29T00:09:28.000Z" itemprop="datePublished">2020-03-29</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/29/课程表制作/">课程表制作</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h5 id="课程表制作"><a href="#课程表制作" class="headerlink" title="课程表制作"></a>课程表制作</h5><p>使用微信小程序制作的课程表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//index.wxml文件</span><br><span class="line"></span><br><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;view class=&quot;top&quot;&gt;</span><br><span class="line">    &lt;view wx:for=&quot;&#123;&#123;[&apos;一&apos;,&apos;二&apos;,&apos;三&apos;,&apos;四&apos;,&apos;五&apos;,&apos;六&apos;,&apos;日&apos;]&#125;&#125;&quot; class=&quot;top-text&quot;&gt;</span><br><span class="line">      周&#123;&#123;item&#125;&#125;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view style=&quot;display:flex;flex-direction:row;background:#D2E6B3&quot;&gt;</span><br><span class="line">  &lt;view style=&quot;color:#7cba23;&quot;&gt;</span><br><span class="line">    &lt;view wx:for=&quot;&#123;&#123;[1,2,3,4,5,6,7,8,9,10]&#125;&#125;&quot; class=&quot;left&quot;&gt;</span><br><span class="line">      &#123;&#123;item&#125;&#125;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">  &lt;!-- &lt;view wx:for=&quot;&#123;&#123;[1,2,3,4,5,6,7,8,9,10]&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;view style=&quot;width:750rpx;margin-top:&#123;&#123;(index+1)*100&#125;&#125;rpx;  position: absolute;border-bottom:1rpx solid &#123;&#123;index==3?&apos;red&apos;:&apos;lightgray&apos;&#125;&#125;;&quot;&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt; --&gt;</span><br><span class="line">  &lt;view wx:for=&quot;&#123;&#123;wlist&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;view class=&quot;flex-item kcb-item&quot; bindtap=&quot;showCardView&quot; data-statu=&quot;open&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; style=&quot;margin-left:&#123;&#123;(item.xqj-1)*100&#125;&#125;rpx;margin-top:&#123;&#123;(item.skjc-1)*100+10&#125;&#125;rpx;height:&#123;&#123;item.skcd*100-5&#125;&#125;rpx;background-color:&#123;&#123;colorArrays[index%9]&#125;&#125;&quot;&gt;</span><br><span class="line">      &lt;view class=&quot;smalltext&quot;&gt;&#123;&#123;item.kcmc&#125;&#125;&lt;/view&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<p>index.wxss</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">.top &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: row;</span><br><span class="line">  margin-left: 35rpx;</span><br><span class="line">  background-color: #d2e6b3;</span><br><span class="line">  color: #7cba23;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.top-text &#123;</span><br><span class="line">  width: 100rpx;</span><br><span class="line">  height: 35rpx;</span><br><span class="line">  font-size: 9pt;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">  border: 1px solid gray;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">  width: 35rpx;</span><br><span class="line">  height: 100rpx;</span><br><span class="line">  font-size: 9pt;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">  border: 1px solid gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.flex-item &#123;</span><br><span class="line">  width: 95rpx;</span><br><span class="line">  height: 100px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.kcb-item &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.smalltext &#123;</span><br><span class="line">  font-size: 8pt;</span><br><span class="line">  color: #fff;</span><br><span class="line">  padding-left: 2px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.scroll &#123;</span><br><span class="line">  height: 1170rpx;</span><br><span class="line">  z-index: 101;</span><br><span class="line">  position: fixed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.js文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">//获取应用实例</span><br><span class="line">const app = getApp()</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    colorArrays: [&quot;#85B8CF&quot;, &quot;#C0C652&quot;, &quot;#D8AA5A&quot;, &quot;#FC9F9D&quot;, &quot;#0A9A84&quot;, &quot;#61BC69&quot;, &quot;#12AEF3&quot;, &quot;#E29AAD&quot;], </span><br><span class="line">    wlist: [</span><br><span class="line">      &#123; &quot;xqj&quot;: 1, &quot;skjc&quot;: 1, &quot;skcd&quot;: 3, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 1, &quot;skjc&quot;: 5, &quot;skcd&quot;: 3, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 2, &quot;skjc&quot;: 1, &quot;skcd&quot;: 2, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 2, &quot;skjc&quot;: 8, &quot;skcd&quot;: 2, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 3, &quot;skjc&quot;: 4, &quot;skcd&quot;: 1, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 3, &quot;skjc&quot;: 8, &quot;skcd&quot;: 1, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 3, &quot;skjc&quot;: 5, &quot;skcd&quot;: 2, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 4, &quot;skjc&quot;: 2, &quot;skcd&quot;: 3, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 4, &quot;skjc&quot;: 8, &quot;skcd&quot;: 2, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 5, &quot;skjc&quot;: 1, &quot;skcd&quot;: 2, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 6, &quot;skjc&quot;: 3, &quot;skcd&quot;: 2, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">      &#123; &quot;xqj&quot;: 7, &quot;skjc&quot;: 5, &quot;skcd&quot;: 3, &quot;kcmc&quot;: &quot;高等数学@教A-301&quot; &#125;,</span><br><span class="line">    ],</span><br><span class="line">    motto: &apos;Hello World&apos;,</span><br><span class="line">    userInfo: &#123;&#125;,</span><br><span class="line">    hasUserInfo: false,</span><br><span class="line">    canIUse: wx.canIUse(&apos;button.open-type.getUserInfo&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  //事件处理函数</span><br><span class="line">  bindViewTap: function() &#123;</span><br><span class="line">    wx.navigateTo(&#123;</span><br><span class="line">      url: &apos;../logs/logs&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: function () &#123;</span><br><span class="line">    if (app.globalData.userInfo) &#123;</span><br><span class="line">      this.setData(&#123;</span><br><span class="line">        userInfo: app.globalData.userInfo,</span><br><span class="line">        hasUserInfo: true</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else if (this.data.canIUse)&#123;</span><br><span class="line">      // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回</span><br><span class="line">      // 所以此处加入 callback 以防止这种情况</span><br><span class="line">      app.userInfoReadyCallback = res =&gt; &#123;</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">          userInfo: res.userInfo,</span><br><span class="line">          hasUserInfo: true</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 在没有 open-type=getUserInfo 版本的兼容处理</span><br><span class="line">      wx.getUserInfo(&#123;</span><br><span class="line">        success: res =&gt; &#123;</span><br><span class="line">          app.globalData.userInfo = res.userInfo</span><br><span class="line">          this.setData(&#123;</span><br><span class="line">            userInfo: res.userInfo,</span><br><span class="line">            hasUserInfo: true</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getUserInfo: function(e) &#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">    app.globalData.userInfo = e.detail.userInfo</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      userInfo: e.detail.userInfo,</span><br><span class="line">      hasUserInfo: true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5CCCY%5CDesktop%5C3.png" alt="3"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-CSS3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/26/CSS3/" class="article-date">
      <time datetime="2020-03-26T03:48:03.000Z" itemprop="datePublished">2020-03-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/CSS3/">CSS3</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>CSS知识点</p>
<h2 id="一-解决老的浏览器支持问题"><a href="#一-解决老的浏览器支持问题" class="headerlink" title="一 . 解决老的浏览器支持问题"></a>一 . 解决老的浏览器支持问题</h2><h5 id="1-加上相应的前缀即可"><a href="#1-加上相应的前缀即可" class="headerlink" title="1.加上相应的前缀即可"></a>1.加上相应的前缀即可</h5><table>
<thead>
<tr>
<th>Chorme</th>
<th>IE</th>
<th>Firefox</th>
<th>Safari</th>
<th>Opera</th>
</tr>
</thead>
<tbody><tr>
<td>-webkit-</td>
<td>-ms-</td>
<td>-moz-</td>
<td>-webkit-</td>
<td>-o-或者-xv-</td>
</tr>
</tbody></table>
<h4 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h4><ul>
<li>CSS3弹性盒子：<ul>
<li>是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式；引入弹性布局的目的是提供更有效的方式来对一个容器中的子元素进行排列，对齐和分配空白空间。</li>
<li>弹性容器通过设置display属性为flex或inline-flex将其定义为弹性盒子，弹性容器内包含了一个或多个弹性子元素； 弹性容器外及弹性子元素内是正常渲染的。弹性盒子只定义了弹性子元素如何在弹性容器内布局。</li>
<li>弹性子元素通常在弹性盒子内一行显示。默认情况每个容器只有一行。</li>
</ul>
</li>
</ul>
<h4 id="3-选择器"><a href="#3-选择器" class="headerlink" title="3.选择器"></a>3.选择器</h4><table>
<thead>
<tr>
<th>.intro</th>
<th>选择所有class=”intro”的元素</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-id.html" target="_blank" rel="noopener">#<em>id</em></a></td>
<td>#firstname</td>
<td>选择所有id=”firstname”的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-all.html" target="_blank" rel="noopener">*</a></td>
<td>*</td>
<td>选择所有元素</td>
</tr>
<tr>
<td><em>element</em></td>
<td>p</td>
<td>选择所有p元素</td>
</tr>
<tr>
<td><em>element,element</em></td>
<td>div,p</td>
<td>选择所有元素和元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-element-element.html" target="_blank" rel="noopener"><em>element element</em></a></td>
<td>div p</td>
<td>选择元素内的所有元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-element-gt.html" target="_blank" rel="noopener"><em>element</em>&gt;<em>element</em></a></td>
<td>div&gt;p</td>
<td>选择所有父级是div元素的p元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-element-pluss.html" target="_blank" rel="noopener"><em>element</em>+<em>element</em></a></td>
<td>div+p</td>
<td>选择所有紧接着元素之后的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-attribute.html" target="_blank" rel="noopener">[<em>attribute</em>]</a></td>
<td>[target]</td>
<td>选择所有带有target属性元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-attribute-value.html" target="_blank" rel="noopener">[<em>attribute</em>=<em>value</em>]</a></td>
<td>[target=-blank]</td>
<td>选择所有使用target=”-blank”的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-attribute-value-contains.html" target="_blank" rel="noopener">[<em>attribute</em>~=<em>value</em>]</a></td>
<td>[title~=flower]</td>
<td>选择标题属性包含单词”flower”的所有元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-attribute-value-lang.html" target="_blank" rel="noopener">[<em>attribute</em>|=<em>language</em>]</a></td>
<td>[lang|=en]</td>
<td>选择一个lang属性的起始值=”EN”的所有元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-link.html" target="_blank" rel="noopener">:link</a></td>
<td>a:link</td>
<td>选择所有未访问链接</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-visited.html" target="_blank" rel="noopener">:visited</a></td>
<td>a:visited</td>
<td>选择所有访问过的链接</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-active.html" target="_blank" rel="noopener">:active</a></td>
<td>a:active</td>
<td>选择活动链接</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-hover.html" target="_blank" rel="noopener">:hover</a></td>
<td>a:hover</td>
<td>选择鼠标在链接上面时</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-focus.html" target="_blank" rel="noopener">:focus</a></td>
<td>input:focus</td>
<td>选择具有焦点的输入元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-firstletter.html" target="_blank" rel="noopener">:first-letter</a></td>
<td>p:first-letter</td>
<td>选择每一个元素的第一个字母</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-firstline.html" target="_blank" rel="noopener">:first-line</a></td>
<td>p:first-line</td>
<td>选择每一个元素的第一行</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-firstchild.html" target="_blank" rel="noopener">:first-child</a></td>
<td>p:first-child</td>
<td>指定只有当元素是其父级的第一个子级的样式。</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-before.html" target="_blank" rel="noopener">:before</a></td>
<td>p:before</td>
<td>在每个元素之前插入内容</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-after.html" target="_blank" rel="noopener">:after</a></td>
<td>p:after</td>
<td>在每个元素之后插入内容</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-lang.html" target="_blank" rel="noopener">:lang(<em>language</em>)</a></td>
<td>p:lang(it)</td>
<td>选择一个lang属性的起始值=”it”的所有元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-gen-sibling.html" target="_blank" rel="noopener"><em>element1</em>~<em>element2</em></a></td>
<td>p~ul</td>
<td>选择p元素之后的每一个ul元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-attr-begin.html" target="_blank" rel="noopener">[<em>attribute</em>^=<em>value</em>]</a></td>
<td>a[src^=”https”]</td>
<td>选择每一个src属性的值以”https”开头的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-attr-end.html" target="_blank" rel="noopener">[<em>attribute</em>$=<em>value</em>]</a></td>
<td>a[src$=”.pdf”]</td>
<td>选择每一个src属性的值以”.pdf”结尾的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-attr-contain.html" target="_blank" rel="noopener">[<em>attribute*</em>=<em>value</em>]</a></td>
<td>a[src*=”44lan”]</td>
<td>选择每一个src属性的值包含子字符串”44lan”的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-first-of-type.html" target="_blank" rel="noopener">:first-of-type</a></td>
<td>p:first-of-type</td>
<td>选择每个p元素是其父级的第一个p元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-last-of-type.html" target="_blank" rel="noopener">:last-of-type</a></td>
<td>p:last-of-type</td>
<td>选择每个p元素是其父级的最后一个p元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-only-of-type.html" target="_blank" rel="noopener">:only-of-type</a></td>
<td>p:only-of-type</td>
<td>选择每个p元素是其父级的唯一p元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-only-child.html" target="_blank" rel="noopener">:only-child</a></td>
<td>p:only-child</td>
<td>选择每个p元素是其父级的唯一子元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-nth-child.html" target="_blank" rel="noopener">:nth-child(<em>n</em>)</a></td>
<td>p:nth-child(2)</td>
<td>选择每个p元素是其父级的第二个子元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-nth-last-child.html" target="_blank" rel="noopener">:nth-last-child(<em>n</em>)</a></td>
<td>p:nth-last-child(2)</td>
<td>选择每个p元素的是其父级的第二个子元素，从最后一个子项计数</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-nth-of-type.html" target="_blank" rel="noopener">:nth-of-type(<em>n</em>)</a></td>
<td>p:nth-of-type(2)</td>
<td>选择每个p元素是其父级的第二个p元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-nth-last-of-type.html" target="_blank" rel="noopener">:nth-last-of-type(<em>n</em>)</a></td>
<td>p:nth-last-of-type(2)</td>
<td>选择每个p元素的是其父级的第二个p元素，从最后一个子项计数</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-last-child.html" target="_blank" rel="noopener">:last-child</a></td>
<td>p:last-child</td>
<td>选择每个p元素是其父级的最后一个子级。</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-root.html" target="_blank" rel="noopener">:root</a></td>
<td>:root</td>
<td>选择文档的根元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-empty.html" target="_blank" rel="noopener">:empty</a></td>
<td>p:empty</td>
<td>选择每个没有任何子级的p元素（包括文本节点）</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-target.html" target="_blank" rel="noopener">:target</a></td>
<td>#news:target</td>
<td>选择当前活动的#news元素（包含该锚名称的点击的URL）</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-enabled.html" target="_blank" rel="noopener">:enabled</a></td>
<td>input:enabled</td>
<td>选择每一个已启用的输入元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-disabled.html" target="_blank" rel="noopener">:disabled</a></td>
<td>input:disabled</td>
<td>选择每一个禁用的输入元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-checked.html" target="_blank" rel="noopener">:checked</a></td>
<td>input:checked</td>
<td>选择每个选中的输入元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-not.html" target="_blank" rel="noopener">:not(<em>selector</em>)</a></td>
<td>:not(p)</td>
<td>选择每个并非p元素的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-selection.html" target="_blank" rel="noopener">::selection</a></td>
<td>::selection</td>
<td>匹配元素中被用户选中或处于高亮状态的部分</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-out-of-range.html" target="_blank" rel="noopener">:out-of-range</a></td>
<td>:out-of-range</td>
<td>匹配值在指定区间之外的input元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-in-range.html" target="_blank" rel="noopener">:in-range</a></td>
<td>:in-range</td>
<td>匹配值在指定区间之内的input元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-read-write.html" target="_blank" rel="noopener">:read-write</a></td>
<td>:read-write</td>
<td>用于匹配可读及可写的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-read-only.html" target="_blank" rel="noopener">:read-only</a></td>
<td>:read-only</td>
<td>用于匹配设置 “readonly”（只读） 属性的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-optional.html" target="_blank" rel="noopener">:optional</a></td>
<td>:optional</td>
<td>用于匹配可选的输入元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-required.html" target="_blank" rel="noopener">:required</a></td>
<td>:required</td>
<td>用于匹配设置了 “required” 属性的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-valid.html" target="_blank" rel="noopener">:valid</a></td>
<td>:valid</td>
<td>用于匹配输入值为合法的元素</td>
</tr>
<tr>
<td><a href="https://www.w3cschool.cn/cssref/sel-invalid.html" target="_blank" rel="noopener">:invalid</a></td>
<td>:invalid</td>
<td>用于匹配输入值为非法的元素</td>
</tr>
</tbody></table>
<h2 id="二-多重样式优先级深入概念"><a href="#二-多重样式优先级深入概念" class="headerlink" title="二 . 多重样式优先级深入概念"></a>二 . 多重样式优先级深入概念</h2><p>优先级是浏览器是通过判断哪些属性值与元素最相关以决定并应用到该元素上的。优先级仅由选择器组成的匹配规则决定的。</p>
<p>优先级就是分配给指定的CSS声明的一个权重，它由匹配的选择器中的每一种选择器类型的数值决定。</p>
<h3 id="优先级顺序"><a href="#优先级顺序" class="headerlink" title="优先级顺序"></a>优先级顺序</h3><p>下列是一份优先级逐级增加的选择器列表：</p>
<ul>
<li>通用选择器（*）</li>
<li>元素(类型)选择器</li>
<li>类选择器</li>
<li>属性选择器</li>
<li>伪类</li>
<li>ID 选择器</li>
<li>内联样式</li>
</ul>
<h3 id="important-规则例外"><a href="#important-规则例外" class="headerlink" title="!important 规则例外"></a>!important 规则例外</h3><p>当 !important 规则被应用在一个样式声明中时,该样式声明会覆盖CSS中任何其他的声明, 无论它处在声明列表中的哪里. 尽管如此, !important规则还是与优先级毫无关系.使用 !important 不是一个好习惯，因为它改变了你样式表本来的级联规则，从而使其难以调试。</p>
<p>一些经验法则：</p>
<ul>
<li><strong>Always</strong> 要优化考虑使用样式规则的优先级来解决问题而不是 <code>!important</code></li>
<li><strong>Only</strong> 只在需要覆盖全站或外部 css（例如引用的 ExtJs 或者 YUI ）的特定页面中使用 <code>!important</code></li>
<li><strong>Never</strong> 永远不要在全站范围的 css 上使用<code>!important</code></li>
<li><strong>Never</strong> 永远不要在你的插件中使用 <code>!important</code></li>
<li><ul>
<li>内联样式表的权值最高 1000；</li>
<li>ID 选择器的权值为 100</li>
<li>Class 类选择器的权值为 10</li>
<li>HTML 标签选择器的权值为 1</li>
</ul>
</li>
<li>id属性不要以数字开头，数字开头的id在Mozilla/Firefox浏览器不起作用</li>
<li>创建样式表<ul>
<li>外部样式表</li>
<li>内部样式表</li>
<li>内联样式表</li>
<li>多重样式表</li>
</ul>
</li>
</ul>
<h3 id="CSS-优先级法则："><a href="#CSS-优先级法则：" class="headerlink" title="CSS 优先级法则："></a>CSS 优先级法则：</h3><ul>
<li>A 选择器都有一个权值，权值越大越优先；</li>
<li>B 当权值相等时，后出现的样式表设置要优于先出现的样式表设置；</li>
<li>C 创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；</li>
<li>D 继承的CSS 样式不如后来指定的CSS 样式；</li>
<li>E 在同一组属性设置中标有“!important”规则的优先级最大；</li>
</ul>
<h4 id="目标选择器"><a href="#目标选择器" class="headerlink" title="目标选择器"></a>目标选择器</h4><ul>
<li>：target{ }当目标被选中时就会执行该样式</li>
</ul>
<h2 id="三-CSS属性"><a href="#三-CSS属性" class="headerlink" title="三 . CSS属性"></a>三 . CSS属性</h2><h4 id="1-align-content"><a href="#1-align-content" class="headerlink" title="1.align-content"></a>1.align-content</h4><ul>
<li><p>align-content属性在弹性容器内的各项没有占用交叉轴上所有可用的空间时对齐容器内的各项（垂直）</p>
</li>
<li><p><strong>提示：</strong>使用 justify-content 属性对齐主轴上的各项（水平）</p>
<p><strong>注意：</strong>容器内必须有多行的项目，该属性才能渲染出效果。</p>
<h2 id="CSS-语法"><a href="#CSS-语法" class="headerlink" title="CSS 语法"></a>CSS 语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-content: stretch|center|flex-start|flex-end|space-between|space-around|initial|inherit;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性值</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>stretch</td>
<td>默认值。项目被拉伸以适应容器</td>
</tr>
<tr>
<td>center</td>
<td>项目位于容器的中心。</td>
</tr>
<tr>
<td>flex-start</td>
<td>项目位于容器的开头。</td>
</tr>
<tr>
<td>flex-end</td>
<td>项目位于容器的结尾。</td>
</tr>
<tr>
<td>space-between</td>
<td>项目位于各行之间留有空白的容器内。</td>
</tr>
<tr>
<td>space-around</td>
<td>项目位于各行之前、之间、之后都留有空白的容器内。</td>
</tr>
<tr>
<td>initial</td>
<td>设置该属性为它的默认值。</td>
</tr>
<tr>
<td>inherit</td>
<td>从父元素继承该属性。</td>
</tr>
</tbody></table>
<p>#main { width: 70px; height: 300px; border: 1px solid #c3c3c3; display: -webkit-flex; display: flex; -webkit-flex-wrap: wrap; flex-wrap: wrap; -webkit-align-content: center; align-content: center;}</p>
</li>
</ul>
<h4 id="2-align-items属性"><a href="#2-align-items属性" class="headerlink" title="2.align-items属性"></a>2.align-items属性</h4><ul>
<li>设置flex容器的对齐方式，使用每个flex对象元素的 align-self 属性可重写 align-items 属性。</li>
<li>语法<ul>
<li>align-items: stretch|center|flex-start|flex-end|baseline（位置元素在容器的基线）|initial（设为默认值）|inherit;</li>
</ul>
</li>
</ul>
<h5 id="3-背景属性background"><a href="#3-背景属性background" class="headerlink" title="3.背景属性background"></a>3.背景属性background</h5><ul>
<li>当使用简写属性时，属性值的顺序为：:<ul>
<li>background-color</li>
<li>background-image</li>
<li>background-repeat</li>
<li>background-attachment</li>
<li>background-position</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Property</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>background</td>
<td>简写属性，作用是将背景属性设置在一个声明中。</td>
</tr>
<tr>
<td>background-attachment</td>
<td>背景图像是否固定或者随着页面的其余部分滚动。</td>
</tr>
<tr>
<td>background-color</td>
<td>设置元素的背景颜色。</td>
</tr>
<tr>
<td>background-image</td>
<td>把图像设置为背景。</td>
</tr>
<tr>
<td>background-position</td>
<td>设置背景图像的起始位置。</td>
</tr>
<tr>
<td>background-repeat</td>
<td>设置背景图像是否及如何重复。</td>
</tr>
</tbody></table>
<h5 id="四-文本格式"><a href="#四-文本格式" class="headerlink" title="四 . 文本格式"></a>四 . 文本格式</h5><ul>
<li>文本颜色color</li>
<li>文本对齐方式：text-align</li>
<li>文本修饰：text-decoration</li>
<li>文本转换：text-transform</li>
<li>文本缩进（指定第一行缩进）：text-indent</li>
<li>指定字符间的距离：letter-spacing（可正可负）</li>
<li>指定一个段落中行之间的空间：line-height</li>
<li>指定单词间的间距：word-spacing</li>
</ul>
<h2 id="一-CSS3的基本概念"><a href="#一-CSS3的基本概念" class="headerlink" title="一 . CSS3的基本概念"></a>一 . CSS3的基本概念</h2><ul>
<li>CSS 用于控制网页的样式和布局。而CSS3是CSS技术的升级版本，CSS3语言开发是朝着模块化发展的。</li>
<li>CSS3使用了层叠样式表技术，可以对网页布局、字体、颜色、背景灯效果做出控制。css3作为css的进阶版，拆分和增加了盒子模型、列表模块、语言模块 、背景边框 、文字特效 、多栏布局等等。CSS3的改变有很多，增加了文字特效，丰富了下划线样式，加入了圈重点的功能。在边框方面，有了更多的灵活性，可以更加轻松地操控渐变效果和动态效果等等。在文字效果方面，特意增加了投影。CSS3在兼容上做了很大的功夫，并且网络浏览器也还将继续支持CSS2，因此原来的代码不需要做太多的改变，只会变得更加地轻松。</li>
<li>css是指层叠样式表，解决内容与表现分离的问题</li>
<li>id选择器可为特有的id的html元素指定特定的样式，ID属性不要以数字开头，数字开头的ID在 Mozilla/Firefox 浏览器中不起作用。</li>
<li><em>不要在属性值与单位之间留有空格（如：”margin-left: 20 px” ），正确的写法是 “margin-left: 20px” 。</em></li>
</ul>
<h2 id="二-CSS3的新属性"><a href="#二-CSS3的新属性" class="headerlink" title="二 . CSS3的新属性"></a>二 . CSS3的新属性</h2><h4 id="1-边框border"><a href="#1-边框border" class="headerlink" title="1.边框border"></a>1.边框border</h4><ul>
<li>圆角边框：border-radius<ul>
<li>border-radius：左上 右上 右下 左下；</li>
</ul>
</li>
<li>阴影边框：border-shadow<ul>
<li>box-shadow: 右偏移量 下偏移量 模糊距离 阴影尺寸  颜色 内外阴影；(可同时加多个)</li>
<li><ul>
<li>h-shadow：必需，水平阴影的位置。允许负值</li>
<li>v-shadow：必需。垂直阴影的位置。允许负值。</li>
<li>blur：可选，模糊距离</li>
<li>spread：可选，阴影尺寸</li>
<li>color：颜色</li>
<li>insert：可选，将外部阴影（outset）改为内部阴影，外部阴影是默认值（不允许写）</li>
</ul>
</li>
</ul>
</li>
<li>图像边框（IE浏览器不支持）：border-image</li>
<li>对于 border-image，Safari 5 以及更老的版本需要前缀 -webkit-。Opera 支持 border-radius 和 box-shadow 属性，但是对于 border-image 需要前缀 -o-。</li>
</ul>
<h4 id="2-图片滤镜filter属性"><a href="#2-图片滤镜filter属性" class="headerlink" title="2.图片滤镜filter属性"></a>2.图片滤镜filter属性</h4><ul>
<li>为元素添加可视效果（如饱和度与模糊度）</li>
<li>img{ filter:grayscale(100%); //修改所有图片的颜色为100%灰度}</li>
<li>常用属性值<ul>
<li>filter:none | biur() | brightness() | contrast() | drop-shadow() | grayscale() | hue-rotate() | invert() | opacity()| saturate() | sepia() | url();</li>
</ul>
</li>
</ul>
<p><strong>提示:</strong> 使用空格分隔多个滤镜。</p>
<h2 id="Filter-函数"><a href="#Filter-函数" class="headerlink" title="Filter 函数"></a>Filter 函数</h2><p><strong>注意:</strong> 滤镜通常使用百分比 (如：75%), 当然也可以使用小数来表示 (如：0.75)。</p>
<table>
<thead>
<tr>
<th>Filter</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>默认值，没有效果。</td>
</tr>
<tr>
<td>blur(<em>px</em>)</td>
<td>给图像设置高斯模糊。”radius”一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起， 所以值越大越模糊； 如果没有设定值，则默认是0；这个参数可设置css长度值，但不接受百分比值。</td>
</tr>
<tr>
<td>brightness(<em>%</em>)</td>
<td>给图片应用一种线性乘法，使其看起来更亮或更暗。如果值是0%，图像会全黑。值是100%，则图像无变化。其他的值对应线性乘数效果。值超过100%也是可以的，图像会比原来更亮。如果没有设定值，默认是1。</td>
</tr>
<tr>
<td>contrast(<em>%</em>)</td>
<td>调整图像的对比度。值是0%的话，图像会全黑。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。</td>
</tr>
<tr>
<td>drop-shadow(<em>h-shadow v-shadow blur spread color</em>)</td>
<td>给图像设置一个阴影效果。阴影是合成在图像下面，可以有模糊度的，可以以特定颜色画出的遮罩图的偏移版本。 函数接受<shadow>(在CSS3背景中定义)类型的值，除了”inset”关键字是不允许的。该函数与已有的box-shadow box-shadow属性很相似；不同之处在于，通过滤镜，一些浏览器为了更好的性能会提供硬件加速。<code>&lt;shadow&gt;参数如下：```**&lt;offset-x&gt; &lt;offset-y&gt;** (必须)这是设置阴影偏移量的两个 &lt;length&gt;值. **&lt;offset-x&gt;** 设定水平方向距离. 负值会使阴影出现在元素左边. **&lt;offset-y&gt;**设定垂直距离.负值会使阴影出现在元素上方。查看**&lt;length&gt;**可能的单位. **如果两个值都是0**, 则阴影出现在元素正后面 (如果设置了</code><blur-radius> and/or <spread-radius>，会有模糊效果).``<strong><blur-radius></blur-radius></strong> (可选)这是第三个code&gt;<length>值. 值越大，越模糊，则阴影会变得更大更淡.不允许负值 若未设定，默认是0 (则阴影的边界很锐利).<strong><spread-radius></spread-radius></strong> (可选)这是第四个 <length>值. 正值会使阴影扩张和变大，负值会是阴影缩小.若未设定，默认是0 (阴影会与元素一样大小). 注意: Webkit, 以及一些其他浏览器 不支持第四个长度，如果加了也不会渲染。 <strong><color></color></strong> (可选)查看 <color>该值可能的关键字和标记。若未设定，颜色值基于浏览器。在Gecko (Firefox), Presto (Opera)和Trident (Internet Explorer)中， 会应用color<strong>color</strong>属性的值。另外, 如果颜色值省略，WebKit中阴影是透明的。`</color></length></length></spread-radius></blur-radius></shadow></td>
</tr>
<tr>
<td>grayscale(<em>%</em>)</td>
<td>将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0；</td>
</tr>
<tr>
<td>hue-rotate(<em>deg</em>)</td>
<td>给图像应用色相旋转。”angle”一值设定图像会被调整的色环角度值。值为0deg，则图像无变化。若值未设置，默认值是0deg。该值虽然没有最大值，超过360deg的值相当于又绕一圈。</td>
</tr>
<tr>
<td>invert(<em>%</em>)</td>
<td>反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。值在0%和100%之间，则是效果的线性乘子。 若值未设置，值默认是0。</td>
</tr>
<tr>
<td>opacity(<em>%</em>)</td>
<td>转化图像的透明程度。值定义转换的比例。值为0%则是完全透明，值为100%则图像无变化。值在0%和100%之间，则是效果的线性乘子，也相当于图像样本乘以数量。 若值未设置，值默认是1。该函数与已有的opacity属性很相似，不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。</td>
</tr>
<tr>
<td>saturate(<em>%</em>)</td>
<td>转换图像饱和度。值定义转换的比例。值为0%则是完全不饱和，值为100%则图像无变化。其他值，则是效果的线性乘子。超过100%的值是允许的，则有更高的饱和度。 若值未设置，值默认是1。</td>
</tr>
<tr>
<td>sepia(<em>%</em>)</td>
<td>将图像转换为深褐色。值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0；</td>
</tr>
<tr>
<td>url()</td>
<td>URL函数接受一个XML文件，该文件设置了 一个SVG滤镜，且可以包含一个锚点来指定一个具体的滤镜元素。例如：<code>filter: url(svg-url#element-id)</code></td>
</tr>
<tr>
<td>initial</td>
<td>设置属性为默认值，可参阅： <a href="https://www.w3cschool.cn/cssref/css-initial.html" target="_blank" rel="noopener">CSS initial 关键字</a></td>
</tr>
<tr>
<td>inherit</td>
<td>从父元素继承该属性，可参阅：<a href="https://www.w3cschool.cn/cssref/css-inherit.html" target="_blank" rel="noopener">CSS inherit 关键字</a></td>
</tr>
</tbody></table>
<h2 id="三-常见模型和样式表"><a href="#三-常见模型和样式表" class="headerlink" title="三 . 常见模型和样式表"></a>三 . 常见模型和样式表</h2><p><strong>行内元素只有左右边距，没有上下边距，指定padding值可能有bug</strong></p>
<h4 id="1-居中对齐汇总"><a href="#1-居中对齐汇总" class="headerlink" title="1.居中对齐汇总"></a>1.居中对齐汇总</h4><h5 id="1-1-水平居中对齐"><a href="#1-1-水平居中对齐" class="headerlink" title="1-1 . 水平居中对齐"></a>1-1 . 水平居中对齐</h5><h5 id="margin-0-auto"><a href="#margin-0-auto" class="headerlink" title="margin:0 auto;"></a>margin:0 auto;</h5><p>必须是块级元素，且给定了宽度</p>
<h5 id="text-align-center"><a href="#text-align-center" class="headerlink" title="text-align:center;"></a>text-align:center;</h5><p>父级元素是块级元素，自身是行内元素或者行内块元素</p>
<p><strong>width:内容宽；height：内容高；padding：盒宽减去内容宽再除以2；background-clip：content-box；</strong></p>
<p>利用padding和background-clip配合实现div的水平居中</p>
<p>.parent{margin:0 auto;width:200px;height:200px;background-color:red;}.children {width: 100px;height: 100px;padding: 50px;background-color: black;background-clip:content-box;/<em>居中的关键</em>/</p>
<h4 id="2-垂直居中"><a href="#2-垂直居中" class="headerlink" title="2 . 垂直居中"></a>2 . 垂直居中</h4><p><strong>line-height:盒子高</strong></p>
<p>自身或者父级元素必须有具体行高</p>
<p>position加translate（-50%，-50%），百分比以自身为基准,适合没固定大小的内容（min-width,max-height,overflow:scroll)</p>
<style> #ex3_container{ width:200px; height:200px; background-color:yellow; position:relative; } #ex3_content{ left:50%; top:50%; transform:translate(-50%,-50%); -webkit-transform:translate(-50%,-50%); background-color:gray; color:white; position:absolute; } </style>

<p><strong>绝对定位</strong></p>
<p>祖先容器：position：relative；</p>
<p>自身：height：***；position：absolute；margin：auto；top：0；left：0；</p>
<p><em>高度必须给出，建议加overflow：auto；防止内容溢出</em></p>
<h5 id="内容元素：position-fixed，z-index-999，记住父容器元素position-relative"><a href="#内容元素：position-fixed，z-index-999，记住父容器元素position-relative" class="headerlink" title="内容元素：position: fixed，z-index: 999，记住父容器元素position: relative **"></a>内容元素：position: fixed，z-index: 999，记住父容器元素position: relative **</h5><p>.Absolute-Center.is-Fixed { width: 50%; height: 50%; overflow: auto; margin: auto; position: fixed; top: 0; left: 0; bottom: 0; right: 0; z-index: 999;}</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><h5 id="1-相邻的垂直块级盒子，外边距会合并，且以最大的外边距为准"><a href="#1-相邻的垂直块级盒子，外边距会合并，且以最大的外边距为准" class="headerlink" title="1.相邻的垂直块级盒子，外边距会合并，且以最大的外边距为准"></a>1.相邻的垂直块级盒子，外边距会合并，且以最大的外边距为准</h5><h4 id="2-嵌套块元素垂直外边距的合并"><a href="#2-嵌套块元素垂直外边距的合并" class="headerlink" title="2.嵌套块元素垂直外边距的合并"></a>2.嵌套块元素垂直外边距的合并</h4><p>对于两个嵌套关系的块级元素，如果父级元素没有上内边距及边框，则父元素的上边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会合并</p>
<p>解决方法：</p>
<ul>
<li>可以为父级盒子加上1px的上边框或上内边距</li>
<li>可以为父元素添加overflow：hidden；</li>
</ul>
<h4 id="3-宽度属性width和高度属性仅适用于块级元素，对行内元素无效（img标签和input除外）"><a href="#3-宽度属性width和高度属性仅适用于块级元素，对行内元素无效（img标签和input除外）" class="headerlink" title="3.宽度属性width和高度属性仅适用于块级元素，对行内元素无效（img标签和input除外）"></a>3.宽度属性width和高度属性仅适用于块级元素，对行内元素无效（img标签和input除外）</h4><p>计算盒子模型总高度时，还应考虑上下两个盒子外边框合并问题</p>
<p>如果一个盒子没有给定宽度/高度或者继承父亲的宽度/高度，则padding不会影响本盒子的大小</p>
<p>内盒尺寸（元素实际大小）=width/height+padding+border</p>
<h4 id="4-盒子模型布局稳定性"><a href="#4-盒子模型布局稳定性" class="headerlink" title="4.盒子模型布局稳定性"></a>4.盒子模型布局稳定性</h4><p>按照优先使用宽度（width），内边距（padding）外边距（margin）</p>
<p>width &gt; padding &gt; margin</p>
<p>原因：</p>
<ul>
<li>margin会有外边距合并问题还有ie下面的margin加倍的bug，所以最后使用</li>
<li>padding 会影响盒子的大小，需要进行加减计算，比较麻烦，其次使用</li>
<li>width没有什么问题</li>
</ul>
<h4 id="5-CSS盒模型"><a href="#5-CSS盒模型" class="headerlink" title="5. CSS盒模型"></a>5. CSS盒模型</h4><p>CSS3中可以通过box-sizing来指定盒模型，即指定为content-box，border-box，这样我们在计算盒子大小的方式就发生了变化</p>
<p>可分为以下两种情况：</p>
<ul>
<li><p>box-sizing : content-box ;盒子大小为 width+padding +border，content-border指事默认值，其让元素维持W3C的标准Box Mode</p>
</li>
<li><p>box-sizing ： border-box；盒子大小就是width，即padding和border是包含在width里面的，新添属性</p>
<p><strong>注意</strong>：上面的标注的width指的是CSS属性里设置的width：length；content的值会自动调整的</p>
</li>
</ul>
<h4 id="6-CSS层叠样式"><a href="#6-CSS层叠样式" class="headerlink" title="6 . CSS层叠样式"></a>6 . CSS层叠样式</h4><ul>
<li>样式冲突，遵循就近原则。哪个样式离结构近，就执行哪个样式</li>
<li>样式不冲突不会层叠</li>
</ul>
<h4 id="7-CSS继承性"><a href="#7-CSS继承性" class="headerlink" title="7.CSS继承性"></a>7.CSS继承性</h4><p>恰当地使用继承可以简化代码，子元素可以继承父元素的样式（text-，font-，line-，这些元素开头的都可以继承，以及color属性）</p>
<h4 id="8-CSS优先级"><a href="#8-CSS优先级" class="headerlink" title="8.CSS优先级"></a>8.CSS优先级</h4><p>定义css样式时，经常出现两个或更多规则应用在同一元素上，这时就出现优先级问题</p>
<p>继承样式的权重为0.即在嵌套结构中，不管父元素权重多大，被子元素继承时，他的权重都为0，也就是说子元素定义的样式会覆盖继承来的样式，行内样式优先，应用style属性的元素，其行内样式的权重非常高，远大于100.</p>
<p>权重相同时遵循就近原则。！important拥有最大的权重</p>
<h4 id="9-浮动Float"><a href="#9-浮动Float" class="headerlink" title="9.浮动Float"></a>9.浮动Float</h4><ul>
<li><p>浮动首先包含块的概念（包裹）。也就是说，浮动的元素总是找离他最近的父级元素对齐，但是不会超过内边距的范围</p>
</li>
<li><p>浮动元素排列元素，跟上一个元素（块级）有关。如果上一个元素有浮动，则A元素顶部会和上一个元素的顶部对齐；如果上一个元素是标准流，则A元素的顶部会和上一个元素的底部对齐。</p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 陈楚吟
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="陈楚吟">


    
    


<meta name="description" content="将学习技术点汇总">
<meta name="keywords" content="write myBlog">
<meta property="og:type" content="website">
<meta property="og:title" content="Nikita">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Nikita">
<meta property="og:description" content="将学习技术点汇总">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nikita">
<meta name="twitter:description" content="将学习技术点汇总">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Nikita" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Nikita</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">陈楚吟</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不负韶华</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">陈楚吟</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">陈楚吟</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不负韶华</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-刷题笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/13/刷题笔记/" class="article-date">
      <time datetime="2020-06-13T01:16:13.000Z" itemprop="datePublished">2020-06-13</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/13/刷题笔记/">刷题笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><ol>
<li><p>form表单中input元素的disabled指当input元素加载时禁用此元素，input内容不会随着表单提交。readonly规定输入字段为只读，input内容会随着表单提交。但是无论设置readonly还是disabled，通过js脚本都能更改input的value。</p>
</li>
<li><p><code>&lt;parent&gt;&lt;child&gt;content&lt;/child&gt;&lt;/parent&gt;</code>可使child内容垂直居中。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*把parent变成table，child变成table-cell，而vertical-align可设置元素垂直对齐，前提是：只能应用于内联元素，当parent只有child一个子元素时，child会铺满parent全部空间，即使child有宽高*/</span></span><br><span class="line"><span class="selector-tag">parent</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">child</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>:table-cell;</span><br><span class="line">	<span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*弹性布局。*/</span></span><br><span class="line"><span class="selector-tag">parent</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>:flex;</span><br><span class="line">	<span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*父元素设置相对定位，子元素设置绝对定位，子元素的top设置50%，即父元素的高度一半，注意此时是child元素的左上角（0，0）移到了parent的（0，parent高度的50%），而不是子元素的中心点移到了父元素垂直方向的中心点。因此子元素需要上移自身高度的一半，即transform:translateY(-50%)*/</span></span><br><span class="line"><span class="selector-tag">parent</span>&#123;</span><br><span class="line">	<span class="attribute">positionn</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">child</span>&#123;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*设置伪元素。vertical-align属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。如：有两个行内元素a和b，a，b都是img，若s加了vertical-align：middle样式，b的底部（基线）就会对齐a的中间位置；若a，b都加了，则互相对齐了对方的中间位置，也就是他们在垂直方向上的中线对齐了。*/</span></span><br><span class="line"><span class="selector-tag">parent</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">	<span class="attribute">content</span>:<span class="string">''</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">vertical-align</span>: middle;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">child</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: inline-block;</span><br><span class="line">	<span class="attribute">vertical-align</span>: middle;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>display:none</code>指的是元素不完全陈列出来，不占据空间，涉及到了DOM结构，故产生重排和重绘。</p>
<p><code>visibility:hidden</code>指的是元素不可见但存在，保留空间，不影响结构，故只产生重绘，但不可触发绑定事件。</p>
<p><code>opacity=0</code>指的是元素不可见但存在，保留空间，不影响结构，并且如果如果该元素已经绑定了一些事件，如click事件，那么点击该区域，也能触发点击事件的。</p>
</li>
<li><p>Web SQL数据库API并不是HTML5规范的一部分，但它是一个独立的规范，引入了一组使用SQL操作数据库的APIs。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ele.clientWidth = 宽度 + padding</span><br><span class="line">ele.offsetWidth = 宽度 + padding + border</span><br><span class="line">ele.scrollTop = 被卷去的上侧距离</span><br><span class="line">ele.scrollHeight = 自身实际的高度（不包含边框）</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.keys()</code>不能遍历出对象原型链上的属性。<code>Object.assign(obj1,obj2)</code>可以实现对象的浅拷贝。</p>
</li>
<li><p><code>null === null</code>结果为true。</p>
</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下都为true</span></span><br><span class="line">a.__proto__ === A.prototype </span><br><span class="line">b.__proto__ === B.prototype</span><br><span class="line">B.__proto__ === A</span><br><span class="line">B.prototype.__proto__ === A.prototype</span><br><span class="line">b.__proto__.__proto__ === A.prototype</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-前端cookie解读" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/11/前端cookie解读/" class="article-date">
      <time datetime="2020-06-11T07:33:30.000Z" itemprop="datePublished">2020-06-11</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/11/前端cookie解读/">前端cookie解读</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>补充：当关闭浏览器或关机后重新打开，存放在硬盘上的数据不会消失，而存放在内存中的数据会消失。</p>
<h6 id="Cookie的引入"><a href="#Cookie的引入" class="headerlink" title="Cookie的引入"></a>Cookie的引入</h6><p>当用户在未登录状态下在京东购物网站向购物车中添加某些商品后将浏览器关闭，然后再打开浏览器访问京东，此时查看购物车会发现，购物车中仍然有刚才添加的商品，这其实就是cookie的功劳。</p>
<h6 id="Cookie的简介"><a href="#Cookie的简介" class="headerlink" title="Cookie的简介"></a>Cookie的简介</h6><p>cookie是属于web开发的技术，由若干键值对构成，且键值对均为字符串。它是所有web开发语言据支持的技术。它是一种进行网络会话状态跟踪的技术。</p>
<p>会话（当用户打开浏览器，从发出第一次请求开始，一直到最终关闭浏览器就表示一次会话的完成）则是由一组请求和响应组成，是围绕看一件相关事情所进行的请求和响应，所以这些请求和响应之间必须有数据传递，即进行会话状态跟踪。但http协议是一种无状态协议，在不同请求间无法进行数据传递。此时就需要一种可以进行请求间数据传递的会话跟踪技术，而cookie就是这样一种技术。</p>
<p>Cookie是由服务器生成，保存在客户端的一种信息载体。这个载体中存放着用户访问该站点的会话状态信息。只要cookie没有被清空，或cookie没有生效，那么保存在其中的会话状态就有效。用户在提交第一次请求后，由服务器生成cookie并将其封装到响应头中，以响应的形式发送给客户端，客户端接收到这个响应后，将cookie保存到客户端。当客户端再发起同类的请求（资源路径路径相同）后，在请求中会携带保存在客户端的cookie数据，发送给服务器，由服务器对会话进行跟踪。</p>
<p>注意：cookie禁用仅是客户端不接收来自客户端的cookie，后端服务器还是有响应cookie回来的。一般不会禁用cookie，否则就不能使用，会出现500错误。</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>session即会话，是web开发中的一种会话状态跟踪技术，跟cookie类似，不过cookie是将会话状态存放于客户端的，而session是存在于服务端的。</p>
<h6 id="服务端生成session"><a href="#服务端生成session" class="headerlink" title="服务端生成session"></a>服务端生成session</h6><p>在服务器中系统会为每个会话维护一个session。不同的会话，对应不同的session。服务器对当前应用中的session是以Map的形式进行管理的，这个Map称为Session列表，该map的key为一个32位长度的随机串，这个随机串称为JSession，value则为session对象的引用。当用户第一次提交请求时，服务端servlet中执行到<code>request.getSession()</code>后会自动生成一个<code>Map.Entry</code>对象，key为一个根据某种算法新生成的JSessionID，value则为新创建的HttpSession对象。</p>
<h6 id="服务器生成并发送cookie"><a href="#服务器生成并发送cookie" class="headerlink" title="服务器生成并发送cookie"></a>服务器生成并发送cookie</h6><p>在将Session信息写入session列表后，系统还会自动将JSESSIONID作为name，这个32位长度的随机串作为value，以cookie的形式存放到响应头中，并随着响应将该cookie发送到客户端。</p>
<h6 id="客户端接收并发送cookie"><a href="#客户端接收并发送cookie" class="headerlink" title="客户端接收并发送cookie"></a>客户端接收并发送cookie</h6><p>客户端接受到这个cookie后会将其存放到浏览器的缓存中。即只要客户端浏览器不关闭，浏览器缓存的cookie就不会消失。</p>
<p>当用户提交第二次请求时，会将缓存中的这个cookie伴随着请求的头部信息一块发到服务端。</p>
<h6 id="congsession列表中查找"><a href="#congsession列表中查找" class="headerlink" title="congsession列表中查找"></a>congsession列表中查找</h6><p>服务端从请求中读取到从客户端发来的cookie，并根据cookie的JSESSIONID的值，从Map中查找相应key所对应的value，即session对象。然后对该session对象的域属性进行读写操作。</p>
<h6 id="session的失效"><a href="#session的失效" class="headerlink" title="session的失效"></a>session的失效</h6><p>web开发中引入的session超时的概念，session的失效就是指session的超时。若某个session在指定的时间范围内一直未被访问，那session将超时，即将失效。</p>
<p>服务器针对不同的会话找到不同的session，是因为cookie完成了会话的跟踪。但是，若客户端浏览器将cookie禁用，则服务器每提交一次请求，服务器在给出的响应中都会包含名称为JSESSIONID的cookie，只不过这个cookie值每次都不同，也就是说客户端所提交的请求中没有包含JSESSIONID，服务器就会认为这是一次新的会话的开始，就会为其生成一个<code>Map.Entry</code>对象，所以也就无法实现会话跟踪了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-前端经验" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/04/前端经验/" class="article-date">
      <time datetime="2020-06-04T06:01:42.000Z" itemprop="datePublished">2020-06-04</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/04/前端经验/">前端经验</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="字体图标的使用"><a href="#字体图标的使用" class="headerlink" title="字体图标的使用"></a>字体图标的使用</h3><h6 id="字体图标的优势"><a href="#字体图标的优势" class="headerlink" title="字体图标的优势"></a>字体图标的优势</h6><ol>
<li>性能好，可以减少http请求。</li>
<li>解决图标放大失真问题。</li>
<li>解决图片占用内存问题。</li>
</ol>
<h6 id="图片格式分类"><a href="#图片格式分类" class="headerlink" title="图片格式分类"></a>图片格式分类</h6><ol>
<li>位图图片：bmp，jpg，gif，png。（大小改变时可能出现锯齿状）。</li>
<li>矢量图图片：以svg格式为代表，可缩放矢量图形（Scalable Vector Graphics）。SVG是一种使用XML格式定义的图像。（颜色和字体可选范围较小）</li>
</ol>
<h6 id="字体图标出现的背景"><a href="#字体图标出现的背景" class="headerlink" title="字体图标出现的背景"></a>字体图标出现的背景</h6><p><strong>雪碧图处理图标</strong></p>
<ul>
<li>首先载入带有所有图标的图片。</li>
<li>利用定位截取想要的图标。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.bgImg&#123;</span><br><span class="line">	background: url(img/logos.png);</span><br><span class="line">	display: block;</span><br><span class="line">	text-indent: -9999px;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">	background-repeate: no-repeate;</span><br><span class="line">	width: 16px;</span><br><span class="line">	height: 16px;</span><br><span class="line">&#125;</span><br><span class="line">.help&#123;</span><br><span class="line">	background-position: -48px -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优势：当有大量的小图标时，可减少请求次数，网页加载速度更快，减少阻塞网络的情况，用户体验不好。</p>
<p>缺点：需要先设置背景图片，再通过精灵图中小图标的宽度和位置，设置对应的div宽高和背景定位坐标。设计人员后期的维护难度较大，编码也比较难（对定位精准性要求较大）。</p>
<h6 id="字体图标的使用-1"><a href="#字体图标的使用-1" class="headerlink" title="字体图标的使用"></a>字体图标的使用</h6><ul>
<li>一般会再建一个新的css文件来设置<code>font-family</code>和字体颜色，一来可以整体设置，二来当新字体图标覆盖时，文字的样式可以保持原先的状态。</li>
</ul>
<h3 id="星级评分"><a href="#星级评分" class="headerlink" title="星级评分"></a>星级评分</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-linux学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/22/linux学习/" class="article-date">
      <time datetime="2020-05-22T01:12:25.000Z" itemprop="datePublished">2020-05-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/22/linux学习/">linux学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="linux基础"><a href="#linux基础" class="headerlink" title="linux基础"></a>linux基础</h4><h4 id="linux实战"><a href="#linux实战" class="headerlink" title="linux实战"></a>linux实战</h4><h6 id="远程登陆"><a href="#远程登陆" class="headerlink" title="远程登陆"></a>远程登陆</h6><p>xShell xFtp</p>
<h6 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h6><h6 id="远程管理"><a href="#远程管理" class="headerlink" title="远程管理"></a>远程管理</h6><h6 id="vi和vim编译器"><a href="#vi和vim编译器" class="headerlink" title="vi和vim编译器"></a>vi和vim编译器</h6><h6 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h6><h6 id="RPM与YUM"><a href="#RPM与YUM" class="headerlink" title="RPM与YUM"></a>RPM与YUM</h6>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pandas之excel" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/10/pandas之excel/" class="article-date">
      <time datetime="2020-05-10T04:44:58.000Z" itemprop="datePublished">2020-05-10</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/10/pandas之excel/">pandas之excel</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h4><h6 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'ID'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">'Name'</span>:[<span class="string">'Tim'</span>,<span class="string">'Victor'</span>,<span class="string">'Nick'</span>]&#125;)</span><br><span class="line">df = df.set_index(<span class="string">'ID'</span>)</span><br><span class="line">df.to_excel(<span class="string">'F:/webProject/python/output.xlsx'</span>)</span><br><span class="line">print(<span class="string">'Done'</span>)</span><br></pre></td></tr></table></figure>

<p>遇到问题：</p>
<ol>
<li><p>NameError: name ‘pandas’ is not defined？</p>
<p>这是没有pandas模块，这是因为python默认没有安装numpy和pandas，最直接的方法是在python的scripts中执行<code>pip install pandas</code>不过，据说用pip安装会损坏原文件。</p>
</li>
<li><p>或者在Spyder编辑器中安装<code>pip install pandas</code>,却报<code>Note: you may need to restart the kernel to use updated packages.</code>?</p>
<p>在Terminal中更新<code>conda update spyder</code>。</p>
</li>
</ol>
<h6 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line">people = pd.read_execl(<span class="string">'path'</span>,header=<span class="literal">None</span>)  <span class="comment">#表示没有行头</span></span><br><span class="line">people.set_index(<span class="string">'ID'</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">print(people.shape)   <span class="comment">#打印出多少行多少列</span></span><br><span class="line">print(people.columns)  <span class="comment">#列</span></span><br><span class="line">print(people.head(<span class="number">3</span>))  <span class="comment">#打印出前3行，head不加参数默认为5行</span></span><br><span class="line">print(people.tail(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">df = pd.read_excel(<span class="string">'path'</span>,index_col=<span class="string">'ID'</span>)  <span class="comment">#后面的参数是为了不要将系统自动添加的索引加到新的表中</span></span><br><span class="line">df.to_excel(<span class="string">'path'</span>)</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-HTML5和CSS3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/09/HTML5和CSS3/" class="article-date">
      <time datetime="2020-05-09T14:12:59.000Z" itemprop="datePublished">2020-05-09</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/09/HTML5和CSS3/">HTML5和CSS3</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li><p>contentEditable设置为true时，该元素就变成了可编辑的，且该元素可继承。</p>
</li>
<li><p>designMode属性用来指定整个页面是否可编辑。<code>document.designMode=&quot;on&quot;</code></p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-爬虫" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/08/爬虫/" class="article-date">
      <time datetime="2020-05-08T12:22:36.000Z" itemprop="datePublished">2020-05-08</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/08/爬虫/">爬虫</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="爬虫基础"><a href="#爬虫基础" class="headerlink" title="爬虫基础"></a>爬虫基础</h4><p>爬虫就是获取网页并提取和保存信息的自动化程序。</p>
<p>Cookies里面保存了登录的凭证，有了它，只需在下次请求携带Cookies发送请求而不必重新输入用户名和密码。因此在爬虫中，有时候需要登录才能访问页面时，我们一般会直接将登录成功后截取的Cookies放在请求头里面直接请求，而不必重新模拟登录。</p>
<h6 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h6><p>Accept：请求报文域，用于指定客户端可接受哪些类型的信息。</p>
<p>Accept-Language：指定客户端可接受的语言类型。</p>
<p>Accept-Encoding：指定客户端可接受的内容编码。</p>
<p>Host：用于指定请求资源的主机IP和端口号，其内容为请求URL的原始服务器或网关的位置。从HTTP1.1版本开始，请求必须包含此内容。</p>
<p>Cookie：也常用复数形式Cookies，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前会话。如：我们输入用户名和密码成功登陆到某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登陆状态，这就是Cookies的功劳。Cookies里面有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上Cookies并将其发送给服务器，服务器通过Cookies识别出是我们自己，并且查出当前状态是登录状态，所以返回的是登陆后才能看到的网页内容。</p>
<p>Referer：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并作相应的处理，如来源统计，防盗链处理等。</p>
<p>User-Agent：简称UA，它是一个特殊的字符串头，可以是服务器识别客户使用的操作系统和版本，浏览器及版本等信息。在做爬虫的时候加上此信息可以伪装为浏览器；如果不加，很可能会被识别为爬虫。</p>
<p>Content-Type：也叫互联网媒体类型或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。如：text/html表示HTML格式，image/gif表示GIF图片，application/json表示JSON类型。</p>
<table>
<thead>
<tr>
<th>Content-Type</th>
<th>提交数据的方式</th>
</tr>
</thead>
<tbody><tr>
<td>application/x-www-form-urlencoded</td>
<td>表单数据</td>
</tr>
<tr>
<td>multipart/form-data</td>
<td>表单文件上传</td>
</tr>
<tr>
<td>application/data</td>
<td>序列化JSON数据</td>
</tr>
<tr>
<td>text/xml</td>
<td>XML数据</td>
</tr>
</tbody></table>
<p>在爬虫中，若要构造POST请求，需要使用正确的Content-Type，并了解各种请求库的各个参数设置时使用的是哪种Content-Type，不然可能导致POST提交后无法正常响应。</p>
<p>请求头是请求的重要组成部分，再写爬虫时大部分情况下都需要设定请求头。</p>
<h6 id="请求主体"><a href="#请求主体" class="headerlink" title="请求主体"></a>请求主体</h6><p>请求体一般承载的内容是POST请求中的表单数据，而对于GET请求，请求体则为空。</p>
<p>响应三部分：响应状态码，响应头，响应体。</p>
<h6 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h6><p>Date：标识响应产生的时间。</p>
<p>Last-Modified：指定资源的最后修改时间。</p>
<p>Content-Encoding：指定响应内容的编码。</p>
<p>Server：包含服务器的信息，比如名称和版本号等。</p>
<p>Content-Type：文档类型，指定返回的数据类型是什么，如text/html代表返回的是HTML文档，application/x-javascript则代表返回JavaScript文件，image/jpeg则代表返回图片。</p>
<p>Set-Cookie：设置Cookies，响应头中的Set-Cookie告诉浏览器需要将此内容放在Cookies中，下次请求携带Cookies请求。</p>
<p>Expires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。</p>
<h6 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h6><p>响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的        HTML代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体。</p>
<h6 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h6><p>在Web中，会话对象用来存储特定用户会话所需的属性及配置信息，这样，当用户在应用程序的Web页之间跳转时，存储在会话对象中的变量将不会丢失，而是在整个用户会话中一直村下去。当用户请求来自应用程序的Web页时，如果该用户还没有会话，则Web服务器将自动创建一个会话对象。当会话过期或放弃后，服务器将终止该会话。</p>
<p><strong>会话维持</strong></p>
<p>当客户端第一次请求服务器时，服务器会返回一个请求头中带有Set-Cookie字段的响应给客户端，用来标记是哪一个用户，客户端浏览器就会把此Cookies放到请求头一起提交给服务器，Cookies携带了会话ID信息，服务器检查该Cookies即可找到对应的会话是什么，然后再判断会话来以此来辨认用户状态。</p>
<p>在成功登录某个网站时，服务器就会告诉客户端设置哪些Cookies信息，在后续访问页面时客户端会把Cookies发送给服务器，服务器再找到对应的会话加以判断。如果会话中某些设置登录状态的变量是有效的，那就证明用户处于登录状态，此时返回登陆之后才可以查看的网页内容，浏览器解析便可以看到了。</p>
<p>反之，如果传给服务器的Cookies是无效的，或者会话已经过期了，我们将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录页面重新登陆。</p>
<p>所以，Cookies和会话需要配合，一个处于客户端，一个处于服务端，两者共同协作就实现会话控制。</p>
<h6 id="会话Cookie与持久Cookie"><a href="#会话Cookie与持久Cookie" class="headerlink" title="会话Cookie与持久Cookie"></a>会话Cookie与持久Cookie</h6><p>从表面意思来说，会话Cookie就是把Cookie放在浏览器内存中，浏览器在关闭之后该Cookie即失效；持久Cookie则会保存到客户端的硬盘中，方便下一次使用，用于长久保持用户登录状态。</p>
<p>因此一些持久化登陆的网站其实就是把Cookie的有效时间和会话有效期设置得较长，下次我们再访问页面时仍然携带之前的Cookie，就可以直接保持登录状态。</p>
<h6 id="会话误区"><a href="#会话误区" class="headerlink" title="会话误区"></a>会话误区</h6><p>在谈论会话机制时，人们认为“只要关闭浏览器，会话就会消失”。可以想象一下会员卡的例子除非顾客主动对店家提出销卡，否则店家绝不会轻易删除顾客的资料。对会话来说，也是一样，除非程序通知服务器删除一个会话，否则服务器会一直保留。比如，程序一般都是在我们做注销操作时才去删除会话。</p>
<p>但是当我们关闭浏览器时，浏览器不会主动在关闭之前通知服务器他将关闭，所以服务器根本不会有机会知道浏览器已经关闭。之所以会有这种错觉是因为大部分会话机制都使用会话Cookie来保存会话ID信息，而关闭浏览器后Cookies就消失了，再次连接服务器时，也就无法找到原来的会话了。如果服务器设置的Cookies保存到硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的Cookies发送给服务器，则再次打开浏览器能找到原来的会话ID，依旧还是可以保持登录状态的。</p>
<p>而恰恰是由于关闭浏览器不会导致会话被删除，这就需要服务器为会话设置一个失效的时间，当距离客户端上一次使用会话的时间时，服务器就可以认为客户端已经停止了活动，才会把会话删除以节省存储空间。</p>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><h6 id="代理的基本原理"><a href="#代理的基本原理" class="headerlink" title="代理的基本原理"></a>代理的基本原理</h6><p>我们在做爬虫时经常会遇到这种情况，最初爬虫正常运行，但过一会就报403Forbidden错误，可能会看到“您的IP访问频率太高”这样的提示，原因是网站采取了反爬虫措施。比如，服务器会检测某个IP在单位时间内的请求次数，如果超过了这个阈值就会直接拒绝服务，返回一些错误信息，这种情况称为封IP。这时就可以采用代理来实现IP伪装。</p>
<p>代理实际是代理服务器，proxy server，功能是代理网络用户去取得网络信息，形象地说是网络信息的中转站，在我们正常请求一个网站时，是发送了请求给Web服务器，WEb服务器把响应传回给我们。如果设置了代理服务器，实际上就是在本机和服务器之间架一座桥，此时本机不是直接向Web服务器发起请求，而是向代理服务器发起请求，请求会发送给代理服务器，然后由代理服务器再发送给Web服务器，接着由代理服务器再把Web服务器返回的响应转发给本机，这样就可正常访问网页了，但这个过程中Web服务器识别出的真实IP就不再是我们本机的IP了，就成功实现了IP伪装，这就是代理的原理。</p>
<p><strong>使用代理隐藏真实的IP，让服务器误以为是代理服务器在请求自己，这样在爬取过程中不断更换代理就不会被封锁，可达到很好的效果</strong>。</p>
<h6 id="代理作用："><a href="#代理作用：" class="headerlink" title="代理作用："></a>代理作用：</h6><ol>
<li><p>突破自身限制，访问一些平时不能访问的站点。</p>
</li>
<li><p>访问一些单位或团体内部资源：比如使用教育网内地址段访问免费代理服务器，就可以实现对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。</p>
</li>
<li><p>提高访问速度：通常代理服务器都设置了一个较大的硬盘缓存区，当有外界的信息通过时，同时也将其保存到缓存区中，当其他用户再访问相同的信息时，则直接由缓存区中取出信息，传给用户，以提高访问速度。</p>
</li>
<li><p>隐藏真实的IP:上网者也可以通过这种方法隐藏自己的IP免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身IP，防止自身的IP被封锁。</p>
</li>
</ol>
<h6 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h6><ol>
<li><p>根据协议区分：</p>
<p>FTP 代理服务器： 主要用于访问 TP 服务器， 般有上传 下载以及 存功能，端口一般为21 212</p>
<p>HTTP 代理服务器： 主要用于访问网页，一般有内容过滤和缓存功能，端口 般为 80  8080 3128</p>
<p>SSL LS 代理： 主要用于访问加密网站， 般有 SSL TLS 加密功能（最高支持 128 位加密强度），端口一般为 443</p>
<p>RTSP 代理： 主要用于访问 Real 流媒体服务器， 般有缓存功能，端口 般为 554</p>
<p>Telnet 代理： 主要用于 telnet 远程控制（黑客人侵计算机时常用于隐藏身份），端口 般为 23</p>
<p>POP3/SMTP 代理： 主要用于 POP3 SMTP 方式收发邮件， 般有缓存功能，端口 般为 110 25</p>
<p>SOCKS 代理： 只是单纯传递数据包，不关心具体协议和用法，所以速度快很 般有存功能，端口一般为 1080  SOCKS 代理协议又分为 SOCKS4 SOCKS5 ，前者只支持 TCP,而后者支持 TC UDP ，还支持各种身份验证机制、服务器端域名解析 简单来说，SOCKS4 能做到的 SOCKS5 都可以做到，但 SOCKS5 能做到的 SOCKS4 定能做到</p>
</li>
<li><p>根据匿名程度区分</p>
<p>高度匿名代理： 会将数据包原封不动地转发，在服务端看来就好像真的是 个普通客户端访问，而记录的 IP 是代理服务器的 IP</p>
<p>普通匿名代理： 会在数据包上做一些改动 服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实 代理服务器通常会加入的 Hπ？头有 HTTP VIA HTTP X FOR DED FOR</p>
<p>透明代理： 不但改动了数据包 还会告诉服务器客户端的真实 IP 这种代理除了能用缓存技术提高浏览速度，能用内容过滤提高安全性之外，并无其他显著作用，最常见的例子是内网的硬件防火墙</p>
<p>间谍代理： 指组织或个人创建的用于记录用户传输的数据，然后进行研究 监控 目的的代理服务器。</p>
</li>
</ol>
<h4 id="基本库"><a href="#基本库" class="headerlink" title="基本库"></a>基本库</h4><h6 id="使用urllib"><a href="#使用urllib" class="headerlink" title="使用urllib"></a>使用urllib</h6><p>urllib库是Python内置的HTTP请求库，不需安装即可使用。包含4个模块：</p>
<ol>
<li>request：它是最基本的 HTTP 请求模块，可以用来模拟发送请求 就像在浏览器里输入网址然后回车一样，只需要给库方法传入 RL 及额外的 数，就可以模拟实现这个过程了</li>
<li>error 异常处理模块，如果出现请求错误 可以捕获这些异常，然后进行重试或作以保证程序不会意外终止</li>
<li>parse 个工具模块，提供了许多 URL 处理方法，比如拆分、解析 合并</li>
<li>robot parser ：主要是用来识别网站的 robots.txt 文件，然后判断哪些网站可以爬，它其实用得 较少。</li>
</ol>
<h6 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h6><p>使用urllib的request模块方便实现请求的发送并得到响应。利用它可模拟浏览器的一个请求发起过程，同时他还带有处理授权验证（authentication），重定向（redirection），浏览器的Cookies以及其他内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">response = urllib.request.urlopen(<span class="string">'https://www.python.org'</span>)</span><br><span class="line">print(response);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>利用最基本的<code>urllib.request.urlopen(url,data=None,[timeout,]*,cafile=None,capath=None,cadefault-False,context=None)</code>方法，可以完成最基本的简单网页的GET请求抓取。</p>
</li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">urllib</span>.<span class="title">request</span>.<span class="title">Request</span><span class="params">(url,data=None,headers=&#123;&#125;,origin_req_host=None,unveriable,method=Node)</span></span></span><br></pre></td></tr></table></figure>

<p>url为必传参数，data要传时必须传bytes（字节流）类型，若为字典，可用<code>urllib.parse</code>模块的<code>urlencode()</code>编码。</p>
<p>headers是一个字典，它是一个请求头，我们可以在构造函数请求时通过headers参数直接构造，也可以通过调用请求实例的add_header()方法添加。添加请求头最常用的方法就是通过修改User-Agent来伪装浏览器，默认的User-Agent是Python-urllib，我们可以通过修改它来伪装浏览器。比如伪装成火狐浏览器，可将它设置为：<code>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:76.0) Gecko/20100101 Firefox/76.0</code>。</p>
<p>origin_req_host指的是请求方的host名称或者IP地址。</p>
<p>unverifiable表示这个请求是否是无法通过验证的，默认是False，意思是说用户没有足够的权限来选择接受这个请求的结果。如：我们请求一个HTML文档中的图片，但是我们没有自动抓取图像的权限，这是unverifiable的值就是true。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,parse</span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:76.0) Gecko/20100101 Firefox/76.0'</span>,</span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'httpbin.org'</span></span><br><span class="line">&#125;</span><br><span class="line">dict = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Germy'</span></span><br><span class="line">&#125;</span><br><span class="line">data = bytes(parse.urlencode(dict),encoding=<span class="string">'utf8'</span>)</span><br><span class="line">req = request.Request(url=url,data=data,headers=headers,method=<span class="string">'POST'</span>)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(<span class="string">'utf8'</span>))</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-python的学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/07/python的学习/" class="article-date">
      <time datetime="2020-05-07T14:00:45.000Z" itemprop="datePublished">2020-05-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/07/python的学习/">python的学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>rmdir    删除目录</p>
<p>ipconfig      查看IP地址</p>
<p>ping         测试网络连接</p>
<p>python       进入python环境</p>
<p>exit()           退出环境</p>
<p>cd   指定目录</p>
<p>dir   浏览目录</p>
<p>mkdir   创建新的目录</p>
<h6 id="pip包管理命令"><a href="#pip包管理命令" class="headerlink" title="pip包管理命令"></a>pip包管理命令</h6><p>pip list     列出匹配管理的包有哪些</p>
<p>pip install   包名      </p>
<p>pip  install  redis == 3.0.2 </p>
<p>pip   uninstall   包名        卸载</p>
<p>pip  -v       查看版本</p>
<p>pip  freeze &gt;  requirements.txt       将项目依赖的包输出到指定的requirements.txt中</p>
<p>pip  install   -r   requirements.txt     使用pip安装requirements.txt中依赖的文件，其中<code>-r</code>指requirements.txt文件</p>
<h6 id="安装requests"><a href="#安装requests" class="headerlink" title="安装requests"></a>安装requests</h6><p>requests是第三方库，python默认不会自带这个库。</p>
<ol>
<li>git clone https ://github.com/kennethreitz/requests</li>
<li>cd  requests</li>
<li>python  setup.py  install</li>
</ol>
<h6 id="安装Selenium"><a href="#安装Selenium" class="headerlink" title="安装Selenium"></a>安装Selenium</h6><p>Selenium是一个自动化测试工具，利用它我们可以驱动浏览器执行特定的动作，如点击，下拉等操作。对于一些js渲染的页面来说，这种抓取方式很有效。</p>
<h6 id="print"><a href="#print" class="headerlink" title="print"></a>print</h6><p>print(value, …, sep=’  ‘，end=’\n’, file=sys.stdout, flush=False)        </p>
<p>sep默认的分隔符是空格</p>
<h4 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h4><h6 id="数与表达式"><a href="#数与表达式" class="headerlink" title="数与表达式"></a>数与表达式</h6><p>乘方运算符的优先级比求负（单目减）高，因此<code>-3**2等价于-（3**2)</code>。如果要计算的是<code>(-3)**2</code>,必须明确指出。</p>
<p>十六进制：0xAF</p>
<p>八进制：010</p>
<p>二进制：0b101011</p>
<p>2 / 4          # 除法，得到一个浮点数</p>
<p>2 // 4          # 除法，得到一个整数</p>
<p>2 ** 5            # 乘方   32</p>
<p>用a + bj,或者complex(a,b)表示复数。</p>
<p><strong>注意</strong></p>
<p>1、Python可以同时为多个变量赋值，如a, b = 1, 2。</p>
<p>2、一个变量可以通过赋值指向不同类型的对象。</p>
<p>3、数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。</p>
<p>4、在混合计算时，Python会把整型转换成为浮点数。</p>
<h6 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h6><ul>
<li>Number数字</li>
<li>String字符串</li>
<li>List列表</li>
<li>Tuple元组</li>
<li>Set集合</li>
<li>Dictionary字典</li>
</ul>
<p>有四种数字类型</p>
<ol>
<li>int整数</li>
<li>bool布尔</li>
<li>float浮点数</li>
<li>complex复数</li>
</ol>
<p><strong>判断类型</strong></p>
<p>type（a） ：判断a的数据类型，不会认为子类是一种父类类型。</p>
<p>isinstance（a,int）：判断a是否为int类型，会认为子类是一种父类类型。</p>
<p>del  val_a, var_b      删除单个或多个对象。</p>
<h6 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h6><p>str=’Runoob’  print(str)                 # 输出字符串 </p>
<p>print(str[0:-1])           # 输出第一个到倒数第二个的所有字符 </p>
<p>print(str[0])              # 输出字符串第一个字符 </p>
<p>print(str[2:5])            # 输出从第三个开始到第五个的字符 </p>
<p>print(str[2:])             # 输出从第三个开始后的所有字符 </p>
<p>print(str * 2)             # 输出字符串两次 </p>
<p>print(str + ‘你好’)        # 连接字符串</p>
<p>print(‘hello\nrunoob’)      # 使用反斜杠()+n转义特殊字符 </p>
<p>print(r’hello\nrunoob’)     # 在字符串前面添加一个 r，表示原始字符串，不会发生转义</p>
<p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 <strong>end=””</strong></p>
<p>print(x)    # 换行输出</p>
<p>print(x,end=” “)        # 不换行输出</p>
<h6 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h6><p>import somemodule         导入整个模块</p>
<p>from somemodule import firstfunc, secondfunc, thirdfunc        从某个模块中导入多个函数</p>
<h6 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h6><p>不可用作任何标识符名称。Python的标准库提供了一个keyword模块，可输出当前版本的所有关键字。</p>
<h6 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h6><p>单行以<code>#</code>开头，多行用三个单或双引号包裹。</p>
<h4 id="urllib库"><a href="#urllib库" class="headerlink" title="urllib库"></a>urllib库</h4><p>python内置的HTTP请求库</p>
<h6 id="request解析库"><a href="#request解析库" class="headerlink" title="request解析库"></a>request解析库</h6><p>urlopen：打开网址</p>
<h6 id="bs4解析库"><a href="#bs4解析库" class="headerlink" title="bs4解析库"></a>bs4解析库</h6><p>bs4: BeautifulSoup</p>
<p>用于解析网页，提取指定数据的。接口简单，较人性化，但bs4只能解析html格式的数据。</p>
<p><strong>BeautifulSoup类</strong></p>
<p>文件解析库：</p>
<p>‘html.parser’：是python自带的一个文件解析库。</p>
<p>‘lxml’：是一个第三方文件解析库，需安装。</p>
<p>根据html标签查找信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content = soup.find(&apos;div&apos;,itemprop=&apos;acticleBody&apos;).text</span><br></pre></td></tr></table></figure>

<p><strong>find()</strong> <strong>方法：返回第一个匹配的内容，为字符串类型</strong></p>
<p>find(name,attrs,recursive,text,**kwargs)</p>
<p>这五个参数都可以<strong>充当过滤器</strong>，提高匹配结果的精确度。</p>
<p><strong>find_all()</strong> <strong>方法：返回所有匹配的项，为一个列表类型</strong></p>
<p>find(name,attrs,recursive, text,<strong>limit</strong>,**kwargs)</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h6 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip install MyQR</span><br><span class="line"></span><br><span class="line">from MyQR Simport myqr</span><br><span class="line">words:  文本，链接地址或字符串</span><br><span class="line">picture：二维码的背景图片</span><br><span class="line">colorized：True，表示生成彩图</span><br><span class="line">save_name: 表示生成的二维码的名字</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from MyQR import myqr</span><br><span class="line">myqr.run(</span><br><span class="line">    words=&quot;https://www.icourse163.org/learn/NHDX-1449955168&quot;,</span><br><span class="line">    picture=&quot;1.png&quot;,</span><br><span class="line">    colorized=True,</span><br><span class="line">    save_name=&quot;ORMooc.png&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h6 id="个人名片"><a href="#个人名片" class="headerlink" title="个人名片"></a>个人名片</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pip install Segno</span><br><span class="line"></span><br><span class="line">from segno import helpers</span><br><span class="line">qr = helpers.make_mecard(</span><br><span class="line">    name=&apos;Erin&apos;,</span><br><span class="line">    city=&apos;湖南省衡阳市南华大学&apos;,</span><br><span class="line">    phone=&apos;1581529632&apos;,</span><br><span class="line">    email=&apos;3511564414@qq.com&apos;</span><br><span class="line">)</span><br><span class="line">qr.save(&apos;Erin名片.png&apos;,scale=10)</span><br></pre></td></tr></table></figure>

<h6 id="爬取小说"><a href="#爬取小说" class="headerlink" title="爬取小说"></a>爬取小说</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(&apos;http://www.39shubao.com/&apos;)</span><br><span class="line">print(response.read().decode(&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure>

<p><strong>报错</strong>：<code>UnicodeDecodeError: &#39;utf-8&#39; codec can&#39;t decode byte 0x8b in position 1: invalid start byte</code></p>
<p>所以去掉解码格式utf-8，<strong>输出的字节码可以看到它是以”b’\x1f\x8b\x08”开头的 ，说明它是gzip压缩过的数据，这也是报错的原因，所以我们需要对我们接收的字节码进行一个解码操作。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line">from io import BytesIO</span><br><span class="line">import gzip</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(&apos;http://www.39shubao.com/&apos;)</span><br><span class="line">buff = BytesIO(response.read())</span><br><span class="line">f = gzip.GzipFile(fileobj=buff)</span><br><span class="line">htmls = f.read().decode(&apos;utf-8&apos;)</span><br><span class="line">print(htmls)</span><br></pre></td></tr></table></figure>

<p><strong>解决乱码问题</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">'http://www.shuquge.com/txt/63542/9645082.html'</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>

<p>通过response.text拿到的数据出现乱码是因为该网页对数据进行加密，所以直接拿到的数据乱码了。</p>
<p>解决：</p>
<p>方法一：使用较老的方法<code>response.encoding=&#39;utf-8&#39;</code>，只能解决utf-8的乱码，其他格式的不能解决。</p>
<p>方法二：<code>response.encoding=response.apparent_encoding</code>，自动解决乱码格式，不仅utf-8格式的可解决，gbk格式的也可解决。</p>
<p>未封装的爬一章小说</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"># 使用parsel来解析网页内容</span><br><span class="line">import parsel</span><br><span class="line">url = &apos;http://www.shuquge.com/txt/63542/9645082.html&apos;</span><br><span class="line">response = requests.get(url)</span><br><span class="line"># 自动解决乱码问题</span><br><span class="line">response.encoding = response.apparent_encoding</span><br><span class="line"># print(response.text)</span><br><span class="line"># 把网页数据结构化</span><br><span class="line">sel = parsel.Selector(response.text)</span><br><span class="line"># 根据css选择器提取标题</span><br><span class="line">title = sel.css(&apos;.content &gt; h1::text&apos;).get()</span><br><span class="line"># 根据css路径提取内容</span><br><span class="line">content = sel.css(&apos;#content::text&apos;).getall()</span><br><span class="line"># 根据xPath提取内容,getall是提取全部的内容，也有re方法，用于匹配正则里面的内容</span><br><span class="line"># print(sel.xpath(&apos;//div[@id=&quot;content&quot;]/text()&apos;).getall())</span><br><span class="line"># 保存数据</span><br><span class="line">with open(title + &apos;.txt&apos;,mode=&apos;w&apos;, encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">    f.write(title)</span><br><span class="line">    # 用切片去掉最后三行</span><br><span class="line">    for con in content[:-3]:</span><br><span class="line">        # str使用replace去除空格</span><br><span class="line">        f.write(con.replace(&apos;\xa0&apos;,&apos;&apos;))</span><br><span class="line">        # f.write(con.strip(&apos;\xa0&apos;))</span><br></pre></td></tr></table></figure>

<h6 id="动态爬取数据"><a href="#动态爬取数据" class="headerlink" title="动态爬取数据"></a>动态爬取数据</h6><p>数据信息不是存放在网页源代码中，它是一个动态更新的网站，需要实时更新的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">url = &apos;https://api.inews.qq.com/newsqa/v1/automation/foreign/country/ranklist&apos;</span><br><span class="line">response = requests.get(url)</span><br><span class="line">content = json.loads(response.text)</span><br><span class="line">print(content[&apos;data&apos;])</span><br><span class="line">df = pd.DataFrame(columns=[&apos;国家及地区&apos;,&apos;确诊人数&apos;,&apos;死亡病例&apos;,&apos;治愈病例&apos;])</span><br><span class="line">for i in range(len(content[&apos;data&apos;])):</span><br><span class="line">    df.loc[i + 1] = [content[&apos;data&apos;][i][&apos;name&apos;],</span><br><span class="line">                     content[&apos;data&apos;][i][&apos;confirm&apos;],</span><br><span class="line">                     content[&apos;data&apos;][i][&apos;dead&apos;],</span><br><span class="line">                     content[&apos;data&apos;][i][&apos;heal&apos;]]</span><br><span class="line">df.to_csv(&apos;F://data.csv&apos;,index=0,encoding=&apos;utf-8&apos;)</span><br><span class="line">print(&apos;爬取完成&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-AJAX学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/30/AJAX学习/" class="article-date">
      <time datetime="2020-04-30T03:04:57.000Z" itemprop="datePublished">2020-04-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/30/AJAX学习/">AJAX学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><h6 id="传统网站存在的问题"><a href="#传统网站存在的问题" class="headerlink" title="传统网站存在的问题"></a>传统网站存在的问题</h6><ol>
<li>网速慢的情况下，页面加载时间长，用户只能等待。</li>
<li>表单提交后，如果一项内容不合格，需要重新填写所有表单内容。</li>
<li>页面跳转，重新加载页面，造成资源浪费，增加用户等待时间。</li>
</ol>
<h6 id="Ajax概述"><a href="#Ajax概述" class="headerlink" title="Ajax概述"></a>Ajax概述</h6><p>它是浏览器提供的一套方法，可以实现页面无刷新更新数据，提高用户浏览网站应用的体验。</p>
<h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><ol>
<li>页面上拉加载更多数据，当下拉到底部并点击加载更多时才会向服务器发起请求并响应给用户。</li>
<li>列表数据无刷新分页，当从第一页切换到第二页时，只有列表中的数据才会变，头部和底部是不会发生变化的。</li>
<li>表单项离开焦点数据验证，当用户输入数据且该表单项失去焦点后，网页会自动将数据传给服务器进行验证，若已有该记录提示给用户。</li>
<li>搜索框提示文字下拉列表。</li>
</ol>
<h6 id="AJAX优缺点"><a href="#AJAX优缺点" class="headerlink" title="AJAX优缺点"></a>AJAX优缺点</h6><p>浏览器可以从服务器同时请求多项内容，利用异步请求可以确保浏览器在后台工作，避免因完全页面刷新而中断用户的工作。</p>
<p>浏览器请求返回的速度会快得多，只是在有些情况下如此而已，请求和响应的速度取决于服务器返回的内容。AJAX页面完全有可能比传统页面的速度更慢。</p>
<p>不能够更真实的渲染颜色，因为颜色渲染由用户监视器控制而不是由用户支配。</p>
<p>只有页面真正改变部分会得到更新。</p>
<p>会减少服务器数据流量，利用AJAX可以建立更小更集中的请求。不过要当心……这也很容易导致建立更多的请求以至于增大数据流量，因为可能要一部建立所有这些请求。</p>
<p>页面的不兼容问题会更严重，由于除了XHTML外，AJAX页面还依赖于其它一些技术，所以使用AJAX后的兼容性问题实际会更严重。</p>
<h6 id="Ajax运行原理及实现"><a href="#Ajax运行原理及实现" class="headerlink" title="Ajax运行原理及实现"></a>Ajax运行原理及实现</h6><p><strong>原理</strong></p>
<p>Ajax相当于浏览器发送请求与接收响应的代理人以实现在不影响用户浏览页面的情况下，局部更新数据，从而提高用户体验。</p>
<p><strong>Ajax实现步骤</strong></p>
<ol>
<li><p>创建Ajax对象</p>
<p><code>var xhr = new XMLHttpRequest();</code></p>
</li>
<li><p>告诉Ajax请求地址以及请求方式</p>
<p><code>xhr.open(&#39;get&#39;,&#39;http://www.example.com&#39;)</code></p>
</li>
<li><p>发送请求</p>
<p><code>xhr.send();</code></p>
</li>
<li><p>获取服务器端给与客户端的响应数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.onload = function()&#123;</span><br><span class="line">	console.log(xhr.responseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>为避免ajax跨域请求，故用express开启一个后端服务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js文件</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用app.use拦截了所有请求，将请求交给express.static处理</span></span><br><span class="line"><span class="comment">// 也就是当网页请求该服务器时，请求全部转向public文件夹进行访问。</span></span><br><span class="line">app.use(express.static(path.join(__dirname,<span class="string">'public'</span>)));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/first'</span>, (req,res) =&gt; &#123;</span><br><span class="line">    res.send(<span class="string">'hello ajax'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'服务器启动成功'</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public/index.html文件</span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">        xhr.open(<span class="string">'GET'</span>,<span class="string">'http://localhost:3000/first'</span>);</span></span><br><span class="line">        xhr.send();</span><br><span class="line"><span class="javascript">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(xhr.responseText);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>服务器端相应的数据格式</strong></p>
<p>在真实的项目中，服务器端大多数情况下会以JSON对象作为响应数据的格式。</p>
<p>在http请求与响应过程中，无论是请求参数还是响应内容，如果是对象类型最终都会被转换为对象字符串进行传输。</p>
<p><code>JSON.parse()   //将json字符串转换为json对象</code></p>
<p><strong>请求参数传递</strong></p>
<p>传统网站表单提交</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"get"</span> <span class="attr">action</span>=<span class="string">"http://www.example.com"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- http://www.example.com?username=zhangsan&amp;passwor=123456 --&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Ajax中的get请求</strong></p>
<p><code>xhr.open(&#39;GET&#39;,&#39;http://www.example.com?name=zhangsan&amp;age=20&#39;);</code></p>
<p><strong>post请求</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.setResquestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;)</span><br><span class="line">xhr.send(&apos;name=zhangsan&amp;age=20&apos;);</span><br></pre></td></tr></table></figure>

<p>application/json</p>
<p>{name:’zhangsan’ , age: ‘20’ ,  sex: ‘男 ‘}</p>
<p>在请求头中指定Content-Type属性的值是application/json，告诉服务器当前请求参数的格式是json。</p>
<p><code>JSON.stringify()</code>    // 将json对象转换为json字符串</p>
<h6 id="Ajax状态码"><a href="#Ajax状态码" class="headerlink" title="Ajax状态码"></a>Ajax状态码</h6><p>在创建ajax对象，配置ajax对象，发送请求以及接受完服务器端响应数据，这个过程中的每一个步骤都会对应一个数值，这个数值就是ajax状态码。</p>
<p>0：请求未初始化，还没调用open（）</p>
<p>1：请求已经建立，但是还没有发送（还没调用send（））</p>
<p>2：请求已经发送</p>
<p>3：请求正在处理中，通常响应中已经有部分数据可以用了。</p>
<p>4：响应已经完成，可以获取并使用服务器的响应了。</p>
<p><code>xhr.readyState    //获取ajax状态码</code></p>
<p><code>onreadystatechange事件</code>，当ajax状态码发生变化时将自动触发该事件。不过推荐使用<code>xhr.onload</code>方法。</p>
<h6 id="Ajax错误处理"><a href="#Ajax错误处理" class="headerlink" title="Ajax错误处理"></a>Ajax错误处理</h6><ol>
<li><p>网络畅通，服务端能接收到请求，服务器返回的结果不是预期的结果。</p>
<p>可以判断服务器端返回的状态码，分别进行处理。xhr.status获取http状态码。</p>
</li>
<li><p>网络畅通，服务器没有接收到请求，返回404状态码。</p>
<p>检查请求地址是否错误。</p>
</li>
<li><p>网络畅通，服务器端能接受收到请求，服务器端返回500状态码。</p>
<p>服务器端错误，找后端程序员进行沟通。</p>
</li>
<li><p>网络中断，请求无法发送到服务器端。（模拟断网，可在浏览器中的network中将offline勾选即可）</p>
<p>会触发xhr对象下面的onerror事件，但不会会触发onload事件，在onerror事件处理函数中对错误进行处理。</p>
</li>
</ol>
<h6 id="封装Ajax函数"><a href="#封装Ajax函数" class="headerlink" title="封装Ajax函数"></a>封装Ajax函数</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 存储的是默认值</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">default</span> = &#123;</span><br><span class="line">        type: <span class="string">'get'</span>,</span><br><span class="line">        url: <span class="string">''</span>,</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        header: &#123;</span><br><span class="line">            <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">                 </span><br><span class="line">&#125;;</span><br><span class="line">	<span class="comment">// 使用options对象中的属性覆盖default对象中的属性</span></span><br><span class="line">	<span class="built_in">Object</span>.assign(<span class="keyword">default</span>,options);</span><br><span class="line">	<span class="comment">// 创建ajax对象</span></span><br><span class="line">	<span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="comment">// 拼接请求参数的变量</span></span><br><span class="line">    <span class="keyword">var</span> params = <span class="string">''</span>;</span><br><span class="line">    <span class="comment">// 循环用户传递进来的对象格式参数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> <span class="keyword">default</span>.data)&#123;</span><br><span class="line">        <span class="comment">// 将参数转换为字符串</span></span><br><span class="line">        params += attr + <span class="string">'='</span> + <span class="keyword">default</span>.data[attr] + <span class="string">'&amp;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将参数最后的&amp;截取掉</span></span><br><span class="line">    <span class="comment">// 将截取的结果重新赋值给params变量</span></span><br><span class="line">    params = params.substr(<span class="number">0</span>,params.length - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断请求方式</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">default</span>.type == <span class="string">'get'</span>)&#123;</span><br><span class="line">        <span class="keyword">default</span>.url = <span class="keyword">default</span>.url + <span class="string">'?'</span> + params;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 配置ajax对象</span></span><br><span class="line">	xhr.open(<span class="keyword">default</span>.type,<span class="keyword">default</span>.url);</span><br><span class="line">    <span class="comment">// 如果是post请求</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">default</span>.type == <span class="string">'post'</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> contentType = <span class="keyword">default</span>.header[<span class="string">'Content-Type'</span>];</span><br><span class="line">          <span class="comment">// 设置请求参数格式的类型</span></span><br><span class="line">        xhr.setRequestHeader(<span class="string">'Content-Type'</span>,contentType);</span><br><span class="line">        <span class="keyword">if</span>(contentType == <span class="string">'application/json'</span>)&#123;</span><br><span class="line">            xhr.send(<span class="built_in">JSON</span>.stringify(<span class="keyword">default</span>.data))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            xhr.send(params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 监听xhr对象上的onload事件</span></span><br><span class="line">	<span class="comment">// 当xhr对象接收完响应数据后触发</span></span><br><span class="line">	xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 获取响应头中的数据</span></span><br><span class="line">        <span class="keyword">var</span> contentType = xhr.getResponseHeader(<span class="string">'Content-Type'</span>);</span><br><span class="line">        <span class="comment">// 服务器端返回的数据</span></span><br><span class="line">        <span class="keyword">var</span> responseText = xhr.responseText;</span><br><span class="line">        <span class="comment">// 如果响应类型中包含application/json</span></span><br><span class="line">        <span class="keyword">if</span>(contentType.includes(<span class="string">'application/json'</span>))&#123;</span><br><span class="line">            responseText = <span class="built_in">JSON</span>.parse(responseText);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">           <span class="keyword">default</span>.success(xhr.responseText,xhr);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">default</span>.error(xhr.responseText,xhr);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(&#123;</span><br><span class="line">	type: <span class="string">'get'</span>,</span><br><span class="line">	url: <span class="string">'http://lcalhost:3000/first'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      name: <span class="string">'zhangsan'</span>,</span><br><span class="line">        age:<span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    header:&#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'json'</span></span><br><span class="line">    &#125;,</span><br><span class="line">	sucess: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(data);</span><br><span class="line">	&#125;,</span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="验证邮箱地址的唯一性"><a href="#验证邮箱地址的唯一性" class="headerlink" title="验证邮箱地址的唯一性"></a>验证邮箱地址的唯一性</h6><ol>
<li>获取文本框并为其添加离开焦点事件</li>
<li>离开焦点时，检测用户输入的邮箱地址是否符合规则。</li>
<li>如果不符合规则，组织程序向下执行并给出提示信息。</li>
<li>向服务端发送请求，检测邮箱地址是否被别人注册。</li>
<li>根据服务端返回值决定客户端显示何种提示信息。</li>
</ol>
<p><strong>常用元字符</strong></p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母或数字或下划线</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的开始或结束</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结束</td>
</tr>
</tbody></table>
<p><strong>常用限定符</strong></p>
<table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody></table>
<p>以此举个例子如邮箱：<a href="mailto:Yuan.Yiuri691@ningmeng.com.cn" target="_blank" rel="noopener">Yuan.Yiuri691@ningmeng.com.cn</a><br> 正则表达式为：<code>^[A-Za-z0-9-._]+@[A-Za-z0-9-]+(\.[A-Za-z0-9]+)\*(\.[A-Za-z]{2,6})$</code></p>
<p>创建过程：</p>
<ol>
<li>开头和结尾：^$;</li>
<li>加入@：^@$;</li>
<li>@前的内容匹配：[A-Za-z0-9-._]  大小写字母，数字,”.”,下划线 随机出现；”+” 号表示当前规则中的字符可以重复；</li>
<li>@后的内容受顶级域名的限制，按点号分割后的规则略有不同：(.[A-Za-z]{2,6}) 必须是字母出现，比如.com，.cn等</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-node进阶" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/30/node进阶/" class="article-date">
      <time datetime="2020-04-30T02:30:22.000Z" itemprop="datePublished">2020-04-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/30/node进阶/">node进阶</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="单线程的弱点"><a href="#单线程的弱点" class="headerlink" title="单线程的弱点"></a>单线程的弱点</h4><ol>
<li>无法利用多核CPU。</li>
<li>错误会引起整个应用退出，应用的健壮性值得考虑。</li>
<li>大量计算占用CPU导致无法继续调用异步I/O。</li>
</ol>
<p>像浏览器中JavaScript与UI共用一个线程一样，JavaScript长时间执行会导致UI渲染和响应被中断。在Node中，长时间的CPU占用也会导致后续异步I/O发不出调用，已完成的异步I/O的回调函数也会得不到及时执行。</p>
<p>Node采用了与Web Workers相同的思路来解决单线程中大计算量的问题：child_process。</p>
<p>子进程的出现，意味着Node可以从容地应对单线程在健壮性和无法利用多核CPU方面的问题。通过计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好的保持应用模型的简单和地低依赖。通过Master-Worker的管理方式，也可以很好地管理各个工作进程，以达到更高的的健壮性。</p>
<h4 id="node简介"><a href="#node简介" class="headerlink" title="node简介"></a>node简介</h4><ul>
<li>Node.js是一个js运行环境，实际上它是对Google v8引擎的封装。V8引擎执行js的速度快，性能好。node.js对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境上运行的更好。</li>
<li>node.js是一个基于chrome javascript运行建立的平台，用于方便的搭建响应速度快，易于拓展的网络应用。node.js使用事件驱动，非阻塞I/O模型得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。</li>
<li>node采用一系列“非阻塞”库来支持事件循环的方式。本质上就是为文件系统，数据库之类的资源提供接口。向文件系统发送一个请求时，无需等待硬盘（寻址并检索文件），硬盘准备好的时候非阻塞接口会通知node。该模型以可拓展的方式简化了对慢资源的访问，直观易懂。</li>
<li>node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理——node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，因此，我们应该要充分的利用这一点——尽可能地避免阻塞操作</li>
</ul>
<h4 id="node-js组成部分"><a href="#node-js组成部分" class="headerlink" title="node.js组成部分"></a>node.js组成部分</h4><ul>
<li>引入required模块：我们可使用required指令载入node.js模块   var http = require(“http”);</li>
<li>创建服务器：服务器可监听客户端请求，类似于Apache，Nginx等http服务器 。使用http.createServer()方法创建服务器，并使用listen方法绑定端口。</li>
<li>接收请求和响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送http请求，服务器接收请求并返回响应数据。使用request和response参数来接收和响应数据。</li>
</ul>
<h4 id="npm包管理器"><a href="#npm包管理器" class="headerlink" title="npm包管理器"></a>npm包管理器</h4><ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用</li>
</ul>
<h4 id="NPM常用命令"><a href="#NPM常用命令" class="headerlink" title="NPM常用命令"></a>NPM常用命令</h4><p>NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。</p>
<ul>
<li><p>NPM提供了很多命令，例如<code>install</code>和<code>publish</code>，使用<code>npm help</code>可查看所有命令。</p>
</li>
<li><p>使用<code>npm help &lt;command&gt;</code>可查看某条命令的详细帮助，例如<code>npm help install</code>。</p>
</li>
<li><p>在<code>package.json</code>所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</p>
</li>
<li><p>使用<code>npm update &lt;package&gt;</code>可以把当前目录下<code>node_modules</code>子目录里边的对应模块更新至最新版本。</p>
</li>
<li><p>使用<code>npm update &lt;package&gt; -g</code>可以把全局安装的对应命令行程序更新至最新版。</p>
</li>
<li><p>使用<code>npm cache clear</code>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</p>
</li>
<li><p>使用<code>npm unpublish &lt;package&gt;@&lt;version&gt;</code>可以撤销发布自己发布过的某个版本代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm -v  						查看版本</span><br><span class="line">npm version  					查看所有模块的版本</span><br><span class="line">npm search 包名/部分包名			 搜索包</span><br><span class="line">npm init   						初始化package.json文件</span><br><span class="line">npm install/i 安装包     </span><br><span class="line">npm remove/r包名					删除包</span><br><span class="line">npm install/i 包名 --save 		安装包并添加到依赖中</span><br><span class="line">npm install 					根据package.json下载当前项目所依赖的包</span><br><span class="line">npm install 包名 -g				全局安装包，用于一些编译根据，比如：gulp，webpack</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>注意：如果想在页面中引入node_module中某个模块，优先从当前目录引入，如果没有，则从上一级目录中找，直到根目录。</li>
</ul>
<h4 id="REPL交互式解释器"><a href="#REPL交互式解释器" class="headerlink" title="REPL交互式解释器"></a>REPL交互式解释器</h4><ul>
<li>REPL(Read Eval Print Loop:交互式解释器)表示一个电脑的环境，类似于终端，可接受系统的响应。node自带了交互式解释器，可执行以下任务<ul>
<li>读取，读取用户输入，解析输入js数据结构并存储于内存中。</li>
<li>执行，执行输入的数据结构。</li>
<li>打印，输出结果。</li>
<li>循环，循环操作以上步骤直到用户两次按下ctrl+c按钮退出。</li>
</ul>
</li>
</ul>
<h4 id="node知识"><a href="#node知识" class="headerlink" title="node知识"></a>node知识</h4><h6 id="node-js与其它语言的区别"><a href="#node-js与其它语言的区别" class="headerlink" title="node.js与其它语言的区别"></a>node.js与其它语言的区别</h6><ul>
<li><p>node.js不是一门独立的语言。php，jsp即使语言，又是平台。node.js用js进行编程，运行平台是封装后的js引擎V8</p>
</li>
<li><p>轻量级架构</p>
<ul>
<li>java，php，net，需要运行在服务器上，apache，tomcat</li>
<li>node.js不用架设在任何服务器软件之上。</li>
<li>用最低的硬件成本，达到更高的开发，更优的处理函数。</li>
</ul>
</li>
<li><p>node.js没有web容器，就是安装配置完成之后，没有根目录（php的根目录是www）</p>
</li>
</ul>
<h6 id="node-js的特点（追求极致性能）"><a href="#node-js的特点（追求极致性能）" class="headerlink" title="node.js的特点（追求极致性能）"></a>node.js的特点（追求极致性能）</h6><ul>
<li>单线程<ul>
<li>优势：减少内存消耗（操作系统不再有创建线程，销毁线程的开销。<ul>
<li>在php，jsp等服务器语言中，会为每个用户创建一个线程，而每个线程大约需要2M内存，每创建一个线程就要占用内存空间。</li>
<li>当有客户链接时，就会触发一个内部事件，通过非阻塞I/O，事件驱动机制，让node.js宏观上是并发的。可同时处理4万用户的请求。即当张三连接着时，李四请求连接，引擎就会停止张三语法的执行，转而将李四加入到时间栈中。</li>
<li>node.js不为每个用户创建一个线程，仅仅使用同一个线程。</li>
</ul>
</li>
<li>劣势：<ul>
<li>如果线程遭遇I/O阻塞，整个线程便阻塞了。</li>
<li>如果有人将node.js搞崩溃了，则会全部奔溃。</li>
</ul>
</li>
</ul>
</li>
<li>非阻塞<ul>
<li>node.js采用非阻塞I/O机制，因此在执行完访问数据库操作后，会立即执行后面的代码（其他非阻塞事件不会，他们会等数据库操作完毕并返回结果才执行后面的代码），把数据库的处理代码放入回调函数中，从而提高效率。</li>
<li>当某个I/O执行完毕后，将以事件的形式通过执行I/O操作的线程，线程执行完这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断检查有没有未处理的事件，并依次予以处理。</li>
<li>阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远执行计算操作，这个线程的CPU核心利用率永远是100%；</li>
</ul>
</li>
<li>事件驱动<ul>
<li>不管用户的请求，还是老用户的I/O完成，都将以事件的形式加入事件环，等待调度。</li>
</ul>
</li>
<li>node.js的iI/O都是异步的，都是回调函数调回调函数</li>
</ul>
<h6 id="node事件触发"><a href="#node事件触发" class="headerlink" title="node事件触发"></a>node事件触发</h6><ul>
<li>继承EventEmitter，大多数情况下不会直接使用EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</li>
<li>原因：<ul>
<li>具有某个实体功能的对象实现时间符合语义，事件的监听和发射应该是一个对象的方法。</li>
<li>js对象是基于原型的，支持多重继承，继承EventEmitter不会打乱对象原有的继承关系。</li>
</ul>
</li>
</ul>
<h6 id="node-js应用方向"><a href="#node-js应用方向" class="headerlink" title="node.js应用方向"></a>node.js应用方向</h6><ol>
<li>特点<ul>
<li>善于I/O，不善于计算。<ul>
<li>因为node.js最擅长任务的调度，如果你的任务有很多CPU计算，实际上相当于这个计算阻塞了这个单线程，就不适合node开发。</li>
<li>当应用程序需要处理大量并发的I/O，而在向客户端发出响应后，应用程序内部并不需要进行复杂的处理时，node也非常适合与websocket配合，开发长连接的实时交互应用程序。</li>
</ul>
</li>
<li>天生异步<ul>
<li>callback，trunk（参数的求值策略），promise，generator（es6的生成器，用于计算），asynac函数</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="node模块化"><a href="#node模块化" class="headerlink" title="node模块化"></a>node模块化</h4><ul>
<li>CommonJS规范为JS能够在任何地方执行，这是一个愿景。</li>
<li>从文件角度看，每个JS文件就是一个个模块，从结构上看，多个JS文件之间可以相互require共同实现一个功能，这整体功能就是一个模块。</li>
<li>在node.js中，一个模块定义的变量只能在该文件中使用，当需要另一文件中的变量时，需使用exports进行暴漏，然后使用require引入。</li>
<li>引入模块时，如果是非核心模块，且在同级目录时，require需要加上<code>./</code>，核心模块则不需要，直接写名字即可</li>
</ul>
<h6 id="node核心模块"><a href="#node核心模块" class="headerlink" title="node核心模块"></a>node核心模块</h6><ul>
<li><p>全局变量是global。</p>
</li>
<li><p>每个node都在外面给我们套了一个函数。</p>
<p><code>function(exports,require,module,_filename,_dirname){//里面是你写的内容}</code></p>
<ul>
<li>exports：该对象用来将函数内部的局部函数暴漏到外部函数中。</li>
<li>require：用来引入外部模块。</li>
<li>module：代表当前模块本身，exports就是module的属性。我们可以使用exports或modile.exports导出。</li>
<li>_filename:当前模块的完整路径</li>
<li>_dirname:当前模块所在的文件的完整路径。</li>
</ul>
</li>
<li><p>exports与module.exports的区别</p>
</li>
<li><p>json文件不能加注释。</p>
</li>
</ul>
<h4 id="Buffer缓存区"><a href="#Buffer缓存区" class="headerlink" title="Buffer缓存区"></a>Buffer缓存区</h4><ul>
<li>可以理解为是一个存放二进制的容器，专门用于数据的存放。</li>
<li>node自带的，不需要引入就可使用。一个字节占8bit</li>
<li>8bit = 1B       1024B  = 1KB      1024KB = 1MKB      1GB=1024KB     1TB=1024GB</li>
<li>Buffer.from(str,编码格式);</li>
<li>Buffer.alloc(size[,fill[,encoding]])<ul>
<li>size:新建的Buffer期望的长度，不能动态改变，溢出的数据不做处理。int值</li>
<li>fill：用来预填充新建的Buffer的值，默认为0.     String   Buffer    int</li>
<li>encoding:如果fill为字符串，则该值就是它的字符编码，默认为“utf-8”</li>
</ul>
</li>
</ul>
<h4 id="fs文件处理"><a href="#fs文件处理" class="headerlink" title="fs文件处理"></a>fs文件处理</h4><ul>
<li><p>fs.open(path,flag[,mode],callback)打开文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//1.引入模块</span><br><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">//2.创建写入流，相当于在it666.txt与服务器之间建立一个通道，使数据可以源源不断从it666.txt中上传至服务器中</span><br><span class="line">let ws = fs.createWriteStream(&quot;it666.txt&quot;);</span><br><span class="line">//3.打开通道，监听打开事件，有on，once等方法，因只需监听一次，故用once</span><br><span class="line">stream.once(&apos;open&apos;,() =&gt; &#123;</span><br><span class="line">    console.log(&apos;通道已经打开&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">stream.once(&apos;close&apos;, ()=&gt; &#123;</span><br><span class="line">    console.log(&apos;通道已经关闭&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">//写入东西</span><br><span class="line">stream.write(&apos;dfsadc&apos;);</span><br><span class="line">stream.write(&apos;dfsadc&apos;);</span><br><span class="line">//关闭通道，当发现还有东西未写入时，不会关闭</span><br><span class="line">stream.end()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">let ws = fs.createWriteStream(&quot;it666.txt&quot;);</span><br><span class="line">let rs = fs.createReadStream(&quot;sp.mp4&quot;);</span><br><span class="line">//创建管道，该语句就会自动将数据存入sp.mp4中，同时监听打开关闭等事件</span><br><span class="line">rs.pipe(ws);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul>
<li>数据库就是按照一定的数据结构来组织，存储和管理数据的仓库。</li>
<li>我们写的程序都是在计算机上运行的，一旦计算机断电或程序运行完毕，程序数据就会全部丢失，所以我们需要将一些程序运行的数据持久性保存到硬盘中，以确保数据的安全性。</li>
<li>选择数据库的原因：<ul>
<li>数据库是有结构的，数据与数据之间可以建立各种关系，类似于网状拓扑图。</li>
<li>数据库提供各种接口，让各种操作（增删改查）变得快捷简单。</li>
<li>给个种语言（php，jsp，java）提供了完善的接口。</li>
</ul>
</li>
<li>数据库分类<ul>
<li>RDBMS(关系型数据库)：MySQL，SQL Server，ORACLE,DB2….</li>
<li>NoSQL（非关系型数据库 Not only SQL）:MongoDB,CouchDB,HBase,Redis…<ul>
<li>没有行列的概念，用JSON来存储数据，集合就相当于“表”，文档就相当于“行”。</li>
<li>非关系型数据库为非标准化的数据库。</li>
<li>特征：键值存储数据库，列存储数据库，文档存储数据库，图形数据库。</li>
</ul>
</li>
<li>两者区别：关系型数据库比较结构化，操作不是很灵活；非关系型数据库操作灵活，但不适合大型数据存储，比较适合微架构….两者相辅相成。</li>
</ul>
</li>
</ul>
<h6 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h6><ul>
<li>MongoDB是为快速开发互联网Web应用而设计的数据库系统。他的数据类型是面向文档的，类似于JSON的结构。</li>
<li>基本组成<ul>
<li>数据库（database）：数据库是一个仓库，在仓库中可以存放集合。</li>
<li>集合（collection）：集合类似于数组，在集合中可以存放文档。</li>
<li>文档（document）：文档数据库中的最小单位，我们存储和操作的内容都是文档。</li>
</ul>
</li>
<li>mongoDB的基本指令:<ul>
<li>show dbs    ：显示当前所有的数据库</li>
<li>use 数据库名        ：进入到指定的数据库中</li>
<li>db     ：显示当前数据库</li>
<li>show  collections        ：显示数据库中的所有集合</li>
</ul>
</li>
<li>命令进行CRUD<ul>
<li>插入：db.<collection>.insert(doc);      如：db.student.insert({id:001,name:’nikita’});</collection></li>
<li>查询：db.<collection>.find();</collection></li>
</ul>
</li>
</ul>
<h4 id="同步与异步，阻塞与非阻塞"><a href="#同步与异步，阻塞与非阻塞" class="headerlink" title="同步与异步，阻塞与非阻塞"></a>同步与异步，阻塞与非阻塞</h4><ul>
<li><p>同步，当发起一个调用时，在没有获取结果前，调用不会返回，直到获取结果。事一件一件做，做完一件在做一件。</p>
</li>
<li><p>异步：当发起一个调用时，在没有获取结果之前，调用就返回了，调用者并不会立即得到结果，而是被调用者通知调用调用者，通过回调函数处理结果。</p>
</li>
<li><p>阻塞，在等待结果时，不能干其他事，线程被挂起，直到结果返回。</p>
</li>
<li><p>非阻塞：在等待结果中，还能干其他事，线程不会被阻塞。</p>
</li>
</ul>
<h4 id="url相关操作"><a href="#url相关操作" class="headerlink" title="url相关操作"></a>url相关操作</h4><ul>
<li>将url解析为一个url对象：url.parse(urlString[,parseQueryString[,slashDenotHost]])</li>
<li>将一个url对象反解析为一个url地址：url.format(urlObject)</li>
<li>将部分url拼接为一个完整url地址url.resolve(from,to)</li>
<li>response对象有一个方法：write可以用来给客户端发送响应数据。write可以使用多次，但最后需要用end来结束响应，否则客户端会一直等待</li>
<li>req.url是地址栏中localhost后面的所有内容，除了hash的内容。</li>
<li>querystring.parse将字符串转为一个对象。</li>
</ul>
<h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><h6 id="使用第三方插件"><a href="#使用第三方插件" class="headerlink" title="使用第三方插件"></a>使用第三方插件</h6><p>需要先安装formidable包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let http = require(&apos;http&apos;);</span><br><span class="line">let url = require(&apos;url&apos;);</span><br><span class="line">let formidable = require(&apos;formidable&apos;);</span><br><span class="line">let util = require(&apos;util&apos;);//用于将object转为字符串</span><br><span class="line"> http.createServer((req,res) =&gt; &#123;</span><br><span class="line"> 	if(req.url === &apos;/postmsg&apos; &amp;&amp; req.methods.tolowerCase() === &quot;post&quot;)&#123;</span><br><span class="line"> 		//实例化对象</span><br><span class="line"> 		let form = new formidable.IncomingForm();</span><br><span class="line"> 		//设置上传文件路径</span><br><span class="line"> 		form.uploadDir = &apos;./uploads&apos;;</span><br><span class="line"> 		//获取表单内容</span><br><span class="line"> 		form.parse(req,(err,fileds,files) =&gt; &#123;</span><br><span class="line"> 			res.writeHead(200,&#123;&quot;content-Type&quot;:&quot;text/plain;charset=UTF-8&quot;&#125;);</span><br><span class="line"> 			res.end(util.inspect(&#123;fields:fields,files:files&#125;));</span><br><span class="line"> 		&#125;)</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;).listen(80,&apos;127.0.0.1&apos;);</span><br></pre></td></tr></table></figure>

<h4 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h4><p>在Node中，每个文件模块都是一个对象，它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Module(id, parent)&#123;</span><br><span class="line">	this.id = id;</span><br><span class="line">	this.exports = &#123;&#125;;</span><br><span class="line">	this.parent = parent;</span><br><span class="line">	if(parent &amp;&amp; parent.children)&#123;</span><br><span class="line">		parent.children.push(this);</span><br><span class="line">	&#125;</span><br><span class="line">	this.filename = null;</span><br><span class="line">	this.loaded = false;</span><br><span class="line">	this.children = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译和执行是引入文件模块的最后一个阶段。定位到具体文件后，Node会新建一个模块对象，然后通过路径载入并编译。对于不同的文件扩展名，其载入的方式也有所不同，具体如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.js文件。通过fs模块同步读取文件后编译执行。</span><br><span class="line"></span><br><span class="line">.node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后的编译生成的文件。</span><br><span class="line"></span><br><span class="line">.json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。</span><br><span class="line"></span><br><span class="line">其余扩展名文件。它们都被当作.js文件解析。(因为node只能解析js文件，其他文件最后都会被转化成js文件，故当其余扩展名文件出现时，node无法识别，故将其认为是默认扩展名进行解析，即.js)</span><br></pre></td></tr></table></figure>

<p>每一个编译成功的模块都会将文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。</p>
<p>根据不同文件扩展名，node会调用不同的读取方式，如：.json文件调用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Module._extensions[&apos;.json&apos;] = function(module,filename)&#123;</span><br><span class="line">	var content = NativeModule.require(&apos;fs&apos;).readFileSync(filename,&apos;utf8&apos;);</span><br><span class="line">	try&#123;</span><br><span class="line">		module.exports = JSON.parse(strinpBOM(cntent));</span><br><span class="line">	&#125;catch(err)&#123;</span><br><span class="line">		err.message = filename + &apos;:&apos; + err.message;</span><br><span class="line">		throw err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，Module._extensions会被赋值给 require() 的extensions属性，所以通过在代码中访问require.extensions可知道系统中已有的加载方式。编写代码测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//新建index.js文件</span><br><span class="line">console.log(require.extensions);</span><br><span class="line">//运行node index.js,输出</span><br><span class="line">//[Object: null prototype] &#123; &apos;.js&apos;: [Function], &apos;.json&apos;: [Function], &apos;.node&apos;: [Function] &#125;</span><br></pre></td></tr></table></figure>

<p>如果想对自定义的扩展名进行特殊的加载，可以通过类似require.extensions[‘.ext’]的方式实现。早期的CoffeeScript文件就是通过添加require.extensions[‘.coffee’]扩展方式来加载的。但是从v0.10.6版本开始，官方不鼓励通过这种方式进行自定义扩展名的加载，而是期望先将其它语言或文件先编译成js文件后再进行加载，这样做的好处是不将繁琐的编译加载等过程引入node的执行过程。</p>
<p>在确定文件的扩展名后，node将调用具体的编译方式来将文件执行后返回给调用者。</p>
<p>注：我们都知道CommonJS模块规范中，每个模块文件都存在<code>require、exports、module、_filename、_dirname</code>这5个变量却不知其从何而来。若是把直接定义模块的过程放在浏览器端，势必会存在污染全局变量的情况，故其不可能。</p>
<p>事实上，在编译过程中，node会对获取的js文件内容进行包装，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function(require、exports、module、_filename、_dirname)&#123;</span><br><span class="line">	var math = require(&apos;math&apos;);</span><br><span class="line">	exports.area = function(radius)&#123;</span><br><span class="line">		return Math.PI * radius * radius;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样每个模块文件之间都进行了作用于隔离。包装之后的代码会通过vm原生模块的runInThisContext() 方法执行，类似于eval，只是具有明确上下文，不污染全局，返回一个体的function对象。最后，将当前模块对象的exports属性，require()方法，module(模块对象本身)，以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。</p>
<p>这就是为什么这些变量并没有在每个模块声明却可以使用的原因。在执行后，模块的exports属性被返回给了调用方。exports属性上的任何方法都可以被外部调用到，但是模块中的其余变量和属性则不可直接被调用。</p>
<p>至此，require、exports、module的流程已经完整，这就是Node对CommonJS模块规范的实现。</p>
<p><strong>JSON文件的编译</strong></p>
<p>json文件的编译是三种编译方式中最简单的。Node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse（）方法得到对象，然后将它赋给模块对象的exports，以供外部调用。</p>
<p>JSON文件在用作项目的配置文件时比较有用。如果你定义了JSON文件作为配置，那就不用调用fs模块去异步读取和解析，直接调用require（）引入即可。此外，你还可以享受到模块缓存的便利，并且二次引入时也没有性能影响。</p>
<p>这里我们提到的模块编译都是指文件编译，即用户自己编写的模块。</p>
<h6 id="内建模块"><a href="#内建模块" class="headerlink" title="内建模块"></a>内建模块</h6><p>内建模块的优势在于：首先，他们本身由C/C++编写，性能上优于脚本语言；其次，其次，在进行文件编译时，他们会被编译进二进制文件。一旦node开始执行，他们会被直接加载进内存中，无需再次坐标识符定位、文件定位、编译等过程，直接就可执行。</p>
<p>Node在启动时，会生成一个全局变量process，并提供Binding()方法来协助加载内建模块。</p>
<p>在加载内建模块时，我们会先创建一个exports空对象，然后调用get_builtin_module（）方法取出内建模块对象，通过执行register_func()填充exports对象，最后将exports对象按模块名缓存，并返回给调用方完成导出。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 陈楚吟
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="陈楚吟">


    
    


<meta name="description" content="将学习技术点汇总">
<meta name="keywords" content="write myBlog">
<meta property="og:type" content="website">
<meta property="og:title" content="Nikita">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Nikita">
<meta property="og:description" content="将学习技术点汇总">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nikita">
<meta name="twitter:description" content="将学习技术点汇总">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Nikita" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Nikita</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">陈楚吟</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不负韶华</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">陈楚吟</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">陈楚吟</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不负韶华</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-JS中外部文件的优势-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/15/JS中外部文件的优势-1/" class="article-date">
      <time datetime="2020-02-15T04:19:45.000Z" itemprop="datePublished">2020-02-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/15/JS中外部文件的优势-1/">JS中外部文件的优势</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="JS中外部文件的优势"><a href="#JS中外部文件的优势" class="headerlink" title="JS中外部文件的优势"></a>JS中外部文件的优势</h4><p>在HTML中嵌入js代码虽然没有问题，但一般认为最好使用外部文件来包含代码。不过，并不存在必须使用外部文件的硬性要求，但支持使用外部文件的人多会强调如下优点：</p>
<ol>
<li>可维护性：遍及不同HTML页面的js代码会造成维护问题，但把所有js文件放在一个文件夹中，维护起来就轻松多了。而且开发人员也可在不触及HTML标记的情况下，集中精力编辑js代码。</li>
<li>可缓存性：浏览器能够根据具体的缓存链接到所有的外部文件。也就是说，如果有两个页面都是使用同一个文件，那么这个文件只需下载一次。因此，最终结果就是能够加快页面加载的速度。</li>
<li>适应未来：通过外部文件来包含js无需使用前面提到的XHTML或注释hack。HTML和XHTM包含外部文件的语法是相同的。</li>
</ol>
<p>把JavaScript插入到HTML页面中要使用<code>&lt;script&gt;</code>元素。使用这个元素可以把JavaScript嵌入到HTML页面中，让脚本与标记混合在一起；也可以包含外部的JavaScript文件。而我们需要注意的地方有：</p>
<ol>
<li>在包含外部JavaScript文件时，必须将src属性设置为指向文件的 url 。而这个文件可以是与包含它的页面位于同一服务器上的文件，也可以是其他文件域中的文件。</li>
<li>所有<code>&lt;script&gt;</code>元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用defer，async属性的情况下，只有解析完前面<code>&lt;script&gt;</code>代码后才会开始解析后面的<code>&lt;/script&gt;</code>元素中的代码。</li>
<li>由于浏览器会先解析完不使用defer属性的<code>&lt;script&gt;</code>元素中的代码，然后再解析后面的内容，所以一般应该把<code>&lt;script&gt;</code>元素放在页面最后，及主要内容的后面，<code>&lt;/body&gt;</code>标签前面。</li>
<li>使用defer属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照它们指定的顺序执行。</li>
<li>使用ansyc属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。</li>
<li>另外，使用<code>&lt;noscript&gt;</code>元素可以指定在不支持脚本的浏览器中显示的替代内容。但在启动了脚本的情况下，浏览器不会显示<code>&lt;noscript&gt;</code>元素中的任何内容。</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-node模块编译" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/15/node模块编译/" class="article-date">
      <time datetime="2020-02-15T04:17:19.000Z" itemprop="datePublished">2020-02-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/15/node模块编译/">node模块编译</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h4><p>在Node中，每个文件模块都是一个对象，它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Module(id, parent)&#123;</span><br><span class="line">	this.id = id;</span><br><span class="line">	this.exports = &#123;&#125;;</span><br><span class="line">	this.parent = parent;</span><br><span class="line">	if(parent &amp;&amp; parent.children)&#123;</span><br><span class="line">		parent.children.push(this);</span><br><span class="line">	&#125;</span><br><span class="line">	this.filename = null;</span><br><span class="line">	this.loaded = false;</span><br><span class="line">	this.children = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译和执行是引入文件模块的最后一个阶段。定位到具体文件后，Node会新建一个模块对象，然后通过路径载入并编译。对于不同的文件扩展名，其载入的方式也有所不同，具体如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.js文件。通过fs模块同步读取文件后编译执行。</span><br><span class="line"></span><br><span class="line">.node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后的编译生成的文件。</span><br><span class="line"></span><br><span class="line">.json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。</span><br><span class="line"></span><br><span class="line">其余扩展名文件。它们都被当作.js文件解析。(因为node只能解析js文件，其他文件最后都会被转化成js文件，故当其余扩展名文件出现时，node无法识别，故将其认为是默认扩展名进行解析，即.js)</span><br></pre></td></tr></table></figure>

<p>每一个编译成功的模块都会将文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。</p>
<p>根据不同文件扩展名，node会调用不同的读取方式，如：.json文件调用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Module._extensions[&apos;.json&apos;] = function(module,filename)&#123;</span><br><span class="line">	var content = NativeModule.require(&apos;fs&apos;).readFileSync(filename,&apos;utf8&apos;);</span><br><span class="line">	try&#123;</span><br><span class="line">		module.exports = JSON.parse(strinpBOM(cntent));</span><br><span class="line">	&#125;catch(err)&#123;</span><br><span class="line">		err.message = filename + &apos;:&apos; + err.message;</span><br><span class="line">		throw err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，Module._extensions会被赋值给 require() 的extensions属性，所以通过在代码中访问require.extensions可知道系统中已有的加载方式。编写代码测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//新建index.js文件</span><br><span class="line">console.log(require.extensions);</span><br><span class="line">//运行node index.js,输出</span><br><span class="line">//[Object: null prototype] &#123; &apos;.js&apos;: [Function], &apos;.json&apos;: [Function], &apos;.node&apos;: [Function] &#125;</span><br></pre></td></tr></table></figure>

<p>如果想对自定义的扩展名进行特殊的加载，可以通过类似require.extensions[‘.ext’]的方式实现。早期的CoffeeScript文件就是通过添加require.extensions[‘.coffee’]扩展方式来加载的。但是从v0.10.6版本开始，官方不鼓励通过这种方式进行自定义扩展名的加载，而是期望先将其它语言或文件先编译成js文件后再进行加载，这样做的好处是不将繁琐的编译加载等过程引入node的执行过程。</p>
<p>在确定文件的扩展名后，node将调用具体的编译方式来将文件执行后返回给调用者。</p>
<p>注：我们都知道CommonJS模块规范中，每个模块文件都存在<code>require、exports、module、_filename、_dirname</code>这5个变量却不知其从何而来。若是把直接定义模块的过程放在浏览器端，势必会存在污染全局变量的情况，故其不可能。</p>
<p>事实上，在编译过程中，node会对获取的js文件内容进行包装，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function(require、exports、module、_filename、_dirname)&#123;</span><br><span class="line">	var math = require(&apos;math&apos;);</span><br><span class="line">	exports.area = function(radius)&#123;</span><br><span class="line">		return Math.PI * radius * radius;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样每个模块文件之间都进行了作用于隔离。包装之后的代码会通过vm原生模块的runInThisContext() 方法执行，类似于eval，只是具有明确上下文，不污染全局，返回一个体的function对象。最后，将当前模块对象的exports属性，require()方法，module(模块对象本身)，以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。</p>
<p>这就是为什么这些变量并没有在每个模块声明却可以使用的原因。在执行后，模块的exports属性被返回给了调用方。exports属性上的任何方法都可以被外部调用到，但是模块中的其余变量和属性则不可直接被调用。</p>
<p>至此，require、exports、module的流程已经完整，这就是Node对CommonJS模块规范的实现。</p>
<p><strong>JSON文件的编译</strong></p>
<p>json文件的编译是三种编译方式中最简单的。Node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse（）方法得到对象，然后将它赋给模块对象的exports，以供外部调用。</p>
<p>JSON文件在用作项目的配置文件时比较有用。如果你定义了JSON文件作为配置，那就不用调用fs模块去异步读取和解析，直接调用require（）引入即可。此外，你还可以享受到模块缓存的便利，并且二次引入时也没有性能影响。</p>
<p>这里我们提到的模块编译都是指文件编译，即用户自己编写的模块。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-webpack学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/12/27/webpack学习/" class="article-date">
      <time datetime="2019-12-27T01:01:57.000Z" itemprop="datePublished">2019-12-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/27/webpack学习/">webpack学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="npm相关"><a href="#npm相关" class="headerlink" title="npm相关"></a>npm相关</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack --save-dev      开发环境下的依赖</span><br></pre></td></tr></table></figure>

<h4 id="运行cnpm-run-dev自动打开"><a href="#运行cnpm-run-dev自动打开" class="headerlink" title="运行cnpm run dev自动打开"></a>运行cnpm run dev自动打开</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//package.json文件</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">	&quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --hot&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="webpack功能"><a href="#webpack功能" class="headerlink" title="webpack功能"></a>webpack功能</h4><ul>
<li>代码转换</li>
<li>文件优化</li>
<li>代码分割</li>
<li>模块合并</li>
<li>自动刷新</li>
<li>代码校验</li>
<li>自动发布</li>
</ul>
<h6 id="loader功能"><a href="#loader功能" class="headerlink" title="loader功能"></a>loader功能</h6><p>loader让webpack能够去处理那些非js文件，（webpack自身只能理解js）。loader能让所有类型的文件转换为webpack能够处理的有效模块，然后就可利用webpack的打包能力对其进行处理。</p>
<p>loader的两大目标：</p>
<ol>
<li>test属性，用于标识出应该被对应的loader进行转换的某个文件。</li>
<li>use属性，表示在转换时，应使用哪个loader。</li>
</ol>
<h4 id="webpack使用"><a href="#webpack使用" class="headerlink" title="webpack使用"></a>webpack使用</h4><ul>
<li>webpack默认只支持js文件</li>
<li>node webpack</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//安装本地的webpack</span><br><span class="line">cnpm i webpack webpack-cli -D</span><br><span class="line">//表示开发依赖</span><br><span class="line">//在命令行上输入webpack即可将入口文件打包</span><br><span class="line">//webpack可以进行0配置</span><br></pre></td></tr></table></figure>

<h6 id="手动配置webpack文件"><a href="#手动配置webpack文件" class="headerlink" title="手动配置webpack文件"></a>手动配置webpack文件</h6><p>webpack配置文件<strong>webpack.config.js</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">	mode: &apos;development&apos;,//模式默认两种，production  development</span><br><span class="line">	entry: path.join(__dirname,&apos;./src/main.js&apos;),</span><br><span class="line">	output: &#123;</span><br><span class="line">		path: path.resolve(__dirname,&apos;dist&apos;),//路径必须是一个绝对路径</span><br><span class="line">		filename: &apos;bundle.js&apos;,//打包后的文件名</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>production：开发的未压缩的文件</p>
<p>development：开发的压缩的文件</p>
<h6 id="更改配置文件名字"><a href="#更改配置文件名字" class="headerlink" title="更改配置文件名字"></a>更改配置文件名字</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在package.json文件中的script对象上</span><br><span class="line">scripts:&#123;</span><br><span class="line">	&quot;builder&quot;: &quot;webpack --config webpack.configmy.js&quot;</span><br><span class="line">&#125;</span><br><span class="line">//命令行上运行 cnpm run builder即可</span><br></pre></td></tr></table></figure>

<h6 id="webpack以本地形式打开文件"><a href="#webpack以本地形式打开文件" class="headerlink" title="webpack以本地形式打开文件"></a>webpack以本地形式打开文件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cnpm i webpack-dev-server -D</span><br><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	devServer:&#123; //开发服务器配置</span><br><span class="line">		port: 3000,  //在3000端口打开</span><br><span class="line">		progress: true,  //显示进度条</span><br><span class="line">		contentBase: &apos;./build&apos;,  //以当前目录运行程序</span><br><span class="line">		compress: true  //启动压缩</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//package.json文件</span><br><span class="line">scripts:&#123;</span><br><span class="line">	&quot;dev&quot;: &quot;webpack-dev-server&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="webpack解析html模块"><a href="#webpack解析html模块" class="headerlink" title="webpack解析html模块"></a>webpack解析html模块</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cnpm i html-webpack-plugin -D</span><br><span class="line">//webpack.config.js</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	output: &#123;</span><br><span class="line">		path: path.resove(__dirname,&apos;./dist&apos;),</span><br><span class="line">		filename: &apos;bundle.[hash].js&apos;,  //每次输出的文件都不同</span><br><span class="line">		//filename: &apos;bundle.[hash:8].js&apos;,  只显示8位hash值 </span><br><span class="line">	&#125;</span><br><span class="line">	plugins: [  //数组 放着所有的webpack插件</span><br><span class="line">		new HtmlWebpackPlugin(&#123;</span><br><span class="line">			template: &apos;./src/index.html&apos;  //以index.html文件为模板</span><br><span class="line">			filename: &apos;index.html&apos;, //打包后的文件名</span><br><span class="line">			minify: &#123;</span><br><span class="line">				removeAttributeQuotes:true,  //压缩时，删除属性中的双引号</span><br><span class="line">				collapseWhiteSpace: true,  //折叠空行，将html文件打包成一行</span><br><span class="line">				</span><br><span class="line">			&#125;,</span><br><span class="line">			hash: true,  //添加哈希戳</span><br><span class="line">		&#125;)</span><br><span class="line">	</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="webpack解析css模块"><a href="#webpack解析css模块" class="headerlink" title="webpack解析css模块"></a>webpack解析css模块</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cnpm i style-loader css-loader -D  //处理css文件</span><br><span class="line">cnpm i less less-loader -D   //less-loader会调用less进行解析</span><br><span class="line">cnpm i node-sass sass-loader -D   //处理sass和scss文件</span><br><span class="line">cnpm i stylus stylus-loader -D   //处理stylus文件</span><br><span class="line"></span><br><span class="line">//main.js文件导入css文件</span><br><span class="line">require(&apos;./index.css&apos;);</span><br><span class="line"></span><br><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	module: &#123; //模块</span><br><span class="line">		rules: [  //规则  css-loader 处理@import这种语法的，将多个css文件合并为一个css文件</span><br><span class="line">		  //style-loader 他是把css插入到head的标签中</span><br><span class="line">		  //loader特点：希望一个loader处理一个功能</span><br><span class="line">		  //只用一个loader用字符串，多个loader用数组,当有参数时可写成对象方式</span><br><span class="line">		  //loader顺序:默认从右向左执行</span><br><span class="line">		  &#123; </span><br><span class="line">		      test: /\.css$/,</span><br><span class="line">              use: [</span><br><span class="line">               &#123;</span><br><span class="line">		  		 loader:&apos;style-loader&apos;,</span><br><span class="line">		  		 options: &#123;</span><br><span class="line">		  		 	insertAt: &apos;top&apos;  //将样式插到head顶部</span><br><span class="line">		  		 &#125;</span><br><span class="line">		 	   &#125;,</span><br><span class="line">		 	   &apos;css-loader&apos;</span><br><span class="line">		 	  ]</span><br><span class="line">		 &#125;,</span><br><span class="line">		 &#123; test: /\.less$/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;] &#125;</span><br><span class="line">		]</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="抽离文件的插件"><a href="#抽离文件的插件" class="headerlink" title="抽离文件的插件"></a>抽离文件的插件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cnpm i mini-css-extract-plugin -D</span><br><span class="line">//专门用于抽离css样式的插件</span><br><span class="line"></span><br><span class="line">//webpack.config.js</span><br><span class="line">let MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line">plugins: [</span><br><span class="line">	new HtmlWebpackPlugin(&#123;</span><br><span class="line">		template: &apos;./src/index.html&apos;,</span><br><span class="line">		filename: &apos;index.html&apos;</span><br><span class="line">	&#125;),</span><br><span class="line">	new MiniCssExtractPlugin(&#123;</span><br><span class="line">		filenmae: &apos;main.css&apos;   //抽离出的名字叫main.css</span><br><span class="line">	&#125;)</span><br><span class="line">],</span><br><span class="line">module: &#123;</span><br><span class="line">	rules:[</span><br><span class="line">		&#123;</span><br><span class="line">		  test:/\.css$/,</span><br><span class="line">		  use: [</span><br><span class="line">		    MiniCssExtractPlugin.loader,</span><br><span class="line">		    &apos;css-loader&apos;    //先解析成css样式，然后使用MiniCssExtractPlugin这个插件的加载器将样式分离成一个main.css文件</span><br><span class="line">		  ]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="自动加前缀的插件"><a href="#自动加前缀的插件" class="headerlink" title="自动加前缀的插件"></a>自动加前缀的插件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cnpm i postcss-loader autoprefixer </span><br><span class="line"></span><br><span class="line">module: &#123;</span><br><span class="line">	rules: [</span><br><span class="line">		&#123;</span><br><span class="line">            test: /\.less$/,</span><br><span class="line">            use:[</span><br><span class="line">				MiniCssExtractPlugin.loader,</span><br><span class="line">				&apos;css-loader&apos;,</span><br><span class="line">				&apos;postcss-loader&apos;,</span><br><span class="line">				&apos;less-loader&apos;</span><br><span class="line">            ]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//新建一个postcss.config.js文件</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	plugins: [require(&apos;autoprefixer&apos;)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="webpack中处理js模块"><a href="#webpack中处理js模块" class="headerlink" title="webpack中处理js模块"></a>webpack中处理js模块</h6><ul>
<li>将es6转为es5</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">cnpm i babel-loader @babel/core @babel/preset-env -D</span><br><span class="line">// @babel/core是babel的核心模块，@babel/preset-env 将高级语法转为低级语法</span><br><span class="line">cnpm i eslint eslint-loader -D  //语法检查</span><br><span class="line"></span><br><span class="line">cnpm i @babel/plugin-proposal-class-properties -D  //像class类这些高级语法</span><br><span class="line"></span><br><span class="line">cnpm i @babel/runtime  @babel/plugin-transform-runtime -D @babel/runtime   //像generator遍历器,在plugins中配置</span><br><span class="line"></span><br><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	module: &#123;</span><br><span class="line">		noParse: /jquery/,  //不去解析jquery中的依赖库</span><br><span class="line">		rules: [</span><br><span class="line">			&#123; test: /\.js$/,</span><br><span class="line">			  use: &#123;</span><br><span class="line">			  	&#123;</span><br><span class="line">                    loader:&apos;babel-loader&apos;,  //用该模块将es6转为es5</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets: [&apos;@babel/preset-env&apos;],</span><br><span class="line">                        plugins: [&apos;@babel/plugin-proposal-class-properties&apos;,&apos;@babel/plugin-transform-runtime&apos;]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      loader: &apos;eslint-loader&apos;, //校验es语法规范</span><br><span class="line">                      options: &#123;</span><br><span class="line">                        enforce: &apos;pre&apos;  //强制先执行，因为loader默认是从下往上执行</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">			  	&#125;</span><br><span class="line">			  &#125;,</span><br><span class="line">			  exclude: /node_modules/,   //不去node_module中找</span><br><span class="line">			  include: path.resolve(__dirname,&apos;src&apos;)  //去src文件夹下找</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="webpack第三方模块的使用"><a href="#webpack第三方模块的使用" class="headerlink" title="webpack第三方模块的使用"></a>webpack第三方模块的使用</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">	resolve: &#123;  //解析第三方包 common</span><br><span class="line">		modules: [path.resolve(&apos;node_modules&apos;)],  //解析时先到该目录下寻找</span><br><span class="line">		alias:&#123; //别名 vue vue.runtime</span><br><span class="line">			bootstrap: &apos;bootstrap/dist/css/bootstrap.css&apos;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cnpm i jquery </span><br><span class="line">cnpm i expose-loader</span><br><span class="line"></span><br><span class="line">//main.js文件</span><br><span class="line">import $ from &apos;jquery&apos;;  //此$不是window上的的$</span><br><span class="line">window.$   //undefined</span><br><span class="line"></span><br><span class="line">import $ from &apos;expose-loader?$!jquery&apos;;</span><br><span class="line">//expose-loader 暴露 全局的loader  内联的loader</span><br><span class="line">//pre 前面执行的loader   normal  普通loader  内联loader  后置 postloader</span><br></pre></td></tr></table></figure>

<p><strong>将$暴露给window的另一种方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cnpm i jquery </span><br><span class="line">cnpm i expose-loader</span><br><span class="line"></span><br><span class="line">//main.js文件</span><br><span class="line">import $ from &apos;jquery&apos;;</span><br><span class="line"></span><br><span class="line">//webpack.config.js文件</span><br><span class="line">module: &#123;</span><br><span class="line">	rules: [</span><br><span class="line">		&#123;</span><br><span class="line">			test:require.resolve(&apos;jquery&apos;),</span><br><span class="line">			use: &apos;expose-loader?$!jquery&apos;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在每个模块中注入$对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js文件</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	plugins: [</span><br><span class="line">		new HtmlWebpackPlugin(&#123;</span><br><span class="line">			template: &apos;./src/index.html&apos;,</span><br><span class="line">			filename: &apos;index.html&apos;</span><br><span class="line">		&#125;),</span><br><span class="line">		new Webpack.ProvidePlugin(&#123;  //在每个模块中注入$</span><br><span class="line">			$: &apos;jquery&apos;</span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//main.js文件</span><br><span class="line">import $ from &apos;jquery&apos;   //运行npm run build时会将jquery打包</span><br><span class="line"></span><br><span class="line">//不像将jquery打包，只需在webpack.config.js文件中</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	externals: &#123;</span><br><span class="line">		jquery: &apos;$&apos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="webpack打包图片"><a href="#webpack打包图片" class="headerlink" title="webpack打包图片"></a>webpack打包图片</h6><ol>
<li>在js中创建图片</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cnpm i file-loader -D  </span><br><span class="line">//file-loader默认会在内部生成一张图片到dist文件夹下，并把生成的图片的名字返回回来</span><br><span class="line"></span><br><span class="line">//main.js文件</span><br><span class="line">import logo from &apos;./logo.png&apos;;</span><br><span class="line">//把图片引入，返回结果是一个新的图片地址</span><br><span class="line">let image = new Image();</span><br><span class="line">image.src = logo;  //就是一个普通的字符串</span><br><span class="line">document.body.appendChildren(image)</span><br><span class="line"></span><br><span class="line">//webpack.config.js文件</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	module: &#123;</span><br><span class="line">		rules: [</span><br><span class="line">			&#123; test: /\.(png|jpg|gif)$/, use: &apos;fle-loader&apos; &#125;,</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在css引入background(‘url’)</p>
</li>
<li><p>使用标签<img src alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cnpm i html-withimg-loader -D</span><br><span class="line">cnpm i url-loader -D</span><br><span class="line">//在html文件中引入image，但是路径不在打包目录中的路径中</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	module: &#123;</span><br><span class="line">		rules: [</span><br><span class="line">			&#123;test: /\.html$/, use: &apos;html-withimg-loader&apos;&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				test: /\.(png|jpg|gif)$/,</span><br><span class="line">				//做一个限制，当图片小于多少k时用base64来转化</span><br><span class="line">				//否则用file-loader产生真实的图片</span><br><span class="line">				use: &#123;</span><br><span class="line">					loader: &apos;url-loader&apos;,</span><br><span class="line">					options: &#123;</span><br><span class="line">						limit: 200*1024,</span><br><span class="line">						outputPath: &apos;/img/&apos;  //输出路径放置在img目录下</span><br><span class="line">						publicPath: &apos;http://www.chenchuyin.com&apos;  //统一给图片加上该域名</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="webpack有多入口文件"><a href="#webpack有多入口文件" class="headerlink" title="webpack有多入口文件"></a>webpack有多入口文件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cnpm i html-webpack-plugin - D</span><br><span class="line">cnpm i @babel/core @babel/preset-dev @babel-loadedr @webpack-dev-server -D</span><br><span class="line">//webpack.config.js文件</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	//源码映射  会单独生成一个sourcemap文件，出错了胡hi标识当前出错的列和行</span><br><span class="line">	devtool: &apos;source-map&apos;,  //增加映射文件 可以帮我们调试源代码</span><br><span class="line">	//多入口</span><br><span class="line">	entry: &#123;</span><br><span class="line">		home: &apos;./src/index.js&apos;,</span><br><span class="line">		other: &apos;./src/other.js&apos;</span><br><span class="line">	&#125;,</span><br><span class="line">	output: &#123;</span><br><span class="line">		//[name]表示 home 和 other  [hash]添加哈希戳</span><br><span class="line">		filename: &apos;[name].[hash].js&apos;,</span><br><span class="line">		path: path.resolve(__dirname,&apos;dist&apos;)</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		//若无chunks，会把两个js文件都引入到index.html和other.html文件中</span><br><span class="line">		new HtmlWebpackPlugin(&#123;</span><br><span class="line">			tempalte: &apos;./index.html&apos;,</span><br><span class="line">			filename: &apos;index.html&apos;,</span><br><span class="line">			chunks: [&apos;index&apos;]  //index.html文件引入index.js文件</span><br><span class="line">		&#125;),</span><br><span class="line">		new HtmlWebpackPlugin(&#123;</span><br><span class="line">			tempalte: &apos;./other.html&apos;,</span><br><span class="line">			filename: &apos;other.html&apos;,</span><br><span class="line">			chunks: [&apos;other&apos;，&apos;index&apos;]   //other.html文件引入other.js和index.js文件</span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>不会产生单独文件，但是可以显示行和列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtol:&apos;eval-source-map&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不会产生列，但是是一个单独的映射文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtoole: &apos;cheap-module-source-map&apos;  //产生后你可以保存起来</span><br></pre></td></tr></table></figure>
</li>
<li><p>不会产生文件，集成在打包后的文件中，不会产生列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtoole: &apos;cheap-module-eval-source-map&apos;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="自动打包出实体文件"><a href="#自动打包出实体文件" class="headerlink" title="自动打包出实体文件"></a>自动打包出实体文件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">	watch: true,  //监听文件，只要文件有所修改便直接生成新的实体文件</span><br><span class="line">	watchOptions:&#123;  //监控选项</span><br><span class="line">		poll: 1000,  //每秒 查看文件是否更改 1000次</span><br><span class="line">		aggreatement: 500,  //防抖 如果一直输入代码，则每过500次再生成实体文件</span><br><span class="line">		ignored: /node_modules/  //不需要进行监控的文件</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="webpack小插件"><a href="#webpack小插件" class="headerlink" title="webpack小插件"></a>webpack小插件</h6><ol>
<li>cleanWebpackPlugin</li>
<li>copyWebpackPlugin</li>
<li>bannerPlugin（内置的，不需要安装该模块）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cnpm i clean-webpack-plugin copy-webpack-plugin webpack -D</span><br><span class="line"></span><br><span class="line">const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)</span><br><span class="line">const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line">plugins: [</span><br><span class="line">	new CleanWebpackPlugin(&apos;./dist&apos;),   //打包之前先将dist目录清除</span><br><span class="line">	new CopyWebpackPlugin(</span><br><span class="line">		&#123;from: &apos;doc&apos;, to: &apos;./&apos;&#125;  //将doc.txt文件复制到输出的根目录下</span><br><span class="line">	),</span><br><span class="line">	new webpack.BannerPlugin(&apos;make 2019 by chenchuyin&apos;)</span><br><span class="line">	//会将这句话插入到出口js文件的开头部分</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h6 id="webpack实现跨域功能"><a href="#webpack实现跨域功能" class="headerlink" title="webpack实现跨域功能"></a>webpack实现跨域功能</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//webpack-dev-server默认打开localhost:8080,若想访问3000端口，可使用代理</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	devServer:&#123;</span><br><span class="line">		proxy: &#123;  //重写的方式 把请求代理到express服务器上</span><br><span class="line">			//  &apos;/api&apos;: &apos;http://localhost:3000&apos;,   //配置了一个代理</span><br><span class="line">			&apos;api&apos;: &#123;</span><br><span class="line">				target: &apos;http://localhost:3000&apos;,</span><br><span class="line">				pathRewrute: &#123;&apos;api&apos;: &apos;&apos;&#125;  </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//server.js文件</span><br><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line">let app = express();</span><br><span class="line">app.get(&apos;/user&apos;, (req,res) =&gt; &#123;</span><br><span class="line">	res.json(&#123;name:&apos;陈楚吟&apos;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000);</span><br><span class="line"></span><br><span class="line">//index.js文件</span><br><span class="line">let xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;GET&apos;,&apos;/api/user&apos;,true);  //请求还是有api目录，显示时将其删除</span><br><span class="line">xhr.onload = function()&#123;</span><br><span class="line">	console.log(xhr.response);</span><br><span class="line">&#125;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line"> //我们前端只想单纯模拟数据</span><br><span class="line"> before(app)&#123;</span><br><span class="line"> 	app.get(&apos;/user&apos;, (req,res) =&gt; &#123;</span><br><span class="line"> 		res.json(&#123;name: &apos;陈楚吟&apos;&#125;)</span><br><span class="line"> 	&#125;)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//server.js文件</span><br><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line">let app = express();</span><br><span class="line">app.listen(3000);</span><br><span class="line"></span><br><span class="line">//index.js文件</span><br><span class="line">let xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;GET&apos;,&apos;/api/user&apos;,true);  //请求还是有api目录，显示时将其删除</span><br><span class="line">xhr.onload = function()&#123;</span><br><span class="line">	console.log(xhr.response);</span><br><span class="line">&#125;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cnpm i webpack-dev-middleware -D</span><br><span class="line"></span><br><span class="line">devServer:&#123;</span><br><span class="line"> //有服务端，不用代理来处理，在服务端中启动webpack端口用服务端端口（即前端页面和服务器在同一个端口）</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//server.js文件</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">//中间件</span><br><span class="line">let middle = require(&apos;webpack-dev-middleware&apos;);</span><br><span class="line">let config = require(&apos;./webpack.config.js&apos;);</span><br><span class="line">let compiler = webpack(config);</span><br><span class="line">app.use(middle(compiler));</span><br><span class="line">app.get(&apos;/user&apos;, (req,res) =&gt; &#123;</span><br><span class="line">	res.json(&#123;name:&apos;陈楚吟&apos;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>

<h6 id="实现多线程打包"><a href="#实现多线程打包" class="headerlink" title="实现多线程打包"></a>实现多线程打包</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">cnpm i happypack</span><br><span class="line">//模块happypack可以实现多线程来打包进程</span><br><span class="line">let Happypack = require(&apos;happypack&apos;)</span><br><span class="line">module: &#123;</span><br><span class="line">	rules: [</span><br><span class="line">		&#123;</span><br><span class="line">			test: /\.js$/,</span><br><span class="line">			exclude: /node_modules/,</span><br><span class="line">			include: &apos;src&apos;,</span><br><span class="line">			use: &apos;Happypack/loader?id=js&apos;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			test: /\.css$/,</span><br><span class="line">			use: &apos;Happypack/loader?id=css&apos;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;,</span><br><span class="line">palugins: [</span><br><span class="line">	new Happypack(&#123;</span><br><span class="line">		id: &apos;css&apos;,</span><br><span class="line">		use: [&apos;style-loader&apos;,&apos;css-loader&apos;]</span><br><span class="line">	&#125;)</span><br><span class="line">	new Happypack(&#123;</span><br><span class="line">		id: &apos;js&apos;,</span><br><span class="line">		use: [&#123;</span><br><span class="line">			loader:&apos;babel-loader&apos;,</span><br><span class="line">			options: &#123;</span><br><span class="line">				presets: [</span><br><span class="line">					&apos;@babel/preset-env&apos;,</span><br><span class="line">					&apos;@babel/preset-react&apos;</span><br><span class="line">				]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h6 id="webpack自带优化"><a href="#webpack自带优化" class="headerlink" title="webpack自带优化"></a>webpack自带优化</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//import 在生成环境下会自动去除没用的代码</span><br><span class="line">//因tree-shaking方法会将没用到的代码自动删除掉·</span><br><span class="line"></span><br><span class="line">//require（es6）模块会把结果都放到default上</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123; </span><br><span class="line">	optimization: &#123;  //将公共部分抽离出来</span><br><span class="line">		splitChunks: &#123;   //分割代码块</span><br><span class="line">			cacheGrounps:&#123; //缓存组</span><br><span class="line">				common:&#123; //公共的模块</span><br><span class="line">					chunks: &apos;initial&apos;,  //代码在刚开始时就被抽离出</span><br><span class="line">					minSize: 0,  //代码有多少字节才被抽离</span><br><span class="line">					minChunks: 2   //代码块被使用多少次才被抽离</span><br><span class="line">				&#125;,</span><br><span class="line">				vendor:&#123;</span><br><span class="line">					priority: 1,  //抽离权重，较大的先抽离</span><br><span class="line">					test: /node_modules/,  //将第三方模块抽离出来</span><br><span class="line">					chunks: &apos;initial&apos;,  </span><br><span class="line">                    minSize: 0,  </span><br><span class="line">                     minChunks: 2 </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="webpack懒加载"><a href="#webpack懒加载" class="headerlink" title="webpack懒加载"></a>webpack懒加载</h6><ul>
<li>vue和react的懒加载其实都是通过import实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">let button = document.createElement(&apos;button&apos;)</span><br><span class="line">button.innerHTML = &apos;hello&apos;;</span><br><span class="line">button.addEventListener(&apos;click&apos;,function()&#123;</span><br><span class="line">	//import 是草案中的语法，由jsonp实现动态加载文件</span><br><span class="line">	//返回值是一个1promise对象</span><br><span class="line">	import(&apos;./source.js&apos;).then(data =&gt; &#123;</span><br><span class="line">		console.log(data.default);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="webpack热更新"><a href="#webpack热更新" class="headerlink" title="webpack热更新"></a>webpack热更新</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">	devServer: &#123;</span><br><span class="line">		hot: true,  //启动热更新操作</span><br><span class="line">		port: 3000</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: [</span><br><span class="line">		new webpack.NameModulesPlugin(),  //告诉我们哪个模块热更新</span><br><span class="line">		new webpack.HotModuleReplacementPlugin()  //热更新插件</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//index.js文件</span><br><span class="line">import str from &apos;./source&apos;;</span><br><span class="line">if(module.hot)&#123;</span><br><span class="line">	module.hot.accept(&apos;./source&apos;, () =&gt; &#123;</span><br><span class="line">		require(&apos;./source&apos;);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h6><ul>
<li>webpack本质上是一种事件流机制，它的工作流程是将各个插件串联起来，而实现这一切的核心是Tapable，Tapable是有点类似于nodeJs的events库，核心原理也是依赖于发布订阅模式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="webpack中使用vue"><a href="#webpack中使用vue" class="headerlink" title="webpack中使用vue"></a>webpack中使用vue</h6><p><strong>在普通网页中使用vue</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//1.使用script标签，引入vue的包   (此包功能较全)</span><br><span class="line">&lt;scrpit src=&quot;./lib/vue.js&quot;&gt;&lt;/srcipt&gt;</span><br><span class="line"></span><br><span class="line">//2.在index页面中，创建一个id为app的div容器</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//3.通过new Vue得到一个vm实例</span><br><span class="line">let vm = new Vue(&#123;</span><br><span class="line">	el: &apos;#app&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>在webpack中尝试使用vue</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//注意：在webpack中，使用import Vue from &apos;vue&apos; 导入的Vue构造函数功能不完整，只提供了runtime-only的形式，并无提供像网页中那样的使用方式；</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">let vm = new Vue(&#123;</span><br><span class="line">	el: &apos;#app&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">解决：指定完整vue.js文件的路径</span><br><span class="line">方式一：import Vue from &apos;./node_modules/vue/dist/vue.js&apos;;</span><br><span class="line">方式二：import vue from &apos;vue&apos;</span><br><span class="line">在webpack.config.js文件中</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	resolve: &#123;</span><br><span class="line">		alias: &#123;  //修改vue时被导入时包的路径</span><br><span class="line">			&quot;vue$&quot;: &quot;vue/dist/vue.js&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cnpm i vue -S</span><br><span class="line">cnpm i vue-loader vue-template-compiler -D</span><br><span class="line"></span><br><span class="line">//webpack.config.js文件</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &quot;development&quot;,</span><br><span class="line">    entry: &apos;./src/index.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname,&apos;./dist&apos;),</span><br><span class="line">        filename: &apos;bundle.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: &apos;./src/index.html&apos;,</span><br><span class="line">            filename: &apos;index.html&apos;</span><br><span class="line">        &#125;),</span><br><span class="line">        new VueLoaderPlugin()</span><br><span class="line">    ],</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123; test: /\.css/, use: [&apos;style-loader&apos;,&apos;css-loader&apos;] &#125;,</span><br><span class="line">            &#123; test: /\.vue/, use: &apos;vue-loader&apos; &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.安装 vue 包，cnpm i vue -S</span><br><span class="line">2.由于在webpack中推荐使用vue组件模板文件定义组件，故需要安装能解析这种文件的loader    cnpm i vue-loader vue-template-compiler -D</span><br><span class="line">3.在main.js中导入vue模块， import Vue from &apos;vue&apos;</span><br><span class="line">4.定义.vue结尾的组件，由三部分组成：template script  style</span><br><span class="line">5.使用import login from &apos;./login.vue&apos;导入这个组件</span><br><span class="line">6.创建vm实例 let vm = new Vue(&#123; el: &apos;#app&apos;, render: c =&gt; c(login) &#125;)</span><br><span class="line">7.在页面创建一个id为app的div元素，作为我们vm实例要控制的区域；</span><br></pre></td></tr></table></figure>

<p>注意：App这个组件是通过vm实例的render函数渲染出来的，render函数如果要渲染组件，渲染出来的组件只能放到el：‘#app’ 所指定的元素中。</p>
<p>Account和Goodlist组件是通过路由配置监听到的，所以这两个组件只能展示到属于路由的<router-view></router-view>中去。</p>
<h6 id="包的查找规则"><a href="#包的查找规则" class="headerlink" title="包的查找规则"></a>包的查找规则</h6><p><strong>找vue文件</strong></p>
<ol>
<li>找项目根目录中有没有 node_modules 的文件夹</li>
<li>在node_modules中根据包名找对应的vue文件夹</li>
<li>在vue文件夹中，找一个叫package.json 的包配置文件</li>
<li>在 package.json 文件中，查找一个main 属性【main属性指定了这个包在被加载时的入口文件】</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//sf-pack.js文件</span><br><span class="line">//需要找到当前执行命令的路径，拿到webpack.config.json</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">//config配置文件</span><br><span class="line">let config = require(path.resolve(&apos;webpack.config.js&apos;));</span><br><span class="line"></span><br><span class="line">let Compiler = require(&apos;../lib/Compiler.js&apos;);</span><br><span class="line">let compiler = new Compiler(config);</span><br><span class="line">//标识运行编译</span><br><span class="line">compiler.run();</span><br><span class="line"></span><br><span class="line">//Compiler.js文件</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">class Compiler&#123;</span><br><span class="line">	constructor(config)&#123;</span><br><span class="line">		//entry  output</span><br><span class="line">		this.config = config;</span><br><span class="line">		//需要保存入口文件的路径</span><br><span class="line">		this.entryId;    //&apos;./src/index.js&apos;</span><br><span class="line">		//需要保存所有模块依赖</span><br><span class="line">		this.modules = &#123;&#125;;</span><br><span class="line">		this.entry = config.entry;  //入口路径</span><br><span class="line">		//工作路径</span><br><span class="line">		this.root = process.cwd();</span><br><span class="line">	&#125;</span><br><span class="line">	getSource(modulePath)&#123;</span><br><span class="line">		let content = fs.readFileSync(modulePath,&apos;utf-8&apos;);</span><br><span class="line">		return content;</span><br><span class="line">	&#125;</span><br><span class="line">	//构建模块</span><br><span class="line">	buildModule(modulePath,isEntry)&#123;</span><br><span class="line">		//拿到模块内容</span><br><span class="line">		let source = this.getSource(modulePath);</span><br><span class="line">		//模块id  modulePath = modulePath - this.root;</span><br><span class="line">		let modulePath = &apos;./&apos; +  path.relative(this.root,modulePath);</span><br><span class="line">	&#125;</span><br><span class="line">	run()&#123;</span><br><span class="line">		//执行并且创建模块的依赖关系</span><br><span class="line">		this.buildModule(path.resolve(this.root,this.entry),true);</span><br><span class="line">		//true表示为主模块</span><br><span class="line">		//发射一个文件，该文件即为打包后的文件</span><br><span class="line">		this.emitFile();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = Compiler</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-攻克object对象" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/15/攻克object对象/" class="article-date">
      <time datetime="2019-11-15T13:32:33.000Z" itemprop="datePublished">2019-11-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/15/攻克object对象/">攻克object对象</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><ul>
<li>Object构造函数创建一个对象包装器。如果给定值是null或undefined，将返回一个空对象</li>
</ul>
<h4 id="改变原型链的方法"><a href="#改变原型链的方法" class="headerlink" title="改变原型链的方法"></a>改变原型链的方法</h4><p>几乎所有的js对象都是Object的实例；一个典型的对象继承Object.prototype的属性及方法。改变Object原型会通过原型链改变所有对象。</p>
<ul>
<li>Object.create(null)创建的对象</li>
<li>Object.setPrototypeOf()</li>
<li><code>obj.__proto__</code> = 原型对象</li>
</ul>
<h4 id="Object构造函数的属性"><a href="#Object构造函数的属性" class="headerlink" title="Object构造函数的属性"></a>Object构造函数的属性</h4><ul>
<li><p>Object.length         //值为1</p>
</li>
<li><p>Object.prototype ：可以为所有Object类型的对象添加属性（现在一般用class类代替）</p>
<ul>
<li><strong>Object.prototype.constructor</strong><ul>
<li>返回创建实例对象的Object构造函数的引用（new 关键字后面的值）；注意，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。对原始类型来说，如<code>1</code>，<code>true</code>和<code>&quot;test&quot;</code>，该值只可读。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">arr.constructor  //Array</span><br><span class="line">var obj = new zhuTou()    </span><br><span class="line">obj.constrctor    //zhuTou</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="Object构造函数的方法"><a href="#Object构造函数的方法" class="headerlink" title="Object构造函数的方法"></a>Object构造函数的方法</h4><h6 id="Object-assign-复制"><a href="#Object-assign-复制" class="headerlink" title="Object.assign()复制"></a>Object.assign()复制</h6><p><strong>Object.assign( targetObj, obj1,obj2,…)</strong></p>
<ul>
<li>将obj1，obj2等对象里的自身属性且为可枚举属性复制到targetObj对象上，属于浅拷贝。</li>
<li>若有相同属性，则targetObj里的属性会被覆盖。</li>
<li>返回值是一个与targetObj一样的对象，两者绝对相等。</li>
<li>Deep Clone  <code>let obj3 = JSON.parse(JSON.stringify(obj1));</code>   obj1与obj3更改属性值互不影响。</li>
<li>可拷贝symbol类型属性，继承属性和不可枚举属性不能被拷贝。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let targetObj = &#123;name:&apos;targetObj&apos;&#125;</span><br><span class="line">let obj1 = Object.create(&#123;foo:1&#125;,&#123;</span><br><span class="line">    bar1:&#123;</span><br><span class="line">   	 value:1   //bar是一个不可枚举属性</span><br><span class="line">    &#125;，</span><br><span class="line">    bar2:&#123;</span><br><span class="line">    	value:2,</span><br><span class="line">    	enumerable:true  //bar2是个自身可枚举属性</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">let obj2 = &#123; [Symbol(&apos;foo&apos;)]:2,name:&apos;obj1&apos; &#125;;</span><br><span class="line">let </span><br><span class="line">let obj = Object.assign(targetObject,obj1,obj2)</span><br><span class="line">&#123;</span><br><span class="line">	name:&apos;obj1&apos;,     //后来居上，覆盖targetObj里的值</span><br><span class="line">	[Symbol(&apos;foo&apos;)]:2,   //可拷贝symbol类型属性</span><br><span class="line">	bar2 : 2,        //bar1不可枚举，bar2指定可枚举</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原始类型会被包装成对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const v1 = &quot;abc&quot;;</span><br><span class="line">const v2 = true;</span><br><span class="line">const v3 = 10;</span><br><span class="line">const v4 = Symbol(&quot;foo&quot;)</span><br><span class="line"></span><br><span class="line">const obj = Object.assign(&#123;&#125;, v1, null, v2, undefined, v3, v4); </span><br><span class="line">// 原始类型会被包装，null 和 undefined 会被忽略。</span><br><span class="line">// 注意，只有字符串的包装对象才可能有自身可枚举属性。</span><br><span class="line">console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>异常会打断后续拷贝任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const target = Object.defineProperty(&#123;&#125;, &quot;foo&quot;, &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    writable: false</span><br><span class="line">&#125;); // target 的 foo 属性是个只读属性。</span><br><span class="line"></span><br><span class="line">Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);</span><br><span class="line">// TypeError: &quot;foo&quot; is read-only</span><br><span class="line">// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</span><br><span class="line"></span><br><span class="line">console.log(target.bar);  // 2，说明第一个源对象拷贝成功了。</span><br><span class="line">console.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。</span><br><span class="line">console.log(target.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span><br><span class="line">console.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span><br><span class="line">console.log(target.baz);  // undefined，第三个源对象更是不会被拷贝到的。</span><br></pre></td></tr></table></figure>

<ul>
<li>异常会打断后续拷贝任务。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//以下函数会拷贝所有自有属性的属性描述符</span><br><span class="line">function completeAssign(target,...sources)&#123;</span><br><span class="line">	sources.forEach(source =&gt; &#123;</span><br><span class="line">		let descritors = Object.keys(source).reduce( (descriptors,key) =&gt; &#123;</span><br><span class="line">			descriptors[key] = Object.getOwnPropertyDescriptor(source,key);</span><br><span class="line">			return descriptors;</span><br><span class="line">		&#125;,&#123;&#125;);</span><br><span class="line">		//Object.assign默认也会拷贝可枚举的Symbols</span><br><span class="line">		object.getOwnPropertySymbols(source).forEach( sym =&gt; &#123;</span><br><span class="line">		  let descriptor = Object.getOwnPropertyDescriptor(source,sym);</span><br><span class="line">		  if(descriptor.enumerable)&#123;</span><br><span class="line">		  	descriptors[sym] = descriptor;</span><br><span class="line">		  &#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		Object.defineProperties(target,descriptors);</span><br><span class="line">	&#125;);</span><br><span class="line">	return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>此<a href="https://developer.mozilla.org/en-US/docs/Glossary/Polyfill" target="_blank" rel="noopener">polyfill</a>不支持 symbol 属性，因为ES5 中根本没有 symbol ：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">if (typeof Object.assign != &apos;function&apos;) &#123;</span><br><span class="line">  // Must be writable: true, enumerable: false, configurable: true</span><br><span class="line">  Object.defineProperty(Object, &quot;assign&quot;, &#123;</span><br><span class="line">    value: function assign(target, varArgs) &#123; // .length of function is 2</span><br><span class="line">      &apos;use strict&apos;;</span><br><span class="line">      if (target == null) &#123; // TypeError if undefined or null</span><br><span class="line">        throw new TypeError(&apos;Cannot convert undefined or null to object&apos;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      let to = Object(target);</span><br><span class="line"></span><br><span class="line">      for (var index = 1; index &lt; arguments.length; index++) &#123;</span><br><span class="line">        var nextSource = arguments[index];</span><br><span class="line"></span><br><span class="line">        if (nextSource != null) &#123; // Skip over if undefined or null</span><br><span class="line">          for (let nextKey in nextSource) &#123;</span><br><span class="line">            // Avoid bugs when hasOwnProperty is shadowed</span><br><span class="line">            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) &#123;</span><br><span class="line">              to[nextKey] = nextSource[nextKey];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return to;</span><br><span class="line">    &#125;,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Object-create-继承"><a href="#Object-create-继承" class="headerlink" title="Object.create()继承"></a>Object.create()继承</h6><ul>
<li><p>Object(proto[,propertiesObject])：实现类式继承</p>
<ul>
<li>proto：新创建的原型对象。</li>
<li>propertiesObject：未指定为undefined，要添加到新创建对象的可枚举属性（不是其原型链上的枚举属性，而是自定义属性）对象的属性描述符以及相应的属性名称。若为null或非原始包装对象抛出TypeError异常。</li>
<li>返回一个带着指定原型对象和属性的新对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Shape()&#123;	//父类</span><br><span class="line">  this.x = 0;</span><br><span class="line">  this.y = 0;</span><br><span class="line">&#125;</span><br><span class="line">Shape.prototype.move = function(x,y)&#123;</span><br><span class="line">  this.x += x;</span><br><span class="line">  this.y += y;</span><br><span class="line">  console.log(this,&apos;shape moved&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">function Rectangle()&#123;</span><br><span class="line">  Shape.call(this);</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype = Object.create(Shape.prototype);</span><br><span class="line">Rectangle.prototype.constructor = Rectangle;//没有这句，输出的this指向父类Shape</span><br><span class="line">var rect = new Rectangle();</span><br><span class="line">console.log(rect instanceof Rectangle);</span><br><span class="line">console.log(rect instanceof Shape);</span><br><span class="line">rect.move();</span><br><span class="line">//true</span><br><span class="line">//true</span><br><span class="line">//Rectangle &#123; x: NaN, y: NaN &#125; &apos;shape moved&apos;</span><br></pre></td></tr></table></figure>

<ul>
<li>继承多个对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function MyClass()&#123;</span><br><span class="line">	SuperClass.call(this);</span><br><span class="line">	otherSuperClass.call(this);</span><br><span class="line">&#125;</span><br><span class="line">//继承一个类</span><br><span class="line">MyClass.prototype = Object.create(SuperClass.prototype);</span><br><span class="line">//混合其他</span><br><span class="line">Object.assign(MyClass.prototype,OtherSuperclass.prototype);</span><br><span class="line">//重新指定constructor</span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">var o;</span><br><span class="line">// 创建一个原型为null的空对象</span><br><span class="line">o = Object.create(null);</span><br><span class="line"></span><br><span class="line">o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 以字面量方式创建的空对象就相当于:</span><br><span class="line">o = Object.create(Object.prototype);</span><br><span class="line">o = Object.create(Object.prototype, &#123;</span><br><span class="line">  // foo会成为所创建对象的数据属性</span><br><span class="line">  foo: &#123; </span><br><span class="line">    writable:true,</span><br><span class="line">    configurable:true,</span><br><span class="line">    value: &quot;hello&quot; </span><br><span class="line">  &#125;,</span><br><span class="line">  // bar会成为所创建对象的访问器属性</span><br><span class="line">  bar: &#123;</span><br><span class="line">    configurable: false,</span><br><span class="line">    get: function() &#123; return 10 &#125;,</span><br><span class="line">    set: function(value) &#123;</span><br><span class="line">      console.log(&quot;Setting `o.bar` to&quot;, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Constructor()&#123;&#125;</span><br><span class="line">o = new Constructor();</span><br><span class="line">// 上面的一句就相当于:</span><br><span class="line">o = Object.create(Constructor.prototype);</span><br><span class="line">// 当然,如果在Constructor函数中有一些初始化代码,Object.create不能执行那些代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 创建一个以另一个空对象为原型,且拥有一个属性p的对象</span><br><span class="line">o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;)</span><br><span class="line"></span><br><span class="line">// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:</span><br><span class="line">o.p = 24</span><br><span class="line">o.p</span><br><span class="line">//42</span><br><span class="line"></span><br><span class="line">o.q = 12</span><br><span class="line">for (var prop in o) &#123;</span><br><span class="line">   console.log(prop)</span><br><span class="line">&#125;</span><br><span class="line">//&quot;q&quot;</span><br><span class="line"></span><br><span class="line">delete o.p</span><br><span class="line">//false</span><br><span class="line"></span><br><span class="line">//创建一个可写的,可枚举的,可配置的属性p</span><br><span class="line">o2 = Object.create(&#123;&#125;, &#123;</span><br><span class="line">  p: &#123;</span><br><span class="line">    value: 42, </span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true </span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties()"></a>Object.defineProperties()</h6><ul>
<li>Object.defineProperties(obj,props):在对象obj上定义或修改现有属性，并返回该对象obj</li>
<li>props：要定义的其可枚举属性或修改的属性描述符对象。对象上存在的属性描述符主要有两种：数据描述符（有值的属性，该值可写，也可能不可写）和访问器描述符。描述符具有以下键：<ul>
<li>configurable：默认为false。描述属性能否被修改或删除，一旦定义值后不可修改，否则会抛出错误。但是删除configurable属性值为false的属性值nothing happen，也不会报错。</li>
<li>enumerable：默认为false。能否使用<strong>for…in循环和Object.keys()</strong>，是否可枚举。</li>
<li>value：默认undefined。可为任何有效js值。</li>
<li>writable：默认false。是否可重写。</li>
<li>get：默认undefined。作为函数的getter函数，若无getter函数则为undefined。</li>
<li>set：与get同理。</li>
</ul>
</li>
</ul>
<h6 id="object-defineProperty"><a href="#object-defineProperty" class="headerlink" title="object.defineProperty()"></a>object.defineProperty()</h6><ul>
<li>Object.defineProperty(obj,prop,descriptor):返回被传递给函数的对象，即obj，该方法式定义key为Symbol的属性的方法之一。</li>
<li>通过简单赋值操作的普通属性可delete，<strong>通过该方法定义的属性值不能修改</strong>。</li>
<li>如果一个描述符不具有value,writable,get 和 set 任意一个关键字，那么它将被认为是一个数据描述符。如果一个描述符同时有(value或writable)和(get或set)关键字，将会产生一个异常。</li>
<li>如果某些属性是继承来的，需要先冻结Object.prototype，明确指定所有属性，或通过Object.create(nill)将<code>__proto__</code>属性指向null。var des</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//使用__proto__</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var descriptor = Object.create(null);//没有继承的属性</span><br><span class="line">//默认没有enumerable，没有configurable，没有writable</span><br><span class="line">descriptor.value=&quot;static&quot;;</span><br><span class="line">Object.defineProperty(obj,&quot;key&quot;,descriptor);</span><br><span class="line"></span><br><span class="line">//显式定义</span><br><span class="line">Object.defineProperty(obj,&quot;key&quot;,&#123;</span><br><span class="line">	enumerable:false,</span><br><span class="line">	confingurable:false,</span><br><span class="line">	writable:false,</span><br><span class="line">	value:&apos;static&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//循环使用同一个对象</span><br><span class="line">function withValue(value)&#123;</span><br><span class="line">	var d = withValue.d || (</span><br><span class="line">		withValue.d = &#123;</span><br><span class="line">			enumerable:false,</span><br><span class="line">			configurable:false,</span><br><span class="line">			writable:false,</span><br><span class="line">			value:null</span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line">	d.value = value;</span><br><span class="line">	return d;</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(obj,&quot;key&quot;,withValue(&quot;static&quot;));</span><br><span class="line"></span><br><span class="line">//如果freeze可用，防止代码添加或删除对象圆形的属性</span><br><span class="line">(Object.freeze || object)(Object.prototype);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果对象中不存在指定的属性，<code>Object.defineProperty()</code>就创建这个属性。当描述符中省略某些字段时，这些字段将使用它们的默认值。拥有布尔值的字段的默认值都是<code>false</code>。<code>value</code>，<code>get</code>和<code>set</code>字段的默认值为<code>undefined</code>。一个没有<code>get/set/value/writable</code>定义的属性被称为“通用的”，并被“键入”为一个数据描述符。</li>
<li>如果访问者的属性是被继承的，它的get和set方法会在子对象的属性被修改或访问时调用。如果这些方法用一个变量存值，该值会被所有对象共享。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function myClass()&#123;&#125;</span><br><span class="line">var value;</span><br><span class="line">myClass.prototype.x = 2;</span><br><span class="line">Object.defineProperty(myClass.prototype,&quot;x&quot;,&#123;</span><br><span class="line">	get()&#123; return value; &#125;,</span><br><span class="line">	set(x)&#123; value = x; &#125;</span><br><span class="line">&#125;);</span><br><span class="line">var a = new myClass();</span><br><span class="line">var b = new myClass();</span><br><span class="line">a.x = 1;</span><br><span class="line">b.x   //1</span><br><span class="line">myClass.prototype.x   //2   实例上的x与原型上的x不同，更改实例上的值不影响原型上的值</span><br></pre></td></tr></table></figure>

<ul>
<li>这可通过将值存入另一个属性中解决，在get或set中，this指向某个被访问的被访问和修改属性的对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function myClass()&#123;&#125;</span><br><span class="line">Object.defineProperty(myClass.prototype,&quot;x&quot;,&#123;</span><br><span class="line">	get()&#123; return this.stored_x; &#125;,</span><br><span class="line">	set(x)&#123; this._stored_x = x; &#125;</span><br><span class="line">&#125;);</span><br><span class="line">myClass.prototype.x = 1;</span><br><span class="line">Object.defineProperty(myClass.prototype,&quot;y&quot;,&#123;</span><br><span class="line">	writable:false,</span><br><span class="line">	value:&quot;y&quot;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var a = new myClass();</span><br><span class="line">var b = new myClass();</span><br><span class="line">a.x = 2;</span><br><span class="line">b.x    //undefined</span><br></pre></td></tr></table></figure>

<h6 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h6><ul>
<li>Object.entries(obj)：返回一个给定对象<strong>自身可枚举属性的键值对数组</strong>，其排列顺序与<strong>for…in循环（会遍历原型链上的可枚举属性</strong>）返回顺序相同。如果是类数组则按数字键从小到大排列。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;</span><br><span class="line">console.log(Object.entries(obj)); // [ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42] ]</span><br><span class="line"></span><br><span class="line">// array like object</span><br><span class="line">const obj = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; &#125;;</span><br><span class="line">console.log(Object.entries(obj)); // [ [&apos;0&apos;, &apos;a&apos;], [&apos;1&apos;, &apos;b&apos;], [&apos;2&apos;, &apos;c&apos;] ]</span><br><span class="line"></span><br><span class="line">// array like object with random key ordering</span><br><span class="line">const anObj = &#123; 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; &#125;;</span><br><span class="line">console.log(Object.entries(anObj)); // [ [&apos;2&apos;, &apos;b&apos;], [&apos;7&apos;, &apos;c&apos;], [&apos;100&apos;, &apos;a&apos;] ]</span><br><span class="line"></span><br><span class="line">// getFoo is property which isn&apos;t enumerable</span><br><span class="line">const myObj = Object.create(&#123;&#125;, &#123; getFoo: &#123; value() &#123; return this.foo; &#125; &#125; &#125;);</span><br><span class="line">myObj.foo = &apos;bar&apos;;</span><br><span class="line">console.log(Object.entries(myObj)); // [ [&apos;foo&apos;, &apos;bar&apos;] ]</span><br><span class="line"></span><br><span class="line">// non-object argument will be coerced to an object</span><br><span class="line">console.log(Object.entries(&apos;foo&apos;)); // [ [&apos;0&apos;, &apos;f&apos;], [&apos;1&apos;, &apos;o&apos;], [&apos;2&apos;, &apos;o&apos;] ]</span><br><span class="line"></span><br><span class="line">// iterate through key-value gracefully</span><br><span class="line">const obj = &#123; a: 5, b: 7, c: 9 &#125;;</span><br><span class="line">for (const [key, value] of Object.entries(obj)) &#123;</span><br><span class="line">  console.log(`$&#123;key&#125; $&#123;value&#125;`); // &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Or, using array extras</span><br><span class="line">Object.entries(obj).forEach(([key, value]) =&gt; &#123;</span><br><span class="line">console.log(`$&#123;key&#125; $&#123;value&#125;`); // &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h6><ul>
<li>Object.freeze(obj)：将obj对象冻结，不能对其自身属性进行任何操作，同时该对象的原型也不能修改。如果一个属性的值是个对象，则这个对象中的属性是可以修改的，除非它也是个冻结对象。数组作为一种对象，被冻结，其元素不能被修改。没有数组元素可以被添加或移除。</li>
<li>这个方法返回传递的对象obj，而不是创建一个被冻结的副本。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//浅冻结</span><br><span class="line">obj1 = &#123; name:&apos;nikita&apos;, internal:&#123;&#125; &#125;;</span><br><span class="line">Object.freeze(obj1);</span><br><span class="line">obj1.name = &apos;hello&apos;</span><br><span class="line">obj1.internal.a = 1;</span><br><span class="line">obj1     //&#123;name: &quot;nikita&quot;, internal: &#123;a:1&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归冻结每个对象属性，即深度冻结</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function deepFreeze(obj)&#123;</span><br><span class="line">	//取回定义在obj上的属性名</span><br><span class="line">	var propNames = object.getPropertyName(obj);</span><br><span class="line">	//在冻结对象之前冻结属性</span><br><span class="line">	propNames.forEach(function(name)&#123;</span><br><span class="line">		var prop = obj[name];</span><br><span class="line">		if(typeof prop == &apos;object&apos; &amp;&amp; prop !== null)&#123;</span><br><span class="line">			deepFreeze(prop);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	//冻结自身</span><br><span class="line">	return Object.freeze(obj);</span><br><span class="line">&#125;</span><br><span class="line">obj2 = &#123;</span><br><span class="line">  internal: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">deepFreeze(obj2);</span><br><span class="line">obj2.internal.a = &apos;anotherValue&apos;;</span><br><span class="line">obj2.internal.a; // undefined</span><br></pre></td></tr></table></figure>

<h6 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h6><ul>
<li>Object.getOwnPropertyDescriptor(obj,prop)：返回指定对象自身属性的属性描述符。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o, d;</span><br><span class="line"></span><br><span class="line">o = &#123; get foo() &#123; return 17; &#125; &#125;;</span><br><span class="line">d = Object.getOwnPropertyDescriptor(o, &quot;foo&quot;);</span><br><span class="line">// d &#123;</span><br><span class="line">//   configurable: true,</span><br><span class="line">//   enumerable: true,</span><br><span class="line">//   get: /*the getter function*/,</span><br><span class="line">//   set: undefined</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>若第一个参数不是对象，ES5报错，ES6强制转换为对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor(&apos;foo&apos;, 0);</span><br><span class="line">// 类型错误: &quot;foo&quot; 不是一个对象  // ES5 code</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(&apos;foo&apos;, 0);</span><br><span class="line">// Object returned by ES2015 code: &#123;</span><br><span class="line">//   configurable: false,</span><br><span class="line">//   enumerable: true,</span><br><span class="line">//   value: &quot;f&quot;,</span><br><span class="line">//   writable: false</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Object.getOwnPropertyDescriptors()</code> 方法用来获取一个对象的所有自身属性的描述符。</li>
<li>浅拷贝一个对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.create(</span><br><span class="line">	Object.getPrototypeOf(obj),</span><br><span class="line">	Object.getownpropertyDescriptors(obj)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>创建子类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function superClass()&#123;&#125;</span><br><span class="line">superClass.prototype=&#123;&#125;</span><br><span class="line">function subClass = &#123;&#125;</span><br><span class="line">subClass.prototype = Object.create(superClass.prototype,Object.getOwnpropertyDescriptors(&#123;&#125;));</span><br></pre></td></tr></table></figure>

<h6 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h6><ul>
<li>返回一个包含所有属性名（<strong>包括不可枚举属性但不包括Symbol值作为名称的属性</strong>）组成的<strong>数组</strong>。</li>
</ul>
<h6 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h6><ul>
<li>返回自身属性的字符串数组</li>
</ul>
<h6 id="Object-values-obj"><a href="#Object-values-obj" class="headerlink" title="Object.values(obj)"></a>Object.values(obj)</h6><ul>
<li>返回给定对象自身的所有可枚举属性值的数组。</li>
</ul>
<h6 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h6><p>object.is(val1,val2)：判断两个值是否是相同的值，作用与”==”相似，只不过Object.is()不会隐式类型转换，返回boolean值。</p>
<p><strong>注意相等的几种情况</strong>：</p>
<ul>
<li>两个值都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a></li>
<li>两个值都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null" target="_blank" rel="noopener"><code>null</code></a></li>
<li>两个值都是 <code>true</code> 或者都是 <code>false</code></li>
<li>两个值是由相同个数的字符按照相同的顺序组成的字符串</li>
<li>两个值指向同一个对象</li>
<li>两个值都是数字并且<ul>
<li>都是正零 <code>+0</code></li>
<li>都是负零 <code>-0</code></li>
<li>都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN" target="_blank" rel="noopener"><code>NaN</code></a></li>
<li>都是除零和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN" target="_blank" rel="noopener"><code>NaN</code></a> 外的其它同一个数字</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 特例</span><br><span class="line">Object.is(0, -0);            // false</span><br><span class="line">Object.is(0, +0);            // true</span><br><span class="line">Object.is(-0, -0);           // true</span><br><span class="line">Object.is(NaN, 0/0);         // true</span><br></pre></td></tr></table></figure>

<h6 id="Object-isExtensible-obj"><a href="#Object-isExtensible-obj" class="headerlink" title="Object.isExtensible(obj)"></a>Object.isExtensible(obj)</h6><ul>
<li>检测对象obj是否可扩展（能否加新的属性），返回boolean值。</li>
<li>默认是可扩展的，即可为他们添加新的属性。以及他们的<code>__prop__</code>属性也是可被更改的。Object.preventExtensions,Object.seal或Object.freeze方法都可使对象obj变成不可扩展。</li>
<li>若参数不是object类型，ES5会报错，ES6会将其转为不可扩展的普通对象.</li>
</ul>
<h6 id="Object-isFrozen-obj"><a href="#Object-isFrozen-obj" class="headerlink" title="Object.isFrozen(obj)"></a>Object.isFrozen(obj)</h6><ul>
<li>判断对象obj是否被冻结，冻结指它不可扩展，所有属性所有属性都是不可配置的，且所有数据属性（即没有getter或setter组件的访问器）都是不可写的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var oneProp = &#123;p:42&#125;</span><br><span class="line">// 让这个对象变的不可扩展,并不意味着这个对象变成了冻结对象,</span><br><span class="line">// 因为p属性仍然是可以配置的(而且可写的).</span><br><span class="line">Object.preventExtensions(oneProp);</span><br><span class="line">Object.isFrozen(oneProp) //=== false</span><br><span class="line">//此时如果删除了这个属性，则它会变成一个冻结对象</span><br><span class="line">delete oneProp.p;</span><br><span class="line">Object.isFrozen(oneProp) //===true</span><br><span class="line">//一个不可扩展的对象，拥有一个不可写但可配置的属性，则它仍是不可冻结的</span><br><span class="line">var nonWritable = &#123;e:&apos;plep&apos;&#125;;</span><br><span class="line">Object.preventExtensions(nonWritable);</span><br><span class="line">Object.defineProperty(noWritable,&apos;e&apos;,&#123;writable:false&#125;);</span><br><span class="line">Object.isFrozen(nonWritable)  //===false</span><br><span class="line">//将该属性变为不可配置则可让其变为冻结对象</span><br><span class="line">Object.defineProperty(noWritable,&apos;e&apos;,&#123;configurable:false&#125;);</span><br><span class="line">Object.isFrozen(nonWritable)  //===true</span><br></pre></td></tr></table></figure>

<ul>
<li>如果参数不是对象类型，ES5报错。ES6将其视为一个冻结的普通对象。</li>
</ul>
<h6 id="Object-isSealed-obj"><a href="#Object-isSealed-obj" class="headerlink" title="Object.isSealed(obj)"></a>Object.isSealed(obj)</h6><ul>
<li>判断一个对象是否被密封，返回boolean值。密封对象是指那些不可扩展且所有自身属性都不可配置且不可删除（但不一定是不可写的）的对象。</li>
</ul>
<h6 id="Object-hasOwnProperty-str-symbol"><a href="#Object-hasOwnProperty-str-symbol" class="headerlink" title="Object.hasOwnProperty(str/symbol)"></a>Object.hasOwnProperty(str/symbol)</h6><ul>
<li>判断某个属性是否为对象自身属性，与in不同，该方法会忽略掉从原型链上继承来的属性。即使属性值为null或undefined，只要属性存在都返回true</li>
</ul>
<h6 id="Object-toString"><a href="#Object-toString" class="headerlink" title="Object.toString()"></a>Object.toString()</h6><ul>
<li>返回【Object  type】</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var toString = Object.prototype.toString;</span><br><span class="line"></span><br><span class="line">toString.call(new Date); // [object Date]</span><br><span class="line">toString.call(new String); // [object String]</span><br><span class="line">toString.call(Math); // [object Math]</span><br><span class="line"></span><br><span class="line">//Since JavaScript 1.8.5</span><br><span class="line">toString.call(undefined); // [object Undefined]</span><br><span class="line">toString.call(null); // [object Null]</span><br></pre></td></tr></table></figure>

<h6 id="obj-valueOf"><a href="#obj-valueOf" class="headerlink" title="obj.valueOf()"></a>obj.valueOf()</h6><ul>
<li>返回指定对象的原始值</li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong>对象</strong></th>
<th align="left"><strong>返回值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Array</td>
<td align="left">返回数组对象本身。</td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">布尔值。</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。</td>
</tr>
<tr>
<td align="left">Function</td>
<td align="left">函数本身。</td>
</tr>
<tr>
<td align="left">Number</td>
<td align="left">数字值。</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="left">对象本身。这是默认情况。</td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">字符串值。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Math 和 Error 对象没有 valueOf 方法。</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>字符串上下文中的对象通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString" target="_blank" rel="noopener"><code>toString()</code></a>方法转换，这与使用<code>valueOf</code>转换为原始字符串的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String" target="_blank" rel="noopener"><code>String</code></a>对象不同。所有对象都能转换成一个“<code>[object *类型*]</code>”这种格式的字符串。但是很多对象不能转换为数字，布尔或函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// new一个Boolean对象</span><br><span class="line">var newBool = new Boolean(true);</span><br><span class="line">// valueOf()返回的是true，两者的值相等</span><br><span class="line">console.log(newBool.valueOf() == newBool);   // true</span><br><span class="line">// 但是不全等，两者类型不相等，前者是boolean类型，后者是object类型</span><br><span class="line">console.log(newBool.valueOf() === newBool);   // false</span><br></pre></td></tr></table></figure>

<h6 id="Object-seal-prop"><a href="#Object-seal-prop" class="headerlink" title="Object.seal(prop)"></a>Object.seal(prop)</h6><p><code>**Object.seal()**</code>方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-qq小程序天坑之旅" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/15/qq小程序天坑之旅/" class="article-date">
      <time datetime="2019-11-15T13:18:47.000Z" itemprop="datePublished">2019-11-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/15/qq小程序天坑之旅/">qq小程序天坑之旅</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="qq小程序"><a href="#qq小程序" class="headerlink" title="qq小程序"></a>qq小程序</h4><h6 id="吐槽qq小程序开发者工具"><a href="#吐槽qq小程序开发者工具" class="headerlink" title="吐槽qq小程序开发者工具"></a>吐槽qq小程序开发者工具</h6><ul>
<li>不能通过uni-app打开。</li>
<li>项目文件间互相引用问题颇多。</li>
<li>开发工具容易崩溃。</li>
<li>文档不够详尽。</li>
</ul>
<h6 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h6><ul>
<li>在组件qss中不应使用id，属性，标签选择器，最好用类选择器。</li>
<li>qml文件标签名只能是小写字母，中划线，下划线的组合，所以自定义组件的标签名也只能包含这些字符。</li>
<li>自定义组件也是可以引用自定义组件，引用方法类似于页面引用自定义组件的方式<code>usingComponent</code>字段</li>
<li>自定义组件和页面所在项根目录名不能以qq-为前缀，否则会报错。</li>
<li>是否在页面文件中使用 <code>usingComponents</code> 会使得页面的 <code>this</code> 对象的原型稍有差异，包括：<ul>
<li>使用 <code>usingComponents</code> 页面的原型与不使用时不一致，即 <code>Object.getPrototypeOf(this)</code> 结果不同。</li>
<li>使用 <code>usingComponents</code> 时会多一些方法，如 <code>selectComponent</code> 。</li>
<li>出于性能考虑，使用 <code>usingComponents</code> 时， <code>setData</code> 内容不会被直接深复制，即 <code>this.setData({ field: obj })</code> 后 <code>this.data.field === obj</code>。（深复制会在这个值被组件间传递时发生。）</li>
</ul>
</li>
<li><strong><em>直接修改this.data而不调用this.setData是无法改变页面的状态的，还会造成数据不一致</em></strong></li>
<li>不要将data里的任何一项的value设为undefined，否则这一项将不被设置并可能会存在一些潜在问题。</li>
<li><strong>navigateTo，redirectTo</strong>只能打开非tabBar页面，<strong>switchtab</strong>只能打开tabBar的页面。<strong>reLaunch</strong>可打开任意页面。调用页面路由带的参数可以在目标页面的onLoad中获取。</li>
<li>通过全局函数getApp（）可以获取全局的应用实例，如果需要全局的数据可以在App（）中获取。</li>
<li>require只支持相对路径，不支持绝对路径。</li>
<li>约定以on开头的API用来监听某个时间是否发生，当事件触发时会调用这个回调函数并将相关数据以参数的形式传入。</li>
<li>除继承样式外，app.qss中的样式，组将所在页面的样式对自定义组件无效。组件可以指定他所在节点的默认样式，使用:host选择器。</li>
</ul>
<h6 id="使用自定义组件"><a href="#使用自定义组件" class="headerlink" title="使用自定义组件"></a>使用自定义组件</h6><ol>
<li>在自定义组件中的json文件定义<code>{&quot;component&quot;:true}</code></li>
<li>在自定义组件中的qml编写组件模板（同index.qml写的相同），qss中加样式。（在组件qss中不应使用id，属性，标签选择器，最好用类选择器）</li>
<li>在自定义组件的 <code>js</code> 文件中，需要使用 <code>Component()</code> 来注册组件，并提供组件的属性定义、内部数据和自定义方法。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  properties: &#123;</span><br><span class="line">    // 这里定义了innerText属性，属性值可以在组件使用时指定</span><br><span class="line">    innerText: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      value: &apos;default value&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    // 这里是一些组件内部数据</span><br><span class="line">    someData: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 这里是一个自定义方法</span><br><span class="line">    customMethod() &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  externalClasses:[&apos;my-class&apos;]//从index页面中传过来的类</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在index.json文件中引用声明。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;usingComponents&quot;: &#123;</span><br><span class="line">    &quot;component-tag-name&quot;: &quot;path/to/the/custom/component&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//路径是相对于index文件夹的</span><br><span class="line">//component-tag-name是在页面中使用的组件名</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>index页面中使用组件。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;!-- 以下是对一个自定义组件的引用 --&gt;</span><br><span class="line">  &lt;component-tag-name inner-text=&quot;Some text&quot; class=&quot;my-class&quot;&gt;&lt;/component-tag-name&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<h6 id="父子组件间传值"><a href="#父子组件间传值" class="headerlink" title="父子组件间传值"></a>父子组件间传值</h6><p>注：设index页面是引用页面，component为组件，便于理解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;component-tag-name prop-a=&quot;&#123;&#123;dataFieldA&#125;&#125;&quot; prop-b=&quot;&#123;&#123;dataFieldB&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;!-- 这部分内容将被放置在组件 &lt;slot&gt; 的位置上 --&gt;</span><br><span class="line">    &lt;view&gt;这里是插入到组件slot中的内容&lt;/view&gt;</span><br><span class="line">  &lt;/component-tag-name&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;!-- 在引用组件中的js文件中定义dataFiledA，并通过属性propA传给组件 --&gt;</span><br><span class="line">&lt;!-- 标签中中划线连接者，在组件中都需要将其转为驼峰式 --&gt;</span><br></pre></td></tr></table></figure>

<p><strong>在组件的js文件中通过properties进行接收</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">	properties:&#123;</span><br><span class="line">		propA:Object //注名类型</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在组件的qml文件中引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;view&gt;这是组件内部的节点&lt;/view&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &#123;&#123;propA.name&#125;&#125;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<h6 id="组件中使用多slot"><a href="#组件中使用多slot" class="headerlink" title="组件中使用多slot"></a>组件中使用多slot</h6><ul>
<li>默认情况下，一个组件只能使用一个slot。需要使用多slot时，可以在组件js中声明启用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">	options:&#123;</span><br><span class="line">		multipleSlots:true</span><br><span class="line">	&#125;,</span><br><span class="line">	properties:&#123;&#125;,</span><br><span class="line">	data:&#123;&#125;,</span><br><span class="line">	methods:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>在组件模板component.qml使用多个slot，以不同name值区分</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;wrapper&quot;&gt;</span><br><span class="line">	&lt;slot name = &quot;before&quot;&gt;&lt;/slot&gt;</span><br><span class="line">	&lt;view&gt;这里是组件的内部细节&lt;/view&gt;</span><br><span class="line">	&lt;slot name=&quot;after&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在index.qml中使用时，用 <code>slot</code> 属性来将节点插入到不同的slot上。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;!-- 这部分内容将被放置在组件 &lt;slot name=&quot;before&quot;&gt; 的位置上 --&gt;</span><br><span class="line">    &lt;view slot=&quot;before&quot;&gt;这里是插入到组件slot name=&quot;before&quot;中的内容&lt;/view&gt;</span><br><span class="line">    &lt;!-- 这部分内容将被放置在组件 &lt;slot name=&quot;after&quot;&gt; 的位置上 --&gt;</span><br><span class="line">    &lt;view slot=&quot;after&quot;&gt;这里是插入到组件slot name=&quot;after&quot;中的内容&lt;/view&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<h6 id="导入模板"><a href="#导入模板" class="headerlink" title="导入模板"></a>导入模板</h6><ul>
<li>定义模板template.qml及其样式文件template.qss</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- template.qml --&gt;</span><br><span class="line">&lt;template name=&quot;navigation&quot;&gt;</span><br><span class="line">    &lt;view class=&quot;navigation_grounp&quot;&gt;</span><br><span class="line">        &lt;view class=&quot;navigation&quot; hover-class=&quot;none&quot; hover-stop-propagation=&quot;false&quot;&gt;</span><br><span class="line">            &lt;block wx:if=&quot;&#123;&#123;true&#125;&#125;&quot;&gt;</span><br><span class="line">                &lt;text class=&quot;nav_search&quot;&gt;返回&lt;/text&gt;</span><br><span class="line">            &lt;/block&gt;</span><br><span class="line">            &lt;text class=&quot;nav_title&quot;&gt;nija&lt;/text&gt;</span><br><span class="line">        &lt;/view&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> /* template.qss */</span><br><span class="line">.navigation_grounp&#123;</span><br><span class="line">     position: flexed;</span><br><span class="line">     top: 0;</span><br><span class="line">     width: 100%;</span><br><span class="line"> &#125;</span><br><span class="line"> .navigation_grounp &gt; .navigation&#123;</span><br><span class="line">     display: flex;</span><br><span class="line">     align-items: center;</span><br><span class="line">     justify-content: center;</span><br><span class="line">     box-sizing: border-box;</span><br><span class="line">     padding: 0 15px;</span><br><span class="line">     background-color: green; </span><br><span class="line">     height: 44px;</span><br><span class="line">     color:red;</span><br><span class="line"> &#125;</span><br><span class="line"> .navigation .nav_search&#123;</span><br><span class="line">     width: 33.3%;</span><br><span class="line">     overflow: hidden;</span><br><span class="line"> &#125;</span><br><span class="line">  .navigation .nav_title&#123;</span><br><span class="line">        width: 33.3%;</span><br><span class="line">        text-align: center;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        text-overflow:ellipsis;</span><br><span class="line">        white-space: nowrap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在index文件中导入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- index.qml --&gt;</span><br><span class="line">&lt;import src=&quot;./../template/template&quot; /&gt;</span><br><span class="line">&lt;template is=&quot;navigation&quot;&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* index.qss，没导入该文件，其样式不会在index中显示 */</span><br><span class="line">@import &apos;./../template/template.qss&apos;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-proto" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/10/27/proto/" class="article-date">
      <time datetime="2019-10-27T05:45:18.000Z" itemprop="datePublished">2019-10-27</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/27/proto/">proto</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="类的prototype属性和-proto-属性"><a href="#类的prototype属性和-proto-属性" class="headerlink" title="类的prototype属性和__proto__属性"></a>类的prototype属性和<code>__proto__</code>属性</h4><ul>
<li>每个对象都有<code>__proto__</code>属性，指向对应的构造函数的prototype属性。</li>
<li><strong>子类的<code>__proto__</code>属性表示构造函数的继承，总是指向父类。</strong></li>
<li><strong>子类的prototype属性的<code>__proto__</code>属性表示方法的继承，总是指向父类的prototype属性。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">class B extends A&#123;&#125;</span><br><span class="line">B.__proto__ === A  //true</span><br><span class="line">B.prototype.__proto__  === A.prototype  //true</span><br><span class="line"></span><br><span class="line">//B的实例继承A的实例</span><br><span class="line">Object.setPrototypeOf(B.prototype,A.prototype);</span><br><span class="line">//B继承A的静态属性</span><br><span class="line">Object.setPrototypeOf(B,A);</span><br><span class="line"></span><br><span class="line">//Object.setPrototypeOf方法实现</span><br><span class="line">Object.setPrototypeOf = function(obj,proto)&#123;</span><br><span class="line">	obj.__proto__ = proto;</span><br><span class="line">	return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</p>
<p>上面代码的<code>A</code>，只要是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p>
<h6 id="以下两种特殊情况"><a href="#以下两种特殊情况" class="headerlink" title="以下两种特殊情况"></a>以下两种特殊情况</h6><ul>
<li>子类继承Object类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A extends Object&#123;&#125;</span><br><span class="line">A.__proto__ === Object  //true</span><br><span class="line">A.prototype.__proto__ === Object.prototype  //true</span><br><span class="line">//A其实就是构造函数Object的复制，A的实例就是Object的实例</span><br></pre></td></tr></table></figure>

<ul>
<li>不存在任何继承</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">A.__proto__ === Function.prototype   //true</span><br><span class="line">A.prototype.__proto__ === Object.prototype   //true</span><br></pre></td></tr></table></figure>

<p>A作为一个基类，即不存在任何继承，就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象即object实例，所以<code>A.prototype.__proto__</code>指向构造函数Object的prototype属性。</p>
<h6 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的 proto 属性"></a>实例的 <strong>proto</strong> 属性</h6><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123; /* ... */ &#125;</span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    super(x, y); // 调用父类的constructor(x, y)</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p1 = new Point(2, 3);</span><br><span class="line">var p2 = new ColorPoint(2, 3, &apos;red&apos;);</span><br><span class="line"></span><br><span class="line">p2.__proto__ === p1.__proto__ // false</span><br><span class="line">p2.__proto__.__proto__ === p1.__proto__ // true</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型。</p>
<p>因此，通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p2.__proto__.__proto__.printName = function () &#123;</span><br><span class="line">  console.log(&apos;Ha&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() // &quot;Ha&quot;</span><br></pre></td></tr></table></figure>

<h6 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h6><ul>
<li><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。一般不能继承，有以下九种：</p>
<p><code>Boolean(),Number(),String(),Array(),Date(),Function(),RegExp(),Error(),Object()</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function MyArray() &#123;</span><br><span class="line">  Array.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyArray.prototype = Object.create(Array.prototype, &#123;</span><br><span class="line">  constructor: &#123;</span><br><span class="line">    value: MyArray,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    enumerable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">var colors = new MyArray();</span><br><span class="line">colors[0] = &quot;red&quot;;</span><br><span class="line">colors.length  // 0</span><br><span class="line"></span><br><span class="line">colors.length = 0;</span><br><span class="line">colors[0]  // &quot;red&quot;</span><br></pre></td></tr></table></figure>

<p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过<code>Array.apply()</code>或者分配给原型对象都不行。原生构造函数会忽略<code>apply</code>方法传入的<code>this</code>，也就是说，原生构造函数的<code>this</code>无法绑定，导致拿不到内部属性。</p>
<p>ES5 是先新建子类的实例对象<code>this</code>，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，<code>Array</code>构造函数有一个内部属性<code>[[DefineOwnProperty]]</code>，用来定义新属性时，更新<code>length</code>属性，这个内部属性无法在子类获取，导致子类的<code>length</code>属性行为不正常。</p>
<p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。下面是一个继承<code>Array</code>的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyArray extends Array &#123;</span><br><span class="line">  constructor(...args) &#123;</span><br><span class="line">    super(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = new MyArray();</span><br><span class="line">arr[0] = 12;</span><br><span class="line">arr.length // 1</span><br><span class="line"></span><br><span class="line">arr.length = 0;</span><br><span class="line">arr[0] // undefined</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-项目开发流程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/26/项目开发流程/" class="article-date">
      <time datetime="2019-09-25T23:40:32.000Z" itemprop="datePublished">2019-09-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/26/项目开发流程/">项目开发流程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="WEB前端项目开发流程"><a href="#WEB前端项目开发流程" class="headerlink" title="WEB前端项目开发流程"></a>WEB前端项目开发流程</h1><h3 id="项目需求分析"><a href="#项目需求分析" class="headerlink" title="项目需求分析"></a>项目需求分析</h3><p>这个环节是由设计师完成，设计师首先和客户进行交流，了解客户的需求，然后分析项目的可行性，如果项目可以被实现，设计师直接进行设计开发。</p>
<h3 id="页面设计"><a href="#页面设计" class="headerlink" title="页面设计"></a>页面设计</h3><p>这个环节主要是UI设计师参与，UI设计师根据产品需求分析文档，对产品的整体美术风格、交互设计、界面结构、操作流程等做出设计。负责项目中各种交互界面、图标、LOGO、按钮等相关元素的设计与制作。最后设计出一份设计稿并交由程序员进行下一步开发。程序员拿到设计稿交流完需求后公司方需要支付3成定金。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>这个部分由程序员来实现。（程序员分为WEB前端开发工程师和后台开发工程师。前端开发人员主要根据原型图用代码写出我们可以在网页上看的见的页面，途中一些问题也需要同设计师直接交流，后台就做一些我们看不见的管理系统以及功能的实现。）程序员根据UI设计师的设计，用编码来完成整个项目的各个功能。</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>由程序员部署到服务器上。</p>
<h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>程序的维护是整个项目的最后一个阶段，但也是耗时最多，成本最高最高的的一个阶段。程序的维护是由程序员免费维护半年。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-事件机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/25/事件机制/" class="article-date">
      <time datetime="2019-09-25T13:25:10.000Z" itemprop="datePublished">2019-09-25</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/25/事件机制/">事件机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="事件机制之冒泡、传播、委托"><a href="#事件机制之冒泡、传播、委托" class="headerlink" title="事件机制之冒泡、传播、委托"></a>事件机制之冒泡、传播、委托</h2><p>DOM事件流（event flow）存在三个阶段：<strong>事件捕获阶段，处于目标阶段，事件冒泡阶段</strong>。</p>
<h5 id="事件捕获阶段（event-capuring）"><a href="#事件捕获阶段（event-capuring）" class="headerlink" title="事件捕获阶段（event  capuring）"></a>事件捕获阶段（event  capuring）</h5><p>通俗理解就是，当鼠标点击或触发dom事件时，浏览器会从根节点<strong>由外往内</strong>进行事件传播，即点击了子元素，如果父元素通过事件捕获注册了对应的事件的话，会先触发父元素绑定的的事件。</p>
<h5 id="事件冒泡（dubbed-bubbling）"><a href="#事件冒泡（dubbed-bubbling）" class="headerlink" title="事件冒泡（dubbed bubbling）"></a>事件冒泡（dubbed bubbling）</h5><p>与事件捕获相反，事件冒泡是从目标元素<strong>由内往外</strong>进行事件传播，直到根节点。</p>
<p>无论是事件冒泡还是事件捕获，都有一个共同点就是事件传播，她就像一根引线，只有通过引线才能将绑在引线上的鞭炮（事件监听器）引爆，试想一下，如果引线不导火了，那鞭炮就只有一响了！</p>
<p>dom事件标准事件流的触发先后顺序是：<strong>先捕获后冒泡</strong>，即当触发dom事件时，会进行事件捕获，捕获到事件源后通过事件传播进行事件冒泡。不同浏览器对此有不同的实现，IE10及以下不支持捕获型事件，所以就少了一个时间捕获阶段，IE11,Chrome，Firefox，Safari等浏览器则同时存在。</p>
<h5 id="事件绑定的方法"><a href="#事件绑定的方法" class="headerlink" title="事件绑定的方法"></a>事件绑定的方法</h5><h6 id="addEventlistener-event-listener-useCapture"><a href="#addEventlistener-event-listener-useCapture" class="headerlink" title="addEventlistener(event,listener,useCapture)"></a>addEventlistener(event,listener,useCapture)</h6><p>参数定义：event——（事件名称：如click，不带on）</p>
<p>listener——事件监听函数，</p>
<p>useCapture——是否采用事件捕获进行事件捕获，默认为false，即采用事件冒泡方式。</p>
<p>addEventListener在IE11，Chrome，Firefox，Safari等浏览器都得到支持。</p>
<h6 id="attachEvent（event，listener）"><a href="#attachEvent（event，listener）" class="headerlink" title="attachEvent（event，listener）"></a>attachEvent（event，listener）</h6><p>参数定义：event—（事件名称，如onclick，带on），</p>
<p>listener—事件监听函数。</p>
<p>attachEvent主要用于IE浏览器，并且仅在IE10及以下才支持，IE11已经废了这个方法了</p>
<h6 id="事件冒泡例子"><a href="#事件冒泡例子" class="headerlink" title="事件冒泡例子"></a>事件冒泡例子</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">    #parent&#123;width:200px;height:200px;background:yellow;margin:10px auto;border:1px solid black;&#125;</span><br><span class="line">    #children&#123;width:50px;height:50px;background:pink;margin:80px auto;&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;children&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var children = document.getElementById(&apos;children&apos;);</span><br><span class="line">    var parent = document.getElementById(&apos;parent&apos;);</span><br><span class="line">    document.body.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;body&apos;)&#125;,false);</span><br><span class="line">    parent.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;parent&apos;)&#125;,false);</span><br><span class="line">    children.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;children&apos;);</span><br><span class="line">    //event.stopProparation;</span><br><span class="line">    //可停止事件传播&#125;,false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当点击子盒子时，打印结果依次为children——parent——body</p>
<p>事件触发的顺序是由内到外的，这就是事件冒泡，虽然只点击了子元素，但是他的父元素也会触发相应的事件，其实这也是合理的，因为父元素里面，点击了子元素不就相当于变相的点击了父元素。</p>
<p>若不想触发父元素可停止事件传播只需在子元素中添加<strong>event.stopProparation;</strong>即可。</p>
<h6 id="事件捕获例子"><a href="#事件捕获例子" class="headerlink" title="事件捕获例子"></a>事件捕获例子</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">    body&#123;background: green;&#125;</span><br><span class="line">    #parent&#123;width:200px;height:200px;background:yellow;margin:10px auto;border:1px solid black;&#125;</span><br><span class="line">    #children&#123;width:50px;height:50px;background:pink;margin:80px auto;&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;children&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var children = document.getElementById(&apos;children&apos;);</span><br><span class="line">    var parent = document.getElementById(&apos;parent&apos;);</span><br><span class="line">    document.body.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;body&apos;)&#125;,true);</span><br><span class="line">    parent.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;parent&apos;)&#125;,true);</span><br><span class="line">    children.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;children&apos;)&#125;,true);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>点击children方块，打印body——parent——childre</p>
<p>点击parent方块，打印body——parent</p>
<p>点击body区域，打印body</p>
<p>事件通过事件捕获的方式注册了click事件，所以在事件捕获阶段就会触发，先是触发最外围注册了事件捕获的body，而后触发事件捕获的parent，最后触发事件源。这就是事件的时间流程。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-js执行上下文" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/15/js执行上下文/" class="article-date">
      <time datetime="2019-09-15T12:36:10.000Z" itemprop="datePublished">2019-09-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/15/js执行上下文/">js执行上下文</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="js的执行上下文"><a href="#js的执行上下文" class="headerlink" title="js的执行上下文"></a>js的执行上下文</h2><p>执行上下文是当前js代码被解析和执行时所在的环境的抽象概念，js中的运行任何代码都是在执行上下文中运行。</p>
<h4 id="执行上下文的的三种类型"><a href="#执行上下文的的三种类型" class="headerlink" title="执行上下文的的三种类型"></a>执行上下文的的三种类型</h4><p><strong>全局执行上下文</strong>：这是默认的，最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文。它做了两件事：</p>
<ul>
<li>创建一个全局对象，在浏览器中这个全局对象就是window对象。</li>
<li>将this指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。</li>
</ul>
<p><strong>函数执行上下文</strong>：每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在被调用时才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，她都会按照特定的顺序执行一系列步骤。</p>
<p><strong>Eval函数执行上下文</strong>：运行在eval函数中的代码也获得自己的执行上下文。</p>
<h4 id="执行上下文的生命周期"><a href="#执行上下文的生命周期" class="headerlink" title="执行上下文的生命周期"></a>执行上下文的生命周期</h4><p>执行上下文的生命周期包括三个阶段：<strong>创建阶段——执行阶段——回收阶段</strong></p>
<h6 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h6><p>当函数被调用时，但未被执行其内部任意代码前，会做以下三件事：</p>
<ol>
<li>创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。</li>
<li>创建作用域链（scope chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，js始终从代码嵌套的最内层开始，如果最内层没有该变量，就往上一层父级作用域中找，直到找到变量。</li>
<li>确定this指向</li>
</ol>
<p>在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</p>
<p>另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出this arguments和函数的参数。</p>
<p>以上过程实则为代码的预处理阶段，详细过程如下：</p>
<ol>
<li>读取分析整个源代码</li>
<li>先扫描函数声明，之后扫描变量（var声明）<ul>
<li>处理函数声明时有冲突，会覆盖。</li>
<li>处理变量声明有冲突，会忽略。</li>
</ul>
</li>
<li>将扫描到的函数和变量保存到一个对象中（全局的会保存在window对象中）</li>
<li>变量的值是undefined，函数的值则是指向该函数（是一个函数字符串）<ul>
<li>形式如：window = { x : undefined , f : ‘function(){console.log(1);}’ }</li>
</ul>
</li>
</ol>
<p><strong>注意：当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。</strong></p>
<p>function声明的优先级比var声明高，也就意味着当两个同名变量同时被function和var声明时，function声明会覆盖var声明</p>
<h4 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h4><p>执行变量赋值、代码执行。</p>
<p>该过程为：</p>
<ol>
<li><p>将变量的值从undefined改为给定值。</p>
</li>
<li><p>调用函数f（），以便函数得到执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">上面函数(f)内，代码的处理过程：</span><br><span class="line"></span><br><span class="line">    1、预处理阶段</span><br><span class="line"></span><br><span class="line">        a、将函数的参数添加到一个对象（暂定为：词法对象）</span><br><span class="line"></span><br><span class="line">        b、扫描函数声明，之后扫描变量(var声明)</span><br><span class="line"></span><br><span class="line">        d、将扫描到的函数和方法添加到词法对象里面</span><br><span class="line"></span><br><span class="line">        c、变量的值是undefined，函数的值则指向该函数（与全局的一样）</span><br><span class="line"></span><br><span class="line">    2、运行阶段</span><br><span class="line"></span><br><span class="line">        与全局的的运行原理一样</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="回收阶段"><a href="#回收阶段" class="headerlink" title="回收阶段"></a>回收阶段</h4><p>执行上下文出栈等待虚拟机回收执行上下文</p>
<p>看看一下例子就知道变量提升是怎么回事了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function test(arg)&#123;</span><br><span class="line">    // 1. 形参 arg 是 &quot;hi&quot;</span><br><span class="line">    // 2. 因为函数声明比变量声明优先级高，所以此时 arg 是 function</span><br><span class="line">    console.log(arg);  </span><br><span class="line">    var arg = &apos;hello&apos;; // 3.var arg 变量声明被忽略， arg = &apos;hello&apos;被执行</span><br><span class="line">    function arg()&#123;</span><br><span class="line">	console.log(&apos;hello world&apos;) </span><br><span class="line">    &#125;</span><br><span class="line">    console.log(arg);  </span><br><span class="line">&#125;</span><br><span class="line">test(&apos;hi&apos;);</span><br><span class="line">/* 输出：</span><br><span class="line">function arg()&#123;</span><br><span class="line">    console.log(&apos;hello world&apos;) </span><br><span class="line">    &#125;</span><br><span class="line">hello </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h4 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h4><p>函数多了，就有多个函数执行上下文，每次调用函数创建一个新的执行上下文，那如何管理创建的那么多执行上下文呢？</p>
<p>JavaScript 引擎创建了执行上下文栈来管理执行上下文。<strong>可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</strong>。</p>
<p>我们需要记住几个关键点：</p>
<ul>
<li>JavaScript执行在单线程上，所有的代码都是排队执行。</li>
<li>一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。</li>
<li>每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。</li>
<li>浏览器的JS执行引擎总是访问栈顶的执行上下文。</li>
<li>全局上下文只有唯一的一个，它在浏览器关闭时出栈。</li>
</ul>
<p>推荐：</p>
<p><a href="https://www.cnblogs.com/lark-/p/7954047.html" target="_blank" rel="noopener">https://www.cnblogs.com/lark-/p/7954047.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-js中的立即执行函数" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/09/15/js中的立即执行函数/" class="article-date">
      <time datetime="2019-09-15T02:07:11.000Z" itemprop="datePublished">2019-09-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/15/js中的立即执行函数/">js中的立即执行函数</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="js中的立即执行函数"><a href="#js中的立即执行函数" class="headerlink" title="js中的立即执行函数"></a>js中的立即执行函数</h2><p>立即执行函数是一种语法模式，可以让你的函数在定义后立即执行。本质是一个表达式，使用运算符将函数声明转换为函数表达式之后就可达到立即执行效果</p>
<p>这样，使得页面加载完成后只执行一次设置的函数。且因将设置函数中的变量包裹在局部变量中，不会泄露成全局变量。</p>
<h6 id="立即执行函数的写法"><a href="#立即执行函数的写法" class="headerlink" title="立即执行函数的写法"></a>立即执行函数的写法</h6><ol>
<li><p>匿名函数不能单独定义，必须赋值操作或立即执行，否则会被JS引擎定义为语法错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function()&#123;alert(dada);&#125;</span><br><span class="line">VM229:1 Uncaught SyntaxError: Unexpected token</span><br></pre></td></tr></table></figure>
</li>
<li><p>在函数体后面加括号就能立即调用，这个函数形式必须是函数表达式，不能是函数声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function()&#123;alert(123);&#125;();</span><br><span class="line">VM265:1 Uncaught SyntaxError: Unexpected token (</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以在函数前面加符号，或者用括号将函数包住来消除函数声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;alert(123);&#125;)();</span><br></pre></td></tr></table></figure>
</li>
<li><p>消除函数声明最安全的做法是加括号，因为运算符号还会和函数的返回值进行运算，造成不必要麻烦。</p>
</li>
<li><p>包住函数表达式的括号可以括住参数，也可以不括住，效果是一样的。</p>
</li>
</ol>
<p>通常，全局变量被作为一个参数传递给立即执行函数参数，这样她在函数内部不使用window就可以访问到全局变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function (global)&#123;</span><br><span class="line">	console.log(global);</span><br><span class="line">&#125;)(this);</span><br></pre></td></tr></table></figure>

<p>通过定义一个匿名函数，创建了一个新的函数作用域，相当于创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏污染全局的命名空间。此时若是想访问全局对象，将全局对象以参数形式传进去即可，如jQuery代码结构。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 陈楚吟
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
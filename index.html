<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="陈楚吟">


    
    


<meta name="description" content="将学习技术点汇总">
<meta name="keywords" content="write myBlog">
<meta property="og:type" content="website">
<meta property="og:title" content="Nikita">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Nikita">
<meta property="og:description" content="将学习技术点汇总">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nikita">
<meta name="twitter:description" content="将学习技术点汇总">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Nikita" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Nikita</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">陈楚吟</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不负韶华</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">陈楚吟</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">陈楚吟</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不负韶华</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-前端经验" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/01/前端经验/" class="article-date">
      <time datetime="2020-06-01T03:27:12.000Z" itemprop="datePublished">2020-06-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/01/前端经验/">字体图标</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h6 id="字体图标的优势"><a href="#字体图标的优势" class="headerlink" title="字体图标的优势"></a>字体图标的优势</h6><ol>
<li>性能好，可以减少http请求。</li>
<li>解决图标放大失真问题。</li>
<li>解决图片占用内存问题。</li>
</ol>
<h6 id="图片格式分类"><a href="#图片格式分类" class="headerlink" title="图片格式分类"></a>图片格式分类</h6><ol>
<li>位图图片：bmp，jpg，gif，png。（大小改变时可能出现锯齿状）。</li>
<li>矢量图图片：以svg格式为代表，可缩放矢量图形（Scalable Vector Graphics）。SVG是一种使用XML格式定义的图像。（颜色和字体可选范围较小）</li>
</ol>
<h6 id="字体图标出现的背景"><a href="#字体图标出现的背景" class="headerlink" title="字体图标出现的背景"></a>字体图标出现的背景</h6><p><strong>雪碧图处理图标</strong></p>
<ul>
<li>首先载入带有所有图标的图片。</li>
<li>利用定位截取想要的图标。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.bgImg&#123;</span><br><span class="line">	background: url(img/logos.png);</span><br><span class="line">	display: block;</span><br><span class="line">	text-indent: -9999px;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">	background-repeate: no-repeate;</span><br><span class="line">	width: 16px;</span><br><span class="line">	height: 16px;</span><br><span class="line">&#125;</span><br><span class="line">.help&#123;</span><br><span class="line">	background-position: -48px -150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优势：当有大量的小图标时，可减少请求次数，网页加载速度更快，减少阻塞网络的情况，用户体验不好。</p>
<p>缺点：需要先设置背景图片，再通过精灵图中小图标的宽度和位置，设置对应的div宽高和背景定位坐标。设计人员后期的维护难度较大，编码也比较难（对定位精准性要求较大）。</p>
<h4 id="字体图标的使用"><a href="#字体图标的使用" class="headerlink" title="字体图标的使用"></a>字体图标的使用</h4><ul>
<li>一般会再建一个新的css文件来设置<code>font-family</code>和字体颜色，一来可以整体设置，二来当新字体图标覆盖时，文字的样式可以保持原先的状态。</li>
</ul>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h4 id="星级评分"><a href="#星级评分" class="headerlink" title="星级评分"></a>星级评分</h4>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-linux学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/22/linux学习/" class="article-date">
      <time datetime="2020-05-22T01:12:25.000Z" itemprop="datePublished">2020-05-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/22/linux学习/">linux学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="linux基础"><a href="#linux基础" class="headerlink" title="linux基础"></a>linux基础</h4><h4 id="linux实战"><a href="#linux实战" class="headerlink" title="linux实战"></a>linux实战</h4><h6 id="远程登陆"><a href="#远程登陆" class="headerlink" title="远程登陆"></a>远程登陆</h6><p>xShell xFtp</p>
<h6 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h6><h6 id="远程管理"><a href="#远程管理" class="headerlink" title="远程管理"></a>远程管理</h6><h6 id="vi和vim编译器"><a href="#vi和vim编译器" class="headerlink" title="vi和vim编译器"></a>vi和vim编译器</h6><h6 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h6><h6 id="RPM与YUM"><a href="#RPM与YUM" class="headerlink" title="RPM与YUM"></a>RPM与YUM</h6>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pandas之excel" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/10/pandas之excel/" class="article-date">
      <time datetime="2020-05-10T04:44:58.000Z" itemprop="datePublished">2020-05-10</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/10/pandas之excel/">pandas之excel</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h4><h6 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'ID'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">'Name'</span>:[<span class="string">'Tim'</span>,<span class="string">'Victor'</span>,<span class="string">'Nick'</span>]&#125;)</span><br><span class="line">df = df.set_index(<span class="string">'ID'</span>)</span><br><span class="line">df.to_excel(<span class="string">'F:/webProject/python/output.xlsx'</span>)</span><br><span class="line">print(<span class="string">'Done'</span>)</span><br></pre></td></tr></table></figure>

<p>遇到问题：</p>
<ol>
<li><p>NameError: name ‘pandas’ is not defined？</p>
<p>这是没有pandas模块，这是因为python默认没有安装numpy和pandas，最直接的方法是在python的scripts中执行<code>pip install pandas</code>不过，据说用pip安装会损坏原文件。</p>
</li>
<li><p>或者在Spyder编辑器中安装<code>pip install pandas</code>,却报<code>Note: you may need to restart the kernel to use updated packages.</code>?</p>
<p>在Terminal中更新<code>conda update spyder</code>。</p>
</li>
</ol>
<h6 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line">people = pd.read_execl(<span class="string">'path'</span>,header=<span class="literal">None</span>)  <span class="comment">#表示没有行头</span></span><br><span class="line">people.set_index(<span class="string">'ID'</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">print(people.shape)   <span class="comment">#打印出多少行多少列</span></span><br><span class="line">print(people.columns)  <span class="comment">#列</span></span><br><span class="line">print(people.head(<span class="number">3</span>))  <span class="comment">#打印出前3行，head不加参数默认为5行</span></span><br><span class="line">print(people.tail(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">df = pd.read_excel(<span class="string">'path'</span>,index_col=<span class="string">'ID'</span>)  <span class="comment">#后面的参数是为了不要将系统自动添加的索引加到新的表中</span></span><br><span class="line">df.to_excel(<span class="string">'path'</span>)</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-HTML5和CSS3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/09/HTML5和CSS3/" class="article-date">
      <time datetime="2020-05-09T14:12:59.000Z" itemprop="datePublished">2020-05-09</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/09/HTML5和CSS3/">HTML5和CSS3</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ol>
<li><p>contentEditable设置为true时，该元素就变成了可编辑的，且该元素可继承。</p>
</li>
<li><p>designMode属性用来指定整个页面是否可编辑。<code>document.designMode=&quot;on&quot;</code></p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-爬虫" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/08/爬虫/" class="article-date">
      <time datetime="2020-05-08T12:22:36.000Z" itemprop="datePublished">2020-05-08</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/08/爬虫/">爬虫</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="爬虫基础"><a href="#爬虫基础" class="headerlink" title="爬虫基础"></a>爬虫基础</h4><p>爬虫就是获取网页并提取和保存信息的自动化程序。</p>
<p>Cookies里面保存了登录的凭证，有了它，只需在下次请求携带Cookies发送请求而不必重新输入用户名和密码。因此在爬虫中，有时候需要登录才能访问页面时，我们一般会直接将登录成功后截取的Cookies放在请求头里面直接请求，而不必重新模拟登录。</p>
<h6 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h6><p>Accept：请求报文域，用于指定客户端可接受哪些类型的信息。</p>
<p>Accept-Language：指定客户端可接受的语言类型。</p>
<p>Accept-Encoding：指定客户端可接受的内容编码。</p>
<p>Host：用于指定请求资源的主机IP和端口号，其内容为请求URL的原始服务器或网关的位置。从HTTP1.1版本开始，请求必须包含此内容。</p>
<p>Cookie：也常用复数形式Cookies，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前会话。如：我们输入用户名和密码成功登陆到某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登陆状态，这就是Cookies的功劳。Cookies里面有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上Cookies并将其发送给服务器，服务器通过Cookies识别出是我们自己，并且查出当前状态是登录状态，所以返回的是登陆后才能看到的网页内容。</p>
<p>Referer：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并作相应的处理，如来源统计，防盗链处理等。</p>
<p>User-Agent：简称UA，它是一个特殊的字符串头，可以是服务器识别客户使用的操作系统和版本，浏览器及版本等信息。在做爬虫的时候加上此信息可以伪装为浏览器；如果不加，很可能会被识别为爬虫。</p>
<p>Content-Type：也叫互联网媒体类型或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。如：text/html表示HTML格式，image/gif表示GIF图片，application/json表示JSON类型。</p>
<table>
<thead>
<tr>
<th>Content-Type</th>
<th>提交数据的方式</th>
</tr>
</thead>
<tbody><tr>
<td>application/x-www-form-urlencoded</td>
<td>表单数据</td>
</tr>
<tr>
<td>multipart/form-data</td>
<td>表单文件上传</td>
</tr>
<tr>
<td>application/data</td>
<td>序列化JSON数据</td>
</tr>
<tr>
<td>text/xml</td>
<td>XML数据</td>
</tr>
</tbody></table>
<p>在爬虫中，若要构造POST请求，需要使用正确的Content-Type，并了解各种请求库的各个参数设置时使用的是哪种Content-Type，不然可能导致POST提交后无法正常响应。</p>
<p>请求头是请求的重要组成部分，再写爬虫时大部分情况下都需要设定请求头。</p>
<h6 id="请求主体"><a href="#请求主体" class="headerlink" title="请求主体"></a>请求主体</h6><p>请求体一般承载的内容是POST请求中的表单数据，而对于GET请求，请求体则为空。</p>
<p>响应三部分：响应状态码，响应头，响应体。</p>
<h6 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h6><p>Date：标识响应产生的时间。</p>
<p>Last-Modified：指定资源的最后修改时间。</p>
<p>Content-Encoding：指定响应内容的编码。</p>
<p>Server：包含服务器的信息，比如名称和版本号等。</p>
<p>Content-Type：文档类型，指定返回的数据类型是什么，如text/html代表返回的是HTML文档，application/x-javascript则代表返回JavaScript文件，image/jpeg则代表返回图片。</p>
<p>Set-Cookie：设置Cookies，响应头中的Set-Cookie告诉浏览器需要将此内容放在Cookies中，下次请求携带Cookies请求。</p>
<p>Expires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。</p>
<h6 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h6><p>响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的        HTML代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体。</p>
<h6 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h6><p>在Web中，会话对象用来存储特定用户会话所需的属性及配置信息，这样，当用户在应用程序的Web页之间跳转时，存储在会话对象中的变量将不会丢失，而是在整个用户会话中一直村下去。当用户请求来自应用程序的Web页时，如果该用户还没有会话，则Web服务器将自动创建一个会话对象。当会话过期或放弃后，服务器将终止该会话。</p>
<p><strong>会话维持</strong></p>
<p>当客户端第一次请求服务器时，服务器会返回一个请求头中带有Set-Cookie字段的响应给客户端，用来标记是哪一个用户，客户端浏览器就会把此Cookies放到请求头一起提交给服务器，Cookies携带了会话ID信息，服务器检查该Cookies即可找到对应的会话是什么，然后再判断会话来以此来辨认用户状态。</p>
<p>在成功登录某个网站时，服务器就会告诉客户端设置哪些Cookies信息，在后续访问页面时客户端会把Cookies发送给服务器，服务器再找到对应的会话加以判断。如果会话中某些设置登录状态的变量是有效的，那就证明用户处于登录状态，此时返回登陆之后才可以查看的网页内容，浏览器解析便可以看到了。</p>
<p>反之，如果传给服务器的Cookies是无效的，或者会话已经过期了，我们将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录页面重新登陆。</p>
<p>所以，Cookies和会话需要配合，一个处于客户端，一个处于服务端，两者共同协作就实现会话控制。</p>
<h6 id="会话Cookie与持久Cookie"><a href="#会话Cookie与持久Cookie" class="headerlink" title="会话Cookie与持久Cookie"></a>会话Cookie与持久Cookie</h6><p>从表面意思来说，会话Cookie就是把Cookie放在浏览器内存中，浏览器在关闭之后该Cookie即失效；持久Cookie则会保存到客户端的硬盘中，方便下一次使用，用于长久保持用户登录状态。</p>
<p>因此一些持久化登陆的网站其实就是把Cookie的有效时间和会话有效期设置得较长，下次我们再访问页面时仍然携带之前的Cookie，就可以直接保持登录状态。</p>
<h6 id="会话误区"><a href="#会话误区" class="headerlink" title="会话误区"></a>会话误区</h6><p>在谈论会话机制时，人们认为“只要关闭浏览器，会话就会消失”。可以想象一下会员卡的例子除非顾客主动对店家提出销卡，否则店家绝不会轻易删除顾客的资料。对会话来说，也是一样，除非程序通知服务器删除一个会话，否则服务器会一直保留。比如，程序一般都是在我们做注销操作时才去删除会话。</p>
<p>但是当我们关闭浏览器时，浏览器不会主动在关闭之前通知服务器他将关闭，所以服务器根本不会有机会知道浏览器已经关闭。之所以会有这种错觉是因为大部分会话机制都使用会话Cookie来保存会话ID信息，而关闭浏览器后Cookies就消失了，再次连接服务器时，也就无法找到原来的会话了。如果服务器设置的Cookies保存到硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的Cookies发送给服务器，则再次打开浏览器能找到原来的会话ID，依旧还是可以保持登录状态的。</p>
<p>而恰恰是由于关闭浏览器不会导致会话被删除，这就需要服务器为会话设置一个失效的时间，当距离客户端上一次使用会话的时间时，服务器就可以认为客户端已经停止了活动，才会把会话删除以节省存储空间。</p>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><h6 id="代理的基本原理"><a href="#代理的基本原理" class="headerlink" title="代理的基本原理"></a>代理的基本原理</h6><p>我们在做爬虫时经常会遇到这种情况，最初爬虫正常运行，但过一会就报403Forbidden错误，可能会看到“您的IP访问频率太高”这样的提示，原因是网站采取了反爬虫措施。比如，服务器会检测某个IP在单位时间内的请求次数，如果超过了这个阈值就会直接拒绝服务，返回一些错误信息，这种情况称为封IP。这时就可以采用代理来实现IP伪装。</p>
<p>代理实际是代理服务器，proxy server，功能是代理网络用户去取得网络信息，形象地说是网络信息的中转站，在我们正常请求一个网站时，是发送了请求给Web服务器，WEb服务器把响应传回给我们。如果设置了代理服务器，实际上就是在本机和服务器之间架一座桥，此时本机不是直接向Web服务器发起请求，而是向代理服务器发起请求，请求会发送给代理服务器，然后由代理服务器再发送给Web服务器，接着由代理服务器再把Web服务器返回的响应转发给本机，这样就可正常访问网页了，但这个过程中Web服务器识别出的真实IP就不再是我们本机的IP了，就成功实现了IP伪装，这就是代理的原理。</p>
<p><strong>使用代理隐藏真实的IP，让服务器误以为是代理服务器在请求自己，这样在爬取过程中不断更换代理就不会被封锁，可达到很好的效果</strong>。</p>
<h6 id="代理作用："><a href="#代理作用：" class="headerlink" title="代理作用："></a>代理作用：</h6><ol>
<li><p>突破自身限制，访问一些平时不能访问的站点。</p>
</li>
<li><p>访问一些单位或团体内部资源：比如使用教育网内地址段访问免费代理服务器，就可以实现对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。</p>
</li>
<li><p>提高访问速度：通常代理服务器都设置了一个较大的硬盘缓存区，当有外界的信息通过时，同时也将其保存到缓存区中，当其他用户再访问相同的信息时，则直接由缓存区中取出信息，传给用户，以提高访问速度。</p>
</li>
<li><p>隐藏真实的IP:上网者也可以通过这种方法隐藏自己的IP免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身IP，防止自身的IP被封锁。</p>
</li>
</ol>
<h6 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h6><ol>
<li><p>根据协议区分：</p>
<p>FTP 代理服务器： 主要用于访问 TP 服务器， 般有上传 下载以及 存功能，端口一般为21 212</p>
<p>HTTP 代理服务器： 主要用于访问网页，一般有内容过滤和缓存功能，端口 般为 80  8080 3128</p>
<p>SSL LS 代理： 主要用于访问加密网站， 般有 SSL TLS 加密功能（最高支持 128 位加密强度），端口一般为 443</p>
<p>RTSP 代理： 主要用于访问 Real 流媒体服务器， 般有缓存功能，端口 般为 554</p>
<p>Telnet 代理： 主要用于 telnet 远程控制（黑客人侵计算机时常用于隐藏身份），端口 般为 23</p>
<p>POP3/SMTP 代理： 主要用于 POP3 SMTP 方式收发邮件， 般有缓存功能，端口 般为 110 25</p>
<p>SOCKS 代理： 只是单纯传递数据包，不关心具体协议和用法，所以速度快很 般有存功能，端口一般为 1080  SOCKS 代理协议又分为 SOCKS4 SOCKS5 ，前者只支持 TCP,而后者支持 TC UDP ，还支持各种身份验证机制、服务器端域名解析 简单来说，SOCKS4 能做到的 SOCKS5 都可以做到，但 SOCKS5 能做到的 SOCKS4 定能做到</p>
</li>
<li><p>根据匿名程度区分</p>
<p>高度匿名代理： 会将数据包原封不动地转发，在服务端看来就好像真的是 个普通客户端访问，而记录的 IP 是代理服务器的 IP</p>
<p>普通匿名代理： 会在数据包上做一些改动 服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实 代理服务器通常会加入的 Hπ？头有 HTTP VIA HTTP X FOR DED FOR</p>
<p>透明代理： 不但改动了数据包 还会告诉服务器客户端的真实 IP 这种代理除了能用缓存技术提高浏览速度，能用内容过滤提高安全性之外，并无其他显著作用，最常见的例子是内网的硬件防火墙</p>
<p>间谍代理： 指组织或个人创建的用于记录用户传输的数据，然后进行研究 监控 目的的代理服务器。</p>
</li>
</ol>
<h4 id="基本库"><a href="#基本库" class="headerlink" title="基本库"></a>基本库</h4><h6 id="使用urllib"><a href="#使用urllib" class="headerlink" title="使用urllib"></a>使用urllib</h6><p>urllib库是Python内置的HTTP请求库，不需安装即可使用。包含4个模块：</p>
<ol>
<li>request：它是最基本的 HTTP 请求模块，可以用来模拟发送请求 就像在浏览器里输入网址然后回车一样，只需要给库方法传入 RL 及额外的 数，就可以模拟实现这个过程了</li>
<li>error 异常处理模块，如果出现请求错误 可以捕获这些异常，然后进行重试或作以保证程序不会意外终止</li>
<li>parse 个工具模块，提供了许多 URL 处理方法，比如拆分、解析 合并</li>
<li>robot parser ：主要是用来识别网站的 robots.txt 文件，然后判断哪些网站可以爬，它其实用得 较少。</li>
</ol>
<h6 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h6><p>使用urllib的request模块方便实现请求的发送并得到响应。利用它可模拟浏览器的一个请求发起过程，同时他还带有处理授权验证（authentication），重定向（redirection），浏览器的Cookies以及其他内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">response = urllib.request.urlopen(<span class="string">'https://www.python.org'</span>)</span><br><span class="line">print(response);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>利用最基本的<code>urllib.request.urlopen(url,data=None,[timeout,]*,cafile=None,capath=None,cadefault-False,context=None)</code>方法，可以完成最基本的简单网页的GET请求抓取。</p>
</li>
<li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">urllib</span>.<span class="title">request</span>.<span class="title">Request</span><span class="params">(url,data=None,headers=&#123;&#125;,origin_req_host=None,unveriable,method=Node)</span></span></span><br></pre></td></tr></table></figure>

<p>url为必传参数，data要传时必须传bytes（字节流）类型，若为字典，可用<code>urllib.parse</code>模块的<code>urlencode()</code>编码。</p>
<p>headers是一个字典，它是一个请求头，我们可以在构造函数请求时通过headers参数直接构造，也可以通过调用请求实例的add_header()方法添加。添加请求头最常用的方法就是通过修改User-Agent来伪装浏览器，默认的User-Agent是Python-urllib，我们可以通过修改它来伪装浏览器。比如伪装成火狐浏览器，可将它设置为：<code>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:76.0) Gecko/20100101 Firefox/76.0</code>。</p>
<p>origin_req_host指的是请求方的host名称或者IP地址。</p>
<p>unverifiable表示这个请求是否是无法通过验证的，默认是False，意思是说用户没有足够的权限来选择接受这个请求的结果。如：我们请求一个HTML文档中的图片，但是我们没有自动抓取图像的权限，这是unverifiable的值就是true。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,parse</span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:76.0) Gecko/20100101 Firefox/76.0'</span>,</span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'httpbin.org'</span></span><br><span class="line">&#125;</span><br><span class="line">dict = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Germy'</span></span><br><span class="line">&#125;</span><br><span class="line">data = bytes(parse.urlencode(dict),encoding=<span class="string">'utf8'</span>)</span><br><span class="line">req = request.Request(url=url,data=data,headers=headers,method=<span class="string">'POST'</span>)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(<span class="string">'utf8'</span>))</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-python的学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/07/python的学习/" class="article-date">
      <time datetime="2020-05-07T14:00:45.000Z" itemprop="datePublished">2020-05-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/07/python的学习/">python的学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>rmdir    删除目录</p>
<p>ipconfig      查看IP地址</p>
<p>ping         测试网络连接</p>
<p>python       进入python环境</p>
<p>exit()           退出环境</p>
<p>cd   指定目录</p>
<p>dir   浏览目录</p>
<p>mkdir   创建新的目录</p>
<h6 id="pip包管理命令"><a href="#pip包管理命令" class="headerlink" title="pip包管理命令"></a>pip包管理命令</h6><p>pip list     列出匹配管理的包有哪些</p>
<p>pip install   包名      </p>
<p>pip  install  redis == 3.0.2 </p>
<p>pip   uninstall   包名        卸载</p>
<p>pip  -v       查看版本</p>
<p>pip  freeze &gt;  requirements.txt       将项目依赖的包输出到指定的requirements.txt中</p>
<p>pip  install   -r   requirements.txt     使用pip安装requirements.txt中依赖的文件，其中<code>-r</code>指requirements.txt文件</p>
<h6 id="安装requests"><a href="#安装requests" class="headerlink" title="安装requests"></a>安装requests</h6><p>requests是第三方库，python默认不会自带这个库。</p>
<ol>
<li>git clone https ://github.com/kennethreitz/requests</li>
<li>cd  requests</li>
<li>python  setup.py  install</li>
</ol>
<h6 id="安装Selenium"><a href="#安装Selenium" class="headerlink" title="安装Selenium"></a>安装Selenium</h6><p>Selenium是一个自动化测试工具，利用它我们可以驱动浏览器执行特定的动作，如点击，下拉等操作。对于一些js渲染的页面来说，这种抓取方式很有效。</p>
<h6 id="print"><a href="#print" class="headerlink" title="print"></a>print</h6><p>print(value, …, sep=’  ‘，end=’\n’, file=sys.stdout, flush=False)        </p>
<p>sep默认的分隔符是空格</p>
<h4 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h4><h6 id="数与表达式"><a href="#数与表达式" class="headerlink" title="数与表达式"></a>数与表达式</h6><p>乘方运算符的优先级比求负（单目减）高，因此<code>-3**2等价于-（3**2)</code>。如果要计算的是<code>(-3)**2</code>,必须明确指出。</p>
<p>十六进制：0xAF</p>
<p>八进制：010</p>
<p>二进制：0b101011</p>
<p>2 / 4          # 除法，得到一个浮点数</p>
<p>2 // 4          # 除法，得到一个整数</p>
<p>2 ** 5            # 乘方   32</p>
<p>用a + bj,或者complex(a,b)表示复数。</p>
<p><strong>注意</strong></p>
<p>1、Python可以同时为多个变量赋值，如a, b = 1, 2。</p>
<p>2、一个变量可以通过赋值指向不同类型的对象。</p>
<p>3、数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。</p>
<p>4、在混合计算时，Python会把整型转换成为浮点数。</p>
<h6 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h6><ul>
<li>Number数字</li>
<li>String字符串</li>
<li>List列表</li>
<li>Tuple元组</li>
<li>Set集合</li>
<li>Dictionary字典</li>
</ul>
<p>有四种数字类型</p>
<ol>
<li>int整数</li>
<li>bool布尔</li>
<li>float浮点数</li>
<li>complex复数</li>
</ol>
<p><strong>判断类型</strong></p>
<p>type（a） ：判断a的数据类型，不会认为子类是一种父类类型。</p>
<p>isinstance（a,int）：判断a是否为int类型，会认为子类是一种父类类型。</p>
<p>del  val_a, var_b      删除单个或多个对象。</p>
<h6 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h6><p>str=’Runoob’  print(str)                 # 输出字符串 </p>
<p>print(str[0:-1])           # 输出第一个到倒数第二个的所有字符 </p>
<p>print(str[0])              # 输出字符串第一个字符 </p>
<p>print(str[2:5])            # 输出从第三个开始到第五个的字符 </p>
<p>print(str[2:])             # 输出从第三个开始后的所有字符 </p>
<p>print(str * 2)             # 输出字符串两次 </p>
<p>print(str + ‘你好’)        # 连接字符串</p>
<p>print(‘hello\nrunoob’)      # 使用反斜杠()+n转义特殊字符 </p>
<p>print(r’hello\nrunoob’)     # 在字符串前面添加一个 r，表示原始字符串，不会发生转义</p>
<p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 <strong>end=””</strong></p>
<p>print(x)    # 换行输出</p>
<p>print(x,end=” “)        # 不换行输出</p>
<h6 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h6><p>import somemodule         导入整个模块</p>
<p>from somemodule import firstfunc, secondfunc, thirdfunc        从某个模块中导入多个函数</p>
<h6 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h6><p>不可用作任何标识符名称。Python的标准库提供了一个keyword模块，可输出当前版本的所有关键字。</p>
<h6 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h6><p>单行以<code>#</code>开头，多行用三个单或双引号包裹。</p>
<h4 id="urllib库"><a href="#urllib库" class="headerlink" title="urllib库"></a>urllib库</h4><p>python内置的HTTP请求库</p>
<h6 id="request解析库"><a href="#request解析库" class="headerlink" title="request解析库"></a>request解析库</h6><p>urlopen：打开网址</p>
<h6 id="bs4解析库"><a href="#bs4解析库" class="headerlink" title="bs4解析库"></a>bs4解析库</h6><p>bs4: BeautifulSoup</p>
<p>用于解析网页，提取指定数据的。接口简单，较人性化，但bs4只能解析html格式的数据。</p>
<p><strong>BeautifulSoup类</strong></p>
<p>文件解析库：</p>
<p>‘html.parser’：是python自带的一个文件解析库。</p>
<p>‘lxml’：是一个第三方文件解析库，需安装。</p>
<p>根据html标签查找信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content = soup.find(&apos;div&apos;,itemprop=&apos;acticleBody&apos;).text</span><br></pre></td></tr></table></figure>

<p><strong>find()</strong> <strong>方法：返回第一个匹配的内容，为字符串类型</strong></p>
<p>find(name,attrs,recursive,text,**kwargs)</p>
<p>这五个参数都可以<strong>充当过滤器</strong>，提高匹配结果的精确度。</p>
<p><strong>find_all()</strong> <strong>方法：返回所有匹配的项，为一个列表类型</strong></p>
<p>find(name,attrs,recursive, text,<strong>limit</strong>,**kwargs)</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h6 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip install MyQR</span><br><span class="line"></span><br><span class="line">from MyQR Simport myqr</span><br><span class="line">words:  文本，链接地址或字符串</span><br><span class="line">picture：二维码的背景图片</span><br><span class="line">colorized：True，表示生成彩图</span><br><span class="line">save_name: 表示生成的二维码的名字</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from MyQR import myqr</span><br><span class="line">myqr.run(</span><br><span class="line">    words=&quot;https://www.icourse163.org/learn/NHDX-1449955168&quot;,</span><br><span class="line">    picture=&quot;1.png&quot;,</span><br><span class="line">    colorized=True,</span><br><span class="line">    save_name=&quot;ORMooc.png&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h6 id="个人名片"><a href="#个人名片" class="headerlink" title="个人名片"></a>个人名片</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pip install Segno</span><br><span class="line"></span><br><span class="line">from segno import helpers</span><br><span class="line">qr = helpers.make_mecard(</span><br><span class="line">    name=&apos;Erin&apos;,</span><br><span class="line">    city=&apos;湖南省衡阳市南华大学&apos;,</span><br><span class="line">    phone=&apos;1581529632&apos;,</span><br><span class="line">    email=&apos;3511564414@qq.com&apos;</span><br><span class="line">)</span><br><span class="line">qr.save(&apos;Erin名片.png&apos;,scale=10)</span><br></pre></td></tr></table></figure>

<h6 id="爬取小说"><a href="#爬取小说" class="headerlink" title="爬取小说"></a>爬取小说</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(&apos;http://www.39shubao.com/&apos;)</span><br><span class="line">print(response.read().decode(&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure>

<p><strong>报错</strong>：<code>UnicodeDecodeError: &#39;utf-8&#39; codec can&#39;t decode byte 0x8b in position 1: invalid start byte</code></p>
<p>所以去掉解码格式utf-8，<strong>输出的字节码可以看到它是以”b’\x1f\x8b\x08”开头的 ，说明它是gzip压缩过的数据，这也是报错的原因，所以我们需要对我们接收的字节码进行一个解码操作。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line">from io import BytesIO</span><br><span class="line">import gzip</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(&apos;http://www.39shubao.com/&apos;)</span><br><span class="line">buff = BytesIO(response.read())</span><br><span class="line">f = gzip.GzipFile(fileobj=buff)</span><br><span class="line">htmls = f.read().decode(&apos;utf-8&apos;)</span><br><span class="line">print(htmls)</span><br></pre></td></tr></table></figure>

<p><strong>解决乱码问题</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">'http://www.shuquge.com/txt/63542/9645082.html'</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>

<p>通过response.text拿到的数据出现乱码是因为该网页对数据进行加密，所以直接拿到的数据乱码了。</p>
<p>解决：</p>
<p>方法一：使用较老的方法<code>response.encoding=&#39;utf-8&#39;</code>，只能解决utf-8的乱码，其他格式的不能解决。</p>
<p>方法二：<code>response.encoding=response.apparent_encoding</code>，自动解决乱码格式，不仅utf-8格式的可解决，gbk格式的也可解决。</p>
<p>未封装的爬一章小说</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"># 使用parsel来解析网页内容</span><br><span class="line">import parsel</span><br><span class="line">url = &apos;http://www.shuquge.com/txt/63542/9645082.html&apos;</span><br><span class="line">response = requests.get(url)</span><br><span class="line"># 自动解决乱码问题</span><br><span class="line">response.encoding = response.apparent_encoding</span><br><span class="line"># print(response.text)</span><br><span class="line"># 把网页数据结构化</span><br><span class="line">sel = parsel.Selector(response.text)</span><br><span class="line"># 根据css选择器提取标题</span><br><span class="line">title = sel.css(&apos;.content &gt; h1::text&apos;).get()</span><br><span class="line"># 根据css路径提取内容</span><br><span class="line">content = sel.css(&apos;#content::text&apos;).getall()</span><br><span class="line"># 根据xPath提取内容,getall是提取全部的内容，也有re方法，用于匹配正则里面的内容</span><br><span class="line"># print(sel.xpath(&apos;//div[@id=&quot;content&quot;]/text()&apos;).getall())</span><br><span class="line"># 保存数据</span><br><span class="line">with open(title + &apos;.txt&apos;,mode=&apos;w&apos;, encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">    f.write(title)</span><br><span class="line">    # 用切片去掉最后三行</span><br><span class="line">    for con in content[:-3]:</span><br><span class="line">        # str使用replace去除空格</span><br><span class="line">        f.write(con.replace(&apos;\xa0&apos;,&apos;&apos;))</span><br><span class="line">        # f.write(con.strip(&apos;\xa0&apos;))</span><br></pre></td></tr></table></figure>

<h6 id="动态爬取数据"><a href="#动态爬取数据" class="headerlink" title="动态爬取数据"></a>动态爬取数据</h6><p>数据信息不是存放在网页源代码中，它是一个动态更新的网站，需要实时更新的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">url = &apos;https://api.inews.qq.com/newsqa/v1/automation/foreign/country/ranklist&apos;</span><br><span class="line">response = requests.get(url)</span><br><span class="line">content = json.loads(response.text)</span><br><span class="line">print(content[&apos;data&apos;])</span><br><span class="line">df = pd.DataFrame(columns=[&apos;国家及地区&apos;,&apos;确诊人数&apos;,&apos;死亡病例&apos;,&apos;治愈病例&apos;])</span><br><span class="line">for i in range(len(content[&apos;data&apos;])):</span><br><span class="line">    df.loc[i + 1] = [content[&apos;data&apos;][i][&apos;name&apos;],</span><br><span class="line">                     content[&apos;data&apos;][i][&apos;confirm&apos;],</span><br><span class="line">                     content[&apos;data&apos;][i][&apos;dead&apos;],</span><br><span class="line">                     content[&apos;data&apos;][i][&apos;heal&apos;]]</span><br><span class="line">df.to_csv(&apos;F://data.csv&apos;,index=0,encoding=&apos;utf-8&apos;)</span><br><span class="line">print(&apos;爬取完成&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-AJAX学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/30/AJAX学习/" class="article-date">
      <time datetime="2020-04-30T03:04:57.000Z" itemprop="datePublished">2020-04-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/30/AJAX学习/">AJAX学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h4><h6 id="AJAX优缺点"><a href="#AJAX优缺点" class="headerlink" title="AJAX优缺点"></a>AJAX优缺点</h6><p>浏览器可以从服务器同时请求多项内容，利用异步请求可以确保浏览器在后台工作，避免因完全页面刷新而中断用户的工作。</p>
<p>浏览器请求返回的速度会快得多，只是在有些情况下如此而已，请求和响应的速度取决于服务器返回的内容。AJAX页面完全有可能比传统页面的速度更慢。</p>
<p>不能够更真实的渲染颜色，因为颜色渲染由用户监视器控制而不是由用户支配。</p>
<p>只有页面真正改变部分会得到更新。</p>
<p>会减少服务器数据流量，利用AJAX可以建立更小更集中的请求。不过要当心……这也很容易导致建立更多的请求以至于增大数据流量，因为可能要一部建立所有这些请求。</p>
<p>页面的不兼容问题会更严重，由于除了XHTML外，AJAX页面还依赖于其它一些技术，所以使用AJAX后的兼容性问题实际会更严重。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-node进阶" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/30/node进阶/" class="article-date">
      <time datetime="2020-04-30T02:30:22.000Z" itemprop="datePublished">2020-04-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/30/node进阶/">node进阶</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h6 id="单线程的弱点"><a href="#单线程的弱点" class="headerlink" title="单线程的弱点"></a>单线程的弱点</h6><ol>
<li>无法利用多核CPU。</li>
<li>错误会引起整个应用退出，应用的健壮性值得考虑。</li>
<li>大量计算占用CPU导致无法继续调用异步I/O。</li>
</ol>
<p>像浏览器中JavaScript与UI共用一个线程一样，JavaScript长时间执行会导致UI渲染和响应被中断。在Node中，长时间的CPU占用也会导致后续异步I/O发不出调用，已完成的异步I/O的回调函数也会得不到及时执行。</p>
<p>Node采用了与Web Workers相同的思路来解决单线程中大计算量的问题：child_process。</p>
<p>子进程的出现，意味着Node可以从容地应对单线程在健壮性和无法利用多核CPU方面的问题。通过计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好的保持应用模型的简单和地低依赖。通过Master-Worker的管理方式，也可以很好地管理各个工作进程，以达到更高的的健壮性。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-http进阶" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/30/http进阶/" class="article-date">
      <time datetime="2020-04-29T23:40:38.000Z" itemprop="datePublished">2020-04-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/30/http进阶/">http进阶</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h6 id="Telnet实例"><a href="#Telnet实例" class="headerlink" title="Telnet实例"></a>Telnet实例</h6><p>由于Http使用的是TCP/IP传输协议，而且它是基于文本的，没有使用哪些难以理解的二进制格式，因此很容易直接1与Web服务器进行对话。</p>
<p>Telnet程序可以将键盘连接到某个目标TCP端口，并将此TCP端口的输出回送到显示屏上。Telnet常用于远程终端会话，但它几乎可以连接所有的TCP服务器，包括HTTP服务器。</p>
<h4 id="Web结构组件"><a href="#Web结构组件" class="headerlink" title="Web结构组件"></a>Web结构组件</h4><ol>
<li>代理：位于客户端和服务器之间的HTTP中间实体。</li>
<li>缓存：HTTP的仓库，是常用页面的副本可以存在离客户端更近的地方。</li>
<li>网关：连接应用程序的特殊Web服务器。</li>
<li>隧道：对HTTP通信报文进行盲转发的特殊代理。</li>
<li>Agent代理：发起自动HTTP请求的半智能Web客户端。</li>
</ol>
<h6 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h6><p>HTTP代理服务器是Web安全，应用集成以及性能优化的重要组成模块。</p>
<p>代理位于客户端与服务器之间，接收所有客户端的HTTP请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。</p>
<p>出于安全考虑，通常会将代理作为转发所有Web流量的可信任中间节点使用。代理还可以对请求和响应进行过滤。比如，在企业中对下载的应用程序进行病毒检测，或者对小学生屏蔽一些成人才能看的内容。</p>
<h6 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h6><p>WEb缓存（Web cache）或代理缓存（proxy cache）是一种特殊的HTTP代理服务器，可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了。</p>
<h6 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h6><p>网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用，通常用于将HTTP流量转换成其他的协议。网关接受时就好像自己是咨议员的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。</p>
<p>如：一个HTTP/FTP网关会通过HTTP请求接受对FTP URI的请求，但通过FTP协议来获取文档。得到的文档会被封装成一条HTTP报文发给客户端。</p>
<h6 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h6><p>隧道（tunnel）是建立起来之后就会在两条连接之间对原始数据进行盲转发的HTTP应用程序。HTTP隧道通常用来在一条或多条HTTP连接上进行转发非HTTP数据，转发时不会窥探数据。</p>
<p>HTTP隧道的一种常见用途是通过HTTP连接承载加密的安全套接字层（SSL,Secure Socket Layout)流量，这样ssl流量就可以穿过只允许Web流量通过的防火墙了。</p>
<p><img src="C:%5CUsers%5CCCY%5CDesktop%5C%E9%9A%A7%E9%81%93.png" alt="隧道"></p>
<p>如：HTTP/SSL隧道收到一条HTTP请求，要求建立一条到目的的地址和端口的输出连接，然后在HTTP信道上通过隧道传输加密的SSL流量，这样就可以将其转发到目的服务器上。</p>
<h6 id="Agent代理"><a href="#Agent代理" class="headerlink" title="Agent代理"></a>Agent代理</h6><p>用户代理是代表用户发起HTTP请求的客户端程序。所有发布Web请求的应用程序都是HTTP Agent代理。到目前为止，我们只提过一种HTTP Agent代理：WEb浏览器，但用户Agent代理还有很多类型。</p>
<p>如：有些自己会在Web上闲逛的自动用户Agent代理，可以在无人监视的情况下发布HTTP事务并获取内容。这些自动代理的名字很生动，比如“网络蜘蛛”或“web机器人”。网络蜘蛛会在WEb上闲逛，搜集信息以构建有效的Web内容档案，比如一个搜索引擎的数据库或者为比较购物机器人生成的产品目录。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200430094207000.png" alt="image-20200430094207000"></p>
<h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><p>请求报文格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;method&gt;     &lt;request-URL&gt;  &lt;version&gt;</span><br><span class="line">&lt;headers&gt; </span><br><span class="line">&lt;entrity-body&gt;</span><br></pre></td></tr></table></figure>

<p>响应报文</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;version&gt;   &lt;status&gt;   &lt;response-phrase&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line">&lt;entrity-body&gt;</span><br></pre></td></tr></table></figure>

<h6 id="方法（method）"><a href="#方法（method）" class="headerlink" title="方法（method）"></a>方法（method）</h6><p>客户端希望服务器对资源执行的动作，是一个单独的词，比如GET,HEAD或POST.</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>是否包含主体</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>从服务器获取一份文档</td>
<td>否</td>
</tr>
<tr>
<td>HEAD</td>
<td>只从服务器获取文档的首部</td>
<td>否</td>
</tr>
<tr>
<td>POST</td>
<td>向服务器发送需要处理的数据</td>
<td>是</td>
</tr>
<tr>
<td>PUT</td>
<td>将请求的主体部分存储在服务器上</td>
<td>是</td>
</tr>
<tr>
<td>TRACE</td>
<td>对可能经过代理服务器传送到服务器上去的报文进行追踪</td>
<td>否</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>决定可以在服务器上执行哪些方法</td>
<td>否</td>
</tr>
<tr>
<td>DELETE</td>
<td>从服务器上删除一份文档</td>
<td>否</td>
</tr>
</tbody></table>
<p><strong>扩展方法</strong>：指的是没有在HTTP/1.1规范中定义的方法，服务器会为它所管理的资源实现一些二HTTP服务，这些方法为开发者提供了一种扩展这些HTTP服务能力的手段。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LOCK</td>
<td>允许用户“锁定”资源——比如，可以在编辑某个资源的时候将其锁定，以防别人对其进行修改。</td>
</tr>
<tr>
<td>MKCOL</td>
<td>允许用户创建资源</td>
</tr>
<tr>
<td>COPY</td>
<td>便于在服务器上复制资源</td>
</tr>
<tr>
<td>MOVE</td>
<td>在服务器上移动资源</td>
</tr>
</tbody></table>
<p>惯例：对所发送的内容要求严一点，对接收的内容宽容一些处理扩展方法。</p>
<ol start="2">
<li><p>请求URL(request-URL)</p>
<p>命名了所有请求资源，或者URL路径组件的完整URL。如果直接与服务器进行对话，只要URL的路径组件是资源的绝对路径，通常就不会有什么问题——服务器可以假定自己是URL的主机/端口。</p>
</li>
<li><p>版本（version）</p>
</li>
<li><p>状态码（status-code）</p>
<p>这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般类型（“成功”、“出错”）。</p>
<p><strong>状态码分类</strong></p>
<table>
<thead>
<tr>
<th>整体范围</th>
<th>已定义范围</th>
<th>分类</th>
</tr>
</thead>
<tbody><tr>
<td>100-199</td>
<td>100-101</td>
<td>信息提示</td>
</tr>
<tr>
<td>200-299</td>
<td>200-206</td>
<td>成功</td>
</tr>
<tr>
<td>300-399</td>
<td>300-305</td>
<td>重定向</td>
</tr>
<tr>
<td>400-499</td>
<td>400-415</td>
<td>客户端错误</td>
</tr>
<tr>
<td>500-599</td>
<td>500-505</td>
<td>服务器错误</td>
</tr>
</tbody></table>
<p><strong>常见状态码</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>成功。请求的所有数据都在响应主体中。</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized（未授权）</td>
<td>需要输入用户名和密码</td>
</tr>
<tr>
<td>404</td>
<td>Not Found（未找到）</td>
<td>服务器无法找到所请求URL对应的资源</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented（无法实现）</td>
<td></td>
</tr>
</tbody></table>
<p><strong>信息性状态码</strong>‘</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue</td>
<td>说明受到了请求的初始部分，请客户端继续，发送了这个状态码后，服务器在收到请求后必须进行响应。</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td>说明服务器正在根据客户端的指定，将协议切换成Update’首部所列的协议。</td>
</tr>
</tbody></table>
<p>100 Continue是一种优化，客户端应用程序只有在避免向服务器发送一个服务器无法处理或使用的大实体时才会使用100 Continue。当服务端超时一定时间后，客户端直接将实体发出去。</p>
<p><strong>成功状态码</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>请求没问题，实体的主体部分包含了所请求的资源</td>
<td>OK</td>
</tr>
<tr>
<td>201</td>
<td>用于创建对象的请求（PUT)。响应的主体部分包含各种已创建资源的URL，location首部包含则是最具体的引用。</td>
<td>Created</td>
</tr>
<tr>
<td>202</td>
<td>请求已被接受，但服务器还未对其执行任何动作，不能保证服务器会完成这个请求。</td>
<td>Accepted</td>
</tr>
<tr>
<td>203</td>
<td>实体部分包含的资源不是来自源服务器，而是来自资源的一份副本。如果中间节点上有一份资源副本，但无法对它所发送的与资源有关的元信息（首部）进行验证，就会出现这种情况。</td>
<td>Non-Authoritative-Information</td>
</tr>
<tr>
<td>204</td>
<td>响应报文中包含若干首部和一个状态行，但没有实体部分，主要用于在浏览器不转为显示新文档的情况下，对其将进行更新（如刷新一个表单页面）</td>
<td>No Content</td>
</tr>
<tr>
<td>205</td>
<td>另一个主要用于浏览器的代码，负责告诉浏览器清除当前页面中所有HTML表单元素。</td>
<td>Reset Content</td>
</tr>
<tr>
<td>206</td>
<td>成功执行一部分请求。稍后会看到，客户端可以通过一些特殊的首部来获取部分或某个范围内的文档——这个状态码就说明请求成功了。</td>
<td>Partial Content</td>
</tr>
</tbody></table>
<p><strong>重定向状态码</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>300</td>
<td>Multiple Choices</td>
<td>客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如服务器上有某个HTML文档的英语和法语版本。返回这个代码时会带有一个选项列表，这样用户就可以选择他希望使用的那一项了。有多个版本1可用时，客户端需要沟通解决。</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permananently</td>
<td>在请求的URL已被移除时使用。响应的Location首部中应该包含资源现在所处的URL。</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>与301状态码相似，但是客户端应该使用Location首部给出的URL来临时定位资源。将来的请求仍应使用老的URL。</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的Location首部。其主要目的是允许POST请求的响应将客户端定向到某个资源上去。</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>客户端可以通过所包含的请求首部，使其请求变成有条件的。如果客户端发起一个GET请求，而最近资源未被修改，就可用这个状态码来说明资源未被修改，带有这个状态吗的响应不应该包含实体的主体部分。</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>用来说明必须通过一个代理来访问资源，代理的位置由Location首部给出。很重要一点是，客户端是相对某个特定资源来解析这个响应的，不能假定所有请求，甚至所有对持有所请求资源的服务器的请求都通过这个代理进行。如果客户端错误的让代理介入了某条请求，可能会引发破环性的行为，而且会造成安全漏洞。</td>
</tr>
<tr>
<td>306</td>
<td>（未使用）</td>
<td>当前未使用</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>与301状态码相似，但是客户端应该使用Location首部给出的URL来临时定位资源。将来的请求仍应使用老的URL。</td>
</tr>
</tbody></table>
<p><strong>客户端错误</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>Bad Request</td>
<td>用于告诉客户端他发送了一个错误的请求</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>与适当的首部一同返回，在这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证。</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>现在这个状态码还未使用，但已经被保留，以作未来之用。</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>用以说明请求被服务器拒绝了，如果服务器想说明为什么拒绝请求，可以包含实体的主体部分来对原因进行描述。但这个状态通常是在服务器不想说明拒绝原因的时候使用的。</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>用于说明服务器无法找到所请求的URL。通常会包含一个实体以便客户端应用程序显示给用户看。</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>发起的请求中带所请求的URL不支持的方法时，使用此状态码。应该在响应中包含Allow首部，以告知客户端对请求的资源可以使用哪些方法。</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>客户端可以指定参数来说明他们愿意接受什么类型的实体。服务器没有与客户端可接受的URL相匹配的资源时，使用此代码。通常，服务器会包含一些首部以便客户端弄清楚为什么请求无法满足。</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>与401状态码类似，但用于要求对资源进行认证的代理服务器。</td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout</td>
<td>如果客户端完成请求所花的时间太长，服务器可以回送此状态码，并关闭连接。超时时长随服务器的不同而不同，但通常对所有合法请求来说都是够长的。</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>用于说明请求可能在资源上引发的一些冲突，服务器担心请求会引发冲突时可发送此状态码。响应中应该包含描述冲突的主体。</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>与404相似，只要服务曾经拥有过此资源。主要用于Web站点的维护，这样服务器的管理者就可以在资源被移除的情况下通知客户端了。</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>服务器要求在请求报文中包含Content-Length首部时使用。</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>客户端发起了条件请求且其中一个条件失败时使用。</td>
</tr>
<tr>
<td>413</td>
<td>Request Entrity Too Large</td>
<td>客户端发送实体主体部分比服务器能够或希望处理的要大时发送此状态码。</td>
</tr>
<tr>
<td>414</td>
<td>Request URL Too Long</td>
<td>客户端发送请求中的URL比服务器希望处理的要大时发送此状态码。</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器无法理解或无法支持客户端所发送实体的内容类型时</td>
</tr>
<tr>
<td>416</td>
<td>Unsupported Media Type</td>
<td>请求报文所请求的是指定资源的某个范围，而此范围无效或无法满足时使用此状态码。</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>请求的Expect请求首部包含了一个期望，但服务器无法满足此期望时，使用此状态码。如果代理或其他中间应用程序与确切证据说明源端服务器会为某请求产生一个失败的期望就可发送此状态码。</td>
</tr>
</tbody></table>
<p><strong>服务器错误</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器遇到一个妨碍它为请求提供服务的错误时使用此状态码。</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>客户端发起的请求超出服务器的能力范围。</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应（如，他无法链接到其父网关时）。</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>用来说明服务器现在不能为请求提供服务，但将来可以。如果服务器知道什么时候资源会变为可用的，可在响应中包含一个Retry-After首部。</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout</td>
<td>与状态码408相似，只是这里的响应来自一个网关或代理，他们在等待另一服务器对其请求进行响应时超时了。</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version Not Supported</td>
<td>服务器收到的请求使用了它无法或不愿支持的协议版本。有些服务器应用程序会选择不支持协议的早期版本。</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="5">
<li><p>原因短语（reason-phrase）</p>
<p>数字状态码的可读版本，包含行终止序列的所有文本。</p>
</li>
<li><p>首部（header）</p>
<p>可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号，然后是一个可选的空格，接着是一个值，最后是一个CRLF。首部是由一个空行结束的，表示了首部列表的结束和实体主体部分的开始。</p>
<p><strong>首部分类</strong></p>
<ul>
<li>通用首部：既可以出现在请求报文中，又可以出现在响应报文中。</li>
<li>请求首部：提供更多有关请求的信息。</li>
<li>响应首部：提供更多有关响应的信息。</li>
<li>实体首部：描述主体的长度和内容，或者资源自身。</li>
<li>扩展首部：规范中没有定义的新首部。</li>
</ul>
<p><strong>常见首部实例</strong></p>
<table>
<thead>
<tr>
<th>首部实例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Date：Tue,3 Oct 1997  02:16:03  GMT</td>
<td>服务器产生响应的日期</td>
</tr>
<tr>
<td>Content-length:15040</td>
<td>实体的主体部分包含了</td>
</tr>
<tr>
<td>Content-type:image/gif</td>
<td>实体的主体部分是一个GIF图片</td>
</tr>
<tr>
<td>Accept:image/gif, image/jpeg, text/html</td>
<td>客户端可以接收</td>
</tr>
<tr>
<td>Connection</td>
<td>允许客户端和服务器指定与请求或响应连接有关的选项。</td>
</tr>
<tr>
<td>MIME-Version</td>
<td>给定发送端使用的MIME版本。</td>
</tr>
<tr>
<td>Trailer</td>
<td>如果报文采用了分块传输编码（chunked transfer encoding）方式就可以用这个首部列出位于报文拖挂（trailer）部分的首部集合。</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>告知接收端为了保证报文可靠传输，对报文采取什么编码方式。</td>
</tr>
<tr>
<td>Update</td>
<td>给出了发送端可能想要“升级”使用的新版本或协议。</td>
</tr>
<tr>
<td>Via</td>
<td>显示了报文经过的中间节点（代理，网关）</td>
</tr>
</tbody></table>
</li>
<li><p>实体的主体部分（entrity-body）</p>
<p>实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分。</p>
</li>
</ol>
<h6 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h6><p>通用缓存首部：HTTP/1.0引入了第一个允许HTTP应用程序缓存对象本地副本的首部，这样就不需要总是直接从源端服务器获取了。</p>
<table>
<thead>
<tr>
<th>首部</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>用于随报文传送缓存指示。</td>
</tr>
<tr>
<td>Pragma</td>
<td>另一种随报文传送指示的方式，但并不专用于缓存。</td>
</tr>
</tbody></table>
<p><strong>请求首部</strong>：是只在请求报文中有意义的首部，用于说明是谁或什么在发送请求，请求源自何处，或者客户端的喜好和能力。服务器可以根据请求首部给出的客户端信息，试着为客户端提供更好的响应。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502215359440.png" alt="image-20200502215359440"></p>
<p><strong>Accept首部</strong>为客户端提供一种将其喜好和能力告知服务器的方式，包括它们想要什么，可以使用什么，以及最重要的，他们不想要什么，这样，服务器可以根据这些额外的信息，对要发送的内容做出更明智的决定。Accept首部会使连接的两端都受益。客户端会得到它们想要的内容，服务器则不会浪费时间和带宽来发送客户端无法使用的东西。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502220337984.png" alt="image-20200502220337984"></p>
<p><strong>条件请求首部</strong>：有时客户端希望为请求加上某些限制。比如，如果客户端已经有了一份文件副本就希望只在服务器上的文档与客户端拥有的副本有所区别时才请求服务器传输文档。通过条件请求首部，客户端就可以为请求加上这种限制，要求服务器在对请求进行响应前，确保某个条件为真。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502220845355.png" alt="image-20200502220845355"></p>
<p><strong>安全请求首部</strong></p>
<p>HTTP本身就支持一种简单的机制，可以对请求进行质询/响应认证。这种机制要求客户端在获取特定资源之前，先对自身进行认证，这样就可以使事务稍微安全一些。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502221420633.png" alt="image-20200502221420633"></p>
<p><strong>代理请求首部</strong></p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200502221552479.png" alt="image-20200502221552479"></p>
<h6 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h6><p>响应报文有自己的响应首部集。响应首部为客户端提供了一些额外信息，比如谁发送响应，响应者的功能，甚至与响应相关的一些特殊指令，这些首部有助于客户端处理响应，并在将来发起更好的请求。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200503080735091.png" alt="image-20200503080735091"></p>
<p><strong>协商首部</strong></p>
<p>如果资源有多种表示方法——如，若服务器上有某文档的法语和德语译稿，HTTP/1.1可以为服务器和客户端提供对资源进行协商的能力。</p>
<p><img src="C:%5CUsers%5CCCY%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200503082210004.png" alt="image-20200503082210004"></p>
<p><strong>安全响应首部</strong></p>
<table>
<thead>
<tr>
<th>首部</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Proxy-Authenticate</td>
<td>来自代理的对客户端的质询列表</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>不是真正的安全首部，但隐含有安全功能，可以在客户端设置一个令牌，以便服务器对客户端进行标识。</td>
</tr>
<tr>
<td>Set-Cookie2</td>
<td>与Set-Cookie类似</td>
</tr>
<tr>
<td>www-Authenticate</td>
<td>来自服务器的对客户端的质询列表</td>
</tr>
</tbody></table>
<h6 id="HTTP事务产生时延的原因"><a href="#HTTP事务产生时延的原因" class="headerlink" title="HTTP事务产生时延的原因"></a>HTTP事务产生时延的原因</h6><ol>
<li>客户端首先需要根据URI确定Web服务器的IP地址和端口号。如果最近没有对URI中的主机名进行访问，通过DNS解析系统将URI中的主机名转换成一个IP地址可能要花费数十秒的时间。</li>
<li>接下来，客户端会向服务器发送一条TCP连接请求，并等待服务器回送一个请求经接受应答。每条新的TCP连接都会有连接建立时延。这个值通常最多只有一两秒钟，但如果有数百个HTTP事务的话，这个值就会快速叠加上去。</li>
<li>一旦连接建立起来，客户端就会通过新建立的TCP管道来发送HTTP请求。数据到达时，Web服务器会从TCP链接中读取请求报文，并对请求进行处理。因特网传输请求报文，以及服务器请求报文都需要时间。</li>
<li>然后，Web服务器会回送HTTP响应，这也需要花费时间。</li>
</ol>
<p>注：大多数HTTP客户端都有一个小的DNS缓存,用来保存近期所访问站点的IP地址。如果已经在本地“缓存”了IP地址，查询就可立即完成，因为大多数Web浏览器浏览的是少数常用站点，所以通常可以很快将主机名解析出来。</p>
<p>TCP网络时延的大小取决于硬件速度，网络和服务器的负载，请求和响应报文的尺寸，以及客户端和服务器之间的距离。</p>
<h6 id="TCP连接握手步骤"><a href="#TCP连接握手步骤" class="headerlink" title="TCP连接握手步骤"></a>TCP连接握手步骤</h6><ol>
<li>请求新的TCP连接时，客户端要向服务器发送一个小的TCP分组（通常是40-60字节）。这个分组中设置了一个特殊的SYN标记，说明这是一个连接请求。</li>
<li>如果服务器接受了连接，就会对连接参数进行计算，并向客户端回送一个TCP分组，这个分组中的SYN和ACK标记都被置位，说明连接请求已被接受。</li>
<li>最后，客户端向服务器回送一条确认消息，通知他连接已成功建立，现代的TCP栈都允许客户端在这个确认分组中发送消息。</li>
</ol>
<p>小的HTTP事务可能会在TCP建立上花费50%，或更多的时间</p>
<h6 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h6><p>由于因特网自身无法确保可靠的分组传输（因特网路由器超负荷的话，可以随意丢弃分组），所以TCP实现了自己的确认机制来确保数据的成功传输。</p>
<p>每个TCP段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段时，都会向发送者回送小的确认分组。如果发送者，欸有在指定的窗口时间内收到确认信息，发送者就会认为分组已被破环或损毁，并重发数据。</p>
<p>由于u企鹅人保温很小，所以TCP允许在发往相同方向的输出数据分组中对其进行“捎带”。TCP将将返回的确认信息与输出的数据分组结合在一起，可以更有效利用网络。为了增加确认报文找到同向传输数据分组的可能性，很多TCP栈都实现了一种延迟确认算法。延迟确认算法会在一个特定的窗口时间内将输出确认缓存放在缓存区中，以寻找能够捎带他的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。</p>
<p>但是，HTTP具有双峰特征的请求——应答行为就降低了捎带信息的可能。当希望有相反方向回传分组的时候，偏偏没有那么多。通常，延迟确认算法会引起相当大的时延。根据所使用的操作系统的不同，可以调整或禁止延迟确认算法。</p>
<p>在对TCP栈的任何参数进行修改之前，一定要对袭击在做什么会有清晰的了解。TCP中引入这些算法的目的是为了防止设计欠佳的应用程序对因特网造成破环。对TCP配置进行任意修改都要绝对确保应用程序不会引发这些i算法所要避免的问题。</p>
<h6 id="TCP慢启动"><a href="#TCP慢启动" class="headerlink" title="TCP慢启动"></a>TCP慢启动</h6><p>TCP数据传输的性能还取决于TCP连接的使用期。TCP连接会随着时间进行自我“调谐”，起初还会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度，这种调谐被称为TCP慢启动，用于防止因特网的突然过载和拥塞。</p>
<p>TCP慢启动限制了一个TCP端点在任意时刻可以传输的分组数。简单来讲是每成功接收一个分组，发送端就有了发送另外两个分组的权限。如果某个HTTP事务有大量的数据要发送，是不能依次将所有分组都发送出去的，必须发送一个分组，确认后才可以再发。这种方式是”打开拥塞窗口“。</p>
<p>由于存在这种拥塞控制特性，所以新连接的传输速度会比已经交换过一定数据量的，“已调谐”连接慢一些。由于已调谐连接要更快一些，所以HTTP中有一些可以重用现存连接的工具。即HTTP“持久连接”。</p>
<h6 id="提高HTTP连接性能的四类方法"><a href="#提高HTTP连接性能的四类方法" class="headerlink" title="提高HTTP连接性能的四类方法"></a>提高HTTP连接性能的四类方法</h6><ol>
<li>并行连接</li>
<li>持久连接</li>
<li>管道化连接</li>
<li>复用连接</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ES6的学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/28/ES6的学习/" class="article-date">
      <time datetime="2020-04-28T06:51:11.000Z" itemprop="datePublished">2020-04-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/ES6的学习/">ES6的学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 陈楚吟
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
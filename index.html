<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="陈楚吟">


    
    


<meta name="description" content="将学习技术点汇总">
<meta name="keywords" content="write myBlog">
<meta property="og:type" content="website">
<meta property="og:title" content="Nikita">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Nikita">
<meta property="og:description" content="将学习技术点汇总">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nikita">
<meta name="twitter:description" content="将学习技术点汇总">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Nikita" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Nikita</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">陈楚吟</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不负韶华</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">陈楚吟</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">陈楚吟</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不负韶华</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-数组中的reduce" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/23/数组中的reduce/" class="article-date">
      <time datetime="2020-06-23T13:04:21.000Z" itemprop="datePublished">2020-06-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/23/数组中的reduce/">数组中的reduce</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>reduce作为es5新增的常规数组方法之一，却比forEach，filter和map更强大。</p>
<ul>
<li>它是对数组中的每个元素执行一个自定义的累计器，将结果汇总为单个返回值。</li>
</ul>
<ul>
<li>形式：<code>array.reduce((t, v, i, a) =&gt; {}, initValue)</code></li>
<li>参数<ul>
<li><strong>callback</strong>：回调函数(<code>必选</code>)</li>
<li><strong>initValue</strong>：初始值(<code>可选</code>)</li>
</ul>
</li>
<li>回调函数的参数<ul>
<li><strong>total</strong>(<code>t</code>)：累计器完成计算的返回值(<code>必选</code>)</li>
<li><strong>value</strong>(<code>v</code>)：当前元素(<code>必选</code>)</li>
<li><strong>index</strong>(<code>i</code>)：当前元素的索引(<code>可选</code>)</li>
<li><strong>array</strong>(<code>a</code>)：当前元素所属的数组对象(<code>可选</code>)</li>
</ul>
</li>
<li>过程<ul>
<li>以<code>t</code>作为累计结果的初始值，不设置<code>t</code>则以数组第一个元素为初始值</li>
<li>开始遍历，使用累计器处理<code>v</code>，将<code>v</code>的映射结果累计到<code>t</code>上，结束此次循环，返回<code>t</code></li>
<li>进入下一次循环，重复上述操作，直至数组最后一个元素</li>
<li>结束遍历，返回最终的<code>t</code></li>
</ul>
</li>
</ul>
<p><code>reduce</code>的精华所在是将累计器逐个作用于数组成员上，<strong>把上一次输出的值作为下一次输入的值</strong>。下面举个简单的例子，看看<code>reduce</code>的计算结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a = arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t + v);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> b = arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t + v, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>贴一个<code>reduce</code>的作用动图</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/2/14/17041fe31d591f57?imageslim" alt="reduce"></p>
<p><code>reduce</code>实质上是一个累计器函数，通过用户自定义的累计器对数组成员进行自定义累计，得出一个由累计器生成的值。另外<code>reduce</code>还有一个胞弟<code>reduceRight</code>，两个方法的功能其实是一样的，只不过<code>reduce</code>是升序执行，<code>reduceRight</code>是降序执行。</p>
<blockquote>
<p>对空数组调用reduce()和reduceRight()是不会执行其回调函数的，可认为reduce()对空数组无效</p>
</blockquote>
<h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h5 id="累加累乘"><a href="#累加累乘" class="headerlink" title="累加累乘"></a>累加累乘</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Accumulation</span>(<span class="params">...vals</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> vals.reduce(<span class="function">(<span class="params">total,value</span>) =&gt;</span> &#123;</span><br><span class="line">		total + value</span><br><span class="line">	&#125;,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Multiplication</span>(<span class="params">...vals</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> vals.reduce(<span class="function">(<span class="params">total,value</span>) =&gt;</span> &#123;</span><br><span class="line">		total * value</span><br><span class="line">	&#125;,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="权重求和"><a href="#权重求和" class="headerlink" title="权重求和"></a>权重求和</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scores = [</span><br><span class="line">    &#123; <span class="attr">score</span>: <span class="number">90</span>, <span class="attr">subject</span>: <span class="string">"chinese"</span>, <span class="attr">weight</span>: <span class="number">0.5</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">score</span>: <span class="number">95</span>, <span class="attr">subject</span>: <span class="string">"math"</span>, <span class="attr">weight</span>: <span class="number">0.3</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">score</span>: <span class="number">85</span>, <span class="attr">subject</span>: <span class="string">"english"</span>, <span class="attr">weight</span>: <span class="number">0.2</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> result = scores.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t + v.score * v.weight, <span class="number">0</span>); <span class="comment">// 90.5</span></span><br></pre></td></tr></table></figure>

<h5 id="代替reverse"><a href="#代替reverse" class="headerlink" title="代替reverse"></a>代替reverse</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Reverse</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduceRight(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (t.push(v), t), []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reverse([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> (t.push(v), t)，逗号最后面的t 代表的啥意思？</p>
<p>这是用到了逗号操作符，返回t的意思</p>
</blockquote>
<h5 id="代替map和filter"><a href="#代替map和filter" class="headerlink" title="代替map和filter"></a>代替map和filter</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替map：[0, 2, 4, 6]</span></span><br><span class="line"><span class="keyword">const</span> a = arr.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> b = arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> [...t, v * <span class="number">2</span>], []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替filter：[2, 3]</span></span><br><span class="line"><span class="keyword">const</span> c = arr.filter(<span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> d = arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> v &gt; <span class="number">1</span> ? [...t, v] : t, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替map和filter：[4, 6]</span></span><br><span class="line"><span class="keyword">const</span> e = arr.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>).filter(<span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> f = arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> v * <span class="number">2</span> &gt; <span class="number">2</span> ? [...t, v * <span class="number">2</span>] : t, []);</span><br></pre></td></tr></table></figure>

<h5 id="代替some和every"><a href="#代替some和every" class="headerlink" title="代替some和every"></a>代替some和every</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scores = [</span><br><span class="line">    &#123; <span class="attr">score</span>: <span class="number">45</span>, <span class="attr">subject</span>: <span class="string">"chinese"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">score</span>: <span class="number">90</span>, <span class="attr">subject</span>: <span class="string">"math"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">score</span>: <span class="number">60</span>, <span class="attr">subject</span>: <span class="string">"english"</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替some：至少一门合格</span></span><br><span class="line"><span class="keyword">const</span> isAtLeastOneQualified = scores.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t || v.score &gt;= <span class="number">60</span>, <span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替every：全部合格</span></span><br><span class="line"><span class="keyword">const</span> isAllQualified = scores.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t &amp;&amp; v.score &gt;= <span class="number">60</span>, <span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="数组分割"><a href="#数组分割" class="headerlink" title="数组分割"></a>数组分割</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Chunk</span>(<span class="params">arr = [], size = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.length ? arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (t[t.length - <span class="number">1</span>].length === size ? t.push([v]) : t[t.length - <span class="number">1</span>].push(v), t), [[]]) : [];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">Chunk(arr, <span class="number">2</span>); <span class="comment">// [[1, 2], [3, 4], [5]]</span></span><br></pre></td></tr></table></figure>

<h5 id="数组过滤"><a href="#数组过滤" class="headerlink" title="数组过滤"></a>数组过滤</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Difference</span>(<span class="params">arr = [], oarr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (!oarr.includes(v) &amp;&amp; t.push(v), t), []);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line">Difference(arr1, arr2); <span class="comment">// [1, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h5 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fill</span>(<span class="params">arr = [], val = <span class="string">""</span>, start = <span class="number">0</span>, end = arr.length</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span> || start &gt;= end || end &gt; arr.length) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        ...arr.slice(<span class="number">0</span>, start),</span><br><span class="line">        ...arr.slice(start, end).reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (t.push(val || v), t), []),</span><br><span class="line">        ...arr.slice(end, arr.length)</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">Fill(arr, <span class="string">"aaa"</span>, <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// [0, 1, "aaa", "aaa", "aaa", 5, 6]</span></span><br></pre></td></tr></table></figure>

<h5 id="数组扁平"><a href="#数组扁平" class="headerlink" title="数组扁平"></a>数组扁平</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Flat</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t.concat(<span class="built_in">Array</span>.isArray(v) ? Flat(v) : v), [])</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]], [<span class="number">8</span>, [<span class="number">9</span>, <span class="number">10</span>, [<span class="number">11</span>, <span class="number">12</span>]]]];</span><br><span class="line">Flat(arr); <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span></span><br></pre></td></tr></table></figure>

<h5 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Uniq</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t.includes(v) ? t : [...t, v], []);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">Uniq(arr); <span class="comment">// [2, 1, 0, 3]</span></span><br></pre></td></tr></table></figure>

<h5 id="数组最大最小值"><a href="#数组最大最小值" class="headerlink" title="数组最大最小值"></a>数组最大最小值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Max</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t &gt; v ? t : v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Min</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t &lt; v ? t : v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">12</span>, <span class="number">45</span>, <span class="number">21</span>, <span class="number">65</span>, <span class="number">38</span>, <span class="number">76</span>, <span class="number">108</span>, <span class="number">43</span>];</span><br><span class="line">Max(arr); <span class="comment">// 108</span></span><br><span class="line">Min(arr); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<h5 id="数组成员独立拆解"><a href="#数组成员独立拆解" class="headerlink" title="数组成员独立拆解"></a>数组成员独立拆解</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Unzip</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(</span><br><span class="line">        (t, v) =&gt; <span class="function">(<span class="params">v.forEach((w, i</span>) =&gt;</span> t[i].push(w)), t),</span><br><span class="line">        <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="built_in">Math</span>.max(...arr.map(<span class="function"><span class="params">v</span> =&gt;</span> v.length)) &#125;).map(<span class="function"><span class="params">v</span> =&gt;</span> [])</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"> js</span><br><span class="line"><span class="keyword">const</span> arr = [[<span class="string">"a"</span>, <span class="number">1</span>, <span class="literal">true</span>], [<span class="string">"b"</span>, <span class="number">2</span>, <span class="literal">false</span>]];</span><br><span class="line">Unzip(arr); <span class="comment">// [["a", "b"], [1, 2], [true, false]]</span></span><br></pre></td></tr></table></figure>

<h5 id="数组成员个数统计"><a href="#数组成员个数统计" class="headerlink" title="数组成员个数统计"></a>数组成员个数统计</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Count</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (t[v] = (t[v] || <span class="number">0</span>) + <span class="number">1</span>, t), &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>];</span><br><span class="line">Count(arr); <span class="comment">// &#123; 0: 1, 1: 2, 2: 3 &#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>此方法是字符统计和单词统计的原理，入</p>
<p>参时把字符串处理成数组即可</p>
</blockquote>
<h5 id="数组成员位置记录"><a href="#数组成员位置记录" class="headerlink" title="数组成员位置记录"></a>数组成员位置记录</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Position</span>(<span class="params">arr = [], val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v, i</span>) =&gt;</span> (v === val &amp;&amp; t.push(i), t), []);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line">Position(arr, <span class="number">2</span>); <span class="comment">// [0, 4]</span></span><br></pre></td></tr></table></figure>

<h5 id="数组成员特性分组"><a href="#数组成员特性分组" class="headerlink" title="数组成员特性分组"></a>数组成员特性分组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Group</span>(<span class="params">arr = [], key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key ? arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (!t[v[key]] &amp;&amp; (t[v[key]] = []), t[v[key]].push(v), t), &#123;&#125;) : &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">    &#123; <span class="attr">area</span>: <span class="string">"GZ"</span>, <span class="attr">name</span>: <span class="string">"YZW"</span>, <span class="attr">age</span>: <span class="number">27</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">area</span>: <span class="string">"GZ"</span>, <span class="attr">name</span>: <span class="string">"TYJ"</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">area</span>: <span class="string">"SZ"</span>, <span class="attr">name</span>: <span class="string">"AAA"</span>, <span class="attr">age</span>: <span class="number">23</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">area</span>: <span class="string">"FS"</span>, <span class="attr">name</span>: <span class="string">"BBB"</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">area</span>: <span class="string">"SZ"</span>, <span class="attr">name</span>: <span class="string">"CCC"</span>, <span class="attr">age</span>: <span class="number">19</span> &#125;</span><br><span class="line">]; <span class="comment">// 以地区area作为分组依据</span></span><br><span class="line">Group(arr, <span class="string">"area"</span>); <span class="comment">// &#123; GZ: Array(2), SZ: Array(2), FS: Array(1) &#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="数组成员所含关键字统计"><a href="#数组成员所含关键字统计" class="headerlink" title="数组成员所含关键字统计"></a>数组成员所含关键字统计</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Keyword</span>(<span class="params">arr = [], keys = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keys.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (arr.some(<span class="function"><span class="params">w</span> =&gt;</span> w.includes(v)) &amp;&amp; t.push(v), t), []);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> text = [</span><br><span class="line">    <span class="string">"今天天气真好，我想出去钓鱼"</span>,</span><br><span class="line">    <span class="string">"我一边看电视，一边写作业"</span>,</span><br><span class="line">    <span class="string">"小明喜欢同桌的小红，又喜欢后桌的小君，真TM花心"</span>,</span><br><span class="line">    <span class="string">"最近上班喜欢摸鱼的人实在太多了，代码不好好写，在想入非非"</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> keyword = [<span class="string">"偷懒"</span>, <span class="string">"喜欢"</span>, <span class="string">"睡觉"</span>, <span class="string">"摸鱼"</span>, <span class="string">"真好"</span>, <span class="string">"一边"</span>, <span class="string">"明天"</span>];</span><br><span class="line">Keyword(text, keyword); <span class="comment">// ["喜欢", "摸鱼", "真好", "一边"]</span></span><br></pre></td></tr></table></figure>

<h5 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReverseStr</span>(<span class="params">str = <span class="string">""</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">""</span>).reduceRight(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t + v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">"reduce最牛逼"</span>;</span><br><span class="line">ReverseStr(str); <span class="comment">// "逼牛最ecuder"</span></span><br></pre></td></tr></table></figure>

<h5 id="数字千分化"><a href="#数字千分化" class="headerlink" title="数字千分化"></a>数字千分化</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThousandNum</span>(<span class="params">num = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> str = (+num).toString().split(<span class="string">"."</span>);</span><br><span class="line">    <span class="keyword">const</span> int = <span class="function"><span class="params">nums</span> =&gt;</span> nums.split(<span class="string">""</span>).reverse().reduceRight(<span class="function">(<span class="params">t, v, i</span>) =&gt;</span> t + (i % <span class="number">3</span> ? v : <span class="string">`<span class="subst">$&#123;v&#125;</span>,`</span>), <span class="string">""</span>).replace(<span class="regexp">/^,|,$/g</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">const</span> dec = <span class="function"><span class="params">nums</span> =&gt;</span> nums.split(<span class="string">""</span>).reduce(<span class="function">(<span class="params">t, v, i</span>) =&gt;</span> t + ((i + <span class="number">1</span>) % <span class="number">3</span> ? v : <span class="string">`<span class="subst">$&#123;v&#125;</span>,`</span>), <span class="string">""</span>).replace(<span class="regexp">/^,|,$/g</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> str.length &gt; <span class="number">1</span> ? <span class="string">`<span class="subst">$&#123;int(str[<span class="number">0</span>])&#125;</span>.<span class="subst">$&#123;dec(str[<span class="number">1</span>])&#125;</span>`</span> : int(str[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThousandNum(<span class="number">1234</span>); <span class="comment">// "1,234"</span></span><br><span class="line">ThousandNum(<span class="number">1234.00</span>); <span class="comment">// "1,234"</span></span><br><span class="line">ThousandNum(<span class="number">0.1234</span>); <span class="comment">// "0.123,4"</span></span><br><span class="line">ThousandNum(<span class="number">1234.5678</span>); <span class="comment">// "1,234.567,8"</span></span><br></pre></td></tr></table></figure>

<h5 id="异步累计"><a href="#异步累计" class="headerlink" title="异步累计"></a>异步累计</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">AsyncTotal</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="keyword">async</span>(t, v) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> at = <span class="keyword">await</span> t;</span><br><span class="line">        <span class="keyword">const</span> todo = <span class="keyword">await</span> Todo(v);</span><br><span class="line">        at[v] = todo;</span><br><span class="line">        <span class="keyword">return</span> at;</span><br><span class="line">    &#125;, <span class="built_in">Promise</span>.resolve(&#123;&#125;));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> AsyncTotal(); <span class="comment">// 需要在async包围下使用</span></span><br></pre></td></tr></table></figure>

<h5 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">len = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [...new <span class="built_in">Array</span>(len).keys()];</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v, i</span>) =&gt;</span> (i &gt; <span class="number">1</span> &amp;&amp; t.push(t[i - <span class="number">1</span>] + t[i - <span class="number">2</span>]), t), [<span class="number">0</span>, <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fibonacci(<span class="number">10</span>); <span class="comment">// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br></pre></td></tr></table></figure>

<h5 id="URL参数反序列化"><a href="#URL参数反序列化" class="headerlink" title="URL参数反序列化"></a>URL参数反序列化</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParseUrlSearch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> location.search.replace(<span class="regexp">/(^\?)|(&amp;$)/g</span>, <span class="string">""</span>).split(<span class="string">"&amp;"</span>).reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> [key, val] = v.split(<span class="string">"="</span>);</span><br><span class="line">        t[key] = <span class="built_in">decodeURIComponent</span>(val);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设URL为：https://www.baidu.com?age=25&amp;name=TYJ</span></span><br><span class="line">ParseUrlSearch(); <span class="comment">// &#123; age: "25", name: "TYJ" &#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="URL参数序列化"><a href="#URL参数序列化" class="headerlink" title="URL参数序列化"></a>URL参数序列化</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringifyUrlSearch</span>(<span class="params">search = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.entries(search).reduce(</span><br><span class="line">        (t, v) =&gt; <span class="string">`<span class="subst">$&#123;t&#125;</span><span class="subst">$&#123;v[<span class="number">0</span>]&#125;</span>=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(v[<span class="number">1</span>])&#125;</span>&amp;`</span>,</span><br><span class="line">        <span class="built_in">Object</span>.keys(search).length ? <span class="string">"?"</span> : <span class="string">""</span></span><br><span class="line">    ).replace(<span class="regexp">/&amp;$/</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">StringifyUrlSearch(&#123; <span class="attr">age</span>: <span class="number">27</span>, <span class="attr">name</span>: <span class="string">"YZW"</span> &#125;); <span class="comment">// "?age=27&amp;name=YZW"</span></span><br></pre></td></tr></table></figure>

<h5 id="返回对象指定键值"><a href="#返回对象指定键值" class="headerlink" title="返回对象指定键值"></a>返回对象指定键值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetKeys</span>(<span class="params">obj = &#123;&#125;, keys = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(obj).reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (keys.includes(v) &amp;&amp; (t[v] = obj[v]), t), &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> keyword = [<span class="string">"a"</span>, <span class="string">"d"</span>];</span><br><span class="line">GetKeys(target, keyword); <span class="comment">// &#123; a: 1, d: 4 &#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="数组转对象"><a href="#数组转对象" class="headerlink" title="数组转对象"></a>数组转对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">    &#123; <span class="attr">area</span>: <span class="string">"GZ"</span>, <span class="attr">name</span>: <span class="string">"YZW"</span>, <span class="attr">age</span>: <span class="number">27</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">area</span>: <span class="string">"SZ"</span>, <span class="attr">name</span>: <span class="string">"TYJ"</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> map = people.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, ...rest &#125; = v;</span><br><span class="line">    t[name] = rest;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;, &#123;&#125;); <span class="comment">// &#123; YZW: &#123;…&#125;, TYJ: &#123;…&#125; &#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="Redux-Compose函数原理"><a href="#Redux-Compose函数原理" class="headerlink" title="Redux Compose函数原理"></a>Redux Compose函数原理</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compose</span>(<span class="params">...funs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (funs.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (funs.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> funs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> funs.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> t(v(...arg)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>### </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-‘力扣简单题’" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/23/‘力扣简单题’/" class="article-date">
      <time datetime="2020-06-23T07:43:03.000Z" itemprop="datePublished">2020-06-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/23/‘力扣简单题’/">‘力扣简单题’</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="数组取交集"><a href="#数组取交集" class="headerlink" title="数组取交集"></a>数组取交集</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> duplicatedValues = [...new <span class="built_in">Set</span>(arr1)].filter(<span class="function"><span class="params">item</span> =&gt;</span> arr2.includes(item))</span><br></pre></td></tr></table></figure>

<h4 id="数组取差集"><a href="#数组取差集" class="headerlink" title="数组取差集"></a>数组取差集</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> diffValues = [...new <span class="built_in">Set</span>([...arr1,...arr2])].filter(<span class="function"><span class="params">item</span> =&gt;</span> !b.includes(item) || !a.includes(item))</span><br></pre></td></tr></table></figure>

<h4 id="数组转对象"><a href="#数组转对象" class="headerlink" title="数组转对象"></a>数组转对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> newObj = &#123;...arr&#125; <span class="comment">// &#123;0: 1, 1: 2, 2: 3, 3: 4&#125;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="attr">length</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// 对象转数组不能用展开操作符，因为展开操作符必须用在可迭代对象上</span></span><br><span class="line"><span class="keyword">let</span> newArr = [...obj] <span class="comment">// Uncaught TypeError: object is not iterable...</span></span><br><span class="line"><span class="comment">// 可以使用Array.form()将类数组对象转为数组</span></span><br><span class="line"><span class="keyword">let</span> newArr = <span class="built_in">Array</span>.from(obj) <span class="comment">// [0, 1, 2]</span></span><br></pre></td></tr></table></figure>

<h4 id="数组摊平"><a href="#数组摊平" class="headerlink" title="数组摊平"></a>数组摊平</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, [3, [4, 5]]].flat()</span><br><span class="line">// [1, 2, 3, [4, 5]]</span><br><span class="line">[1, 2, [3, [4, 5]]].flat(2)</span><br><span class="line">// [1, 2, 3, 4, 5]</span><br><span class="line">//上面代码中，flat()的参数为2，表示要拉平两层的嵌套数组。</span><br><span class="line">//如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。</span><br><span class="line">[1, [2, [3]]].flat(Infinity)</span><br><span class="line">// [1, 2, 3]</span><br></pre></td></tr></table></figure>

<h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><p><strong>原地修改原数组</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var removeDuplicates = function(nums) &#123;</span><br><span class="line">    // 记录nums元素个数</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    let count = 0;</span><br><span class="line">    //遍历数组元素，若后一项与前一项相同，则复制后面元素到重复位上</span><br><span class="line">    for(var i = 1; i &lt; nums.length; i++)&#123;</span><br><span class="line">        if(nums[i] != nums[i-1])&#123;</span><br><span class="line">            nums[i - count] = nums[i];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return len - count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>不修改原数组</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//数据结构Set数据结构去重。</span><br><span class="line">function removeDuplicates(nums)&#123;</span><br><span class="line">	let arr = [...new Set(nums)];</span><br><span class="line">	return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//利用object对象键值唯一性去重</span><br><span class="line">function removeDuplicates(nums)&#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    let arr = [];</span><br><span class="line">	for(let item of nums)&#123;</span><br><span class="line">		obj[item] = 1;</span><br><span class="line">	&#125;</span><br><span class="line">	for(let key in obj)&#123;</span><br><span class="line">        arr.push(key);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 利用indexOf判断</span><br><span class="line">function removeDuplicates(nums)&#123;</span><br><span class="line">	let arr = [];</span><br><span class="line">	for(let i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">		if(arr.indexOf(nums[i]) == -1)&#123;</span><br><span class="line">			arr.push(nums[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数组移除元素"><a href="#数组移除元素" class="headerlink" title="数组移除元素"></a>数组移除元素</h4><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var removeElement = function (nums, val) &#123;</span><br><span class="line">    // 记录数组元素个数，当匹配到，将最后的元素填到前面来</span><br><span class="line">    var ans = nums.length;</span><br><span class="line">    for(var i = 0; i&lt; ans;)&#123;</span><br><span class="line">        if(nums[i] == val)&#123;</span><br><span class="line">            nums[i] = nums[ans -1];</span><br><span class="line">            ans --;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//最优解</span><br><span class="line">var removeElement = function (nums, val) &#123;</span><br><span class="line">    // for...of循环数组，不等于val的值的存入nums数组中</span><br><span class="line">    let count = 0;</span><br><span class="line">    for(var num of nums)&#123;</span><br><span class="line">        if(num != val)&#123;</span><br><span class="line">            nums[ count++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="移除数组中的元素"><a href="#移除数组中的元素" class="headerlink" title="移除数组中的元素"></a>移除数组中的元素</h4><p>移除数组 arr 中的所有值与 item 相等的元素，<strong>直接在给定的 arr 数组上进行操作</strong>，并将结果返回</p>
<p>示例1</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 2, 3, 4, 2, 2], 2</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 3, 4]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function removeWithoutCopy(arr, item) &#123;</span><br><span class="line">    for(let i = 0; i &lt; arr.length;i++)&#123;</span><br><span class="line">    	if(arr.indexOf(item) == -1) break;</span><br><span class="line">    	if(arr[i] == item)&#123;</span><br><span class="line">    		arr.splice(i,1);</span><br><span class="line">    		i--;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组搜索插入位置"><a href="#数组搜索插入位置" class="headerlink" title="数组搜索插入位置"></a>数组搜索插入位置</h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> var searchInsert = function (nums, target) &#123;</span><br><span class="line">    if (nums.indexOf(target) == -1) &#123;</span><br><span class="line">        nums.push(target);</span><br><span class="line">        nums.sort((a,b) =&gt; a-b);</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.indexOf(target);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="合并两个数组"><a href="#合并两个数组" class="headerlink" title="合并两个数组"></a>合并两个数组</h4><p><strong>改变原数组</strong></p>
<p>给你两个有序整数数组 <em>nums1</em> 和 <em>nums2*，请你将 *nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使 <em>num1</em> 成为一个有序数组。</p>
<p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p>
<p>输出: [1,2,2,3,5,6]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums1</span><br><span class="line"> * @param &#123;number&#125; m</span><br><span class="line"> * @param &#123;number[]&#125; nums2</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead.</span><br><span class="line"> */</span><br><span class="line"> //从返回值为空可知，必须修改nums1中的参数</span><br><span class="line">var merge = function(nums1, m, nums2, n) &#123;</span><br><span class="line">    nums1.splice(m,n,...nums2);</span><br><span class="line">    nums1.sort((a,b) =&gt; a-b)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>不改变原数组</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var merge = function(nums1, m, nums2, n) &#123;</span><br><span class="line">    let arr = [...nums1,...nums2];</span><br><span class="line">    arr.splice(m,n);</span><br><span class="line">    return arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h4><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<p>示例 1：</p>
<p>输入：nums = [2,7,11,15], target = 9<br>输出：[2,7] 或者 [7,2]</p>
<p>示例 2：</p>
<p>输入：nums = [10,26,30,31,47,60], target = 40<br>输出：[10,30] 或者 [30,10]</p>
<p>限制：</p>
<pre><code>1 &lt;= nums.length &lt;= 10^5
1 &lt;= nums[i] &lt;= 10^6</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var twoSum = function (nums, target) &#123;</span><br><span class="line">    let left = 0,</span><br><span class="line">        right = nums.length - 1;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        if (nums[left] + nums[right] == target) &#123;</span><br><span class="line">            return [nums[left], nums[right]];</span><br><span class="line">        &#125; else if (nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var twoSum = function(nums, target) &#123;</span><br><span class="line">    //nums已经排序了，二分法</span><br><span class="line">    let avg= target/2;</span><br><span class="line">    let j;//接近avg的索引下标</span><br><span class="line">    for(let i = 0; i&lt; nums.length; i++)&#123;</span><br><span class="line">        if(avg &gt;= nums[i])&#123;</span><br><span class="line">            j=i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let left=j;</span><br><span class="line">    for(let right=j;right&lt;nums.length;right++)&#123;</span><br><span class="line">        let x = target - nums[right];</span><br><span class="line">        while(left&gt;=0 &amp;&amp; nums[left] &gt; x)&#123;</span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left &lt; 0)break;</span><br><span class="line">        if(nums[left] === x &amp;&amp; left!==right)return [nums[left],nums[right]];</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    return [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h4><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p>示例 1：</p>
<p>输入：target = 9<br>输出：[[2,3,4],[4,5]]</p>
<p>示例 2：</p>
<p>输入：target = 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p>
<p>限制：</p>
<pre><code>1 &lt;= target &lt;= 10^5</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var findContinuousSequence = function(target) &#123;</span><br><span class="line">    ////由规律得，序列中最大值是target的一半+ 或 - 1</span><br><span class="line">    let index = target % 2 ? (target + 1)/2 : target/2;</span><br><span class="line">    </span><br><span class="line">    let res = [];   //存储结果</span><br><span class="line">    let temp = [];   //存储从下标值</span><br><span class="line">    let sum = 0;     //与target作比较</span><br><span class="line">    for(let i = 1; i &lt;= index; i++)&#123;</span><br><span class="line">        temp.push(i);</span><br><span class="line">        sum += i;</span><br><span class="line">        while(sum &gt; target)&#123;</span><br><span class="line">            sum -= temp[0];</span><br><span class="line">            temp.shift();</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum == target)&#123;</span><br><span class="line">            temp.length &gt;= 2 &amp;&amp; res.push([...temp]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums </span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">//动态规划法(缺点：突然中断，算出来的是已经遍历过的数)</span><br><span class="line">// 定义一个回调方法ans保存结果值，sum为求和后的值，将ans和sum中的最大值赋给ans</span><br><span class="line">var maxSubArray = function(nums)&#123;</span><br><span class="line">    let ans = nums[0];</span><br><span class="line">    let sum = 0;</span><br><span class="line">    for(let num of nums)&#123;</span><br><span class="line">        if(sum &gt; 0)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            sum = num;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h4><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p>
<p>示例:</p>
<p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释: </p>
<p>  滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var maxSlidingWindow = function(nums, k) &#123;</span><br><span class="line">    if(nums.length===0)return [];  //边界值</span><br><span class="line">    let max=[];</span><br><span class="line">    for(let i=0; i+k-1&lt;nums.length;i++)&#123;  </span><br><span class="line">        let m=Math.max(...nums.slice(i,i+k));</span><br><span class="line">        max.push(m);</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h4><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p>
<p>示例 2:</p>
<p>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]</p>
<p>说明:</p>
<p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的 原地 算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//改变数组，利用数组的splice的增加删除操作原地操作</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @return &#123;void&#125; Do not return anything, modify nums in-place instead.</span><br><span class="line"> */</span><br><span class="line">var rotate = function(nums,k)&#123;</span><br><span class="line">    nums.splice(0,0,...nums.splice(nums.length-k));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="字符异位词分组"><a href="#字符异位词分组" class="headerlink" title="字符异位词分组"></a>字符异位词分组</h4><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p>示例:</p>
<p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]</p>
<p>说明：</p>
<p>所有输入均为小写字母。<br>不考虑答案输出的顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string[]&#125; strs</span><br><span class="line"> * @return &#123;string[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var groupAnagrams = function(strs) &#123;</span><br><span class="line">    // 利用哈希表存储，键值唯一</span><br><span class="line">    let hash = new Map();</span><br><span class="line">    for(let  i = 0; i &lt; strs.length;i++)&#123;</span><br><span class="line">        if(hash.has(str))&#123;</span><br><span class="line">            let temp = hash.get(str);</span><br><span class="line">            temp.push(strs[i]);</span><br><span class="line">            hash.set(str,temp);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            hash.set(str,[strs]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return [...hash.values()]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>#### </p>
<h4 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h4><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>

<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p>将可能出现的情况存到map中，定义一个变量存返回值。优先判断是否符合两个的字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">var romanToInt = function (s) &#123;</span><br><span class="line">    let map = &#123;</span><br><span class="line">        I : 1,</span><br><span class="line">        IV: 4,</span><br><span class="line">        V: 5,</span><br><span class="line">        IX: 9,</span><br><span class="line">        X: 10,</span><br><span class="line">        XL: 40,</span><br><span class="line">        L: 50,</span><br><span class="line">        XC: 90,</span><br><span class="line">        C: 100,</span><br><span class="line">        CD: 400,</span><br><span class="line">        D: 500,</span><br><span class="line">        CM: 900,</span><br><span class="line">        M: 1000</span><br><span class="line">    &#125;</span><br><span class="line">    let ans = 0;</span><br><span class="line">    for(var i = 0; i &lt; s.length;)&#123;</span><br><span class="line">        if(i + 1 &lt; s.length &amp;&amp; map[s.substring(i,i+2)])&#123;</span><br><span class="line">            ans += map[s.substring(i,i+2)];</span><br><span class="line">            i += 2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ans += map[s.substring(i,i+1)];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h4 id="字符串数组中的最长公共前缀"><a href="#字符串数组中的最长公共前缀" class="headerlink" title="字符串数组中的最长公共前缀"></a>字符串数组中的最长公共前缀</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">编写一个函数来查找字符串数组中的最长公共前缀。</span><br><span class="line"></span><br><span class="line">如果不存在公共前缀，返回空字符串 &quot;&quot;。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param &#123;string[]&#125; strs</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line"> var longestCommonPrefix = function(strs) &#123;</span><br><span class="line">    if(strs.length == 0) return &apos;&apos;;</span><br><span class="line">    let ans = strs[0];</span><br><span class="line">    for(let i = 0;i &lt; strs.length;i++)&#123;</span><br><span class="line">        let  j = 0;</span><br><span class="line">        for(;j &lt; ans.length &amp;&amp; j &lt; strs[i].length;j++)&#123;</span><br><span class="line">            if(ans[j] != strs[i][j]) break;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans.substr(0,j);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br><span class="line">let strs =  [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">console.log(longestCommonPrefix(strs));</span><br></pre></td></tr></table></figure>

<h4 id="有效字符串"><a href="#有效字符串" class="headerlink" title="有效字符串"></a>有效字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">给定一个只包括 &apos;(&apos;，&apos;)&apos;，&apos;&#123;&apos;，&apos;&#125;&apos;，&apos;[&apos;，&apos;]&apos; 的字符串，判断字符串是否有效。</span><br><span class="line"></span><br><span class="line">有效字符串需满足：</span><br><span class="line"></span><br><span class="line">左括号必须用相同类型的右括号闭合。</span><br><span class="line">左括号必须以正确的顺序闭合。</span><br><span class="line">注意空字符串可被认为是有效字符串。</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    边遍历便匹配，即遇到的第一个右括号必须与数组中最后一个元素匹配，否则无效。</span><br><span class="line">    匹配完成后从数组中删除此元素。</span><br><span class="line">    @param &#123;string&#125; s</span><br><span class="line">    @return &#123;boolean&#125;</span><br><span class="line">*/</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line"> var isValid = function(s)&#123;</span><br><span class="line">    //构建一个map结构的对象</span><br><span class="line">    let map = &#123;</span><br><span class="line">        &quot;(&quot;: &quot;)&quot;,</span><br><span class="line">        &quot;&#123;&quot;: &quot;&#125;&quot;,</span><br><span class="line">        &quot;[&quot;: &quot;]&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    let leftArr = []; //用于存放左括号</span><br><span class="line">    for(let ch of s)&#123;</span><br><span class="line">        if(ch in map) leftArr.push(ch);</span><br><span class="line">        else&#123;</span><br><span class="line">            if(ch != map[leftArr.pop()])&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return !leftArr.length;   //避免都是左括号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串中找最大数字"><a href="#字符串中找最大数字" class="headerlink" title="字符串中找最大数字"></a>字符串中找最大数字</h4><p> 输入一串只有数字和字母的字符串，输出该字符串中最大的数字</p>
<p>输入：hellowolrd520hellowor</p>
<p>ld1314</p>
<p>输出：1314 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let str = &apos;hellowolrd520helloworld1314&apos;;</span><br><span class="line"></span><br><span class="line">let reg = /\d+/g;</span><br><span class="line"></span><br><span class="line">let arr = str.match(reg);</span><br><span class="line"></span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">let max = Math.max(...arr);</span><br><span class="line"></span><br><span class="line">console.log(max);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let str = &apos;hellowolrd520helloworld1314&apos;;</span><br><span class="line"></span><br><span class="line">let reg = /[a-z]+/g;</span><br><span class="line"></span><br><span class="line">let arr = str.split(reg);</span><br><span class="line"></span><br><span class="line">let max = Math.max(...arr);</span><br><span class="line"></span><br><span class="line">console.log(max);</span><br></pre></td></tr></table></figure>

<h4 id="最后一个单词的长度"><a href="#最后一个单词的长度" class="headerlink" title="最后一个单词的长度"></a>最后一个单词的长度</h4><p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<p>说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var lengthOfLastWord = function(s) &#123;</span><br><span class="line">    // 去除字符串两边的空格</span><br><span class="line">    s = s.trim();</span><br><span class="line">    let arr = s.split(&apos; &apos;);</span><br><span class="line">    let len = arr.length;</span><br><span class="line">    if(len == 0) return 0;</span><br><span class="line">    return arr[len - 1].length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h4><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p>示例 1：</p>
<p>输入: “the sky is blue”<br>输出: “blue is sky the”</p>
<p>示例 2：</p>
<p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
<p>示例 3：</p>
<p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
<p>说明：</p>
<pre><code>无空格字符构成一个单词。
输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//先去空格（此步可省），分割为字符串数组，去除多余空格，翻转后转为字符串</span><br><span class="line">var reverseWords = function(s) &#123;</span><br><span class="line">    return s.trim().split(&apos; &apos;).filter(x =&gt; !!x).reverse().join(&apos; &apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="颠倒二进制"><a href="#颠倒二进制" class="headerlink" title="颠倒二进制"></a>颠倒二进制</h4><p>颠倒给定的 32 位无符号整数的二进制位。</p>
<p>示例 1：</p>
<p>输入: 00000010100101000001111010011100<br>输出: 00111001011110000010100101000000<br>解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，<br>      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</p>
<p>示例 2：</p>
<p>输入：11111111111111111111111111111101<br>输出：10111111111111111111111111111111<br>解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，<br>      因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。 </p>
<p>提示：</p>
<pre><code>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</code></pre><p>进阶:<br>如果多次调用这个函数，你将如何优化你的算法？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//利用字符串的toString方法转为二进制数</span><br><span class="line">var reverseBits = function(n) &#123;</span><br><span class="line">	//二进制以0b开头</span><br><span class="line">    return +(&apos;0b&apos;+n.toString(2).padStart(32,0).split(&apos;&apos;).reverse().join(&apos;&apos;))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function ListNode(val)&#123;</span><br><span class="line">	this.val = val;</span><br><span class="line">	this.next = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="合并两个排序链表"><a href="#合并两个排序链表" class="headerlink" title="合并两个排序链表"></a>合并两个排序链表</h4><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">&gt; 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var mergeTwoLists = function(l1,l2)&#123;</span><br><span class="line">	if(l1 == null)&#123;</span><br><span class="line">		return l2;</span><br><span class="line">	&#125;</span><br><span class="line">	if(l2 == null)&#123;</span><br><span class="line">		return l1;</span><br><span class="line">	&#125;</span><br><span class="line">	if(l1.val &lt; l2.val)&#123;</span><br><span class="line">		l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">		return l1;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">		return l2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除排序列表中的重复元素"><a href="#删除排序列表中的重复元素" class="headerlink" title="删除排序列表中的重复元素"></a>删除排序列表中的重复元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var deleteDuplicates = function(head) &#123;</span><br><span class="line">    let cur = head;</span><br><span class="line">    while(cur &amp;&amp; cur.next)&#123;</span><br><span class="line">        if(cur.val == cur.next.val)&#123;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var reverseList = function(head) &#123;</span><br><span class="line">    let prev = null;</span><br><span class="line">    let curr = head;</span><br><span class="line">    let cnext = null;</span><br><span class="line">    while (curr !== null) &#123;</span><br><span class="line">        cnext = curr.next;</span><br><span class="line">        if (prev === null) &#123;</span><br><span class="line">            curr.next = null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = cnext;</span><br><span class="line">    &#125;</span><br><span class="line">    return prev</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代法</p>
<p>从前到后开始反转，我们需要三个指针，第一个指针指向当前头结点 head，第二个指针指向第二个节点 curP（当前结点）,第三个指针为保存下一个节点的临时节点 temp。</p>
<p>1、反转顺序为，先保存下一节点。</p>
<p>2、然后让当前结点的指向前一节点。</p>
<p>3、最后移动当前结点到下一结点。（head 头节点一开始初始化指向 null）。</p>
<p>4、重复该循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var reverseList = function(head)&#123;</span><br><span class="line">    if(head == null &amp;&amp; head.next)  return head;</span><br><span class="line">    let curNode = head.next;</span><br><span class="line">    head.next = null;</span><br><span class="line">    let temp = null;</span><br><span class="line">    while(curNode != null)&#123;</span><br><span class="line">        temp = curNode.next;</span><br><span class="line">        curNode.next = head;</span><br><span class="line">        head = curNode;</span><br><span class="line">        curNode = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除链表中的值"><a href="#删除链表中的值" class="headerlink" title="删除链表中的值"></a>删除链表中的值</h4><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>注意：此题对比原题有改动</p>
<p>示例 1:</p>
<p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
<p>示例 2:</p>
<p>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.next = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @param &#123;number&#125; val</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> */</span><br><span class="line">var deleteNode = function(head, val) &#123;</span><br><span class="line">    let current = head;</span><br><span class="line">    let prev = null;</span><br><span class="line">    while(current.val != val)&#123;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(current == head)&#123;</span><br><span class="line">        head = current.next;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        prev.next = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h4><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.next = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> */</span><br><span class="line">var getKthFromEnd = function(head, k) &#123;</span><br><span class="line">    let length = 0;</span><br><span class="line">    let current = head;</span><br><span class="line">    let count = 0;</span><br><span class="line">    while(current)&#123;</span><br><span class="line">        length++;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    current = head;</span><br><span class="line">    while(count != length - k)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return current;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<pre><code>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</code></pre><p>示例 1:</p>
<p>给定二叉树 [3,9,20,null,null,15,7]</p>
<pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7</p>
<p>返回 true 。</p>
<p>示例 2:</p>
<p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<pre><code>   1
  / \
 2   2
/ \</code></pre><p>   3   3<br>  / <br> 4   4</p>
<p>返回 false 。</p>
<p>核心思路：<br>1，从左到右递归树的节点，记录节点的最大深度<br>2，在记录节点的同时对该树的节点的左子树与右子树的最大深度做一次对比，如果差值超过1则返回false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">function isNodeBalance(node)&#123;</span><br><span class="line">    if(!node) return 0;</span><br><span class="line">    let left = isNodeBalance(node.left);</span><br><span class="line">    let right = isNodeBalance(node.right);</span><br><span class="line">    if(left &lt; 0 || right &lt; 0)&#123;</span><br><span class="line">        // 短路机制，有一个子树不满足情况就返回</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if(Math.abs(left - right) &gt; 1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return Math.max(left,right) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var isBalanced = function(root)&#123;</span><br><span class="line">    let ret = isNodeBalance(root);</span><br><span class="line">    if(ret &gt;= 0)  return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断B树是否为A的子树"><a href="#判断B树是否为A的子树" class="headerlink" title="判断B树是否为A的子树"></a>判断B树是否为A的子树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; A</span><br><span class="line"> * @param &#123;TreeNode&#125; B</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isSubStructure = function(A, B) &#123;</span><br><span class="line">    // 题目约定：约定空树不是任意一个树的子结构</span><br><span class="line">    if (!A || !B) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        isSubTree(A, B) ||</span><br><span class="line">        isSubStructure(A.left, B) ||</span><br><span class="line">        isSubStructure(A.right, B)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function isSubTree(pRoot1, pRoot2) &#123;</span><br><span class="line">    // B树遍历完了，说明B是A的子结构</span><br><span class="line">    if (!pRoot2) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // A遍历完了，但是B还没有遍历完，那么B肯定不是A的子结构</span><br><span class="line">    if (!pRoot1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (pRoot1.val !== pRoot2.val) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        isSubTree(pRoot1.left, pRoot2.left) &amp;&amp;</span><br><span class="line">        isSubTree(pRoot1.right, pRoot2.right)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="层序遍历二叉树"><a href="#层序遍历二叉树" class="headerlink" title="层序遍历二叉树"></a>层序遍历二叉树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//层序遍历</span><br><span class="line">   let levelOrderTraversal = function(root)&#123;</span><br><span class="line">       if(!root) return false;   //头节点为空返回false</span><br><span class="line">       let result = [];   //创建一个数组存放结果</span><br><span class="line">       let tree = [];    //创建一个数组存放二叉树</span><br><span class="line">       tree.push(root);    //先传入头节点</span><br><span class="line">       while(tree.length)&#123;       //当tree数组长度不为空</span><br><span class="line">           let node = tree.shift();     //将数组中的第一个节点放到node中</span><br><span class="line">           result.push(node.key);         // 将node节点的值放入result中</span><br><span class="line">           if(node.left)&#123;                 //如果node的左节点不为空，就将左节点压入tree数组中</span><br><span class="line">               tree.push(node.left);</span><br><span class="line">           &#125;</span><br><span class="line">           if(node.right)&#123;                //如果node的右节点不为空，就将左节点压入tree数组中</span><br><span class="line">               tree.push(node.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="之字形遍历"><a href="#之字形遍历" class="headerlink" title="之字形遍历"></a>之字形遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">借助 level 变量标记层数，当 level 为偶数的时候，镜像翻转遍历结果。代码实现如下：</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var levelOrder = function(root) &#123;</span><br><span class="line">    if (!root) return [];</span><br><span class="line">    const queue = [root];</span><br><span class="line">    const res = [];</span><br><span class="line">    let level = 0; // 代表当前层数</span><br><span class="line">    while (queue.length) &#123;</span><br><span class="line">        res[level] = []; // 第level层的遍历结果</span><br><span class="line"></span><br><span class="line">        let levelNum = queue.length; // 第level层的节点数量</span><br><span class="line">        while (levelNum--) &#123;</span><br><span class="line">            const front = queue.shift();</span><br><span class="line">            res[level].push(front.val);</span><br><span class="line">            if (front.left) queue.push(front.left);</span><br><span class="line">            if (front.right) queue.push(front.right);</span><br><span class="line">        &#125;</span><br><span class="line">        // 行号是偶数时，翻转当前层的遍历结果</span><br><span class="line">        if (level % 2) &#123;</span><br><span class="line">            res[level].reverse();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><h4 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h4><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<p>示例 1:</p>
<p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var isMatch = function(s, p) &#123;</span><br><span class="line">    return new RegExp(&quot;^&quot; + p + &quot;$&quot;, &quot;g&quot;).test(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h4><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”及”-1E-16”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var isNumber = function(s) &#123;</span><br><span class="line">    var point = s.match(/\./g);</span><br><span class="line">    if((point &amp;&amp; point.length&gt;1) || !/\d/.test(s))&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    s = s.replace(/^\s*|\s*$/g,&quot;&quot;);   //消除前后空格</span><br><span class="line">    </span><br><span class="line">    if(!/e/i.test(s))&#123;  //不含e的: 正负+整数+点+小数随意搭配 </span><br><span class="line">        return /^[\+\-]?(\d*\.?\d*)$/i.test(s); </span><br><span class="line">    &#125;else&#123;              //含e的: 正负+ (整数+点+小数) 随意搭配 +e+ 正负可带可不带+ 数字一定要带  </span><br><span class="line">        return /^[\+\-]?((\d+\.?\d*)|(\d*\.?\d+))e[\+\-]?\d+$/i.test(s)</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h2><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">实现数组的sort((a,b) =&gt; a-b);</span><br><span class="line">function Bubble_sort(arr)&#123;</span><br><span class="line">let len = arr.length;</span><br><span class="line">	for(let p = len - 1; p &gt;= 0;p--)&#123;</span><br><span class="line">	let flag = 0;    //标记交换</span><br><span class="line">		for(let i = 0; i &lt; p; i++)&#123;   //一趟冒泡</span><br><span class="line">			if(arr[i] &gt; arr[i+1])&#123;</span><br><span class="line">				swap(arr[i],arr[i+1]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag == 0)  break;   //全程无交换</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好情况：顺序 T = O(N)</p>
<p>最坏情况： 逆序 T = O(pow(N,2)) </p>
<h4 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a>从上到下打印二叉树</h4><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7</p>
<p>返回：</p>
<p>[3,9,20,15,7]</p>
<p>提示：</p>
<pre><code>节点总数 &lt;= 1000</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var levelOrder = function(root) &#123;</span><br><span class="line">	//判断是否为空树</span><br><span class="line">    if(!root)&#123;</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line">    let data = [];</span><br><span class="line">    //将头节点放到队列中</span><br><span class="line">    let queue = [root];</span><br><span class="line">    while(queue.length != 0)&#123;</span><br><span class="line">        let first = queue.shift();</span><br><span class="line">        data.push(first.val);</span><br><span class="line">        first.left &amp;&amp; queue.push(first.left);</span><br><span class="line">        first.right &amp;&amp; queue.push(first.right);</span><br><span class="line">    &#125;</span><br><span class="line">    return data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h4 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a>圆圈中最后剩下的数字</h4><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @param &#123;number&#125; m</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var lastRemaining = function(n, m) &#123;</span><br><span class="line">    let ans = 0;</span><br><span class="line">    for(let i = 2; i &lt;= n; i++)&#123;</span><br><span class="line">        ans = (ans + m) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="股票最大利润"><a href="#股票最大利润" class="headerlink" title="股票最大利润"></a>股票最大利润</h4><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<p>示例 1:</p>
<p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p>
<p>示例 2:</p>
<p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; prices</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var maxProfit = function(prices) &#123;</span><br><span class="line">    //此问题的实质就是找到两个差值最大的数，前提是小的在前，大的在后</span><br><span class="line">    //要把此问题的时间复杂度控制在O(n-1)并不难</span><br><span class="line">    let profits = 0;</span><br><span class="line">    let min = prices[0];</span><br><span class="line">    const len = prices.length;</span><br><span class="line">    for(let i = 1; i &lt; len; i ++) &#123;</span><br><span class="line">        min = Math.min(min, prices[i]);</span><br><span class="line">        profits = Math.max(profits, prices[i] - min);</span><br><span class="line">    &#125;</span><br><span class="line">    return profits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="游戏必败问题"><a href="#游戏必败问题" class="headerlink" title="游戏必败问题"></a>游戏必败问题</h4><p>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p>
<p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p>
<p>示例:</p>
<p>输入: 4<br>输出: false<br>解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；<br>     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</p>
<p><strong>Nim 游戏</strong></p>
<p>如果堆中石头的数量 nnn 不能被 444 整除，那么你总是可以赢得 Nim 游戏的胜利。</p>
<p>推理</p>
<p>让我们考虑一些小例子。显而易见的是，如果石头堆中只有一块、两块、或是三块石头，那么在你的回合，你就可以把全部石子拿走，从而在游戏中取胜。而如果就像题目描述那样，堆中恰好有四块石头，你就会失败。因为在这种情况下不管你取走多少石头，总会为你的对手留下几块，使得他可以在游戏中打败你。因此，要想获胜，在你的回合中，必须避免石头堆中的石子数为 4 的情况。</p>
<p>同样地，如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，以确保在再一次轮到你的时候，你会面对四块石头。</p>
<p>显然，它以相同的模式不断重复 n=4,8,12,16,…n=4,8,12,16,\dotsn=4,8,12,16,…，基本可以看出是 4的倍数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var canWinNim = function(n) &#123;</span><br><span class="line">    return !!(n % 4);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="url解析"><a href="#url解析" class="headerlink" title="url解析"></a>url解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function parseUrl(url) &#123;</span><br><span class="line">    let s = url.split(&apos;?&apos;)[0];</span><br><span class="line">    let str = url.split(&apos;?&apos;)[1];</span><br><span class="line">    let items = str.split(&apos;&amp;&apos;);</span><br><span class="line">    let res = &#123;&#125;;</span><br><span class="line">    let result = &#123;&#125;;</span><br><span class="line">    let arr = s.split(&quot;://&quot;);</span><br><span class="line">    result[&apos;protocol&apos;] = arr[0];</span><br><span class="line">    result[&apos;host&apos;] = arr[1].substr(0, arr[1].indexOf(&apos;/&apos;));</span><br><span class="line">    if(arr[1].indexOf(&apos;/&apos;) != arr[1].length - 1)&#123;</span><br><span class="line">        result[&apos;path&apos;] = arr[1].substr(arr[1].indexOf(&apos;/&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0, len = items.length; i &lt; len; ++i) &#123;</span><br><span class="line">        res = items[i].split(&apos;=&apos;);</span><br><span class="line">        result[res[0]] = res[1];</span><br><span class="line">        if(res[1].split(&apos;#&apos;).length &gt; 1)&#123;</span><br><span class="line">            result[res[0]] = res[1].split(&apos;#&apos;)[0];</span><br><span class="line">            result[&apos;hash&apos;] = res[1].split(&apos;#&apos;)[1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return JSON.stringify(result).replace(/\&quot;/g,&quot;&apos;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读取一行输入：read_line()，输出一行：print(something)，注意使用print函数输出时，末尾自动带有换行符，无需自己添加；</strong></p>
<ul>
<li>读取size个字符：gets(size)<br>将读取至多size个字符，当还未达到size个时如果遇到回车或结束符，会提前结束。回车符可能会包含在返回值中。</li>
<li>输出信息：printsth(sth, …)<br>往控制台输出sth，当有多个参数时，空格分隔；最后<strong>不</strong>加回车。</li>
<li>输出一行：print(sth, …) console.error(sth, …) console.debug(sth, …) console.info(sth, …) console.log(sth, …)<br>往控制台输出sth，当有多个参数时，空格分隔；最后加回车。</li>
<li>读取一个（长）整数：readInt()<br>从控制台读取一个（长）整数。</li>
<li>读取一个浮点型：readDouble()<br>从控制台读取一个浮点型。</li>
<li>读取一行输入：read_line()</li>
</ul>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h4 id="模拟-sqrt的整数部分"><a href="#模拟-sqrt的整数部分" class="headerlink" title="模拟 sqrt的整数部分"></a>模拟 sqrt的整数部分</h4><p>计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var mySqrt = function(x)&#123;</span><br><span class="line">	return Math.trunc(Math.sqrt(x));</span><br><span class="line">&#125;</span><br><span class="line">//es6新增的去除一个数的小数部分，</span><br><span class="line">非数值的话会先将其转为数值，</span><br><span class="line">控制和无法截取整数的值，返回NaN</span><br></pre></td></tr></table></figure>

<h4 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a>判断素数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function sushu(n)&#123;</span><br><span class="line">    if(n == 0 || n == 1)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n ==  2)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var i = 2; i &lt;= Math.round(Math.sqrt(n));i++)&#123;</span><br><span class="line">        if(n % i == 0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历n内的素数"><a href="#遍历n内的素数" class="headerlink" title="遍历n内的素数"></a>遍历n内的素数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getSushu(n)&#123;</span><br><span class="line">	//存放素数的数组</span><br><span class="line">	var arr = [];</span><br><span class="line">	for(var i = 2; i &lt; n; i++)&#123;</span><br><span class="line">		if(sushu(i))&#123;</span><br><span class="line">			arr.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(...arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="值加一"><a href="#值加一" class="headerlink" title="值加一"></a>值加一</h4><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>示例 1:</p>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。</p>
<p>示例 2:</p>
<p>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; digits</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var plusOne = function(digits) &#123;</span><br><span class="line">    let str = Number(digits.join(&apos;&apos;)) + 1;</span><br><span class="line">    let arr = str.toString().split(&apos;&apos;);</span><br><span class="line">    return arr;</span><br><span class="line"> &#125;;</span><br><span class="line"> //当数字位达32位及以上时，数值相加有问题</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var plusOne = function(digits) &#123;</span><br><span class="line">    return BigInt(BigInt(digits.join(&apos;&apos;)) + 1n).toString().split(&apos;&apos;)</span><br><span class="line">&#125;;</span><br><span class="line">//利用BigInt解决数字边界问题</span><br><span class="line">//要创建BigInt，只需在整数的末尾追加n即可</span><br></pre></td></tr></table></figure>

<h4 id="递增求和"><a href="#递增求和" class="headerlink" title="递增求和"></a>递增求和</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sumNums = function(n) &#123;</span><br><span class="line">    return (1+n)*n/2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var sumNums = function(n) &#123;</span><br><span class="line">    return multi(n, n+1, 0) &gt;&gt; 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function multi(a, b, sum) &#123;</span><br><span class="line">    if (b === 0) return sum</span><br><span class="line"></span><br><span class="line">    if (b &amp; 1) return multi(a, b-1, sum + a)</span><br><span class="line">    return multi(a + a, b &gt;&gt; 1, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-vue小技巧" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/20/vue小技巧/" class="article-date">
      <time datetime="2020-06-20T13:42:11.000Z" itemprop="datePublished">2020-06-20</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/20/vue小技巧/">vue小技巧</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h6 id="v-for设置键值缘由"><a href="#v-for设置键值缘由" class="headerlink" title="v-for设置键值缘由"></a>v-for设置键值缘由</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--模板部分--&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div v-for=&quot;item in arr&quot;&gt;</span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">        &lt;input/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;button @click=&quot;deleteData&quot;&gt;删除第二个元素&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js 部分</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            arr: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        deleteData() &#123;</span><br><span class="line">            <span class="keyword">this</span>.arr.splice(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>若要删除第二个元素，不使用key值或使用索引值作为key的情况都是一样。即索引值正确，但输入框前面的数字显示不正确。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/7/1728f52ae25450cd?imageView2/0/w/1280/h/960/ignore-error/1" alt="img"></p>
<p>而使用唯一值作为key值则是正确的。为什么<code>v-for</code>需要设置key，原因很简单。 对比数组 [1,2,3]和[1,3]，我们很容易发现删掉了2，但是计算机不是这样的逻辑：</p>
<ol>
<li>计算机对比新旧数组，发现1 === 1，保持不变。</li>
<li>然后再对比2，发现2变成了3，便直接将2改为3，原来第二行的input元素可以复用。</li>
<li>然后再对比3和undefined，发现3被删了，索引把第三行的元素删除。</li>
</ol>
<p>那么为什么不能用索引作为key呢？ 当删掉[1,2,3]中的2之后，数组的长度由3变成了2，那么原来数字3的索引就变成了数字2的索引了。</p>
<ol>
<li>计算机对比key为0的值，发现都是1，保持不变</li>
<li>计算机对比key为1的值，发现从2变成了3，元素复用， 修改元素上面的文字</li>
<li>计算机对比key为2的值，发现被删掉了，所以删掉第三行元素</li>
</ol>
<p>而对于使用id作为key,那么每条数据都有了唯一的标识，当删掉<code>[{id:&#39;1&#39;,value: 1},{id: &#39;2&#39;,value: 2}, {id: &#39;3&#39;, value:3}]</code>中的第二个，整个过程如下</p>
<ol>
<li>计算机取出新数据第一项的id，然后在原来数据里面寻找，发现存在相同id的数据，而且数据没有变化，所以保持不变</li>
<li>计算机继续取第二项的id，发现是3，然后从原来数据里面也找到了3，所以3保留</li>
<li>这时候旧数据里面剩了id为2的数据，而新的里面没有了，所以删掉。</li>
</ol>
<h6 id="vue的数据必须返回一个函数"><a href="#vue的数据必须返回一个函数" class="headerlink" title="vue的数据必须返回一个函数"></a>vue的数据必须返回一个函数</h6><p>假设我们现在开发了一个组件，组件上面的data是一个普通的对象，那么当我们实例化多个组件的时候，所有的实例将共享引用同一个数据对象，任何一个实例对数据的修改都会影响到其他实例。而将组件上面的数据定义为一个函数之后，当实例化多个组件的时候，每个实例通过调用 data 函数，从而返回初始数据的一个全新副本数据对象，这时候就避免了对象引用。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-vue的面试" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/20/vue的面试/" class="article-date">
      <time datetime="2020-06-20T13:32:45.000Z" itemprop="datePublished">2020-06-20</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/20/vue的面试/">vue的面试</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-学习vuex" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/18/学习vuex/" class="article-date">
      <time datetime="2020-06-18T07:05:19.000Z" itemprop="datePublished">2020-06-18</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/18/学习vuex/">学习vuex</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="Vuex概述"><a href="#Vuex概述" class="headerlink" title="Vuex概述"></a>Vuex概述</h4><p>Vuex实现组件全局状态（数据）管理的一种机制，可以方便的实现组件间的数据共享。</p>
<h6 id="组件间共享数据的方式"><a href="#组件间共享数据的方式" class="headerlink" title="组件间共享数据的方式"></a>组件间共享数据的方式</h6><p>父向子传值：v-bind属性绑定</p>
<p>子向父传值：v-on事件绑定</p>
<p>兄弟组件间共享数据：EventBus</p>
<ul>
<li>$on   接受数据的那个组件</li>
<li>$emit       发送数据的那个组件</li>
</ul>
<h6 id="vuex的优点"><a href="#vuex的优点" class="headerlink" title="vuex的优点"></a>vuex的优点</h6><ol>
<li>能够在vuex中集中管理共享的数据，易于开发和后期维护。</li>
<li>能够高效的实现组件间的数据共享，提高开发效率。</li>
<li>存储在vuex中的数据都是响应式的，能够实时保持数据与页面的同步。</li>
</ol>
<h6 id="vuex的使用"><a href="#vuex的使用" class="headerlink" title="vuex的使用"></a>vuex的使用</h6><ol>
<li><p>安装</p>
<p><code>cnpm i vuex --save</code></p>
</li>
<li><p>导入vuex包</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建store对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// state 中存放的就是全局共享的数据</span></span><br><span class="line">  state: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将store对象挂载到vue实例中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(app),</span><br><span class="line">  router,</span><br><span class="line">  <span class="comment">// 所有组件都可以从store中获取全局的数据了</span></span><br><span class="line">  store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-同源策略" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/17/同源策略/" class="article-date">
      <time datetime="2020-06-17T07:41:35.000Z" itemprop="datePublished">2020-06-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/同源策略/">同源策略</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="跨域方式实现原理"><a href="#跨域方式实现原理" class="headerlink" title="跨域方式实现原理"></a>跨域方式实现原理</h2><p>前后端请求经常需要跨域，拿什么是跨域，什么是同域？</p>
<h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>同源策略是跨越问题的源头，在客户端编程语言中，如javascript和ActionScript，同源策略是一个很重要的安全理念，他的目的是为了保证用户信息的安全，防止恶意的网站窃取数据。如：A网站是一家银行，用户登录后又去浏览其他网站，若其他网站可读取A网站的Cookie，信息可能会泄露。若Cookie包含隐私（比如存款总额），这些可能会泄露。更可怕的是，Cookie往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源策略的限制。由此可见，“同源策略”是必须的，否则Cookie可以共享，互联网就毫无安全可言。</p>
<p>同源策略是一种约定，他是浏览器最核心也是最基本的安全功能，如果缺少同源策略，则浏览器的正常功能可能都会受到影响。可以说web是创建在同源策略基础上的。浏览器只是针对同源策略的一种实现。</p>
<p>所谓同源是指，域名，协议，端口号都相同。</p>
<p>当一个浏览器的两个tab页中分别打开百度和谷歌的页面，若浏览器的百度tab执行一个脚本时检查出这个脚本是同源时才会被执行。若非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。</p>
<p>同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染，因此拦截的是客户端发出的请求回来的数据接收，即请求发送了，服务器响应了，但是无法被浏览器接收。</p>
<h4 id="非同源"><a href="#非同源" class="headerlink" title="非同源"></a>非同源</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/23/1638b3579d9eeb32?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="url的组成"></p>
<p><img src="https://segmentfault.com/img/bVEa3w?w=731&h=421" alt="图片描述"></p>
<p><strong>同源策略限制内容有：</strong></p>
<ul>
<li>Cookie、LocalStorage、IndexedDB 等存储性内容</li>
<li>DOM 节点</li>
<li>AJAX 请求发送后，结果被浏览器拦截了</li>
</ul>
<p>补充：同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。</p>
<p>但是有三个标签是允许跨域加载资源：</p>
<ul>
<li><code>&lt;img src=XXX&gt;</code></li>
<li><code>&lt;link href=XXX&gt;</code></li>
<li><code>&lt;script src=XXX&gt;</code></li>
</ul>
<p>特别说明两点：</p>
<p>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。</p>
<p>第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。</p>
<p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong>。<strong>你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</strong></p>
<p>作者：浪里行舟<br>链接：<a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1" target="_blank" rel="noopener">https://juejin.im/post/5c23993de51d457b8c1f4ee1</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="跨域方式"><a href="#跨域方式" class="headerlink" title="跨域方式"></a>跨域方式</h2><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSONP是JSON  with Padding的简写，是应用JSON实现服务器与客户端跨域通信常用的方法，最大特点是简单实用，老式浏览器全部支持，服务器改造非常小。但是只支持get方法，且易遭受XSS攻击。</p>
<p>它的基本思想是，网页通过添加一个<script>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。<br>JSOP包含两部分：回调函数和数据，回调函数是在响应到来时应该调用的函数，一般通过查询字符串添加；数据就是传入回调函数中的JSON数据，确切的说，是一个JSON对象，可以直接访问。所以JSONP请求一定要对方的服务器支持才行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">&#123; url, params, callback &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">    <span class="built_in">window</span>[callback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      resolve(data)</span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(script)</span><br><span class="line">    &#125;</span><br><span class="line">    params = &#123; ...params, callback &#125; <span class="comment">// wd=b&amp;callback=show</span></span><br><span class="line">    <span class="keyword">let</span> arrs = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      arrs.push(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arrs.join(<span class="string">'&amp;'</span>)&#125;</span>`</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: <span class="string">'http://localhost:3000/say'</span>,</span><br><span class="line">  params: &#123; <span class="attr">wd</span>: <span class="string">'Iloveyou'</span> &#125;,</span><br><span class="line">  callback: <span class="string">'show'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面这段代码相当于向<code>http://localhost:3000/say?wd=Iloveyou&amp;callback=show</code>这个地址请求数据，然后后台返回<code>show(&#39;我不爱你&#39;)</code>，最后会运行show()这个函数，打印出'我不爱你'</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line">app.get(<span class="string">'/say'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; wd, callback &#125; = req.query</span><br><span class="line">  <span class="built_in">console</span>.log(wd) <span class="comment">// Iloveyou</span></span><br><span class="line">  <span class="built_in">console</span>.log(callback) <span class="comment">// show</span></span><br><span class="line">  res.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>('我不爱你')`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<h6 id="jQuery的jsonp形式"><a href="#jQuery的jsonp形式" class="headerlink" title="jQuery的jsonp形式"></a>jQuery的jsonp形式</h6><p><strong>JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url:<span class="string">"http://crossdomain.com/jsonServerResponse"</span>,</span><br><span class="line">dataType:<span class="string">"jsonp"</span>,</span><br><span class="line">type:<span class="string">"get"</span>,<span class="comment">//可以省略</span></span><br><span class="line">jsonpCallback:<span class="string">"show"</span>,<span class="comment">//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略</span></span><br><span class="line">jsonp:<span class="string">"callback"</span>,<span class="comment">//-&gt;把传递函数名的那个形参callback，可省略</span></span><br><span class="line">success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p><strong>CORS，即Cross-Origin Resource Sharing</strong>，跨域资源共享，定义了在必须跨域访问资源时，浏览器怎样和服务器交互。基本思想就是使用自定义的HTTP头部让浏览器和服务器进行沟通，从而决定响应的成功与失败。他需要浏览器和后端同时支持，IE8和9需要通过XDomainRequest来实现。</p>
<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>
<p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>
<p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p>
<h6 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h6><p>只要同时满足以下两大条件，就属于简单请求</p>
<p>条件1：使用下列方法之一：</p>
<ul>
<li>GET</li>
<li>HEAD</li>
<li>POST</li>
</ul>
<p>条件2：Content-Type 的值仅限于下列三者之一：</p>
<ul>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>application/x-www-form-urlencoded</li>
</ul>
<p>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</p>
<h6 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h6><p>不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p>
<p>我们用<code>PUT</code>向后台请求时，属于复杂请求，后台需做如下配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许哪个方法访问我</span></span><br><span class="line">res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT'</span>)</span><br><span class="line"><span class="comment">// 预检的存活时间</span></span><br><span class="line">res.setHeader(<span class="string">'Access-Control-Max-Age'</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment">// OPTIONS请求不做任何处理</span></span><br><span class="line"><span class="keyword">if</span> (req.method === <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">  res.end() </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义后台返回的内容</span></span><br><span class="line">app.put(<span class="string">'/getData'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.headers)</span><br><span class="line">  res.end(<span class="string">'我不爱你'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>接下来我们看下一个完整复杂请求的例子，并且介绍下CORS请求相关的字段</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=xiamen'</span> <span class="comment">// cookie不能跨域</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span> <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, <span class="string">'http://localhost:4000/getData'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.setRequestHeader(<span class="string">'name'</span>, <span class="string">'xiamen'</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xhr.response)</span><br><span class="line">      <span class="comment">//得到响应头，后台需设置Access-Control-Expose-Headers</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.getResponseHeader(<span class="string">'name'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server1.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server2.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">let</span> app = express()</span><br><span class="line"><span class="keyword">let</span> whitList = [<span class="string">'http://localhost:3000'</span>] <span class="comment">//设置白名单</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> origin = req.headers.origin</span><br><span class="line">  <span class="keyword">if</span> (whitList.includes(origin)) &#123;</span><br><span class="line">    <span class="comment">// 设置哪个源可以访问我</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, origin)</span><br><span class="line">    <span class="comment">// 允许携带哪个头访问我</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'name'</span>)</span><br><span class="line">    <span class="comment">// 允许哪个方法访问我</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT'</span>)</span><br><span class="line">    <span class="comment">// 允许携带cookie</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 预检的存活时间</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Max-Age'</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="comment">// 允许返回的头</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Expose-Headers'</span>, <span class="string">'name'</span>)</span><br><span class="line">    <span class="keyword">if</span> (req.method === <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">      res.end() <span class="comment">// OPTIONS请求不做任何处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">app.put(<span class="string">'/getData'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.headers)</span><br><span class="line">  res.setHeader(<span class="string">'name'</span>, <span class="string">'nikita'</span>) <span class="comment">//返回一个响应头，后台需设置</span></span><br><span class="line">  res.end(<span class="string">'我不爱你'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">'/getData'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.headers)</span><br><span class="line">  res.end(<span class="string">'我不爱你'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.use(express.static(__dirname))</span><br><span class="line">app.listen(<span class="number">4000</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码由<code>http://localhost:3000/index.html</code>向<code>http://localhost:4000/</code>跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。</p>
<h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h4><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的iframe消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<p><strong>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递</strong>。</p>
<blockquote>
<p>otherWindow.postMessage(message, targetOrigin, [transfer]);</p>
</blockquote>
<p>message: 将要发送到其他 window的数据。</p>
<p>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</p>
<p>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</p>
<h4 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h4><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p>
<p>原生WebSocket API使用起来不太方便，我们使用<code>Socket.io</code>，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket.html</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:3000'</span>);</span><br><span class="line">    socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      socket.send(<span class="string">'我不爱你'</span>);<span class="comment">//向服务器发送数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e.data);<span class="comment">//接收服务器返回的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"><span class="keyword">let</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);<span class="comment">//记得安装ws</span></span><br><span class="line"><span class="keyword">let</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123;<span class="attr">port</span>:<span class="number">3000</span>&#125;);</span><br><span class="line">wss.on(<span class="string">'connection'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    ws.send(<span class="string">'我不爱你'</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Node中间件代理-两次跨域"><a href="#Node中间件代理-两次跨域" class="headerlink" title="Node中间件代理(两次跨域)"></a>Node中间件代理(两次跨域)</h4><p>实现原理：<strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong> 代理服务器，需要做以下几个步骤：</p>
<ul>
<li>接受客户端请求 。</li>
<li>将请求 转发给服务器。</li>
<li>拿到服务器 响应 数据。</li>
<li>将 响应 转发给客户端。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/17/1685c5bed77e7788?imageView2/0/w/1280/h/960/ignore-error/1" alt="img"></p>
<p>本地文件index.html文件，通过代理服务器<code>http://localhost:3000</code>向目标服务器<code>http://localhost:4000</code>请求数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html(http://127.0.0.1:5500)</span></span><br><span class="line"> &lt;script src=<span class="string">"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">        url: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">        type: <span class="string">'post'</span>,</span><br><span class="line">        data: &#123; <span class="attr">name</span>: <span class="string">'xiamen'</span>, <span class="attr">password</span>: <span class="string">'123456'</span> &#125;,</span><br><span class="line">        contentType: <span class="string">'application/json;charset=utf-8'</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(result) <span class="comment">// &#123;"title":"fontend","password":"123456"&#125;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(msg)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">     &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server1.js 代理服务器(http://localhost:3000)</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="comment">// 第一步：接受客户端请求</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段</span></span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'*'</span>,</span><br><span class="line">    <span class="string">'Access-Control-Allow-Methods'</span>: <span class="string">'*'</span>,</span><br><span class="line">    <span class="string">'Access-Control-Allow-Headers'</span>: <span class="string">'Content-Type'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 第二步：将请求转发给服务器</span></span><br><span class="line">  <span class="keyword">const</span> proxyRequest = http</span><br><span class="line">    .request(</span><br><span class="line">      &#123;</span><br><span class="line">        host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        port: <span class="number">4000</span>,</span><br><span class="line">        url: <span class="string">'/'</span>,</span><br><span class="line">        method: request.method,</span><br><span class="line">        headers: request.headers</span><br><span class="line">      &#125;,</span><br><span class="line">      serverResponse =&gt; &#123;</span><br><span class="line">        <span class="comment">// 第三步：收到服务器的响应</span></span><br><span class="line">        <span class="keyword">var</span> body = <span class="string">''</span></span><br><span class="line">        serverResponse.on(<span class="string">'data'</span>, chunk =&gt; &#123;</span><br><span class="line">          body += chunk</span><br><span class="line">        &#125;)</span><br><span class="line">        serverResponse.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'The data is '</span> + body)</span><br><span class="line">          <span class="comment">// 第四步：将响应结果转发给浏览器</span></span><br><span class="line">          response.end(body)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    .end()</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The proxyServer is running at http://localhost:3000'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server2.js(http://localhost:4000)</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">title</span>: <span class="string">'fontend'</span>, <span class="attr">password</span>: <span class="string">'123456'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.url === <span class="string">'/'</span>) &#123;</span><br><span class="line">    response.end(<span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">4000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The server is running at http://localhost:4000'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出<code>{&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;}</code></p>
<h4 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h4><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p>
<p>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p>
<p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p>
<p>先下载<a href="http://nginx.org/en/download.html">nginx</a>，然后将nginx目录下的nginx.conf修改如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proxy服务器</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">81</span>;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http:<span class="comment">//www.domain2.com:8080;  #反向代理</span></span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http:<span class="comment">//www.domain1.com;  #当前端只跨域不带cookie时，可为*</span></span><br><span class="line">        add_header Access-Control-Allow-Credentials <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后通过命令行<code>nginx -s reload</code>启动nginx</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.domain1.com:81/?user=admin'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.parse(req.url.substring(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 向前台写cookie</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>   <span class="comment">// HttpOnly:脚本无法读取</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="window-name-iframe"><a href="#window-name-iframe" class="headerlink" title="window.name + iframe"></a>window.name + iframe</h4><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>
<p>其中a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.html(http://localhost:3000/b.html)</span></span><br><span class="line">  &lt;iframe src=<span class="string">"http://localhost:4000/c.html"</span> frameborder=<span class="string">"0"</span> onload=<span class="string">"load()"</span> id=<span class="string">"iframe"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> first = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(first)&#123;</span><br><span class="line">      <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="line">        <span class="keyword">let</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line">        iframe.src = <span class="string">'http://localhost:3000/b.html'</span>;</span><br><span class="line">        first = <span class="literal">false</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span><br><span class="line">        <span class="built_in">console</span>.log(iframe.contentWindow.name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>b.html为中间代理页，与a.html同域，内容为空。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.html(http://localhost:4000/c.html)</span></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   <span class="built_in">window</span>.name = <span class="string">'我不爱你'</span>  </span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h4 id="location-hash-iframe"><a href="#location-hash-iframe" class="headerlink" title="location.hash +  iframe"></a>location.hash +  iframe</h4><p>实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>
<p>具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。 同样的，a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是`<a href="http://localhost:4000">http://localhost:4000</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.html</span></span><br><span class="line"> &lt;iframe src=<span class="string">"http://localhost:4000/c.html#iloveyou"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">   <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//检测hash的变化</span></span><br><span class="line">     <span class="built_in">console</span>.log(location.hash);</span><br><span class="line">   &#125;</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ b.html</span></span><br><span class="line"><span class="regexp"> &lt;script&gt;</span></span><br><span class="line"><span class="regexp">   window.parent.parent.location.hash = location.hash </span></span><br><span class="line"><span class="regexp">   /</span><span class="regexp">/b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span></span><br><span class="line"><span class="regexp"> &lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// c.html</span></span><br><span class="line"><span class="built_in">console</span>.log(location.hash);</span><br><span class="line"> <span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line"> iframe.src = <span class="string">'http://localhost:3000/b.html#idontloveyou'</span>;</span><br><span class="line"> <span class="built_in">document</span>.body.appendChild(iframe);</span><br></pre></td></tr></table></figure>

<h4 id="document-domain-iframe"><a href="#document-domain-iframe" class="headerlink" title="document.domain + iframe"></a>document.domain + iframe</h4><p><strong>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式</strong>。 只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p>
<p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>
<p>我们看个例子：页面<code>a.zf1.cn:3000/a.html</code>获取页面<code>b.zf1.cn:3000/b.html</code>中a的值</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> helloa</span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://b.zf1.cn:3000/b.html"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">onload</span>=<span class="string">"load()"</span> <span class="attr">id</span>=<span class="string">"frame"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'zf1.cn'</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(frame.contentWindow.a);</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// b.html</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   hellob</span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">     <span class="built_in">document</span>.domain = <span class="string">'zf1.cn'</span></span></span><br><span class="line"><span class="javascript">     <span class="keyword">var</span> a = <span class="number">100</span>;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案</li>
<li>JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li>
<li>不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。</li>
<li>日常工作中，用得比较多的跨域方案是cors和nginx反向代理</li>
</ul>
</script></p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-typescript" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/17/typescript/" class="article-date">
      <time datetime="2020-06-17T07:35:59.000Z" itemprop="datePublished">2020-06-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/typescript/">typescript</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="ts基础"><a href="#ts基础" class="headerlink" title="ts基础"></a>ts基础</h4><h6 id="vscode配置自动编译ts"><a href="#vscode配置自动编译ts" class="headerlink" title="vscode配置自动编译ts"></a>vscode配置自动编译ts</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tsc --init  //生成tsconfig.json文件</span><br><span class="line">//在tsconfig.json文件 改 &quot;outDir&quot;: &quot;./js&quot;</span><br><span class="line">在导航栏找到  任务--&gt; 监视 tsconfig.json</span><br></pre></td></tr></table></figure>

<h6 id="hbuild配置自动编译ts"><a href="#hbuild配置自动编译ts" class="headerlink" title="hbuild配置自动编译ts"></a>hbuild配置自动编译ts</h6><ol>
<li>在最上面菜单栏，点击工具——插件安装。</li>
<li>点击下方浏览Eclipse插件市场，搜索typescript插件进行安装</li>
<li>安装完后重启编译器，点击菜单栏工具——选项，选择编译ts文件</li>
<li>在你的项目上右键点击——配置——Enable TypeScript Builder，之后你再保存</li>
<li>.ts文件时会自动保存在当前目录编译出对应的.js文件</li>
</ol>
<h6 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h6><p>布尔类型(boolean)</p>
<p>数字类型(number)</p>
<p>字符串类型(string)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var str:string = &apos;hello&apos;;</span><br></pre></td></tr></table></figure>

<p>数组类型(array)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr:Array&lt;number&gt; = [11,22,33];  //全是数字的数组</span><br><span class="line">var arr:number[] = [11,22,33];</span><br></pre></td></tr></table></figure>

<p>元组类型(tuple)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//元组类型属于数组类型用于给数组中每个位置指定类型</span><br><span class="line">let arr:[number,string] = [123,&apos;this is ts&apos;];</span><br></pre></td></tr></table></figure>

<p>枚举类型(enum)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum 枚举名&#123;</span><br><span class="line">	标识符[=整型常数]，</span><br><span class="line">	标识符[=整型常数]，</span><br><span class="line">	...</span><br><span class="line">	标识符[=整型常数]，</span><br><span class="line">&#125;;</span><br><span class="line">enum Flag &#123; success=1,error=2 &#125;;</span><br><span class="line">let s:Flag = Flag.success;</span><br><span class="line">console.log(s);   //1</span><br><span class="line">//如果标识符没有赋值，它的值就是下标。</span><br></pre></td></tr></table></figure>

<p>任意类型(any)</p>
<p>null 和 undefined</p>
<p>void类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//一般用于定义方法没有返回值</span><br><span class="line">function run():void&#123;</span><br><span class="line">	console.log(&apos;ksdkl&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>never类型</p>
<ul>
<li>never类型是其他类型（包括null和undefined）的子类型，代表从不会出现的值。这意味着声明never的变量只能被never类型所赋值。</li>
</ul>
<h6 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function run():string&#123;</span><br><span class="line">	//必须返回string类型的值</span><br><span class="line">&#125;</span><br><span class="line">//匿名函数</span><br><span class="line">let fun2 = function():number&#123;</span><br><span class="line">	//返回数字类型的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>es5里面方法的实参和形参可以不一样，但是ts中必须一样，如果不一样就需要配置可选参数。（加个 ? )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getInfo(name:string,age?:number):string&#123;</span><br><span class="line">	if(age)&#123;</span><br><span class="line">		return `$&#123;name&#125; --- $&#123;age&#125;`;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		return `$&#123;name&#125; --- 年龄保密`</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(getInfo(&apos;zhangsan&apos;));   //zhangsan --- 年龄保密</span><br></pre></td></tr></table></figure>

<h6 id="ts的重载"><a href="#ts的重载" class="headerlink" title="ts的重载"></a>ts的重载</h6><ul>
<li>java中的方法的重载，重载指的是两个或两个以上同名函数，但他们的参数不一样，这时会出现函数重载的情况。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getInfo(name:string):string;</span><br><span class="line">function getInfo(age:number):string;</span><br><span class="line">function getInfo(str:any):any&#123;</span><br><span class="line">	if(typeof str === &apos;string&apos;)&#123;</span><br><span class="line">		return &quot;我叫：&quot; + str;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		return &quot;我的年龄是&quot; + str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="对象继承"><a href="#对象继承" class="headerlink" title="对象继承"></a>对象继承</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//es5的类</span><br><span class="line">function Person()&#123;</span><br><span class="line">	this.name = &apos;张三&apos;;</span><br><span class="line">	this.age = 20;</span><br><span class="line">	this.run = function()&#123;</span><br><span class="line">		alert(this.name);  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex = &apos;男&apos;;</span><br><span class="line">Person.prototype.work = function()&#123;</span><br><span class="line">	alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">//web类继承Person类 原型链 + 对象冒充的组合继承模式</span><br><span class="line">function Web()&#123;</span><br><span class="line">	Person.call(this);  //对象冒充实现继承</span><br><span class="line">&#125;</span><br><span class="line">let w = new Web();</span><br><span class="line">w.run();  //对象冒充可以继承构造函数里面的属性和方法</span><br><span class="line">w.work();   //报错，对象冒充不可以继承原型链上的属性和方法</span><br><span class="line"></span><br><span class="line">function Web()&#123;&#125;</span><br><span class="line">Web.prototype = new Person();  //原型链实现继承</span><br><span class="line">let w = new Web();</span><br><span class="line">//原型链实现继承：可以继承构造函数里面的属性和方法，也可以继承原型链上的属性和方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//es6的类</span><br><span class="line">class Person&#123;</span><br><span class="line">	name:string;  //属性 前面省略了public关键字</span><br><span class="line">	constructor(a:string)&#123; </span><br><span class="line">		this.name = n;</span><br><span class="line">	&#125;</span><br><span class="line">	run():void&#123;</span><br><span class="line">		alert(this.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = new Person(&apos;张三&apos;);</span><br><span class="line">p.run();</span><br></pre></td></tr></table></figure>

<h6 id="ts接口"><a href="#ts接口" class="headerlink" title="ts接口"></a>ts接口</h6><ul>
<li>接口的作用：在面向对象编程中，接口是一种规范的定义，它定义了行为和动作的规范</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//封装请求的接口</span><br><span class="line">interface Config&#123;</span><br><span class="line">	type:string;</span><br><span class="line">	url: string;</span><br><span class="line">	data?: string;</span><br><span class="line">	dataType: string;</span><br><span class="line">&#125;</span><br><span class="line">function ajax(config:Config)&#123;</span><br><span class="line">	let xml = new XMLHttpResquest();</span><br><span class="line">	xhr.open(config.type,config.url,true);   //true表示异步请求</span><br><span class="line">	xhr.send(config.data);</span><br><span class="line">	xhr.onreadystatechange = function()&#123;</span><br><span class="line">		if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class="line">			console.log(&apos;success&apos;);</span><br><span class="line">			if(config.dataType == &apos;json&apos;)&#123;</span><br><span class="line">				JSON.parse(xhr.responseText);</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				console.log(xhr.responseText);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(&#123;</span><br><span class="line">	type: &apos;get&apos;,</span><br><span class="line">	data: &apos;name=zhangsan&apos;,</span><br><span class="line">	url: &apos;http://a.itying.com/api/productlist&apos;,</span><br><span class="line">	dataType: &apos;json&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>函数类型接口</strong></p>
<ul>
<li>对方法传入的参数以及返回值进行约束。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//加密的函数类型接口</span><br><span class="line">interface encrypt&#123;</span><br><span class="line">	(key:string,value:string):string;</span><br><span class="line">&#125;</span><br><span class="line">let md5:encrypt = function(key:string,value:string):string&#123;</span><br><span class="line">	return key + value;</span><br><span class="line">&#125;</span><br><span class="line">console.log(md5(&apos;name&apos;,&apos;zhangsan&apos;));</span><br></pre></td></tr></table></figure>

<h6 id="ts的实现和继承"><a href="#ts的实现和继承" class="headerlink" title="ts的实现和继承"></a>ts的实现和继承</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">	eat():void;</span><br><span class="line">&#125;</span><br><span class="line">interface Person extends Animal&#123;</span><br><span class="line">	work():void;</span><br><span class="line">&#125;</span><br><span class="line">class Web implements Person&#123;</span><br><span class="line">	public name:string;</span><br><span class="line">	constructor(name:string)&#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	eat()&#123;&#125;</span><br><span class="line">	work()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//web继承programmer，实现person</span><br><span class="line">class Programmer&#123;</span><br><span class="line">	public name:string;</span><br><span class="line">	constructor(name:string)&#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	coding(code:string)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Web extends Programmer implements Person&#123;</span><br><span class="line">	constructor(name:string)&#123;&#125;</span><br><span class="line">	eat()&#123;&#125;</span><br><span class="line">	work()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="ts泛型"><a href="#ts泛型" class="headerlink" title="ts泛型"></a>ts泛型</h6><ul>
<li>泛型：在软件工程中，我们不仅要创建一致的良好的API，也要考虑其可重用性，组件不仅能够支持大哥钱的数据类型，同时也能能支持未来的数据类型，这在创建大型系统时为你提供灵活的功能。</li>
<li>在像C#和java这样的语言中，可以使用泛型来创建可重用地组件，一个组件支持多种类型的数据，这样用户就可以以自己的数据来使用组件。</li>
<li>泛型就是解决类 接口 方法的复用性，以及对不特定数据类型的支持。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//使用any相当于放弃了数据类型检查</span><br><span class="line">function getData(value:any):any&#123;</span><br><span class="line">	return value;</span><br><span class="line">&#125;</span><br><span class="line">//T表示泛型，具体什么类型是调用这个方法时决定的，可支持不特定类型的数据类型。可支持传入参数与返回参数的类型一致。</span><br><span class="line">function getData&lt;T&gt;(value:T):T&#123;</span><br><span class="line">	return value;</span><br><span class="line">&#125;</span><br><span class="line">getDate&lt;number&gt;(123);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//操作数据库的泛型类</span><br><span class="line">class Mysql&lt;T&gt;&#123;</span><br><span class="line">	add(info:T):boolean&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ArticleCate&#123;</span><br><span class="line">	title: string|undefined;</span><br><span class="line">	desc: string|undefined;</span><br><span class="line">	status: number|undefined;</span><br><span class="line">	constructor(params:&#123;</span><br><span class="line">		title: string|undefined;</span><br><span class="line">		desc: string|undefined;</span><br><span class="line">		status?: number|undefined;</span><br><span class="line">	&#125;)&#123;</span><br><span class="line">		this.title = params.title</span><br><span class="line">		this.deac = params.desc;</span><br><span class="line">		this.status = params.status;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var a = new ArticleCate(&#123;</span><br><span class="line">	title: &apos;分类&apos;,</span><br><span class="line">	desc: &apos;111&apos;,</span><br><span class="line">	status: 1</span><br><span class="line">&#125;)</span><br><span class="line">//类当作参数的泛型类</span><br><span class="line">var Db = new MySqlDb&lt;ArticleCate&gt;();</span><br><span class="line">Db.add(a);</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-jquery" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/17/jquery/" class="article-date">
      <time datetime="2020-06-17T07:29:38.000Z" itemprop="datePublished">2020-06-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/jquery/">jquery</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>jquery对象是一个包含所有匹配的dom元素的伪数组对象。</strong></p>
<h1 id="js-加载时间线"><a href="#js-加载时间线" class="headerlink" title="js 加载时间线"></a><a href="https://www.cnblogs.com/wenlv88/articles/9932919.html" target="_blank" rel="noopener">js 加载时间线</a></h1><p>1、创建document对象，开始<strong>解析</strong>web页面。创建HTMLHtmlElement对象，添加到document中。这个阶段document.readyState = ‘loading’；</p>
<p>2、遇到link外部css，创建线程加载，并继续解析文档。<strong>并发；</strong></p>
<p>3、遇到script外部js，并且没有设置async、defer，浏览器创建线程加载，并<strong>阻塞</strong>，等待js加载完成并执行该脚本，然后继续解析文档。<strong>js拥有修改dom的能力</strong>–&gt;domcument.write；</p>
<p>4、遇到script外部js，并且设置有async、defter，浏览器创建线程加载，并继续解析文档；</p>
<p>　　defer属性设置后，表示加载script外部js和解析html页面是异步，并且等到html解析完成再执行js解析后的代码；</p>
<p>　　async属性设置后，表示加载script外部js和解析html页面是异步，但是当js解析完成，立刻执行它，此时html解析是<strong>被阻塞</strong>的；</p>
<p>document.createElement(‘script’)的方式动态插入script元素来模拟async属性，实现脚本异步加载和执行；</p>
<p>5、遇到img等，浏览器创建线程加载，并继续解析文档。<strong>并发；</strong></p>
<p>6、当文档解析完成，document.readyState = ‘interactive’；</p>
<p>7、文档解析完成后，所有设置有defer的脚本会按照顺序执行（注意与async的不同）；</p>
<p>8、document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，<strong>转化为事件驱动阶段；</strong></p>
<p>9、当所有async的脚本加载完成并执行后、img等加载完成后，document.readyState = ‘complete’，window对象触发load事件；</p>
<p>10、从此，以异步响应方式处理用户输入、网络事件等。</p>
<h1 id="jQeury"><a href="#jQeury" class="headerlink" title="jQeury"></a>jQeury</h1><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络上的内容分发网络，依靠部署在各边缘服务器，通过中心平台的负载均衡，内容分发，调度等功能模块，使用户就近获取所需的内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术在于内容存储和分发技术。</p>
<p>使用Google的CDN</p>
<p>src=”<a href="http://ajax.googleapis.com/ajax/libs/jquery/1.4.0/jquery.min.js&quot;" target="_blank" rel="noopener">http://ajax.googleapis.com/ajax/libs/jquery/1.4.0/jquery.min.js&quot;</a></p>
<p>使用Microsoft的CDN</p>
<p>src=”<a href="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.mim.js&quot;" target="_blank" rel="noopener">http://ajax.microsoft.com/ajax/jquery/jquery-1.4.mim.js&quot;</a></p>
<p>如果您不希望下载并存放 jQuery，那么也可以通过 CDN（内容分发网络） 引用它。</p>
<p>百度、又拍云、新浪、谷歌和微软的服务器都存有 jQuery 。</p>
<p>如果你的站点用户是国内的，建议使用百度、又拍云、新浪等国内CDN地址，如果你站点用户是国外的可以使用谷歌和微软。</p>
<p>使用百度，又拍云，新浪，谷歌或微软的jQuery的一大优势：</p>
<p>当用户在访问其他站点时，已经从百度，又拍云，新浪，谷歌或1微软加载过jQuery，所以当他们访问你的站点时，会从缓存中加载jQuery,这样就减少了加载时间。同时，大多数CDN都可以确保当用户向其请求文件时，会从离用户最近的服务器上访问响应，这样也可以提高加载速度</p>
<p>$(document).ready(function(){//jQuery代码})；</p>
<p>这是为了防止文档未完全加载之前就执行jQuery代码，可能会失败</p>
<table>
<thead>
<tr>
<th align="left">语法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$(“*”)</td>
<td align="left">选取所有元素</td>
</tr>
<tr>
<td align="left">$(this)</td>
<td align="left">选取当前 HTML 元素</td>
</tr>
<tr>
<td align="left">$(“p.intro”)</td>
<td align="left">选取 class 为 intro 的 <p> 元素</p></td>
</tr>
<tr>
<td align="left">$(“p:first”)</td>
<td align="left">选取第一个 <p> 元素</p></td>
</tr>
<tr>
<td align="left">$(“ul li:first”)</td>
<td align="left">选取第一个 <ul> 元素的第一个 <li> 元素</li></ul></td>
</tr>
<tr>
<td align="left">$(“ul li:first-child”)</td>
<td align="left">选取每个 <ul> 元素的第一个 <li> 元素</li></ul></td>
</tr>
<tr>
<td align="left">$(“[href]”)</td>
<td align="left">选取带有 href 属性的元素</td>
</tr>
<tr>
<td align="left">$(“a[target=’_blank’]”)</td>
<td align="left">选取所有 target 属性值等于 “_blank” 的 <a> 元素</a></td>
</tr>
<tr>
<td align="left">$(“a[target!=’_blank’]”)</td>
<td align="left">选取所有 target 属性值不等于 “_blank” 的 <a> 元素</a></td>
</tr>
<tr>
<td align="left">$(“:button”)</td>
<td align="left">选取所有 type=”button” 的 <input> 元素 和 <button> 元素</button></td>
</tr>
<tr>
<td align="left">$(“tr:even”)</td>
<td align="left">选取偶数位置的 </td></tr><tr> 元素
</tr>
<tr>
<td align="left">$(“tr:odd”)</td>
<td align="left">选取奇数位置的 </td></tr><tr> 元素
</tr>
</tbody></table>
<p>常见 DOM 事件：</p>
<table>
<thead>
<tr>
<th align="left">鼠标事件</th>
<th align="left">键盘事件</th>
<th align="left">表单事件</th>
<th align="left">文档/窗口事件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">click</td>
<td align="left">keypress</td>
<td align="left">submit</td>
<td align="left">load</td>
</tr>
<tr>
<td align="left">dblclick</td>
<td align="left">keydown</td>
<td align="left">change</td>
<td align="left">resize</td>
</tr>
<tr>
<td align="left">mouseenter</td>
<td align="left">keyup</td>
<td align="left">focus</td>
<td align="left">scroll</td>
</tr>
<tr>
<td align="left">mouseleave</td>
<td align="left"></td>
<td align="left">blur</td>
<td align="left">unload</td>
</tr>
</tbody></table>
<h4 id="基本行为"><a href="#基本行为" class="headerlink" title="基本行为"></a>基本行为</h4><ul>
<li>length：包含dom元素个数</li>
<li>[index]/get(index)：得到对应位置的DOM元素</li>
<li>each()：遍历包含所有的DOM元素</li>
<li>index():得到所在兄弟元素中的下标</li>
</ul>
<h6 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h6><ul>
<li><p>多个过滤器不是同时执行的，而是依次执行的。</p>
<p>$(‘li:gt(0):lt(3)’).css(‘background’,’red’)      下标是 1  2  3变底色</p>
<p>$(‘li:lt(3):gt(0)’).css(‘background’,’red’)       下标是1  2 变底色</p>
</li>
</ul>
<h6 id="mouseover与mouseenter区别"><a href="#mouseover与mouseenter区别" class="headerlink" title="mouseover与mouseenter区别"></a>mouseover与mouseenter区别</h6><ul>
<li>mouseover：在移入子元素时才会触发，对应mouseout</li>
<li>mouseenter：只在移入当前元素才触发，对应mouseleave</li>
<li>hover（）使用的是mouseenter与mouseleave</li>
</ul>
<h4 id="事件委托（委派-代理）"><a href="#事件委托（委派-代理）" class="headerlink" title="事件委托（委派/代理）"></a>事件委托（委派/代理）</h4><ul>
<li>将多个元素（li）的事件监听委托给父辈元素上（ul）处理。</li>
<li>监听回调是加在父辈元素上</li>
<li>当操作任何一个子元素时（li），事件会冒泡到父辈元素上（ul）</li>
<li>父辈元素不会直接处理事件，而是通过event.target得到发生事件的子元素（li），通过这个子元素调用事件回调函数。</li>
<li>$(‘ul’).delegate(‘li’,’click’,function(){})</li>
<li>委托2方<ul>
<li>委托方：业主   li</li>
<li>被委托方     中介   ul</li>
</ul>
</li>
<li>好处<ul>
<li>新添加的子元素自动有事件响应处理。</li>
<li>减少事件监听的数量 ： n==&gt;1</li>
</ul>
</li>
<li>API<ul>
<li>设置事件委托：$(parentSelector).delegate(childrenSelector,eventName,callback)</li>
<li>移出事件委托：$(parentSlector).undelegate(eventName)</li>
</ul>
</li>
</ul>
<h2 id="比较keypress、keydown与keyup"><a href="#比较keypress、keydown与keyup" class="headerlink" title="比较keypress、keydown与keyup"></a>比较keypress、keydown与keyup</h2><ul>
<li>keydown：在键盘上按下某键时发生，一直按着则会不断触发（opera浏览器除外），它返回的是键盘代码;</li>
<li>keypress：在键盘上按下一个按键，并产生一个字符时发生, 返回ASCII码。注意: shift、alt、ctrl等键按下并不会产生字符，所以监听无效，换句话说，只有按下能在屏幕上输出字符的按键时keypress事件才会触发。若一直按着某按键则会不断触发。</li>
<li>keyup：用户松开某一个按键时触发，与keydown相对，返回键盘代码.</li>
</ul>
<p>$(<em>selector</em>).hide(<em>speed,callback</em>);<br>$(<em>selector</em>).show(<em>speed,callback</em>);</p>
<p>$(selector).toggle(speed,callback);  //切换hide（）和show（）方法</p>
<p>可选的 speed 参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast” 或毫秒。</p>
<p>可选的 callback 参数是 toggle() 方法完成后所执行的函数名称。</p>
<p>可选的 callback 参数，具有以下三点说明：</p>
<ol>
<li>$(selector)选中的元素的个数为n个，则callback函数会执行n次</li>
<li>callback函数名后加括号，会立刻执行函数体，而不是等到显示/隐藏完成后才执行</li>
<li>callback既可以是函数名，也可以是匿名函数</li>
</ol>
<p>在在jQuery中可以通过四个方法来实现元素的淡入淡出，这四个方法分别是：fadeIn()、fadeOut()、fadeToggle() 以及 fadeTo()</p>
<p>$(document).ready(function(){<br>  $(“button”).click(function(){<br>    $(“#div1”).fadeIn();<br>    $(“#div2”).fadeIn(“slow”);<br>    $(“#div3”).fadeIn(3000);<br>  });<br>});</p>
<p>jQuery fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间）。</p>
<p>$(<em>selector</em>).fadeTo(<em>speed,opacity,callback</em>);</p>
<p>jQuery slideDown() 方法用于向下滑动元素。</p>
<p>$(<em>selector</em>).slideDown(<em>speed,callback</em>);</p>
<h2 id="jQuery-slideToggle-方法"><a href="#jQuery-slideToggle-方法" class="headerlink" title="jQuery slideToggle() 方法"></a>jQuery slideToggle() 方法</h2><p>jQuery slideToggle() 方法可以在 slideDown() 与 slideUp() 方法之间进行切换。</p>
<p>如果元素向下滑动，则 slideToggle() 可向上滑动它们。</p>
<p>如果元素向上滑动，则 slideToggle() 可向下滑动它们。</p>
<p> $(<em>selector</em>).animate({<em>params</em>}<em>,speed,callback</em>);</p>
<p>必需的 params 参数定义形成动画的 CSS 属性。</p>
<p>可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。</p>
<p>可选的 callback 参数是动画完成后所执行的函数名称。</p>
<p>默认情况下，所有的 HTML 元素有一个静态的位置，且是不可移动的。 如果需要改变为，我们需要将元素的 position 属性设置为 relative, fixed, 或 absolute!</p>
<p><strong>可以用 animate() 方法来操作所有 CSS 属性吗？</strong><br>是的，几乎可以！不过，需要记住一件重要的事情：当使用 animate() 时，必须使用 Camel 标记法书写所有的属性名，比如，必须使用 paddingLeft 而不是 padding-left，使用 marginRight 而不是 margin-right，等等。</p>
<p>jQuery stop() 方法用于停止动画或效果，在它们完成之前。</p>
<p>stop() 方法适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画。</p>
<p> $(<em>selector</em>).stop(<em>stopAll,goToEnd</em>);</p>
<p>可选的 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。</p>
<p>可选的 goToEnd 参数规定是否立即完成当前动画。默认是 false。</p>
<p>因此，默认地，stop() 会清除在被选元素上指定的当前动画。</p>
<p>三个简单实用的用于 DOM 操作的 jQuery 方法：</p>
<ul>
<li>text() - 设置或返回所选元素的文本内容</li>
<li>html() - 设置或返回所选元素的内容（包括 HTML 标记）</li>
<li>val() - 设置或返回表单字段的值</li>
</ul>
<p>jQuery attr() 方法用于获取属性值。</p>
<h2 id="添加新的-HTML-内容"><a href="#添加新的-HTML-内容" class="headerlink" title="添加新的 HTML 内容"></a>添加新的 HTML 内容</h2><p>我们将学习用于添加新内容的四个 jQuery 方法：</p>
<ul>
<li><p><a href="https://www.w3cschool.cn/jquery/html-append.html" target="_blank" rel="noopener">append()</a> - 在被选元素内部的结尾插入指定内容</p>
</li>
<li><p><a href="https://www.w3cschool.cn/jquery/html-prepend.html" target="_blank" rel="noopener">prepend()</a> - 在被选元素内部的开头插入指定内容</p>
</li>
<li><p><a href="https://www.w3cschool.cn/jquery/html-after.html" target="_blank" rel="noopener">after()</a> - 在被选元素之后插入内容</p>
</li>
<li><p><a href="https://www.w3cschool.cn/jquery/html-before.html" target="_blank" rel="noopener">before()</a> - 在被选元素之前插入内容</p>
<p>$(“img”).after(“在后面添加文本”); </p>
</li>
</ul>
<p>$(“img”).before(“在前面添加文本”);  </p>
<p><strong>提示：</strong>在jQuery中，append/prepend 是在选择元素内部嵌入，而after/before 是在元素外面追加。</p>
<h2 id="删除元素-内容"><a href="#删除元素-内容" class="headerlink" title="删除元素/内容"></a>删除元素/内容</h2><p>如需删除元素和内容，一般可使用以下两个 jQuery 方法：</p>
<ul>
<li><a href="https://www.w3cschool.cn/jquery/html-remove.html" target="_blank" rel="noopener">remove()</a> - 删除被选元素（及其子元素）</li>
<li><a href="https://www.w3cschool.cn/jquery/html-empty.html" target="_blank" rel="noopener">empty()</a> - 从被选元素中删除子元素</li>
</ul>
<h2 id="jQuery-操作-CSS"><a href="#jQuery-操作-CSS" class="headerlink" title="jQuery 操作 CSS"></a>jQuery 操作 CSS</h2><p>jQuery 拥有若干进行 CSS 操作的方法。我们将学习下面这些：</p>
<ul>
<li><a href="https://www.w3cschool.cn/jquery/html-addclass.html" target="_blank" rel="noopener">addClass()</a> - 向被选元素添加一个或多个类</li>
<li><a href="https://www.w3cschool.cn/jquery/html-removeclass.html" target="_blank" rel="noopener">removeClass()</a> - 从被选元素删除一个或多个类</li>
<li><a href="https://www.w3cschool.cn/jquery/html-toggleclass.html" target="_blank" rel="noopener">toggleClass()</a> - 对被选元素进行添加/删除类的切换操作</li>
<li><a href="https://www.w3cschool.cn/jquery/jquery-css.html" target="_blank" rel="noopener">css()</a> - 设置或返回样式属性</li>
</ul>
<h2 id="设置-CSS-属性"><a href="#设置-CSS-属性" class="headerlink" title="设置 CSS 属性"></a>设置 CSS 属性</h2><p>如需设置指定的 CSS 属性，请使用如下语法：    </p>
<p>css({“<em>propertyname</em>“:”<em>value</em>“,”<em>propertyname</em>“:”<em>value</em>“,…});</p>
<p>jQuery 提供多个处理尺寸的重要方法：</p>
<ul>
<li><a href="https://www.w3cschool.cn/jquery/css-width.html" target="_blank" rel="noopener">width()</a></li>
<li><a href="https://www.w3cschool.cn/jquery/css-height.html" target="_blank" rel="noopener">height()</a></li>
<li><a href="https://www.w3cschool.cn/jquery/html-innerwidth.html" target="_blank" rel="noopener">innerWidth()</a></li>
<li><a href="https://www.w3cschool.cn/jquery/html-innerheight.html" target="_blank" rel="noopener">innerHeight()</a></li>
<li><a href="https://www.w3cschool.cn/jquery/html-outerwidth.html" target="_blank" rel="noopener">outerWidth()</a></li>
<li><a href="https://www.w3cschool.cn/jquery/html-outerheight.html" target="_blank" rel="noopener">outerHeight()</a></li>
</ul>
<p><img src="https://7n.w3cschool.cn/statics/images/course/img_jquerydim.gif" alt="jQuery Dimensions"></p>
<h2 id="向上遍历-DOM-树"><a href="#向上遍历-DOM-树" class="headerlink" title="向上遍历 DOM 树"></a>向上遍历 DOM 树</h2><ul>
<li><a href="https://www.w3cschool.cn/jquery/traversing-parent.html" target="_blank" rel="noopener">parent()</a><ul>
<li>parent() 方法返回被选元素的直接父元素。</li>
</ul>
</li>
<li><a href="https://www.w3cschool.cn/jquery/traversing-parents.html" target="_blank" rel="noopener">parents()</a><ul>
<li>parents() 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (<html>)。</html></li>
</ul>
</li>
<li><a href="https://www.w3cschool.cn/jquery/traversing-parentsuntil.html" target="_blank" rel="noopener">parentsUntil()</a><ul>
<li>parentsUntil() 方法返回介于两个给定元素之间的所有祖先元素。</li>
<li>返回介于 <span> 与 <div> 元素之间的所有祖先元素： $(“span”).parentsUntil(“div”);</div></span></li>
</ul>
</li>
</ul>
<h2 id="向下遍历-DOM-树"><a href="#向下遍历-DOM-树" class="headerlink" title="向下遍历 DOM 树"></a>向下遍历 DOM 树</h2><p>下面是两个用于向下遍历 DOM 树的 jQuery 方法：</p>
<ul>
<li><a href="https://www.w3cschool.cn/jquery/traversing-children.html" target="_blank" rel="noopener">children()</a></li>
<li><a href="https://www.w3cschool.cn/jquery/traversing-find.html" target="_blank" rel="noopener">find()</a></li>
</ul>
<h2 id="在-DOM-树中水平遍历"><a href="#在-DOM-树中水平遍历" class="headerlink" title="在 DOM 树中水平遍历"></a>在 DOM 树中水平遍历</h2><p>有许多有用的方法让我们在 DOM 树进行水平遍历：</p>
<ul>
<li>siblings()：返回被选元素的所有同胞元素</li>
<li>next()：返回被选元素的下一个同胞元素</li>
<li>nextAll()：返回被选元素的所有跟随的同胞元素</li>
<li>nextUntil()：返回介于两个给定参数之间的所有跟随的同胞元素</li>
<li>prev()</li>
<li>prevAll()</li>
<li>prevUntil()</li>
</ul>
<h2 id="缩小搜索元素的范围"><a href="#缩小搜索元素的范围" class="headerlink" title="缩小搜索元素的范围"></a>缩小搜索元素的范围</h2><p>三个最基本的过滤方法是：first(), last() 和 eq()，它们允许您基于其在一组元素中的位置来选择一个特定的元素。</p>
<p>其他过滤方法，比如 filter() 和 not() 允许您选取匹配或不匹配某项指定标准的元素。</p>
<p>first（）：返回被选元素的首个元素</p>
<p>last（）：返回被选元素的最后一个元素</p>
<p><a href="https://www.w3cschool.cn/jquery/traversing-eq.html" target="_blank" rel="noopener">eq() 方法</a>返回被选元素中带有指定索引号的元素。</p>
<p>索引号从 0 开始，因此首个元素的索引号是 0 而不是 1。</p>
<p><a href="https://www.w3cschool.cn/jquery/traversing-filter.html" target="_blank" rel="noopener">filter() 方法</a>允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。</p>
<p>jQuery  AJAX</p>
<ul>
<li>AJAX是与服务器交换数据的技术，它在不重载全部页面的情况下，实现对部分页面的更新</li>
<li>AJAX=异步JavaScript和XML（Asynchronous  JavaScript   and  XML),通过AJAX方法，你可以使用HTTP Get和HTTP Post从远程服务器上请求文本，HTML,XML,JSON,同时你可把这些外部数据直接载入网页的被选元素中</li>
</ul>
<h4 id="作为一般函数调用-param"><a href="#作为一般函数调用-param" class="headerlink" title="作为一般函数调用$(param)"></a>作为一般函数调用$(param)</h4><ol>
<li>参数为函数：当DOM加载完成后，执行此回调函数。</li>
<li>参数为选择器字符串：查找所有匹配的标签，并把它们封装成jquery对象。</li>
<li>参数是DOM对象：将dom对象封装成jquery对象。</li>
<li>参数为html标签字符串（用得最少）：创建标签对象并封装成jquery对象。</li>
</ol>
<h4 id="作为对象使用"><a href="#作为对象使用" class="headerlink" title="作为对象使用"></a>作为对象使用</h4><ol>
<li>$.each()：隐式遍历数组</li>
<li>$.trim()：去除两端的空格</li>
</ol>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h4 id="load（）"><a href="#load（）" class="headerlink" title="load（）"></a>load（）</h4><ul>
<li>load（）方法从服务器加载数据，并把返回的数据放入被选元素中<ul>
<li>$(selector).load(URL,data,callback);</li>
<li>必须的URL参数规定你希望加载的URL</li>
<li>可选的data参数规定与请求一同发送的查询字符串键/值对集合</li>
<li>可选的callback（responseTxt，statusTXT，xhr）参数是load（）完成后执行的函数名称，无论AJAX请求是否成功，一旦请求完成后，函数callback立即被触发</li>
<li>responseTxt–包含调用成功时的结果内容     statusTXT—包含调用的状态        xhr——包含XMLHttpRequest对象</li>
</ul>
</li>
</ul>
<h4 id="get（URL-callback）和post（）"><a href="#get（URL-callback）和post（）" class="headerlink" title="$.get（URL,callback）和post（）"></a>$.get（URL,callback）和post（）</h4><ul>
<li>两者都能通过HTTP或POST请求从服务器请求数据</li>
<li>get是从指定的资源请求数据，基本用于从服务器获得数据，可能返回缓存数据</li>
<li>post向指定的资源提交要处理的数据，可用于从服务器获取数据。不过，post方法不会缓存数据，并且常用于连同请求一起发送数据</li>
</ul>
<h4 id="noConflict（）方法"><a href="#noConflict（）方法" class="headerlink" title="$.noConflict（）方法"></a>$.noConflict（）方法</h4><ul>
<li>解决在页面同时使用jQuery和其他框架（在同一个页面加载多个jQuery实例，尤其是不同版本的jQuery）</li>
<li>noConflict（）会释放对$($是jQuery的简写）</li>
</ul>
<h4 id="selector-bind-event-data-function-map"><a href="#selector-bind-event-data-function-map" class="headerlink" title="$(selector).bind(event,data,function,map)"></a>$(selector).bind(event,data,function,map)</h4><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>event</em></td>
<td align="left">必需。规定添加到元素的一个或多个事件。  由空格分隔多个事件值。必须是有效的事件。</td>
</tr>
<tr>
<td align="left"><em>data</em></td>
<td align="left">可选。规定传递到函数的额外数据。</td>
</tr>
<tr>
<td align="left"><em>function</em></td>
<td align="left">必需。规定当事件发生时运行的函数。</td>
</tr>
<tr>
<td align="left"><em>map</em></td>
<td align="left">规定事件映射 (<em>{event:function, event:function, …})</em>，包含要添加到元素的一个或多个事件，以及当事件发生时运行的函数。</td>
</tr>
</tbody></table>
<ul>
<li><p>bind() 方法向被选元素添加一个或多个事件处理程序，以及当事件发生时运行的函数。</p>
</li>
<li><p>自 jQuery 版本 1.7 起，<a href="https://www.w3cschool.cn/jquery/event-on.html" target="_blank" rel="noopener">on()</a> 方法是向被选元素添加事件处理程序的首选方法。</p>
</li>
</ul>
<h4 id="selector-delegate-childSelector-event-data-function"><a href="#selector-delegate-childSelector-event-data-function" class="headerlink" title="$(selector).delegate(childSelector,event,data,function)"></a>$(selector).delegate(childSelector,event,data,function)</h4><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>childSelector</em></td>
<td align="left">必需。规定要添加事件处理程序的一个或多个子元素。</td>
</tr>
<tr>
<td align="left"><em>event</em></td>
<td align="left">必需。规定添加到元素的一个或多个事件。  由空格分隔多个事件值。必须是有效的事件。</td>
</tr>
<tr>
<td align="left"><em>data</em></td>
<td align="left">可选。规定传递到函数的额外数据。</td>
</tr>
<tr>
<td align="left"><em>function</em></td>
<td align="left">必需。规定当事件发生时运行的函数。</td>
</tr>
</tbody></table>
<h1 id="原生js与jQuery的区别"><a href="#原生js与jQuery的区别" class="headerlink" title="原生js与jQuery的区别"></a>原生js与jQuery的区别</h1><p>1.原生JS与jQuery入口函数的加载模式不同</p>
<ul>
<li>原生JS会等到DOM元素和图片都加载完毕再执行</li>
<li>jQuery只是等DOM加载完毕之后就执行</li>
</ul>
<p>2.覆盖问题</p>
<ul>
<li>原生js如果有多个入口函数，后面编写的会覆盖前面的</li>
<li>jQuery有多个入口函数时不会相互覆盖，都会执行</li>
</ul>
<p>3.多个框架时的冲突问题</p>
<ul>
<li>解决方法：释放$的使用权</li>
</ul>
<p>iQuery.noConflict();</p>
<p>注意点：释放操作必须在编写其他jQuery代码之前编写</p>
<p>​              释放之后就不能再使用$改为jQuery</p>
<ul>
<li>自定义访问符号</li>
</ul>
<p>var  nj = jQuery.noConflict();</p>
<p>nj(function (){ });</p>
<p>4.遍历数组</p>
<ul>
<li><p>js中用forEach（）只能遍历数组，不能遍历伪数组，参数位置不同</p>
<p>arr.forEach(function (value,index){  });</p>
</li>
<li><p>利用jQuery的Each（）静态方法遍历数组/伪数组,参数位置不同</p>
<p>$.each(arr,function (index,value){  });//遍历数组</p>
<p>$.each(obj，function (index,value){  });//遍历伪数组</p>
</li>
</ul>
<p>jQuery中的each（）静态方法和map（）静态方法的区别：</p>
<ul>
<li>each（）静态方法默认的返回值就是遍历谁就返回谁，不支持在回调函数中对数组进行处理</li>
<li>map（）静态方法默认的返回值是一个空数组，可通过回调函数进行处理，然后生成一个新的数组返回</li>
</ul>
<h2 id="复习jquery"><a href="#复习jquery" class="headerlink" title="复习jquery"></a>复习jquery</h2><ul>
<li>DOM中的顶级对象：document ——页面中的顶级对象</li>
<li>BOM中的顶级对象：window</li>
<li>jQuery的顶级对象：jQuery——$</li>
</ul>
<h6 id="与-的区别"><a href="#与-的区别" class="headerlink" title="$与$()的区别"></a>$与$()的区别</h6><ul>
<li>$是一个函数对象，包含很多静态方法，这种方法，一般的js也是可以使用。</li>
<li>$（）是调用这个函数对象的一个实例，返回一个对象，一般是由$对象拓展的对象属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$().css();</span><br><span class="line">$().html();</span><br><span class="line"></span><br><span class="line">$.trim();</span><br><span class="line">$.proxy();</span><br></pre></td></tr></table></figure>

<h6 id="常见属性方法"><a href="#常见属性方法" class="headerlink" title="$常见属性方法"></a>$常见属性方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">trim()			去除前后格</span><br><span class="line">makeArray()		类数组转为真数组</span><br><span class="line">inArray()		数组版indexOf</span><br><span class="line">merge()			合并数组</span><br><span class="line">grep()			过滤新数组</span><br><span class="line">map()			映射新数组</span><br><span class="line">guid			唯一标识符</span><br><span class="line">proxy()			改this指向</span><br><span class="line">access()		多功能操作值（内部）</span><br><span class="line">now()			当前时间</span><br><span class="line">swap()			CSS交换（内部）</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-js动画篇" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/17/js动画篇/" class="article-date">
      <time datetime="2020-06-17T07:27:46.000Z" itemprop="datePublished">2020-06-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/js动画篇/">js动画篇</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><h4 id="一-keyframes规则是创建动画，它指定一个css样式和动画将逐步从当前样式更改为新的样式"><a href="#一-keyframes规则是创建动画，它指定一个css样式和动画将逐步从当前样式更改为新的样式" class="headerlink" title="一. @keyframes规则是创建动画，它指定一个css样式和动画将逐步从当前样式更改为新的样式"></a>一. @keyframes规则是创建动画，它指定一个css样式和动画将逐步从当前样式更改为新的样式</h4><p>当在keyframes创建动画时，把他绑定到一个选择器，否则动画不会有任何效果，至少指定这两个动画属性</p>
<ul>
<li>规定动画名称</li>
<li>规定动画时长</li>
<li>animation:  myfirst  5s;</li>
</ul>
<h4 id="二-animation属性"><a href="#二-animation属性" class="headerlink" title="二 . animation属性"></a>二 . animation属性</h4><p>语法：</p>
<p>animation: name    duration    time-function    delay    iteration-count    direction;</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>animation-name</td>
<td>规定需要绑定到选择器的keyframe名称</td>
</tr>
</tbody></table>
<p>animation-duration    规定完成动画所花费的时间，以s/ms记</p>
<p>animation-time-function    规定动画的速度曲线</p>
<p>animation-iteration-count    规定动画应该播放的次数</p>
<p>animation-direction    规定是否应该轮流方向播放动画</p>
<p><strong>注意</strong>：请始终规定animation-duration属性，否则时长为0，就不会播放动画。</p>
<h4 id="三-animation-delay属性"><a href="#三-animation-delay属性" class="headerlink" title="三  . animation-delay属性"></a>三  . animation-delay属性</h4><h5 id="1-定义动画什么时候开始（s-ms）"><a href="#1-定义动画什么时候开始（s-ms）" class="headerlink" title="1.定义动画什么时候开始（s/ms）"></a>1.定义动画什么时候开始（s/ms）</h5><ul>
<li>可为负值，-2s使动画马上开始，但跳过2s进入动画</li>
</ul>
<h4 id="四-animation-direction属性"><a href="#四-animation-direction属性" class="headerlink" title="四 . animation-direction属性"></a>四 . animation-direction属性</h4><h5 id="1-animation-direction：属性控制如何在reverse或alternate周期播放动画。"><a href="#1-animation-direction：属性控制如何在reverse或alternate周期播放动画。" class="headerlink" title="1.animation-direction：属性控制如何在reverse或alternate周期播放动画。"></a>1.animation-direction：属性控制如何在<code>reverse</code>或<code>alternate</code>周期播放动画。</h5><p>如果 animation-direction 值是 “alternate”，则动画会在奇数次数（1、3、5 等等）正常播放，而在偶数次数（2、4、6 等等）向后播放。</p>
<p>注释：如果把动画设置为只播放一次，则该属性没有效果。</p>
<ul>
<li>属性值</li>
</ul>
<table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>normal</td>
<td>以正常的方式播放动画</td>
</tr>
<tr>
<td>reverse</td>
<td>以相反方向播放动画</td>
</tr>
<tr>
<td>alternate</td>
<td>播放动画作为正常每奇数时间（1,3,5等）和反方向每偶数时间（2,4,6，等…）</td>
</tr>
<tr>
<td>alternate-reverse</td>
<td>在每个奇数时间（1,3,5等）在相反方向上播放动画，并且在每个偶数时间（2,4,6等等）的正常方向上播放动画</td>
</tr>
</tbody></table>
<h4 id="五-animation-duration属性"><a href="#五-animation-duration属性" class="headerlink" title="五 . animation-duration属性"></a>五 . animation-duration属性</h4><h5 id="1-定义完成一个动画需要的时间s-ms"><a href="#1-定义完成一个动画需要的时间s-ms" class="headerlink" title="1.定义完成一个动画需要的时间s/ms"></a>1.定义完成一个动画需要的时间s/ms</h5><p>animation-duration：time；</p>
<h4 id="六-animation-fill-mode属性"><a href="#六-animation-fill-mode属性" class="headerlink" title="六 . animation-fill-mode属性"></a>六 . animation-fill-mode属性</h4><h5 id="1-设置样式以在动画不播放时应用元素"><a href="#1-设置样式以在动画不播放时应用元素" class="headerlink" title="1.设置样式以在动画不播放时应用元素"></a>1.设置样式以在动画不播放时应用元素</h5><ul>
<li><p>animation-fill-mode:none | forwards | backwards |both |initial |inherit ;</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>默认值，无样式</td>
</tr>
</tbody></table>
<p>forwards    动画结束后，使用元素的结束属性值</p>
<p>backwards    使用元素的起始值</p>
<p>both    动画遵循向前向后的规则</p>
</li>
</ul>
<h4 id="七-animation-iteration-count属性"><a href="#七-animation-iteration-count属性" class="headerlink" title="七 . animation-iteration-count属性"></a>七 . animation-iteration-count属性</h4><h5 id="1-定义动画应该播放几次"><a href="#1-定义动画应该播放几次" class="headerlink" title="1 . 定义动画应该播放几次"></a>1 . 定义动画应该播放几次</h5><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><em>n</em></td>
<td>定义播放动画多少次。 默认值为1</td>
</tr>
<tr>
<td>infinite</td>
<td>指定动画应该播放无限次（永远）</td>
</tr>
</tbody></table>
<h4 id="八-animation-name属性"><a href="#八-animation-name属性" class="headerlink" title="八 . animation-name属性"></a>八 . animation-name属性</h4><h5 id="1-animation-name属性为-keyframes动画规定名称"><a href="#1-animation-name属性为-keyframes动画规定名称" class="headerlink" title="1. animation-name属性为@keyframes动画规定名称"></a>1. animation-name属性为@keyframes动画规定名称</h5><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>keyframename</td>
<td>规定需要绑定到选择器的 keyframe 的名称。</td>
</tr>
<tr>
<td>none</td>
<td>规定无动画效果（可用于覆盖来自级联的动画）。</td>
</tr>
</tbody></table>
<h4 id="九-animation-play-state属性"><a href="#九-animation-play-state属性" class="headerlink" title="九 . animation-play-state属性"></a>九 . animation-play-state属性</h4><h5 id="1-设置是否运行或者暂停动画"><a href="#1-设置是否运行或者暂停动画" class="headerlink" title="1.设置是否运行或者暂停动画"></a>1.设置是否运行或者暂停动画</h5><p>你可以在js中使用该属性，这样就可以在播放过程中暂停动画</p>
<p>animation-play-state：paused | running；</p>
<h4 id="十-animation-timing-function属性"><a href="#十-animation-timing-function属性" class="headerlink" title="十 . animation-timing-function属性"></a>十 . animation-timing-function属性</h4><h5 id="1-指定动画速度曲线"><a href="#1-指定动画速度曲线" class="headerlink" title="1 . 指定动画速度曲线"></a>1 . 指定动画速度曲线</h5><p>​    速度曲线定义动画从一套CSS样式变为另一套所用的时间，速度曲线用于使变化更为平滑</p>
<p>​    animation-timing-function : linear | ease | ease-in | ease-out | cubic-bezier(n,n,n,n);</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">linear</td>
<td align="left">动画从开始到结束具有相同的速度。</td>
</tr>
<tr>
<td align="left">ease</td>
<td align="left">动画有一个缓慢的开始，然后快，结束慢。</td>
</tr>
<tr>
<td align="left">ease-in</td>
<td align="left">动画有一个缓慢的开始。</td>
</tr>
<tr>
<td align="left">ease-out</td>
<td align="left">动画结束缓慢。</td>
</tr>
<tr>
<td align="left">ease-in-out</td>
<td align="left">动画具有缓慢的开始和慢的结束。</td>
</tr>
<tr>
<td align="left">cubic-bezier(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td align="left">在立方贝塞尔函数中定义速度函数。 可能的值是从0到1的数字值。</td>
</tr>
</tbody></table>
<hr>

<h1 id="转换transform"><a href="#转换transform" class="headerlink" title="转换transform"></a>转换transform</h1><h2 id="一-2D转换"><a href="#一-2D转换" class="headerlink" title="一 . 2D转换"></a>一 . 2D转换</h2><h5 id="1-旋转transform-rotate-30deg"><a href="#1-旋转transform-rotate-30deg" class="headerlink" title="1.旋转transform : rotate(30deg);"></a>1.旋转transform : rotate(30deg);</h5><p>在给定度数顺时针旋转的元素。负值表示逆时针deg表示度数。</p>
<h5 id="2-移动-transform-translate-50px-100px"><a href="#2-移动-transform-translate-50px-100px" class="headerlink" title="2.移动 transform:translate(50px,100px);"></a>2.移动 transform:translate(50px,100px);</h5><p>往左往上为正</p>
<h5 id="3-缩放-transform：scale（2，4）；"><a href="#3-缩放-transform：scale（2，4）；" class="headerlink" title="3.缩放 transform：scale（2，4）；"></a>3.缩放 transform：scale（2，4）；</h5><p>scale（2,4）转变宽度为原来的大小的2倍，和其原始大小4倍的高度。</p>
<h5 id="4-倾斜-transform：skew（30deg，20deg）；"><a href="#4-倾斜-transform：skew（30deg，20deg）；" class="headerlink" title="4.倾斜 transform：skew（30deg，20deg）；"></a>4.倾斜 transform：skew（30deg，20deg）；</h5><p>包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。</p>
<ul>
<li>skewX( );表示只在X轴(水平方向)倾斜。</li>
</ul>
<ul>
<li>skewY( );表示只在Y轴(垂直方向)倾斜。 </li>
<li>skew(30deg,20deg) 是元素在X轴和Y轴上倾斜20度30度。</li>
</ul>
<h2 id="总的语法"><a href="#总的语法" class="headerlink" title="总的语法"></a>总的语法</h2><p>transform: none|<em>transform-functions</em>;</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">none</td>
<td align="left">定义不进行转换。</td>
<td></td>
</tr>
<tr>
<td align="left">matrix(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td align="left">定义 2D 转换，使用六个值的矩阵。</td>
<td></td>
</tr>
<tr>
<td align="left">matrix3d(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td align="left">定义 3D 转换，使用 16 个值的 4x4 矩阵。</td>
<td></td>
</tr>
<tr>
<td align="left">translate(<em>x</em>,<em>y</em>)</td>
<td align="left">定义 2D 转换。</td>
<td></td>
</tr>
<tr>
<td align="left">translate3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td align="left">定义 3D 转换。</td>
<td></td>
</tr>
<tr>
<td align="left">translateX(<em>x</em>)</td>
<td align="left">定义转换，只是用 X 轴的值。</td>
<td></td>
</tr>
<tr>
<td align="left">translateY(<em>y</em>)</td>
<td align="left">定义转换，只是用 Y 轴的值。</td>
<td></td>
</tr>
<tr>
<td align="left">translateZ(<em>z</em>)</td>
<td align="left">定义 3D 转换，只是用 Z 轴的值。</td>
<td></td>
</tr>
<tr>
<td align="left">scale(<em>x</em>[,<em>y</em>]?)</td>
<td align="left">定义 2D 缩放转换。</td>
<td></td>
</tr>
<tr>
<td align="left">scale3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td align="left">定义 3D 缩放转换。</td>
<td></td>
</tr>
<tr>
<td align="left">scaleX(<em>x</em>)</td>
<td align="left">通过设置 X 轴的值来定义缩放转换。</td>
<td></td>
</tr>
<tr>
<td align="left">scaleY(<em>y</em>)</td>
<td align="left">通过设置 Y 轴的值来定义缩放转换。</td>
<td></td>
</tr>
<tr>
<td align="left">scaleZ(<em>z</em>)</td>
<td align="left">通过设置 Z 轴的值来定义 3D 缩放转换。</td>
<td></td>
</tr>
<tr>
<td align="left">rotate(<em>angle</em>)</td>
<td align="left">定义 2D 旋转，在参数中规定角度。</td>
<td></td>
</tr>
<tr>
<td align="left">rotate3d(<em>x</em>,<em>y</em>,<em>z</em>,<em>angle</em>)</td>
<td align="left">定义 3D 旋转。</td>
<td></td>
</tr>
<tr>
<td align="left">rotateX(<em>angle</em>)</td>
<td align="left">定义沿着 X 轴的 3D 旋转。</td>
<td></td>
</tr>
<tr>
<td align="left">rotateY(<em>angle</em>)</td>
<td align="left">定义沿着 Y 轴的 3D 旋转。</td>
<td></td>
</tr>
<tr>
<td align="left">rotateZ(<em>angle</em>)</td>
<td align="left">定义沿着 Z 轴的 3D 旋转。</td>
<td></td>
</tr>
<tr>
<td align="left">skew(<em>x-angle</em>,<em>y-angle</em>)</td>
<td align="left">定义沿着 X 和 Y 轴的 2D 倾斜转换。</td>
<td></td>
</tr>
<tr>
<td align="left">skewX(<em>angle</em>)</td>
<td align="left">定义沿着 X 轴的 2D 倾斜转换。</td>
<td></td>
</tr>
<tr>
<td align="left">skewY(<em>angle</em>)</td>
<td align="left">定义沿着 Y 轴的 2D 倾斜转换。</td>
<td></td>
</tr>
<tr>
<td align="left">perspective(<em>n</em>)</td>
<td align="left">为 3D 转换元素定义透视视图。</td>
<td></td>
</tr>
</tbody></table>
<h4 id="二-transform-origin"><a href="#二-transform-origin" class="headerlink" title="二 . transform-origin"></a>二 . transform-origin</h4><h5 id="1-transform-Origin属性允许您更改转换元素的位置。"><a href="#1-transform-Origin属性允许您更改转换元素的位置。" class="headerlink" title="1.transform-Origin属性允许您更改转换元素的位置。"></a>1.transform-Origin属性允许您更改转换元素的位置。</h5><p>2D转换元素可以改变元素的X和Y轴。 3D转换元素，还可以更改元素的Z轴。</p>
<p>transform-origin: <em>x-axis y-axis z-axis</em>;</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">x-axis</td>
<td align="left">定义视图被置于 X 轴的何处。left center right <em>length</em> <em>%</em></td>
</tr>
<tr>
<td align="left">y-axis</td>
<td align="left">定义视图被置于 Y 轴的何处。可能的值：top center bottom   <em>length</em>     <em>%</em></td>
</tr>
<tr>
<td align="left">z-axis</td>
<td align="left">定义视图被置于 Z 轴的何处。可能的值：<em>length</em></td>
</tr>
</tbody></table>
<h5 id="2-transform-style属性指定嵌套元素是怎么在三维空间中呈现"><a href="#2-transform-style属性指定嵌套元素是怎么在三维空间中呈现" class="headerlink" title="2.transform-style属性指定嵌套元素是怎么在三维空间中呈现"></a>2.transform-style属性指定嵌套元素是怎么在三维空间中呈现</h5><ul>
<li><p>transform-style: flat | preserve-3d;</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">flat</td>
<td align="left">子元素将不保留其 3D 位置。</td>
</tr>
<tr>
<td align="left">preserve-3d</td>
<td align="left">子元素将保留其 3D 位置。</td>
</tr>
</tbody></table>
</li>
</ul>
<p>让转换的子元素保留3D转换：</p>
<p>div<br>{<br>transform: rotateY(60deg);<br>transform-style: preserve-3d;<br>-webkit-transform: rotateY(60deg); /* Safari and Chrome <em>/<br>-webkit-transform-style: preserve-3d; /</em> Safari and Chrome */<br>}</p>
<h1 id="transition属性过渡"><a href="#transition属性过渡" class="headerlink" title="transition属性过渡"></a>transition属性过渡</h1><p>transition 属性是一个简写属性，用于设置四个过渡属性：</p>
<ul>
<li>transition-property</li>
<li>transition-duration</li>
<li>transition-timing-function</li>
<li>transition-delay</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition: property duration timing-function delay;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transition-property</td>
<td>规定设置过渡效果的 CSS 属性的名称。</td>
</tr>
<tr>
<td>transition-duration</td>
<td>规定完成过渡效果需要多少秒或毫秒。</td>
</tr>
<tr>
<td>transition-timing-function</td>
<td>规定速度效果的速度曲线。</td>
</tr>
<tr>
<td>transition-delay</td>
<td>定义过渡效果何时开始。</td>
</tr>
</tbody></table>
<ul>
<li><p>transition-property属性指定css属性的nametransition效果（transition效果时将会启动指定的css属性的变化。</p>
</li>
<li><p>一个转场效果通常发生在当鼠标悬停在一个元素上</p>
</li>
<li><p>始终指定transition-duration属性，否则持续时间为0，transition不会有效果默认值是all，多项改变要添加多个样式的变换效果，添加的属性由逗号分隔</p>
<p>transition-property: none|all| <em>property</em>;</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">none</td>
<td align="left">没有属性会获得过渡效果。</td>
</tr>
<tr>
<td align="left">all</td>
<td align="left">所有属性都将获得过渡效果。</td>
</tr>
<tr>
<td align="left"><em>property</em></td>
<td align="left">定义应用过渡效果的 CSS 属性名称列表，列表以逗号分隔。</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="三-透视3D属性perspective"><a href="#三-透视3D属性perspective" class="headerlink" title="三 . 透视3D属性perspective"></a>三 . 透视3D属性perspective</h4><p>多少像素的3D元素是从视图的perspective属性定义。这个属性允许你改变3D元素是怎样查看透视图。perspective 属性只影响 3D 转换元素；定义时的perspective属性，它是一个元素的子元素，透视图，而不是元素本身。</p>
<p>perspective: <em>number</em>|none;</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>number</em></td>
<td align="left">元素距离视图的距离，以像素计。</td>
</tr>
<tr>
<td align="left">none</td>
<td align="left">默认值。与 0 相同。不设置透视。</td>
</tr>
</tbody></table>
<p>一般跟perspective-origin属性配合使用，默认值都是50%</p>
<h4 id="四-。-backface-visibility属性"><a href="#四-。-backface-visibility属性" class="headerlink" title="四 。 backface-visibility属性"></a>四 。 backface-visibility属性</h4><h5 id="1-backface-visibility属性定义当元素不面向屏幕时是否可见，默认可见"><a href="#1-backface-visibility属性定义当元素不面向屏幕时是否可见，默认可见" class="headerlink" title="1. backface-visibility属性定义当元素不面向屏幕时是否可见，默认可见"></a>1. backface-visibility属性定义当元素不面向屏幕时是否可见，默认可见</h5><p>如果在旋转元素不希望看到其背面时，该属性很有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backface-visibility: visible|hidden;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>visible</td>
<td>默认值。 背面是可见的。</td>
</tr>
<tr>
<td>hidden</td>
<td>背面是不可见的。</td>
</tr>
</tbody></table>
<h4 id="五-盒阴影box-shadow"><a href="#五-盒阴影box-shadow" class="headerlink" title="五 . 盒阴影box-shadow"></a>五 . 盒阴影box-shadow</h4><p>box-shadow : 向左偏移量  向下偏移量  阴影半径  颜色；</p>
<p><strong>注意</strong>：向右向下为正</p>
<h4 id="六-边界图片border-image"><a href="#六-边界图片border-image" class="headerlink" title="六 . 边界图片border-image"></a>六 . 边界图片border-image</h4><p>border-image属性允许你指定一个图片作为边框！用于创建上文边框的原始图像</p>
<p>border-image:url(border.png) 30 30 round; </p>
<p>速记属性</p>
<p>border-image：source    slice   width    outset   repeat；</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>border-image-source</em></td>
<td align="left">用于指定要用于绘制边框的图像的位置</td>
</tr>
<tr>
<td align="left"><em>border-image-slice</em></td>
<td align="left">图像边界向内偏移</td>
</tr>
<tr>
<td align="left"><em>border-image-width</em></td>
<td align="left">图像边界的宽度</td>
</tr>
<tr>
<td align="left"><em>border-image-outset</em></td>
<td align="left">用于指定在边框外部绘制 border-image-area 的量</td>
</tr>
<tr>
<td align="left"><em>border-image-repeat</em></td>
<td align="left">这个例子演示了如何创建一个border-image 属性的按钮。</td>
</tr>
</tbody></table>
<ul>
<li>border-image-source: url(border.png);</li>
</ul>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">none</td>
<td align="left">没有图像被使用</td>
</tr>
<tr>
<td align="left"><em>image</em></td>
<td align="left">边框使用图像的路径</td>
</tr>
</tbody></table>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-image-outset: length|number（代表对应的border-width的倍数）;</span><br></pre></td></tr></table></figure>

<p><strong>注释：</strong>border-image-outset 属性规定边框图像超出边框盒的量。在上、右、下、左侧。如果忽略第四个值，则与第二个值相同。如果省略第三个值，则与第一个值相同。如果省略第二个值，则与第一个值相同。不允许任何负值作为 border-image-outset 值。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-image-width: number|%|auto;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>border-image -width的4个值指定用于把border图像区域分为九个部分。他们代表上，右，底部，左，两侧向内距离。如果第四个值被省略，它和第二个是相同的。如果也省略了第三个，它和第一个是相同的。如果也省略了第二个，它和第一个是相同的。负值是不允许的。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><em>number</em></td>
<td>代表对应的 border-width 的倍数。</td>
</tr>
<tr>
<td><em>%</em></td>
<td>参考边框图像区域的尺寸：区域的高度影响水平偏移，宽度影响垂直偏移。</td>
</tr>
<tr>
<td><em>auto</em></td>
<td>如果规定该属性，则宽度为对应的图像切片的固有宽度。</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="七-border-collapse-属性"><a href="#七-border-collapse-属性" class="headerlink" title="七 . border-collapse 属性"></a>七 . border-collapse 属性</h4><p>设置表格的边框是否被合并为一个单一的边框</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">collapse</td>
<td align="left">如果可能，边框会合并为一个单一的边框。会忽略 border-spacing 和 empty-cells 属性</td>
</tr>
<tr>
<td align="left">separate</td>
<td align="left">默认值。边框会被分开。不会忽略 border-spacing 和 empty-cells 属性</td>
</tr>
<tr>
<td align="left">inherit</td>
<td align="left">规定应该从父元素继承 border-collapse 属性的值</td>
</tr>
</tbody></table>
<h4 id="八-border-color-红，绿，蓝-粉红色"><a href="#八-border-color-红，绿，蓝-粉红色" class="headerlink" title="八 .border-color:红，绿，蓝,粉红色;"></a>八 .<strong>border-color:红，绿，蓝,粉红色;</strong></h4><ul>
<li>上边框是红色</li>
<li>右边框是绿色</li>
<li>底部边框是蓝</li>
<li>左边框是粉红色</li>
</ul>
<p><strong>border-color：红，绿，蓝;</strong></p>
<ul>
<li>上边框是红色</li>
<li>左，右边框是绿色</li>
<li>底部边框是蓝</li>
</ul>
<p><strong>border-color：红，绿;</strong></p>
<ul>
<li>顶部和底部边框是红色</li>
<li>左右边框是绿色</li>
</ul>
<p><strong>border-color：红色;</strong></p>
<ul>
<li>所有四个边框是红色</li>
</ul>
<p>请始终把 border-style 属性声明到 border-color 属性之前。元素必须在您改变其颜色之前获得边框。</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>color</em></td>
<td align="left">指定背景颜色。在CSS颜色值查找颜色值的完整列表</td>
</tr>
<tr>
<td align="left">transparent</td>
<td align="left">指定边框的颜色应该是透明的。这是默认</td>
</tr>
<tr>
<td align="left">inherit</td>
<td align="left">指定边框的颜色，应该从父元素继承</td>
</tr>
</tbody></table>
<h1 id="颜色渐变"><a href="#颜色渐变" class="headerlink" title="颜色渐变"></a>颜色渐变</h1><h2 id="一-线性渐变（Linear-Gradients）"><a href="#一-线性渐变（Linear-Gradients）" class="headerlink" title="一 . 线性渐变（Linear Gradients）"></a>一 . 线性渐变（Linear Gradients）</h2><ul>
<li>background: linear-gradient(direction, color-stop1, color-stop2, …);   <ul>
<li>background: -webkit-linear-gradient(red, blue); /* Safari  */ </li>
<li>background: -o-linear-gradient(red, blue); /* Opera **/ *</li>
<li>background: -moz-linear-gradient(red, blue); /* Firefox  */ </li>
<li>background: linear-gradient(red, blue); /* 标准的语法 */ </li>
</ul>
</li>
</ul>
<h2 id="二-径向渐变（Radial-Gradients）"><a href="#二-径向渐变（Radial-Gradients）" class="headerlink" title="二 . 径向渐变（Radial Gradients）"></a>二 . 径向渐变（Radial Gradients）</h2><ul>
<li><p>默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。</p>
</li>
<li><p>background: radial-gradient(center, shape size, start-color, …, last-color);  </p>
</li>
<li><p><strong>径向渐变 - 颜色结点不均匀分布</strong></p>
<ul>
<li>background: -webkit-radial-gradient(red 5%, green 15%, blue 60%);</li>
</ul>
</li>
<li><p>shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse。</p>
<h5 id="不同尺寸大小关键字的使用"><a href="#不同尺寸大小关键字的使用" class="headerlink" title="不同尺寸大小关键字的使用"></a>不同尺寸大小关键字的使用</h5><p>size 参数定义了渐变的大小。它可以是以下四个值：</p>
<ul>
<li><strong>closest-side</strong></li>
<li><strong>farthest-side</strong></li>
<li><strong>closest-corner</strong></li>
<li><strong>farthest-corner</strong></li>
</ul>
</li>
</ul>
<h3 id="三-透明度transparency"><a href="#三-透明度transparency" class="headerlink" title="三 . 透明度transparency"></a>三 . 透明度transparency</h3><ul>
<li>用于创建减弱变淡的效果；为了添加透明度，我们使用 rgba() 函数来定义颜色结点。rgba() 函数中的最后一个参数可以是从 0 到 1 的值，它定义了颜色的透明度：0 表示完全透明，1 表示完全不透明。</li>
<li>repeating-linear-gradient() 函数用于重复线性渐变：</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-js精研" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/17/js精研/" class="article-date">
      <time datetime="2020-06-17T07:15:42.000Z" itemprop="datePublished">2020-06-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/17/js精研/">js精研</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="一-基础补充"><a href="#一-基础补充" class="headerlink" title="一 . 基础补充"></a>一 . 基础补充</h2><h4 id="1-值，变量和类型"><a href="#1-值，变量和类型" class="headerlink" title="1.值，变量和类型"></a>1.值，变量和类型</h4><ul>
<li><p>typeof  undefined;//“undefined”</p>
</li>
<li><p>js是基于32位整数的</p>
</li>
<li><p>以下两种情况，js会自动将数值转为科学计数法</p>
<ul>
<li>小数点前的数字多于21位</li>
<li>小数点后的0多于5个</li>
</ul>
</li>
<li><p>在js内部，实际存在两个0：+0和-0，他们是等价的</p>
</li>
<li><p>当js在算数运算时发生溢出（overflow，结果是Infinity），下溢（underflow，结果是-Infinity）或被0整除时不会报错</p>
</li>
<li><p>Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。isFinite函数返回一个布尔值，检查某个值是不是正常数值，而不是Infinity。</p>
</li>
<li><p><strong>注意</strong>：0除以0是无意义的，会返回NaN</p>
<ul>
<li>isNaN判断一个值是否为NaN，它只对数值有效，若传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true时，有可能不是NaN，而不是一个字符串</li>
<li>使用isNaN前，最好判断一下数据类型  typeof  value===’number’&amp;&amp; isNaN(value)</li>
<li>判断NaN更可靠的方法是利用NaN在js中唯一不等于自身的值这个特点进行判断   value!==value</li>
</ul>
</li>
<li><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。</p>
<ul>
<li><p>length属性返回字符串的长度，该属性也是无法改变的。</p>
</li>
<li><p>如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。</p>
</li>
<li><p>注意：字符串与数组仅仅是相似而已。字符串是无法改变字符串之中的单个字符。</p>
<p>var a = ‘hello’;</p>
<p>delete s[0];</p>
<p>s // “hello”</p>
<p>s[0] = ‘a’;</p>
<p>s  // “hello”</p>
</li>
</ul>
</li>
<li><p>尽管null和undefined是不同的，但它们都表示“值的空缺”，两者往往可以互换。当用相等运算符“==”来比较两者时，会返回true。（要使用严格相等运算符“===”来区分它们）</p>
</li>
<li><p>如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。</p>
<p>undefined<br>null<br>false<br>0<br>NaN<br>“”或’’（空字符串）</p>
</li>
<li><p>如果一个变量没有声明就直接使用，JavaScript会<strong>报错</strong>，告诉你变量未定义。</p>
</li>
<li><p><strong>声明提前（变量提升）</strong> </p>
<ul>
<li>JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就是声明提前（变量提升，hoisting）。</li>
<li>变量提升只对var命令声明的变量有效，如果一个变量不是用var命令声明的，就不会发生变量提升。</li>
</ul>
</li>
<li><p>typeof运算符对未声明的变量运算，不会报错，输出值也是“undefined”，故不能区分该值是否已声明，但是其他运算符对未声明变量进行运算会报错</p>
</li>
<li><p><strong>对于浮点字面量的有趣之处在于，用它进行计算之前，真正存储的是字符串。</strong>任何值在输出时一般都会转化成字符串输出</p>
</li>
<li><p>ECMAScript默认把具有6个或6个以上前导0的浮点数转化成科学计数法。也可以用64位IEEE 754形式存储浮点值，这意味着十进制最多可以有17个十进制位，17位之后的值将被裁剪，从而造成较小的误差</p>
</li>
<li><p>当计算生成的数大于 Number.MAX_VALUE 时，它将被赋予值Number.POSITIVE_INFINITY，意味着不再有数字值。同样，生成的数值小于Number.MIN_VALUE 的计算也会被赋予值Number.NEGATIVE_INFINITY，也意味着不再有数字值。如果计算返回的是无穷大值，那么生成的结果不能再用于其他计算。</p>
</li>
<li></li>
</ul>
<h4 id="2-语句"><a href="#2-语句" class="headerlink" title="2.语句"></a>2.语句</h4><ul>
<li><p><strong>注意</strong>：由于对每个case的匹配操作实际是“===”恒等运算符比较，而不是“==”相等运算符比较，因此，表达式和case的匹配并不会做任何类型转换。</p>
</li>
<li><p>使用while(true)则会创建一个死循环。</p>
</li>
<li><p><strong>标签语句</strong></p>
<ul>
<li><p>语句是可以添加标签的，标签是由语句前的标识符和冒号组成：</p>
<p>label  :  statement</p>
</li>
</ul>
</li>
<li><p>return语句只能在函数体内出现，否则报错。当执行到return语句时，函数终止执行。</p>
</li>
<li><p><strong>throw语句</strong>:异常是指当发生了某种异常情况或错误时产生的一个信号。</p>
</li>
<li><p>with语句：用于临时扩展作用域链</p>
<p>with ( object ){</p>
<p>statement</p>
<p>}</p>
<p>将object添加到作用域链的头部，然后执行statement，最后把作用域链恢复到原生状态。</p>
<p>注意：在严格模式中是禁止使用with语句的。</p>
</li>
<li><p>debugger语句用来产生一个断点（breakpoint），JavaScript代码的执行会停止在断点的位置。一般用来调试代码。</p>
</li>
<li><p><strong>“use strict”</strong></p>
<p>使用”use strict”指令的目的是说明后续的代码将会解析成严格代码。</p>
</li>
</ul>
<h4 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h4><ul>
<li><p>对象是一个基本数据类型，成员以键值对形式存在</p>
</li>
<li><p>键名：对象的所有键名都是字符串，所以加不加引号都可以。如果键名是数值，会被自动转为字符串。</p>
</li>
<li><p>对象的每一个“键名”又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。</p>
</li>
<li><p>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），也不是数字，则必须加上引号，否则会报错。</p>
</li>
<li><p>为了避免这种歧义，JavaScript规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。</p>
</li>
<li><p><strong>创建对象</strong></p>
<p>在JavaScript中，有三种方法创建对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象直接量： var o=&#123;&#125;;</span><br><span class="line">关键字new： var o=new Object();</span><br><span class="line">Object.create()函数： var o=Object.create(null)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象直接量中的最后一个属性后的逗号可有可无，但是在ie中，如果多了一个逗号，会报错。<strong>通过new创建对象</strong></p>
<p>new运算符创建并初始化一个新对象。关键字new后跟随一个函数调用，这个函数称做<strong>构造函数</strong>（constructor）。</p>
</li>
<li><p>属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性。</p>
</li>
<li><p>读取对象的属性</p>
<ul>
<li>有两种方法，一种是使用点运算符（最终还是得先变成方括号），还有一种是使用方括号运算符</li>
<li>数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。</li>
<li>通过点（.）或方括号（[]）运算符来获取属性的值时，运算符左侧应当是一个表达式，它返回一个对象。</li>
</ul>
</li>
<li><p>查看一个对象本身的所有属性，可以使用Object.keys方法，返回一个类数组</p>
<p>var o = {</p>
<p>  name : ‘a’,</p>
<p>  age : 12</p>
<p>}</p>
<p>Object.keys(o)  //[‘name’,’age’]</p>
</li>
<li><p><strong>删除属性</strong></p>
<ul>
<li><p>delete运算符只能删除自有属性，不能删除继承属性。</p>
</li>
<li><h6 id="删除一个不存在的属性，delete不报错，而且返回true。"><a href="#删除一个不存在的属性，delete不报错，而且返回true。" class="headerlink" title="删除一个不存在的属性，delete不报错，而且返回true。"></a>删除一个不存在的属性，delete不报错，而且返回true。</h6></li>
<li><p>只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。</p>
</li>
</ul>
</li>
<li><p><strong>检测属性</strong>是否存在于某个对象中</p>
<ul>
<li><p>用“！==”来判断一个属性是否是undefined（无法判断属性是否是继承来的）</p>
</li>
<li><h6 id="hasOwnPreperty（）方法：检测的是自身属性，无关继承来的属性"><a href="#hasOwnPreperty（）方法：检测的是自身属性，无关继承来的属性" class="headerlink" title="hasOwnPreperty（）方法：检测的是自身属性，无关继承来的属性"></a>hasOwnPreperty（）方法：检测的是自身属性，无关继承来的属性</h6></li>
<li><h6 id="propertyIsEnumerable（）方法：只有检测到自有属性且这个属性的可枚举性为true时才返回true"><a href="#propertyIsEnumerable（）方法：只有检测到自有属性且这个属性的可枚举性为true时才返回true" class="headerlink" title="propertyIsEnumerable（）方法：只有检测到自有属性且这个属性的可枚举性为true时才返回true"></a>propertyIsEnumerable（）方法：只有检测到自有属性且这个属性的可枚举性为true时才返回true</h6></li>
<li><p>in元素符左侧属性名（字符串），右侧是对象。如果对象的自有属性或继承属性中包含这个属性就返回true（无法判断属性是否是继承来的）</p>
</li>
</ul>
</li>
<li><p>对象的三大属性</p>
<ul>
<li>每个对象都有与之相关的<strong>原型（prototype）</strong>，类（class）和可扩展性（extensible  attribute）</li>
<li>将对象作为参数传入Object.getPrototypeOf()可以查询他的原型</li>
<li>检测一个对象是否是另一个对象的原型，可使用isPrototypeOf（）方法</li>
</ul>
</li>
<li><p>序列化对象</p>
<ul>
<li><p>对象序列化是指将对象的状态转换为字符串，也可将字符串还原为对象</p>
</li>
<li><p>在js中，提供内置函数JSON.stringify（）和JSON.parse（）用来序列化和还原js对象</p>
</li>
<li><p>NaN,Infinity和-Infinity序列化的结果是null</p>
<p>var o = {</p>
<p>  name : ‘a’,</p>
<p>  age : 12,</p>
<p>  intro : [false,null,’’]</p>
<p>}</p>
<p>s= JSON.stringify(o)  // s {“name”:”a”,”age”:12,”intro”:[false,null,””]}</p>
<p>p=JSON.parse(s)  // p是o的深拷贝</p>
</li>
<li><p>JSON.stringify（）只能序列化对象可枚举的自有属性，对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉</p>
</li>
<li><p>深拷贝与浅拷贝的区别</p>
<ul>
<li><p>浅拷贝只是复制了对象的地址，两个对象指向同一个地址，所以修改其中的值，另一个值都会随之改变</p>
</li>
<li><p>深拷贝是将对象及值复制过来，两个对象修改其中任意值，另一个值不会随之改变，这就是深拷贝（如：JSON.stringify（）和JSON.parse（），但是此方法无法复制函数数据类型）</p>
</li>
<li><p>当你需要深拷贝对象中的方法时可使用lodash.js（提高js原生方法性能的js库）中的cloneDeep（）方法</p>
<p>var objA = { “name”: “戈德斯文” };</p>
<p>var objB =lodash.cloneDeep(objA);</p>
</li>
<li><p>深拷贝首推的方法简单有效，JSON.stringfy()和JSON.parse()即可搞定。但是这种简单粗暴的方法有其局限性。当值为<code>undefined</code>、<code>function</code>、<code>symbol</code> 会在转换过程中被忽略。所以，对象值有这三种的话用这种方法会导致属性丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var syb = Symbol(&apos;obj&apos;);</span><br><span class="line">var person = &#123;</span><br><span class="line">   name :&apos;tino&apos;,</span><br><span class="line">   say: function()&#123;</span><br><span class="line">      console.log(&apos;hi&apos;);</span><br><span class="line">   &#125;,</span><br><span class="line">   ok: syb,</span><br><span class="line">   un: undefined</span><br><span class="line">&#125;</span><br><span class="line">var copy = JSON.parse(JSON.stringify(person))</span><br><span class="line">// copy</span><br><span class="line">// &#123;name: &quot;tino&quot;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>js中对象的可枚举属性和不可枚举属性是由属性的enumerable值决定的。可枚举性决定了这个属性能否被for….in查找遍历到</p>
<ul>
<li>js中的基本包装类的原型属性是不可枚举的，如Object，Array，Number，这些对象的内置属性是不可枚举的</li>
<li>需要注意的是：如果判断的属性存在于Object对象的原型内，不管它是否可枚举都会返回false。</li>
</ul>
</li>
<li><p>构造函数是用来生成“对象”的函数。一个构造函数可生成多个对象，这些对象都有相同的结构</p>
<ul>
<li><p>构造函数的特点：函数体内使用this关键字代表所要生成的对象实例。生成对象时，必须用new命令，构造函数名字的首字母通常大写</p>
</li>
<li><p>new命令本身就可以执行构造函数，所以后面的构造函数可带括号可不带</p>
<p>var c = new Car();</p>
<p>var c = new Car;</p>
</li>
<li><p>每一个构造函数都有prototype属性</p>
</li>
</ul>
</li>
</ul>
<h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><p><strong>事件机制之冒泡、传播、委托</strong></p>
<p>DOM事件流（event flow）存在三个阶段：<strong>事件捕获阶段，处于目标阶段，事件冒泡阶段</strong>。</p>
<h4 id="事件捕获阶段（event-capuring）"><a href="#事件捕获阶段（event-capuring）" class="headerlink" title="事件捕获阶段（event  capuring）"></a>事件捕获阶段（event  capuring）</h4><p>通俗理解就是，当鼠标点击或触发dom事件时，浏览器会从根节点<strong>由外往内</strong>进行事件传播，即点击了子元素，如果父元素通过事件捕获注册了对应的事件的话，会先触发父元素绑定的的事件。</p>
<h4 id="事件冒泡（dubbed-bubbling）"><a href="#事件冒泡（dubbed-bubbling）" class="headerlink" title="事件冒泡（dubbed bubbling）"></a>事件冒泡（dubbed bubbling）</h4><p>与事件捕获相反，事件冒泡是从目标元素<strong>由内往外</strong>进行事件传播，直到根节点。</p>
<p>无论是事件冒泡还是事件捕获，都有一个共同点就是事件传播，她就像一根引线，只有通过引线才能将绑在引线上的鞭炮（事件监听器）引爆，试想一下，如果引线不导火了，那鞭炮就只有一响了！</p>
<p>dom事件标准事件流的触发先后顺序是：<strong>先捕获后冒泡</strong>，即当触发dom事件时，会进行事件捕获，捕获到事件源后通过事件传播进行事件冒泡。不同浏览器对此有不同的实现，IE10及以下不支持捕获型事件，所以就少了一个时间捕获阶段，IE11,Chrome，Firefox，Safari等浏览器则同时存在。</p>
<h4 id="事件绑定的方法"><a href="#事件绑定的方法" class="headerlink" title="事件绑定的方法"></a>事件绑定的方法</h4><h6 id="addEventlistener-event-listener-useCapture"><a href="#addEventlistener-event-listener-useCapture" class="headerlink" title="addEventlistener(event,listener,useCapture)"></a>addEventlistener(event,listener,useCapture)</h6><p>参数定义：event——（事件名称：如click，不带on）</p>
<p>listener——事件监听函数，</p>
<p>useCapture——是否采用事件捕获进行事件捕获，默认为false，即采用事件冒泡方式。</p>
<p>addEventListener在IE11，Chrome，Firefox，Safari等浏览器都得到支持。</p>
<h6 id="attachEvent（event，listener）"><a href="#attachEvent（event，listener）" class="headerlink" title="attachEvent（event，listener）"></a>attachEvent（event，listener）</h6><p>参数定义：event—（事件名称，如onclick，带on），</p>
<p>listener—事件监听函数。</p>
<p>attachEvent主要用于IE浏览器，并且仅在IE10及以下才支持，IE11已经废了这个方法了</p>
<h6 id="事件冒泡例子"><a href="#事件冒泡例子" class="headerlink" title="事件冒泡例子"></a>事件冒泡例子</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">    #parent&#123;width:200px;height:200px;background:yellow;margin:10px auto;border:1px solid black;&#125;</span><br><span class="line">    #children&#123;width:50px;height:50px;background:pink;margin:80px auto;&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;children&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var children = document.getElementById(&apos;children&apos;);</span><br><span class="line">    var parent = document.getElementById(&apos;parent&apos;);</span><br><span class="line">    document.body.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;body&apos;)&#125;,false);</span><br><span class="line">    parent.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;parent&apos;)&#125;,false);</span><br><span class="line">    children.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;children&apos;);</span><br><span class="line">    //event.stopProparation;</span><br><span class="line">    //可停止事件传播&#125;,false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当点击子盒子时，打印结果依次为children——parent——body</p>
<p>事件触发的顺序是由内到外的，这就是事件冒泡，虽然只点击了子元素，但是他的父元素也会触发相应的事件，其实这也是合理的，因为父元素里面，点击了子元素不就相当于变相的点击了父元素。</p>
<p>若不想触发父元素可停止事件传播只需在子元素中添加<strong>event.stopProparation;</strong>即可。</p>
<h6 id="事件捕获例子"><a href="#事件捕获例子" class="headerlink" title="事件捕获例子"></a>事件捕获例子</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">    body&#123;background: green;&#125;</span><br><span class="line">    #parent&#123;width:200px;height:200px;background:yellow;margin:10px auto;border:1px solid black;&#125;</span><br><span class="line">    #children&#123;width:50px;height:50px;background:pink;margin:80px auto;&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;children&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var children = document.getElementById(&apos;children&apos;);</span><br><span class="line">    var parent = document.getElementById(&apos;parent&apos;);</span><br><span class="line">    document.body.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;body&apos;)&#125;,true);</span><br><span class="line">    parent.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;parent&apos;)&#125;,true);</span><br><span class="line">    children.addEventListener(&apos;click&apos;,function()&#123;console.log(&apos;children&apos;)&#125;,true);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>点击children方块，打印body——parent——childre</p>
<p>点击parent方块，打印body——parent</p>
<p>点击body区域，打印body</p>
<p>事件通过事件捕获的方式注册了click事件，所以在事件捕获阶段就会触发，先是触发最外围注册了事件捕获的body，而后触发事件捕获的parent，最后触发事件源。这就是事件的时间流程。</p>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><h4 id="高质量代码"><a href="#高质量代码" class="headerlink" title="高质量代码"></a>高质量代码</h4><ul>
<li>bug暴露</li>
<li>不扩展内置原型，多用this取代构造函数的prototype</li>
<li>使用switch模式增强可读性和健壮性</li>
<li>使用绝对相等或绝对不等，避免隐式类型转换</li>
<li>避免使用eval（），因此方法接受任意的字符串，被执行的代码可能被篡改，有极大的安全隐患。且会污染全局变量</li>
<li>用方括号表示法访问动态属性</li>
<li>parseInt（）下数值转换，最好指定基数参数，不然，可能以0开头的数据被当成8进制使用</li>
</ul>
<h4 id="提高性能"><a href="#提高性能" class="headerlink" title="提高性能"></a>提高性能</h4><h6 id="（类）数组循环获取值时缓存长度"><a href="#（类）数组循环获取值时缓存长度" class="headerlink" title="（类）数组循环获取值时缓存长度"></a>（类）数组循环获取值时缓存长度</h6><ul>
<li>不足：每次循环时数组的长度都要去获取，会降低代码</li>
<li>若是类数组，需实时查询基本文档（html页面），这意味着每次你访问任何集合的长度，你要实时查询DOM，而DOM操作一般都是比较昂贵的。</li>
<li>解决：把数组长度放在一个变量里；从后往下标为0的数数，因为和0做比较要比和数组长度或是其他不是0的东西作比较更有效率。</li>
</ul>
<h6 id="for循环遍历数组，for-in循环遍历类数组"><a href="#for循环遍历数组，for-in循环遍历类数组" class="headerlink" title="for循环遍历数组，for-in循环遍历类数组"></a>for循环遍历数组，for-in循环遍历类数组</h6><h6 id="遍历属性时使用hasOwnProperty（）方法过滤原型上的属性"><a href="#遍历属性时使用hasOwnProperty（）方法过滤原型上的属性" class="headerlink" title="遍历属性时使用hasOwnProperty（）方法过滤原型上的属性"></a>遍历属性时使用hasOwnProperty（）方法过滤原型上的属性</h6><h4 id="var的作用"><a href="#var的作用" class="headerlink" title="var的作用"></a>var的作用</h4><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul>
<li>避免创建隐式全局变量：1.函数中未声明就使用变量  2.使用任务链进行部分var声明</li>
<li>可移植性：可在不同主机上使用</li>
</ul>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>通过var创建的全局变量不可通过delete删除，无var创建的隐式全局变量（并非真正的全局变量，只是全局变量的属性）可通过delete删除</li>
</ul>
<h4 id="执行层面"><a href="#执行层面" class="headerlink" title="执行层面"></a>执行层面</h4><h6 id="代码处理的两个阶段（预解析hoisting）"><a href="#代码处理的两个阶段（预解析hoisting）" class="headerlink" title="代码处理的两个阶段（预解析hoisting）"></a>代码处理的两个阶段（预解析hoisting）</h6><ul>
<li>变量，函数声明，以及正常格式的参数创建，这是一个解析和进入上下文的阶段</li>
<li>代码执行，函数表达式和不合格的标识符（为声明的变量）被创建。</li>
</ul>
<h2 id="二-JavaScript对象"><a href="#二-JavaScript对象" class="headerlink" title="二 . JavaScript对象"></a>二 . JavaScript对象</h2><ul>
<li><p>JavaScript是一种直译式脚本语言，是一种动态类型，弱类型，基于原型的语言，内置支持类型</p>
</li>
<li><h6 id="日常用途"><a href="#日常用途" class="headerlink" title="日常用途"></a>日常用途</h6><ol>
<li>嵌入动态文本于HTML页面。</li>
<li>对浏览器事件做出响应。</li>
<li>读写<a href="https://www.w3cschool.cn/html/html-elements.html" target="_blank" rel="noopener">HTML元素</a>。 </li>
<li>在数据被提交到服务器之前验证数据。</li>
<li>检测访客的浏览器信息。 </li>
<li>控制cookies，包括创建和修改等。</li>
<li>基于Node.js技术进行服务器端编程。</li>
</ol>
</li>
</ul>
<h4 id="对象公共属性"><a href="#对象公共属性" class="headerlink" title="对象公共属性"></a>对象公共属性</h4><h5 id="1-constructor属性"><a href="#1-constructor属性" class="headerlink" title="1.constructor属性"></a>1.constructor属性</h5><ul>
<li>constructor属性返回对创建此对象的函数的引用</li>
<li>函数对象。 返回创建布尔对象的函数原型。=函数.constructor;</li>
</ul>
<h5 id="2-prototype属性"><a href="#2-prototype属性" class="headerlink" title="2.prototype属性"></a>2.prototype属性</h5><ul>
<li>是您有能力向对象添加属性和方法</li>
<li>当构造一个原型，所有的对应对象默认都添加了属性和方法</li>
<li>每个js对象（除了null）都和另一个对象相关联，即继承另一个对象。另一个对象就是我们熟知的“原型（prototype），每个对象都从原型继承属性。只有null除外，他没有自己的原型对象</li>
<li>通过Object.prototype获得对原型对象的引用，通过对象或构造函数调用创建的对象的原型就是构造函数的prototype属性的值，找不到原型，返回undefined</li>
</ul>
<h5 id="3-toString（-把对象转为字符串并返回结果"><a href="#3-toString（-把对象转为字符串并返回结果" class="headerlink" title="3.toString（)把对象转为字符串并返回结果"></a>3.toString（)把对象转为字符串并返回结果</h5><ul>
<li>String=对象.toString()</li>
</ul>
<h5 id="4-valueOf（）-返回对象的原始值"><a href="#4-valueOf（）-返回对象的原始值" class="headerlink" title="4.valueOf（）  返回对象的原始值"></a>4.valueOf（）  返回对象的原始值</h5><p>Array=<em>array</em>.valueOf()  不会改变原数组</p>
<h5 id="5-Object-getPrototypeOf"><a href="#5-Object-getPrototypeOf" class="headerlink" title="5.Object.getPrototypeOf()"></a>5.Object.getPrototypeOf()</h5><ul>
<li>返回一个对象的原型</li>
</ul>
<h5 id="6-Object-setPrototypeOf"><a href="#6-Object-setPrototypeOf" class="headerlink" title="6.Object.setPrototypeOf()"></a>6.Object.setPrototypeOf()</h5><ul>
<li>为现有对象设置原型，返回一个新对象</li>
<li>接受两个参数，第一个是现有对象，第二个是原型对象</li>
</ul>
<h5 id="7-Object-create"><a href="#7-Object-create" class="headerlink" title="7.Object.create()"></a>7.Object.create()</h5><ul>
<li>用于从原型对象生成新的实例对象，可以替代new命令</li>
<li>它接受一个对象作为参数，返回一个新的对象，后者完全继承前者的属性，即原有对象成为新对象的原型</li>
</ul>
<h5 id="8-Object-prototype-isPrototypeOf"><a href="#8-Object-prototype-isPrototypeOf" class="headerlink" title="8.Object.prototype.isPrototypeOf()"></a>8.Object.prototype.isPrototypeOf()</h5><ul>
<li>判断一个对象是否是另一个对象的原型</li>
<li>Object.prototype.isPrototypeOf({}) //true</li>
</ul>
<h5 id="9-Object-prototype-proto"><a href="#9-Object-prototype-proto" class="headerlink" title="9.Object.prototype.proto_"></a>9.Object.prototype.<em>proto_</em></h5><p>_proto__属性（前后各两个下划线）可以改写某个对象的原型对象</p>
<h5 id="10-Object-getPropertyOfNames"><a href="#10-Object-getPropertyOfNames" class="headerlink" title="10.Object.getPropertyOfNames()"></a>10.Object.getPropertyOfNames()</h5><ul>
<li>该方法返回一个数组，成员是对象本身的所有属性的键名，不包含的属性键名</li>
</ul>
<h5 id="11-Object-prototype-hasOwnProperty"><a href="#11-Object-prototype-hasOwnProperty" class="headerlink" title="11.Object.prototype.hasOwnProperty()"></a>11.Object.prototype.hasOwnProperty()</h5><ul>
<li>返回一个布尔值，用于判断某个属性定义在对象本身还是在原型链上</li>
</ul>
<h3 id="1-Array数组对象"><a href="#1-Array数组对象" class="headerlink" title="1.Array数组对象"></a>1.Array数组对象</h3><ul>
<li>数组对象的作用是使用单独的变量名来存储一系列的值</li>
<li>length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。</li>
</ul>
<h5 id="1-concat（）连接两个或多个数组"><a href="#1-concat（）连接两个或多个数组" class="headerlink" title="1.concat（）连接两个或多个数组"></a>1.concat（）连接两个或多个数组</h5><ul>
<li>该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本</li>
<li><em>array1</em>.concat(<em>array2</em>,<em>array3</em>,…,<em>arrayX</em>)</li>
</ul>
<h5 id="2-every（-检查所有数组元素-返回boolear"><a href="#2-every（-检查所有数组元素-返回boolear" class="headerlink" title="2.every（)检查所有数组元素,返回boolear"></a>2.every（)检查所有数组元素,返回boolear</h5><ul>
<li><p>用于检测数组所有元素是否都符合指定条件（通过函数提供），只有所有元素都满足条件才返回true</p>
</li>
<li><p>every（）不会对空数组进行检测，且不会改变原始数组</p>
</li>
<li><p>array.every（function（currentValue，index，arr），thisValue）</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>function(currentValue, index,arr)</em></td>
<td align="left">必须。函数，数组中的每个元素都会执行这个函数 函数参数: 参数描述<em>currentValue</em>必须。当前元素的值<em>index</em>可选。当期元素的索引值<em>arr</em>可选。当期元素属于的数组对象</td>
</tr>
<tr>
<td align="left"><em>thisValue</em></td>
<td align="left">可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。 如果省略了 thisValue ，”this” 的值为 “undefined”</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="3-filter-创建所有符合条件元素的数组"><a href="#3-filter-创建所有符合条件元素的数组" class="headerlink" title="3.filter()创建所有符合条件元素的数组"></a>3.filter()创建所有符合条件元素的数组</h5><ul>
<li>创建一个新数组，不会对空数据进行检测，也不会改变原始数组.如果没有符合条件的元素则返回空数组。</li>
<li>array.filter(function(currentValue,index,arr),thisValue)</li>
</ul>
<h5 id="4-indexOf（）返回指定字符串值首次出现的位置"><a href="#4-indexOf（）返回指定字符串值首次出现的位置" class="headerlink" title="4.indexOf（）返回指定字符串值首次出现的位置"></a>4.indexOf（）返回指定字符串值首次出现的位置</h5><ul>
<li>array.indexOf(item,start)</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>item</em></td>
<td align="left">必须。查找的元素。</td>
</tr>
<tr>
<td align="left"><em>start</em></td>
<td align="left">可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。</td>
</tr>
</tbody></table>
<ul>
<li>返回值为number值，如果没有搜索到则返回-1</li>
<li>lastIndexOf()  查找字符串最后出现的位置</li>
</ul>
<h5 id="5-join-把数组中的所有元素为一个字符串"><a href="#5-join-把数组中的所有元素为一个字符串" class="headerlink" title="5.join()  把数组中的所有元素为一个字符串"></a>5.join()  把数组中的所有元素为一个字符串</h5><ul>
<li><p>元素是通过指定的分隔符进行分隔的</p>
</li>
<li><p>string =array.join(separator)</p>
<p>参数separator是可选的，是指定要使用的分隔符，若省略，默认使用逗号</p>
<p>返回值是一字符串。该字符串是通过把arrayObject的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入separator字符串生成</p>
</li>
</ul>
<h5 id="6-map（）通过指定函数处理原始数组，并返回处理后的数组"><a href="#6-map（）通过指定函数处理原始数组，并返回处理后的数组" class="headerlink" title="6.map（）通过指定函数处理原始数组，并返回处理后的数组"></a>6.map（）通过指定函数处理原始数组，并返回处理后的数组</h5><ul>
<li>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。map() 方法按照原始数组元素顺序依次处理元素。</li>
<li>map() 不会对空数组进行检测。map() 不会改变原始数组。</li>
<li>array.map(function(currentValue,index,arr),thisValue)</li>
</ul>
<h5 id="7-pop-删除数组最后一个元素并返回处理后的数组"><a href="#7-pop-删除数组最后一个元素并返回处理后的数组" class="headerlink" title="7.pop()删除数组最后一个元素并返回处理后的数组"></a>7.pop()删除数组最后一个元素并返回处理后的数组</h5><ul>
<li>array.pop();</li>
<li>array.shift();删除数组的第一个元素</li>
</ul>
<h5 id="8-push-向数组的末尾添加一个或更多元素，并返回新的长度"><a href="#8-push-向数组的末尾添加一个或更多元素，并返回新的长度" class="headerlink" title="8.push()向数组的末尾添加一个或更多元素，并返回新的长度"></a>8.push()向数组的末尾添加一个或更多元素，并返回新的长度</h5><ul>
<li>Number =array.push(item1,item2,…,itemX);</li>
<li>array.unshift(item1,item2,…,itemX)) ; 向数组的开头添加一个或多个元素，并返回新的长度</li>
</ul>
<h5 id="9-reverse-颠倒数组中元素的顺序"><a href="#9-reverse-颠倒数组中元素的顺序" class="headerlink" title="9.reverse()颠倒数组中元素的顺序"></a>9.reverse()颠倒数组中元素的顺序</h5><ul>
<li>不影响原数组</li>
</ul>
<ul>
<li>Array=array.reverse()；</li>
</ul>
<h5 id="10-slice（）选取数组中的一部分，并返回一个新数组"><a href="#10-slice（）选取数组中的一部分，并返回一个新数组" class="headerlink" title="10.slice（）选取数组中的一部分，并返回一个新数组"></a>10.slice（）选取数组中的一部分，并返回一个新数组</h5><ul>
<li><p>新数组中不包括end对应的值</p>
</li>
<li><p>Array=array.slice(start,end);</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>start</em></td>
<td align="left">必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</td>
</tr>
<tr>
<td align="left"><em>end</em></td>
<td align="left">可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</td>
</tr>
</tbody></table>
<h5 id="11-some-检测数组元素中是否有元素符合指定条件"><a href="#11-some-检测数组元素中是否有元素符合指定条件" class="headerlink" title="11.some()检测数组元素中是否有元素符合指定条件"></a>11.some()检测数组元素中是否有元素符合指定条件</h5><ul>
<li>some() 方法会依次执行数组的每个元素：如果有一个元素满足条件，则表达式返回<em>true</em> , 剩余的元素不会再执行检测。如果没有满足条件的元素，则返回false。</li>
<li>Boolean =array.some(function(currentValue,index,arr),thisValue);</li>
</ul>
<h5 id="12-sort-对数组的元素进行排序"><a href="#12-sort-对数组的元素进行排序" class="headerlink" title="12.sort()对数组的元素进行排序"></a>12.sort()对数组的元素进行排序</h5><ul>
<li><p>排序顺序可以是字符或数字，并按升序或降序。默认按字母升序。 这种方法会改变原始数组！</p>
</li>
<li><p><strong>注意：</strong>当数字是按字母顺序排列时”40”将排在”5”前面。使用数字排序，你必须通过一个函数作为参数来调用。函数指定数字是按照升序还是降序排列。</p>
</li>
<li><p>Array =array.sort(sortfunction);</p>
<p>参数sortfunction可选，规定排定顺序，必须是函数</p>
<p>返回值Array是对原数组的引用。<strong>注意</strong>，数组在原数组进行排序，不生成副本</p>
</li>
</ul>
<h5 id="13-splice（）从数组中添加或删除，替换元素"><a href="#13-splice（）从数组中添加或删除，替换元素" class="headerlink" title="13.splice（）从数组中添加或删除，替换元素"></a>13.splice（）从数组中添加或删除，替换元素</h5><ul>
<li><p>改变原数组</p>
</li>
<li><p>Array =array.splice(index,howmany,item1,item2,…,itemsX);</p>
<p>参数index是必须的，规定从何处添加或删除元素，该参数是开始插入或删除的数组元素的下标，必须是数字</p>
<p>howmany是必填项，规定应该删除多少元素，若未规定，则默认从index开始删除直到原数组结尾的所有元素</p>
<p>item1，可选，要添加到数组的新元素</p>
</li>
</ul>
<h5 id="14-toString（-把数组转为字符串并返回结果"><a href="#14-toString（-把数组转为字符串并返回结果" class="headerlink" title="14.toString（)把数组转为字符串并返回结果"></a>14.toString（)把数组转为字符串并返回结果</h5><ul>
<li>数组元素之间用逗号分隔</li>
<li>String=array.toString()</li>
</ul>
<h5 id="15-valueOf（）-返回数组对象的原始值"><a href="#15-valueOf（）-返回数组对象的原始值" class="headerlink" title="15.valueOf（）  返回数组对象的原始值"></a>15.valueOf（）  返回数组对象的原始值</h5><p>Array=<em>array</em>.valueOf()  不会改变原数组</p>
<h5 id="16-reduce-返回累计值"><a href="#16-reduce-返回累计值" class="headerlink" title="16.reduce()返回累计值"></a>16.reduce()返回累计值</h5><ul>
<li>定义：对数组中的每个元素执行一个自定义的累计器，将其结果汇总为单个返回值</li>
<li>形式：<code>array.reduce((t, v, i, a) =&gt; {}, initValue)</code></li>
<li>参数<ul>
<li><strong>callback</strong>：回调函数(<code>必选</code>)</li>
<li><strong>initValue</strong>：初始值(<code>可选</code>)</li>
</ul>
</li>
<li>回调函数的参数<ul>
<li><strong>total</strong>(<code>t</code>)：累计器完成计算的返回值(<code>必选</code>)</li>
<li><strong>value</strong>(<code>v</code>)：当前元素(<code>必选</code>)</li>
<li><strong>index</strong>(<code>i</code>)：当前元素的索引(<code>可选</code>)</li>
<li><strong>array</strong>(<code>a</code>)：当前元素所属的数组对象(<code>可选</code>)</li>
</ul>
</li>
<li>过程<ul>
<li>以<code>t</code>作为累计结果的初始值，不设置<code>t</code>则以数组第一个元素为初始值</li>
<li>开始遍历，使用累计器处理<code>v</code>，将<code>v</code>的映射结果累计到<code>t</code>上，结束此次循环，返回<code>t</code></li>
<li>进入下一次循环，重复上述操作，直至数组最后一个元素</li>
<li>结束遍历，返回最终的<code>t</code></li>
</ul>
</li>
</ul>
<p><code>reduce</code>的精华所在是将累计器逐个作用于数组成员上，<strong>把上一次输出的值作为下一次输入的值</strong>。</p>
<h4 id="2-Boolean对象"><a href="#2-Boolean对象" class="headerlink" title="2.Boolean对象"></a>2.Boolean对象</h4><ul>
<li>Boolean 对象用于转换一个不是 Boolean 类型的值转换为 Boolean 类型值 (true 或者false).</li>
</ul>
<h4 id="3-Date对象"><a href="#3-Date对象" class="headerlink" title="3.Date对象"></a>3.Date对象</h4><ul>
<li>四种创建方法<ul>
<li>var d =new Date();</li>
<li>var d =new Date(<em>milliseconds</em>);</li>
<li>var d =new Date(<em>dateString</em>);</li>
<li>var d =new Date(<em>year</em>, <em>month</em>, <em>day</em>, <em>hours</em>, <em>minutes</em>, <em>seconds</em>, <em>milliseconds</em>);</li>
</ul>
</li>
</ul>
<h4 id="4-Number对象"><a href="#4-Number对象" class="headerlink" title="4.Number对象"></a>4.Number对象</h4><ul>
<li><p>Number对象是原始数值的包装对象</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-constructor-number.html" target="_blank" rel="noopener">constructor</a></td>
<td align="left">返回对创建此对象的 Number 函数的引用。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-max-value.html" target="_blank" rel="noopener">MAX_VALUE</a></td>
<td align="left">可表示的最大的数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-min-value.html" target="_blank" rel="noopener">MIN_VALUE</a></td>
<td align="left">可表示的最小的数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-negative-infinity.html" target="_blank" rel="noopener">NEGATIVE_INFINITY</a></td>
<td align="left">负无穷大，溢出时返回该值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-number-nan.html" target="_blank" rel="noopener">NaN</a></td>
<td align="left">非数字值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-positive-infinity.html" target="_blank" rel="noopener">POSITIVE_INFINITY</a></td>
<td align="left">正无穷大，溢出时返回该值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-prototype-num.html" target="_blank" rel="noopener">prototype</a></td>
<td align="left">允许您有能力向对象添加属性和方法。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-toexponential.html" target="_blank" rel="noopener">toExponential(x)</a></td>
<td align="left">把对象的值转换为指数计数法。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-tofixed.html" target="_blank" rel="noopener">toFixed(x)</a></td>
<td align="left">把数字转换为字符串，结果的小数点后有指定位数的数字。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-toprecision.html" target="_blank" rel="noopener">toPrecision(x)</a></td>
<td align="left">把数字格式化为指定的长度。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-tostring-number.html" target="_blank" rel="noopener">toString()</a></td>
<td align="left">把数字转换为字符串，使用指定的基数。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3cschool.cn/jsref/jsref-valueof-number.html" target="_blank" rel="noopener">valueOf()</a></td>
<td align="left">返回一个 Number 对象的基本数字值。</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="三-深入理解js"><a href="#三-深入理解js" class="headerlink" title="三 . 深入理解js"></a>三 . 深入理解js</h2><h4 id="1-最小全局变量（Minimizing-Globals）"><a href="#1-最小全局变量（Minimizing-Globals）" class="headerlink" title="1.最小全局变量（Minimizing Globals）"></a>1.最小全局变量（Minimizing Globals）</h4><ul>
<li><p>js通过函数管理作用域。在函数内部声明的变量只在这个函数内部，函数外面不能使用。另一方面，全局变量就是在任何函数外面声明的或是未声明直接简单实用的</p>
</li>
<li><p>每个js环境都有一个全局对象，但你在任意函数外面使用this就可以访问到。你创建的每一个全局变量都是这个全局对象的属性。在浏览器中，为方便起见，该全局对象有个附加属性叫做window，此window指向该全局对象本身</p>
</li>
<li><p>全局变量的问题在于，你的JavaScript应用程序和web页面上的所有代码都共享了这些全局变量，他们住在同一个全局命名空间，所以当程序的两个不同部分定义同名但不同作用的全局变量的时候，命名冲突在所难免。</p>
<ul>
<li>第三方的JavaScript库</li>
<li>广告方的脚本代码</li>
<li>第三方用户跟踪和分析脚本代码</li>
<li>不同类型的小组件，标志和按钮</li>
</ul>
</li>
<li><p>要想和其他脚本成为好邻居的话，尽可能少的使用全局变量是很重要的。一些减少全局变量的策略，例如命名空间模式或是函数立即自动执行，但是要想让全局变量少最重要的还是始终使用var来声明变量。</p>
</li>
<li><p>js因其特征，会不自觉地创建出全局变量。隐式创建全局变量的情况</p>
<ul>
<li><p>你可以不声明就可以使用变量，js会默认是全局对象的属性（js有隐含的全局概念）</p>
</li>
<li><p>使用任务链进行var声明    在函数内部     var  a=b=0；</p>
<p>其中a是本地变量，而b是全局变量，因为这个是从右到左的赋值，首先通过赋值表达式b=0，此情况下b是未声明的。这个表达式的值是0，然后这个0就分配给通过var定义的全局变量a。若你提前声明了变量，使用链分配是比较好的，不会产生意料之外的情况</p>
</li>
</ul>
</li>
<li><p>另外一个避免全局变量的原因是可移植性，如果你想你的代码在不同环境（主机下）运行，使用全局变量如履薄冰，因为你会无意中覆盖你最初环境下不存在的主机对象（所以你原以为名称可以放心使用，实际上对于有些情况并不适用）</p>
</li>
<li><h6 id="忘记var的副作用（Side-Effect-when-forgetting-var）"><a href="#忘记var的副作用（Side-Effect-when-forgetting-var）" class="headerlink" title="忘记var的副作用（Side Effect when forgetting  var）"></a>忘记var的副作用（Side Effect when forgetting  var）</h6><ul>
<li>隐式全局变量和明确全局变量有小差异，即通过delete操作符让变量未定义的能力。<ul>
<li>通过var创建的全局变量（任何函数之外的程序中创建）是不能被删除的</li>
<li>无var创建的隐式全局变量（无视是否在函数中创建）是能被删除的</li>
</ul>
</li>
<li>这表明，在技术上，隐式全局变量并不是真正的全局变量，但他们是全局对象的属性。属性是可以通过delete操作符删除的，而变量不能</li>
</ul>
</li>
</ul>
<p>// 定义三个全局变量<br>var global_var = 1;<br>global_novar = 2; // 反面教材<br>(function () {<br>global_fromfunc = 3; // 反面教材<br>}());<br>// 试图删除<br>delete global_var; // false<br>delete global_novar; // true<br>delete global_fromfunc; // true<br>// 测试该删除<br>typeof global_var; // “number”<br>typeof global_novar; // “undefined”<br>typeof global_fromfunc; // “undefined”</p>
<ul>
<li><h6 id="访问全局对象-Access-to-the-Global-Object"><a href="#访问全局对象-Access-to-the-Global-Object" class="headerlink" title="访问全局对象(Access to the Global Object)"></a>访问全局对象(Access to the Global Object)</h6><p>在浏览器中，全局对象可以通过<code>window</code>属性在代码的任何位置访问（除非你做了些比较出格的事情，像是声明了一个名为window的局部变量）。但是在其他环境下，这个方便的属性可能被叫做其他什么东西（甚至在程序中不可用）。如果你需要在没有硬编码的<code>window</code>标识符下访问全局对象，你可以在任何层级的函数作用域中做如下操作：</p>
</li>
</ul>
<p>var  global=(function(){</p>
<p>return  this;</p>
<p>}()); 这种方法可随时获得全局对象，因其在函数中被当作一个函数调用了（不是通过new构造），this总是指向全局对象。实际上这个病不适用于ECMAScript 5严格模式，所以，在严格模式下时，你必须采取不同的形式。例如，你正在开发一个JavaScript库，你可以将你的代码包裹在一个即时函数中，然后从 全局作用域中，传递一个引用指向this作为你即时函数的参数。</p>
<ul>
<li><h6 id="单var形式（Single-var-Pattern）"><a href="#单var形式（Single-var-Pattern）" class="headerlink" title="单var形式（Single var Pattern）"></a>单var形式（Single var Pattern）</h6><p>在函数顶部使用单var语句是比较有用的一种形式，其好处在于：</p>
<ul>
<li>提供了一个单一的地方去寻找功能所需要的所有局部变量</li>
<li>防止变量在定义之前使用的逻辑错误</li>
<li>帮助你记住声明的全局变量，因此较少了全局变量</li>
<li>少代码（类型啊传值啊单线完成）</li>
</ul>
</li>
<li><h6 id="预解析：var散布的问题-Hoisting-A-Problem-with-Scattered-vars"><a href="#预解析：var散布的问题-Hoisting-A-Problem-with-Scattered-vars" class="headerlink" title="预解析：var散布的问题(Hoisting: A Problem with Scattered vars)"></a>预解析：var散布的问题(Hoisting: A Problem with Scattered vars)</h6><p>JavaScript中，你可以在函数的任何位置声明多个var语句，并且它们就好像是在函数顶部声明一样发挥作用，这种行为称为 hoisting（悬置/置顶解析/预解析）。当你使用了一个变量，然后不久在函数中又重新声明的话，就可能产生逻辑错误。对于JavaScript，只 要你的变量是在同一个作用域中（同一函数），它都被当做是声明的，即使是它在var声明前使用的时候。</p>
<p>// 反例<br>myname = “global”; // 全局变量<br>function func() {<br>alert(myname); // “undefined”<br>var myname = “local”;<br>alert(myname); // “local”<br>}<br>func();</p>
</li>
</ul>
<h4 id="2-代码处理的两个阶段"><a href="#2-代码处理的两个阶段" class="headerlink" title="2.代码处理的两个阶段"></a>2.代码处理的两个阶段</h4><ul>
<li>第一阶段是变量，函数声明，以及正常格式的参数创建，这是一个解析和进入上下文的阶段</li>
<li>第二阶段是代码执行，函数表达式和不合格的标识符（未声明的变量）被创建</li>
</ul>
<h2 id="四-this-精讲"><a href="#四-this-精讲" class="headerlink" title="四 . this 精讲"></a>四 . this 精讲</h2><h4 id="谁调用这个函数或方法，this关键字就指向谁"><a href="#谁调用这个函数或方法，this关键字就指向谁" class="headerlink" title="谁调用这个函数或方法，this关键字就指向谁"></a>谁调用这个函数或方法，this关键字就指向谁</h4><ul>
<li>this总是返回属性或方法“当前”所在的对象</li>
<li>如果一个函数在全局环境中运行，那么this就是指顶层对象（浏览器中为window对象）。</li>
</ul>
<h4 id="1-改变this指向的三大方法"><a href="#1-改变this指向的三大方法" class="headerlink" title="1.改变this指向的三大方法"></a>1.改变this指向的三大方法</h4><h6 id="1-call、apply、bind方法的共同点和区别："><a href="#1-call、apply、bind方法的共同点和区别：" class="headerlink" title="1.call、apply、bind方法的共同点和区别："></a>1.call、apply、bind方法的共同点和区别：</h6><ul>
<li><p>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；</p>
</li>
<li><p>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文（函数的每次调用都会拥有一个特殊值——本次调用的上下文（context）——这就是this关键字的值。）；</p>
</li>
<li><p>apply 、 call 、bind 三者都可以利用后续参数传参；</p>
</li>
<li><p>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</p>
</li>
</ul>
<h6 id="2-thisObj的取值有以下4种情况："><a href="#2-thisObj的取值有以下4种情况：" class="headerlink" title="2.thisObj的取值有以下4种情况："></a>2.thisObj的取值有以下4种情况：</h6><p>（1） 不传，或者传null,undefined， 函数中的this指向window对象</p>
<p>（2） 传递另一个函数的函数名，函数中的this指向这个函数的引用</p>
<p>（3） 传递字符串、数值或布尔类型等基础类型，函数中的this指向其对应的包装对象，如 String、Number、Boolean</p>
<p>（4） 传递一个对象，函数中的this指向这个对象</p>
<ul>
<li>function.prototype.call(obj,arg1,arg2,…)<ul>
<li>obj是this要指向的对象（一般会写成this），也就是想指定的上下文；arg1，arg2都是要传入的参数</li>
<li>如果参数为空，null和undefined，则默认传入全局对象</li>
</ul>
</li>
<li>function.prototype.apply(obj,[arg1,arg2,..])<ul>
<li>apply()和call（）差不多，但是apply的第二个参数是数组</li>
</ul>
</li>
<li>function.prototype.bind(obj)<ul>
<li>将函数绑定到某个对象，然后返回一个新的函数</li>
</ul>
</li>
</ul>
<h6 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;     console.log(this);   //输出函数a中的this对象&#125;       </span><br><span class="line">function b()&#123;&#125;       </span><br><span class="line">var c=&#123;name:&quot;call&quot;&#125;;    //定义对象c  </span><br><span class="line">a.call();   //window</span><br><span class="line">a.call(null);   //window</span><br><span class="line">a.call(undefined);   //window</span><br><span class="line">a.call(1);   //Number</span><br><span class="line">a.call(&apos;&apos;);   //String</span><br><span class="line">a.call(true);   //Boolean</span><br><span class="line">a.call(b);   //function b()&#123;&#125;</span><br><span class="line">a.call(c);   //Object</span><br></pre></td></tr></table></figure>

<p>function class1(){   </p>
<p>  this.name=function(){   </p>
<p>​    console.log(“我是class1内的方法”);   </p>
<p>  }   </p>
<p>}   </p>
<p>function class2(){ </p>
<p>  class1.call(this); //此行代码执行后，当前的this指向了class1（也可以说class2继承了class1）   </p>
<p>}  </p>
<p>var f=new class2();   </p>
<p>f.name();   //调用的是class1内的方法，将class1的name方法交给class2使用</p>
<p>function eat(x,y){   </p>
<p>  console.log(x+y);   </p>
<p>}   </p>
<p>function drink(x,y){   </p>
<p>  console.log(x-y);   </p>
<p>}   </p>
<p>eat.call(drink,3,2)；/<em>输出：5。这个例子中的意思就是用 eat 来替换 drink，eat.call(drink,3,2) == eat(3,2) ，所以运行结果为：console.log(5);</em>/</p>
<p>function Animal(){   </p>
<p>  this.name=”animal”;   </p>
<p>  this.showName=function(){   </p>
<p>​    console.log(this.name);   </p>
<p>  }   </p>
<p>}   </p>
<p>function Dog(){   </p>
<p>  this.name=”dog”;   </p>
<p>}   </p>
<p>var animal=new Animal();   </p>
<p>var dog=new Dog();       </p>
<p>animal.showName.call(dog);//输出：dog</p>
<p>在上面的代码中，我们可以看到Dog里并没有showName方法，那为什么（this.name）的值是dog呢？</p>
<p>关键就在于最后一段代码（animal.showName.call(dog)），意思是把animal的方法放到dog上执行，也可以说，把animal 的showName()方法放到 dog上来执行，所以this.name 应该是 dog。</p>
<p>function Animal(name){   </p>
<p>  this.name=name;   </p>
<p>  this.showName=function(){   </p>
<p>​    console.log(this.name);   </p>
<p>  }   </p>
<p>}   </p>
<p>function Dog(name){   </p>
<p>  Animal.call(this,name);   </p>
<p>}   </p>
<p>var dog=new Dog(“Crazy dog”);   </p>
<p>dog.showName();//输出：Crazy dog</p>
<p>Animal.call(this) 的意思就是使用 Animal对象代替this对象，那么Dog就能直接调用Animal的所有属性和方法。著作权归作者所有。</p>
<ul>
<li>在JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call ；而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数。著作权归作者所有。</li>
</ul>
<p>详情请看：<a href="http://ghmagical.com/article/page/id/UPLfoGI9vJ91" target="_blank" rel="noopener">http://ghmagical.com/article/page/id/UPLfoGI9vJ91</a></p>
<h2 id="五-垃圾回收机制"><a href="#五-垃圾回收机制" class="headerlink" title="五 . 垃圾回收机制"></a>五 . 垃圾回收机制</h2><ul>
<li>js具有自动垃圾回收机制（GC:Garbage  Collection），也就是说执行环境会负责管理代码执行过程中使用的内存</li>
<li>原理：垃圾收集器会定期（周期性）找出那些不再继续使用的变量，然后释放其内存。此过程并非实时的，因其开销会很大。</li>
<li>不再使用的变量也就是生命周期结束的变量，当让只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束，局部变量只在函数执行过程中存在，而在这个过程会为局部变量在堆和栈分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包由于内部函数的原因，外部函数并不能算是结束。</li>
<li></li>
</ul>
<h2 id="六-枚举"><a href="#六-枚举" class="headerlink" title="六. 枚举"></a>六. 枚举</h2><h2 id="ECMAScript原始值和引用值"><a href="#ECMAScript原始值和引用值" class="headerlink" title="ECMAScript原始值和引用值"></a>ECMAScript原始值和引用值</h2><h4 id="1-原始值"><a href="#1-原始值" class="headerlink" title="1.原始值"></a>1.原始值</h4><p>存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。</p>
<h4 id="2-引用值"><a href="#2-引用值" class="headerlink" title="2.引用值"></a>2.引用值</h4><p>存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。</p>
<p>为变量赋值时，ECMAScript 的解释程序必须判断该值是原始类型，还是引用类型。要实现这一点，解释程序则需尝试判断<em>该值是否为 ECMAScript 的原始类型之一</em>，即 Undefined、Null、Boolean、Number和String型。由于这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 - 栈中。这样存储便于迅速查寻变量的值。</p>
<p><strong>在许多语言中，字符串都被看作引用类型，而非原始类型，因为字符串的长度是可变的。ECMAScript打破了这一传统。</strong></p>
<p>如果一个值是引用类型的，那么它的存储空间将从堆中分配。由于引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响</p>
<p><img src="https://7n.w3cschool.cn/attachments/day_160920/201609201937112397.gif" alt="存储在堆和栈中的原始值和引用值"></p>
<h4 id="3-对象-1"><a href="#3-对象-1" class="headerlink" title="3.对象"></a>3.对象</h4><h6 id="1-属性"><a href="#1-属性" class="headerlink" title="1.属性"></a>1.属性</h6><ul>
<li>constructor：对创建对象的函数的引用（指针）。对于Object对象，该指针指向原始的Object（）函数</li>
<li>prototype：对该对象的原型的引用。对于所有的对象，他默认返回Object对象的一个实例</li>
</ul>
<h6 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h6><ul>
<li>hasOwnProperty（property）：判断对象是否有某个特定的属性。必须用字符串指定该属性（o.hasOwnProperty(“name”))</li>
<li>IsPrototypeOf(object):判断该对象是否为另一个对象的原型</li>
<li>PropertyIsEnumerable：判断给定的属性是否可以用for…in语句进行枚举</li>
<li>ToString（）：返回对象的原始字符串表示。对于Object对象，ECMA-262没有定义这个值，所以不同的ECMAScript实现具有不同的值</li>
<li>ValueOf（）返回最适合该对象的原始值。对于许多对象，该方法返回的值都与ToString（）的返回值相同</li>
<li>上面列出的每种属性和方法都会被其他对象覆盖</li>
</ul>
<h4 id="4-String对象"><a href="#4-String对象" class="headerlink" title="4.String对象"></a>4.String对象</h4><ul>
<li><p>localeCompare（）方法，对字符串进行排序。该方法有一个参数-要进行比较的字符串，返回的是下列三个值之一</p>
<ul>
<li>如果String对象按照字母顺序排在参数中的字符串之前，返回负数</li>
<li>等于参数中的字符串，返回0</li>
<li>排在参数中的字符串之后，返回正数</li>
</ul>
</li>
<li><p>localeCompare()方法的独特之处在于，实现所处的区域（locale，兼指国家/地区和语言）确切说明了这种方法运行的方式。在美国，英语是ECMAScript实现的标准语言，localeCompare()是区分大小写的，大写字母在字母顺序上排在小写字母之后。不过，在其他区域，情况可能并非如此。</p>
</li>
<li><p>slice（）和substring（）</p>
<ul>
<li><p>ECMAScript提供了两种方法从字串创建字符串值，即slice（）和substring（）。这两种返回的都是要处理的字符串的子串，都接受一个或两个参数，第一个参数是要获取字串的起始位置，第二个参数（如果使用的话）是要获取<strong>子串终止前的位置</strong>（也就是说，获取终止位置不包括在返回值内）。若省略第二个参数，终值位就默认为字符串的长度。但是两种方法都不影响String对象本身的值</p>
</li>
<li><p>对于负数参数，slice（）方法会用字符串的长度加上参数，substring（）方法则将其作为0处理（也就是忽略他）</p>
<p>var oStringObject = new String(“hello world”);<br>alert(oStringObject.slice(“-3”));        //输出 “rld”<br>alert(oStringObject.substring(“-3”));    //输出 “hello world”<br>alert(oStringObject.slice(“3, -4”));        //输出 “lo w”<br>alert(oStringObject.substring(“3, -4”));    //输出 “hel”</p>
<p>substring()方法则将两个参数解释为substring(3, 0)，实际上即substring(0, 3)，因为substring()总把较小的数字作为起始位，较大的数字作为终止位。因此，substring(“3, -4”)返回的是”hel”。</p>
</li>
</ul>
</li>
<li><p>toLowerCase()和toUpperCase()方法是原始的，是以java.lang.String中相同方法为原型实现的。</p>
<p>toLocaleLowerCase()和toLocaleUpperCase()方法是基于特定的区域实现的</p>
<ul>
<li>一般来说，如果不知道在以哪种编码运行一种语言，则使用区域特定的方法比较安全。</li>
<li>String对象的所有属性和方法都可应用于String原始值上，因为它们是伪对象。</li>
</ul>
</li>
<li><p>instanceof运算符</p>
<ul>
<li>解决使用typeof运算符时，所有类型的对象都返回“object”</li>
</ul>
</li>
</ul>
<h4 id="5-整数"><a href="#5-整数" class="headerlink" title="5.整数"></a>5.整数</h4><ul>
<li><p>ECMAScript中，所有整数字面量默认都是有符号32位整数，前31位（每一位都表示2的幂）是整数数值，最后一位表示符号，0表示正数，1表示负数</p>
</li>
<li><p>负整数：负数也存储为二进制代码，不过采用的形式是二进制补码。计算补码三部曲：</p>
<ul>
<li>确定该数字的非负版本的二进制表示（如，要计算-18的二进制补码，首先要确定18的二进制表示）</li>
<li>求得二进制反码，即把0替换成1，把1替换成0</li>
<li>在二进制反码上加上1</li>
</ul>
</li>
<li><p>位运算NOT（~）三部曲</p>
<ul>
<li><p>把运算数转化成32位数字</p>
</li>
<li><p>把二进制转换成他的二进制反码</p>
</li>
<li><p>把二进制数转化成浮点数</p>
<p><strong>位运算NOT实质上是对数字求负，然后减1</strong>，因此25变成-26</p>
</li>
<li><p>如果运算数是对象，返回false</p>
</li>
<li><p>如果运算数是数字0，返回true</p>
</li>
<li><p>如果运算数是0以外的任何数字，返回false</p>
</li>
<li><p>如果运算数是null，返回true</p>
</li>
<li><p>如果运算数是NaN，返回true</p>
</li>
<li><p>如果运算数是undefined，发生错误。</p>
</li>
</ul>
</li>
<li><p>AND运算符的运算数可以是任何类型的</p>
<ul>
<li>obj &amp;&amp;  boolean  ——–obj</li>
<li>obj1  &amp;&amp;  obj2  ———obj2</li>
<li>有null ———–null</li>
<li>有NaN ——返回NaN</li>
<li>第一个是undefined或第一个是true，第二个是undefined——发生错误</li>
<li>第一个是false，第二个是undefined——返回false，因为第二个没被计算</li>
</ul>
</li>
<li><p>乘法运算符*</p>
<ul>
<li>如果某个运算数是NaN，结果就是NaN</li>
<li>Infinity乘以0，结果是NaN</li>
<li>Infinity乘以0以外的数，结果为Infinity或-Infinity</li>
</ul>
</li>
<li><p>除法运算符/</p>
<ul>
<li>如果结果太大或太小，生成的结果是Infinity或-infinity</li>
<li>如果某个运算数是NaN，结果是NaN</li>
<li>Infinity被Infinity除，结果是NaN。Infinity/Infinity=NaN</li>
<li>Infinity被任何数字除，结果是Infinity    某个数/Infinity=Infinity</li>
<li>0除以一个非无穷大的数字，结果为NaN   0/某个数=NaN</li>
</ul>
</li>
<li><p>取余%</p>
<ul>
<li>Infinity%某数=NaN      某数%0=NaN</li>
<li>Infinity%Infinity=NaN</li>
<li>被除数%Infinity=被除数</li>
<li>0%某数=0</li>
</ul>
</li>
<li><p>加法+</p>
<ul>
<li>某个运算数是NaN，结果为NaN</li>
<li>（-Infinity）+（-Infinity）= -Infinity</li>
<li>Infinity + （-Infinity）=NaN</li>
<li>（+0）+（+0）=（+0）</li>
<li>（-0）+（+0）=（+0）</li>
<li>（-0）-（-0）=（-0）</li>
<li>（-0）+（-0）=（-0）</li>
<li>如果两个运算数都是字符串，把第二个字符串连接到第一个上。</li>
<li>如果只有一个运算数是字符串，把另一个运算数转换成字符串，结果是两个字符串连接成的字符串。</li>
</ul>
</li>
<li><p>等性运算符==和！=</p>
<ul>
<li><p>如果一个运算数是Boolean值，在检查相等性之前，把它转换成数字值，true为1，false为0</p>
</li>
<li><p>字符串和数字，将字符串转成数字</p>
</li>
<li><p>对象和字符串，将对象转为字符串</p>
</li>
<li><p>对象和数字，将对象转成数字</p>
</li>
<li><p>值null和undefined相等</p>
</li>
<li><p>在检查相等性时，不能把null和undefined转换成其他值</p>
</li>
<li><p>有NaN，等号返回false，非等号返回true</p>
</li>
<li><p>如果两个运算数是对象，那比较的是他们的引用值，若指向同一对象，则等号返回true，否则两个运算数不等</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>null == undefined</td>
<td>true</td>
</tr>
<tr>
<td>“NaN” == NaN</td>
<td>false</td>
</tr>
<tr>
<td>5 == NaN</td>
<td>false</td>
</tr>
<tr>
<td>NaN == NaN</td>
<td>false</td>
</tr>
<tr>
<td>NaN != NaN</td>
<td>true</td>
</tr>
<tr>
<td>false == 0</td>
<td>true</td>
</tr>
<tr>
<td>true == 1</td>
<td>true</td>
</tr>
<tr>
<td>true == 2</td>
<td>false</td>
</tr>
<tr>
<td>undefined == 0</td>
<td>false</td>
</tr>
<tr>
<td>null == 0</td>
<td>false</td>
</tr>
<tr>
<td>“5” == 5</td>
<td>true</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="6-语句"><a href="#6-语句" class="headerlink" title="6.语句"></a>6.语句</h4><h6 id="1-有标签的语句"><a href="#1-有标签的语句" class="headerlink" title="1.有标签的语句"></a>1.有标签的语句</h6><ul>
<li>break 语句和 continue 语句都可以与有标签的语句联合使用，返回代码中的特定位置。当循环内部还有循环时，会这样做</li>
<li>with语句用于设置代码在特定对象中的作用域</li>
</ul>
<p>var sMessage = “hello”;<br>with(sMessage) {<br>alert(toUpperCase());    //输出 “HELLO”<br>}</p>
<p>（1）在这个例子中，with语句用于字符串，所以调用toUpperCase()方法时，解释程序将检查该方法是否是本地程序。如果不是，他将检查伪对象sMessage，看他是否为该对象的方法，然后，alert输出“HELLO”,因为解释程序找到了字符串”hello“的toUpperCase（）方法</p>
<p>（2）with语句是运行缓慢的代码块，尤其是在已设置了属性值时。大多情况下，如果可能，最好避免使用它</p>
<h2 id="七-面向对象"><a href="#七-面向对象" class="headerlink" title="七. 面向对象"></a>七. 面向对象</h2><h4 id="1-具备的四种能力"><a href="#1-具备的四种能力" class="headerlink" title="1.具备的四种能力"></a>1.具备的四种能力</h4><ul>
<li>封装：把相关信息（数据或方法）存储在对象中的能力</li>
<li>聚集：把一个对象存储在另一个对象内的能力</li>
<li>继承：有另一个类（或多个类）得来类的属性和方法的能力</li>
<li>多态：编写能以多种方法运行的函数或方法的能力</li>
</ul>
<h4 id="2-对象的应用"><a href="#2-对象的应用" class="headerlink" title="2.对象的应用"></a>2.对象的应用</h4><ul>
<li>对象的创建和销毁都在js执行过程中发生</li>
</ul>
<h4 id="3-对象废除"><a href="#3-对象废除" class="headerlink" title="3.对象废除"></a>3.对象废除</h4><ul>
<li>ECNAScript拥有无用存储单元搜集程序（garbage collection routine），意味着不必专门销毁对象来释放内存。当没有对象引用时，称该对象被废除了（derefence）。运行无用存储单元收集程序时，所有废除的对象都被销毁。每当执行完它的代码，无用存储单元收集程序都会运行，释放所有的局部变量，还有在一些不可预知的情况下，无用存储单元收集程序也会运行</li>
<li>把对象的所有引用都设置为null，可以强制性的废除材料</li>
</ul>
<h4 id="4-绑定"><a href="#4-绑定" class="headerlink" title="4.绑定"></a>4.绑定</h4><ul>
<li>即把对象的接口与对象实例结合起来的方法</li>
<li>早绑定（early binding）是指在实例化对象之前定义它的属性和方法，这样编译器或解释程序就能够提前转换机器代码。在 Java 和 Visual Basic 这样的语言中，有了早绑定，就可以在开发环境中使用 IntelliSense（即给开发者提供对象中属性和方法列表的功能）。ECMAScript 不是强类型语言，所以不支持早绑定。</li>
<li>另一方面，晚绑定（late binding）指的是编译器或解释程序在运行前，不知道对象的类型。使用晚绑定，无需检查对象的类型，只需检查对象是否支持属性和方法即可。ECMAScript 中的所有变量都采用晚绑定方法。这样就允许执行大量的对象操作，而无任何惩罚。</li>
</ul>
<h4 id="5-作用域"><a href="#5-作用域" class="headerlink" title="5.作用域"></a>5.作用域</h4><ul>
<li>指的是变量的适用范围</li>
<li>ECMAScript只有公共作用域，所有对象的作用域都是公共的。由于缺少私有作用域，开发者确定了一个规约，说明哪些属性和方法应该被看做私有的。这种规约规定在属性前后加下划线</li>
<li>ECMAScript没有静态作用域（静态作用域定义的属性和方法任何时候都能从同一位置访问），但可以为构造函数提供属性和方法，构造函数是函数，函数是对象，对象可以有属性和方法</li>
</ul>
<h4 id="6-使用动态原型方法类的属性和方法"><a href="#6-使用动态原型方法类的属性和方法" class="headerlink" title="6.使用动态原型方法类的属性和方法"></a>6.使用动态原型方法类的属性和方法</h4><ul>
<li>在构造函数内定义非函数属性，而函数属性则利用原型属性定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Car(sColor,iDoors,iMpg) &#123;</span><br><span class="line">  this.color = sColor;</span><br><span class="line">  this.doors = iDoors;</span><br><span class="line">  this.mpg = iMpg;</span><br><span class="line">  this.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;);</span><br><span class="line">  </span><br><span class="line">  if (typeof Car._initialized == &quot;undefined&quot;) &#123;</span><br><span class="line">    Car.prototype.showColor = function() &#123;</span><br><span class="line">      alert(this.color);</span><br><span class="line">    &#125;;</span><br><span class="line">	</span><br><span class="line">    Car._initialized = true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>知道检查typeof Car.__initialized是否等于“undefined”之前，这个构造函数都为改变。这行代码是动态原型方法中最重要的一部分。如果这个值没定义，构造函数将用原型方法继续定义对象的方法，然后把Car._initialized设置为true，如果这个值定义了，（它的值为true，typeof的值为Boolean），那么就不再创建该方法。简而言之，该方法使用（_initialized)来判断是否已给原型赋予了任何方法，该方法只创建并赋值一次。</li>
</ul>
<h4 id="7-ECMAScript的字符串"><a href="#7-ECMAScript的字符串" class="headerlink" title="7.ECMAScript的字符串"></a>7.ECMAScript的字符串</h4><ul>
<li>ECMAScript的字符串是不可变的，即它们的值是不可变的</li>
</ul>
<p>var  str=”hello”;str += “world”;</p>
<p>创建此段代码的实际步骤（特别耗资源）</p>
<ul>
<li>创建存储“hello”字符串</li>
<li>创建存储“world”的字符串</li>
<li>创建连接结果的字符串</li>
<li>把str的当前结果复制到结果中</li>
<li>把“world”复制到结果中</li>
<li>更新str，使它指向结果</li>
</ul>
<p>解决方法是用Array对象存储字符串，然后用join（）方法（参数是空字符串）创建最后的字符串（但是不能确切反映出他的意图）</p>
<p>var arr = new Array();<br>arr[0] = “hello “;<br>arr[1] = “world”;<br>var str = arr.join(“”);</p>
<p>实现步骤</p>
<ul>
<li>创建存储结果的字符串</li>
<li>把每个字符串复制到结果中的合适位置</li>
</ul>
<p>最好的方法是使用StringBuffer类包装该功能</p>
<p>function   StringBuffer(){</p>
<p>this.<em>_strings</em>=new Array();</p>
<p>}</p>
<p>StringBuffer.prototype.append=function(str){</p>
<p>this.<em>_strings</em>.push(str);</p>
<p>};</p>
<p>StringBuffer.prototype.toString=function(){</p>
<p>return this.<em>_strings</em>.join(“”);</p>
<p>};</p>
<p>这段代码首先要注意的是strings属性，本意是私有属性。它只有两个方法，append（）和toString（）方法。append（）方法只有一个参数，他把该参数附加到字符串数组中，toString（）方法调用数组的join方法，返回真正连接成的字符串。</p>
<p>var buffer = new StringBuffer ();<br>buffer.append(“hello “);<br>buffer.append(“world”);<br>var result = buffer.toString();</p>
<h2 id="八-继承机制实现"><a href="#八-继承机制实现" class="headerlink" title="八 . 继承机制实现"></a>八 . 继承机制实现</h2><ul>
<li><p>要用ECMAScript实现继承机制，您可以从要继承的基类入手。所有开发者定义的类都可以作为基类。出于安全原因，本地类和宿主类不能作为基类，这样可以防止公用访问编译过的浏览器级的代码，因为这些代码可被用于恶意攻击</p>
</li>
<li><p>选定基类后，就可以创建它的子类了。是否使用基类完全由你决定。有时，你可能创建一个不能直接使用的基类，他只是用于给函数提供通用函数。这种情况下，基类被看成是抽象类。</p>
</li>
<li><p>创建的子类将继承超类的所有属性和方法，包括构造函数及方法的实现。记住，所有的属性和方法都是公用的，因此子类可以直接访问这些方法。子类还可以添加超类中没有的属性和方法，也可以覆盖超类中的属性和方法</p>
</li>
<li><p>JavaScript实现继承并非明确规定，而是通过模仿实现的，故和其他功能一样，不止一种实现方式。这意味着所有的继承细节并非完全由解释程序处理。作为开发者，你有权决定最适合的继承方法</p>
</li>
</ul>
<h4 id="1-对象冒充"><a href="#1-对象冒充" class="headerlink" title="1.对象冒充"></a>1.对象冒充</h4><p>原理：构造函数使用this关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。因为构造函数只是一个函数，所以可以使ClassA构造函数成为ClassB的方法，然后调用它。ClassB就会收到ClassA的构造函数中定义的属性和方法。</p>
<p>function  ClassA(scolor){</p>
<p>this.color=scolor;</p>
<p>this.sayColor=function(){</p>
<p>alert(this.color);}</p>
<p>}</p>
<p>function  ClassB(scolor){  </p>
<p>this.newMethod=ClassA; this.newMethod(scolor);  delete  this.newMethod;</p>
<p>  this.name = sName;<br>this.sayName = function () {<br>alert(this.name);<br>};</p>
<p> }</p>
<p>在这段段代码中，为ClassA赋予方法newMethod（请记住，函数名只是指向它的指针）。然后调用该方法，传递给它的是ClassB构造函数，第三行行删除对ClassA的引用，这样以后就不能再调用它了。所有新属性或新方法都必须在删除了新方法的代码行后才能执行。否则，可能会覆盖超类的相关方法和属性。</p>
<ul>
<li>对象冒充可以实现多重继承，即一个类可继承多个超类</li>
</ul>
<p><img src="https://7n.w3cschool.cn/attachments/day_160921/201609211757355298.gif" alt="继承机制 UML 图示实例"></p>
<p>function ClassZ() {<br>this.newMethod = ClassX;<br>this.newMethod();<br>delete this.newMethod;<br>this.newMethod = ClassY;<br>this.newMethod();<br>delete this.newMethod;<br>}</p>
<p>这里存在一个弊端，如果存在两个类 ClassX 和 ClassY 具有同名的属性或方法，ClassY 具有高优先级。因为它从后面的类继承。除这点小问题之外，用对象冒充实现多重继承机制轻而易举。</p>
<h4 id="2-使用call（对象参数，形参1，2，"><a href="#2-使用call（对象参数，形参1，2，" class="headerlink" title="2.使用call（对象参数，形参1，2，..)"></a>2.使用call（对象参数，形参1，2，..)</h4><h4 id="3-使用apply（对象参数，形参数组）"><a href="#3-使用apply（对象参数，形参数组）" class="headerlink" title="3.使用apply（对象参数，形参数组）"></a>3.使用apply（对象参数，形参数组）</h4><h2 id="九-object对象"><a href="#九-object对象" class="headerlink" title="九.object对象"></a>九.object对象</h2><ul>
<li><p>JavaScript 原生提供<code>Object</code>对象（注意起首的<code>O</code>是大写），所有其他对象都继承自这个对象。<code>Object</code>本身也是一个构造函数，可以直接通过它来生成新对象。</p>
<p>var obj = new Object();</p>
</li>
<li><p>Object作为构造函数使用时，可接受一个参数。如果该参数是一个对象，则直接返回这个对象；如果是原始类型的值，则返回该值的包装对象。注意，通过<code>new Object()</code>的写法生成新对象，与字面量的写法<code>o = {}</code>是等价的。</p>
<p>var o1 = {a: 1};<br>var o2 = new Object(o1);<br>o1 === o2 // true<br>new Object(123) instanceof Number<br>// true</p>
</li>
</ul>
<h4 id="Object对象上面部署一个方法的两种做法。"><a href="#Object对象上面部署一个方法的两种做法。" class="headerlink" title="Object对象上面部署一个方法的两种做法。"></a><code>Object</code>对象上面部署一个方法的两种做法。</h4><h6 id="1-部署在Object对象本身"><a href="#1-部署在Object对象本身" class="headerlink" title="1.部署在Object对象本身"></a>1.部署在Object对象本身</h6><p>比如，在<code>Object</code>对象上面定义一个<code>print</code>方法，显示其他对象的内容。</p>
<p>Object.print = function (o) { console.log(o) } ;</p>
<p>var o =new Object() ;</p>
<p>Object.print(o);</p>
<h6 id="2-部署在Object-prototype对象"><a href="#2-部署在Object-prototype对象" class="headerlink" title="2.部署在Object.prototype对象"></a>2.部署在Object.prototype对象</h6><ul>
<li><p>所有构造函数都有一个prototype属性，指向一个原型对象。凡是在Object.prototype对象上面定义的属性都将被所有实例对象所共享</p>
<p>Object.prototype.print = function () { console.log(this) };</p>
<p>var o = new Object();</p>
<p>o.print();</p>
<p>上面代码在Object.prototype定义了一个print方法，然后生成一个Object的实例o。o直接继承了Object.prototype的属性和方法，可以在自身调用它们，也就是说，o对象的print方法实质上是调用Object.prototype.print方法。。</p>
</li>
</ul>
<h4 id="Object-方法"><a href="#Object-方法" class="headerlink" title="Object()方法"></a>Object()方法</h4><ul>
<li><p>可将任意值转为对象。这个方法常用于保证某个值一定是对象。如果参数是原始类型的值，Object方法返回对应的包装对象的实例</p>
<p>Object() instanceof Object // true<br>Object(undefined) // 返回一个空对象<br>Object(undefined) instanceof Object // true<br>Object(null) // 返回一个空对象<br>Object(null) instanceof Object // true<br>Object(1) // 等同于 new Number(1)<br>Object(1) instanceof Object // true<br>Object(1) instanceof Number // true<br>Object(‘foo’) // 等同于 new String(‘foo’)<br>Object(‘foo’) instanceof Object // true<br>Object(‘foo’) instanceof String // true<br>Object(true) // 等同于 new Boolean(true)<br>Object(true) instanceof Object // true<br>Object(true) instanceof Boolean // true</p>
</li>
<li><p>如果参数是一个对象，他总是返回原对象</p>
<p>var arr = [];<br>Object(arr) // 返回原数组<br>Object(arr) === arr // true<br>var obj = {};<br>Object(obj) // 返回原对象<br>Object(obj) === obj // true<br>var fn = function () {};<br>Object(fn) // 返回原函数<br>Object(fn) === fn // true</p>
<p>利用这一点，可以写一个判断变量是否为对象的函数。</p>
<p>function isObject(value) {<br>return value === Object(value);<br>}<br>isObject([]) // true<br>isObject(true) // false</p>
</li>
</ul>
<h4 id="Object对象的静态方法"><a href="#Object对象的静态方法" class="headerlink" title="Object对象的静态方法"></a>Object对象的静态方法</h4><ul>
<li><p>是指部署在Object对象自身的方法</p>
</li>
<li><p><code>Object.keys</code>方法和<code>Object.getOwnPropertyNames</code>方法很相似，一般用来遍历对象的属性。它们的参数都是一个对象，都返回一个数组，该数组的成员都是对象自身的（而不是继承的）所有属性名。它们的区别在于，<code>Object.keys</code>方法只返回可枚举的属性Object.getOwnPropertyNames`方法还返回不可枚举的属性名。</p>
<p>var o = {<br>p1: 123,<br>p2: 456<br>};<br>Object.keys(o)<br>// [“p1”, “p2”]<br>Object.getOwnPropertyNames(o)<br>// [“p1”, “p2”]</p>
<p>有不可枚举属性length</p>
<p>var a = [“Hello”, “World”];<br>Object.keys(a)<br>// [“0”, “1”]<br>Object.getOwnPropertyNames(a)<br>// [“0”, “1”, “length”]</p>
</li>
<li><p>由于JavaScript没有提供计算对象属性个数的方法，所以可以用这两个方法代替。</p>
<p>Object.keys(o).length</p>
<p>Object.getOwnPropertyNames(o).length</p>
<p>一般情况下，几乎总是使用Object.keys方法遍历数组的属性</p>
</li>
</ul>
<h4 id="对象属性模型的相关方法"><a href="#对象属性模型的相关方法" class="headerlink" title="对象属性模型的相关方法"></a>对象属性模型的相关方法</h4><ul>
<li><code>Object.getOwnPropertyDescriptor()</code>：获取某个属性的<code>attributes</code>对象。</li>
<li><code>Object.defineProperty()</code>：通过<code>attributes</code>对象，定义某个属性。</li>
<li><code>Object.defineProperties()</code>：通过<code>attributes</code>对象，定义多个属性。</li>
<li><code>Object.getOwnPropertyNames()</code>：返回直接定义在某个对象上面的全部属性的名称。</li>
</ul>
<h4 id="控制对象状态的方法"><a href="#控制对象状态的方法" class="headerlink" title="控制对象状态的方法"></a><strong>控制对象状态的方法</strong></h4><ul>
<li><code>Object.preventExtensions()</code>：防止对象扩展。</li>
<li><code>Object.isExtensible()</code>：判断对象是否可扩展。</li>
<li><code>Object.seal()</code>：禁止对象配置。</li>
<li><code>Object.isSealed()</code>：判断一个对象是否可配置。</li>
<li><code>Object.freeze()</code>：冻结一个对象。</li>
<li><code>Object.isFrozen()</code>：判断一个对象是否被冻结。</li>
</ul>
<h4 id="原型链相关方法"><a href="#原型链相关方法" class="headerlink" title="原型链相关方法"></a><strong>原型链相关方法</strong></h4><ul>
<li><code>Object.create()</code>：该方法可以指定原型对象和属性，返回一个新的对象。</li>
<li><code>Object.getPrototypeOf()</code>：获取对象的<code>Prototype</code>对象。</li>
</ul>
<h4 id="Object对象都有的六大实例方法"><a href="#Object对象都有的六大实例方法" class="headerlink" title="Object对象都有的六大实例方法"></a>Object对象都有的六大实例方法</h4><ul>
<li><p>valueOf（）：返回当前对象对应的值</p>
<ul>
<li><p><code>valueOf</code>方法的作用是返回一个对象的“值”，默认情况下返回对象本身。</p>
<p>var o = new Object();<br>o.valueOf() === o // true</p>
</li>
<li><p>valueOf`方法的主要用途是，JavaScript自动类型转换时会默认调用这个方法</p>
<p>var o = new Object();<br>o.valueOf = function (){<br>return 2;<br>};<br>1 + o // 3</p>
</li>
</ul>
</li>
<li><p>toString（）：返回当前对象对应的字符串形式</p>
<ul>
<li><p><code>toString</code>方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。</p>
<p>var o1 = new Object();<br>o1.toString() // “[object Object]”<br>var o2 = {a:1};<br>o2.toString() // “[object Object]”</p>
</li>
<li><p>自动类型转换时</p>
<p>var o = new Object();<br>o.toString = function () {<br>return ‘hello’;<br>};<br>o + ‘ ‘ + ‘world’ // “hello world”</p>
</li>
</ul>
</li>
</ul>
<pre><code>[1, 2, 3].toString() // &quot;1,2,3&quot;
&apos;123&apos;.toString() // &quot;123&quot;
(function () {
return 123;
}).toString()
// &quot;function () {
//   return 123;
// }&quot;
(new Date()).toString()
// &quot;Tue May 10 2016 09:11:31 GMT+0800 (CST)&quot;</code></pre><ul>
<li><p>实例对象可能会自定义<code>toString</code>方法，覆盖掉<code>Object.prototype.toString</code>方法。通过函数的<code>call</code>方法，可以在任意值上调用<code>Object.prototype.toString</code>方法，帮助我们判断这个值的类型。</p>
<p>Object.prototype.toString.call(value)</p>
<p>不同数据类型的<code>Object.prototype.toString</code>方法返回值如下。</p>
<ul>
<li>数值：返回<code>[object Number]</code>。</li>
<li>字符串：返回<code>[object String]</code>。</li>
<li>布尔值：返回<code>[object Boolean]</code>。</li>
<li>undefined：返回<code>[object Undefined]</code>。</li>
<li>null：返回<code>[object Null]</code>。</li>
<li>数组：返回<code>[object Array]</code>。</li>
<li>arguments对象：返回<code>[object Arguments]</code>。</li>
<li>函数：返回<code>[object Function]</code>。</li>
<li>Error对象：返回<code>[object Error]</code>。</li>
<li>Date对象：返回<code>[object Date]</code>。</li>
<li>RegExp对象：返回<code>[object RegExp]</code>。</li>
<li>其他对象：返回<code>[object Object]</code>。</li>
</ul>
</li>
<li><p>也就是说，<code>Object.prototype.toString</code>可以得到一个实例对象的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(2) // &quot;[object Number]&quot;</span><br><span class="line">Object.prototype.toString.call(&apos;&apos;) // &quot;[object String]&quot;</span><br><span class="line">Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;</span><br><span class="line">Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;</span><br><span class="line">Object.prototype.toString.call(null) // &quot;[object Null]&quot;</span><br><span class="line">Object.prototype.toString.call(Math) // &quot;[object Math]&quot;</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;) // &quot;[object Object]&quot;</span><br><span class="line">Object.prototype.toString.call([]) // &quot;[object Array]&quot;</span><br></pre></td></tr></table></figure>

<p>利用这个特性，可以写出一个比<code>typeof</code>运算符更准确的类型判断函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var type = function (o)&#123;</span><br><span class="line">  var s = Object.prototype.toString.call(o);</span><br><span class="line">  return s.match(/\[object (.*?)\]/)[1].toLowerCase();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type(&#123;&#125;); // &quot;object&quot;</span><br><span class="line">type([]); // &quot;array&quot;</span><br><span class="line">type(5); // &quot;number&quot;</span><br><span class="line">type(null); // &quot;null&quot;</span><br><span class="line">type(); // &quot;undefined&quot;</span><br><span class="line">type(/abcd/); // &quot;regex&quot;</span><br><span class="line">type(new Date()); // &quot;date&quot;</span><br></pre></td></tr></table></figure>

<p>在上面这个<code>type</code>函数的基础上，还可以加上专门判断某种类型数据的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[&apos;Null&apos;,</span><br><span class="line"> &apos;Undefined&apos;,</span><br><span class="line"> &apos;Object&apos;,</span><br><span class="line"> &apos;Array&apos;,</span><br><span class="line"> &apos;String&apos;,</span><br><span class="line"> &apos;Number&apos;,</span><br><span class="line"> &apos;Boolean&apos;,</span><br><span class="line"> &apos;Function&apos;,</span><br><span class="line"> &apos;RegExp&apos;,</span><br><span class="line"> &apos;NaN&apos;,</span><br><span class="line"> &apos;Infinite&apos;</span><br><span class="line">].forEach(function (t) &#123;</span><br><span class="line">  type[&apos;is&apos; + t] = function (o) &#123;</span><br><span class="line">    return type(o) === t.toLowerCase();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">type.isObject(&#123;&#125;) // true</span><br><span class="line">type.isNumber(NaN) // true</span><br><span class="line">type.isRegExp(/abc/) // true</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>toLocaleString（）：返回当前对象对应的本地字符串形式。</p>
</li>
<li><p>hasOwnProperty（）：判断某个属性是否为当前对象自身的属性值还是继承自原型对象的属性</p>
</li>
<li><p>isPrototypeOf（）：判断当前对象是否为另一个对象的原型</p>
</li>
<li><p>propertyIsEnumerable（）：判断某个属性是否可枚举</p>
</li>
</ul>
<h4 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h4><ul>
<li><p><code>Array</code>是JavaScript的内置对象，同时也是一个构造函数，可以用它生成新的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(2);</span><br><span class="line">arr.length // 2</span><br><span class="line">arr // [ undefined x 2 ]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array</code>构造函数有一个很大的问题，就是不同的参数，会导致它的行为不一致。`因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。</p>
<p>// 无参数时，返回一个空数组<br>new Array() // []<br>// 单个正整数参数，表示返回的新数组的长度<br>new Array(1) // [ undefined ]<br>new Array(2) // [ undefined x 2 ]<br>// 非正整数的数值作为参数，会报错<br>new Array(3.2) // RangeError: Invalid array length<br>new Array(-3) // RangeError: Invalid array length<br>// 单个非正整数参数（比如字符串、布尔值、对象等），<br>// 则该参数是返回的新数组的成员<br>new Array(‘abc’) // [‘abc’]<br>new Array([1]) // [Array[1]]<br>// 多参数时，所有参数都是返回的新数组的成员<br>new Array(1, 2) // [1, 2]<br>new Array(‘a’, ‘b’, ‘c’) // [‘a’, ‘b’, ‘c’]</p>
</li>
<li><p>注意，如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回<code>undefined</code>，但实际上该位置没有任何值。虽然可以取到<code>length</code>属性，但是取不到键名。</p>
<p>var arr = new Array(3);<br>arr.length // 3<br>arr[0] // undefined<br>arr[1] // undefined<br>arr[2] // undefined<br>0 in arr // false<br>1 in arr // false<br>2 in arr // false</p>
</li>
<li><p>Array.isArray():判断一个值是否为数组，弥补typeof运算符的不足</p>
</li>
</ul>
<h6 id="1-Array实例的方法"><a href="#1-Array实例的方法" class="headerlink" title="1.Array实例的方法"></a>1.Array实例的方法</h6><ul>
<li><p>valueOf（）方法返回数组本身</p>
<p>var a = [1, 2, 3];<br>a.valueOf() // [1, 2, 3]</p>
</li>
<li><p>toString（）方法返回数组的字符串形式</p>
<p>var a = [1, 2, 3];<br>a.toString() // “1,2,3”<br>var a = [1, 2, 3, [4, 5, 6]];<br>a.toString() // “1,2,3,4,5,6”</p>
</li>
<li><p>push（）方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p>
<p>var a = [];<br>a.push(1) // 1<br>a.push(‘a’) // 2<br>a.push(true, {}) // 4<br>a // [1, ‘a’, true, {}]</p>
</li>
<li><p>合并两个数组</p>
<p>var a = [1, 2, 3];<br>var b = [4, 5, 6];<br>Array.prototype.push.apply(a, b)<br>// 或者<br>a.push.apply(a, b)<br>// 上面两种写法等同于<br>a.push(4, 5, 6)<br>a // [1, 2, 3, 4, 5, 6]</p>
</li>
<li><p>push方法还可用于向对象添加元素，添加后的对象变成类似数组的对象，即新加入元素的键对应数组的索引，并且对象有一个length属性,其中的length属性是指加入键名的个数</p>
<p>var  a= {a:1};</p>
<p>[].push.call(a,2); </p>
<p>a  //{a:1 ,0:2 ,  length :1}</p>
<p>[].push.call(a,[3]);</p>
<p>a     // {a:1,0:2,1:[3],length:2};</p>
</li>
<li><p>pop（）方法用于删除数组的最后一个元素，并返回该元素。该方法会改变原数组</p>
<p>var  arr=[‘a’,’b’,’c’];</p>
<p>a.pop()  //‘c’</p>
<p>a  //[‘a’,’b’]</p>
</li>
<li><p>对空数组使用pop方法，不是犯错，而是返回undefined</p>
<p>[ ].pop()   //undefined</p>
</li>
<li><p>push和pop结合使用就构成后进先出的栈结构</p>
</li>
<li><p>join（）方法以参数作为分隔符，将所有数组组成一个字符串返回。如果不提供参数，默认用逗号分隔</p>
<p>var   str=”abcdefgh”;</p>
<p>var  arr=str.split(‘’);    //[“a”, “b”, “c”, “d”, “e”, “f”, “g”, “h”]</p>
<p>arr.join(‘’);   //“abcdefgh”</p>
<p>arr.join(‘ ‘);     //a b c d e f g h’;</p>
</li>
<li><p>如果数组成员是undefined或null或空位，会被转成空字符串</p>
<p>[undefined,null].join(‘#’)      //‘#’</p>
<p>[‘a’, ,’b’].join(‘-‘)    //‘a- -b’</p>
</li>
<li><p>这个方法也可以用于字符串，通过call方法</p>
<p>Array.prototype.join.call(‘hello’,’-‘)       //“h-e-l-l-o”</p>
</li>
<li><p>join方法也可以用于类似数组的对象</p>
<p>var  obj={0:’a’,1:’b’,length:2};</p>
<p>Array.prototype.join.call(obj,’-‘)   //‘a-b’</p>
</li>
<li><p>concat()用于将多个数组合并。它将新数组的成员添加到原数组的尾部，然后返回一个新数组，原数组不变</p>
<p>[‘hello’].concat([‘world’], [‘!’])<br>// [“hello”, “world”, “!”]</p>
</li>
<li><p>concat方法如果不提供参数，<code>concat</code>方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是如果数组成员包括复合类型的值（比如对象），则新数组拷贝的是该值的引用（你改我也会改）。</p>
<p>var obj = { a:1 };<br>var oldArray = [obj];<br>var newArray = oldArray.concat();<br>obj.a = 2;<br>newArray[0].a // 2</p>
</li>
<li><p>concat方法也可以用于将对象合并为数组，但是必须借助call方法</p>
<p>[].concat.call({a: 1}, {b: 2})<br>// [{ a: 1 }, { b: 2 }]<br>[].concat.call({a: 1}, [2])<br>// [{a: 1}, 2]<br>[2].concat({a: 1})<br>// [2, {a: 1}]</p>
</li>
<li><p>shift用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组</p>
<p>var   a=[‘a’,’b’,’c’];</p>
<p>a.shift();</p>
<p>a    //[‘b’,’c’]</p>
</li>
<li><p><code>shift</code>方法可以遍历并清空一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var list = [1, 2, 3, 4, 5, 6];</span><br><span class="line">var item;</span><br><span class="line"></span><br><span class="line">while (item = list.shift()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list // []</span><br></pre></td></tr></table></figure>

<p><code>push</code>和<code>shift</code>结合使用，就构成了“先进先出”的队列结构（queue）。</p>
</li>
<li><p><code>unshift</code>方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">a.unshift(&apos;x&apos;); // 4</span><br><span class="line">a // [&apos;x&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>

<p><code>unshift</code>方法可以在数组头部添加多个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ &apos;c&apos;, &apos;d&apos; ];</span><br><span class="line">arr.unshift(&apos;a&apos;, &apos;b&apos;) // 4</span><br><span class="line">arr // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos; ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>reverse()方法用于颠倒数组中的元素的顺序，返回改变后的数组。注意，会改变原数组</p>
<p>var a = [‘a’, ‘b’, ‘c’];<br>a.reverse() // [“c”, “b”, “a”]<br>a // [“c”, “b”, “a”]</p>
</li>
<li><p>slice方法用于提取原数组的一部分，返回一个新数组，原数组不变。它的第一个参数为起始位置（从零开始），第二个参数为1终止位置（但不包括该元素本身）。若省略第二个参数，则一直返回到原数组最后一个成员，相当于原数组的拷贝。</p>
<p>a.slice(0) // [“a”, “b”, “c”]<br>a.slice(1) // [“b”, “c”]<br>a.slice(1, 2) // [“b”]<br>a.slice(2, 6) // [“c”]<br>a.slice() // [“a”, “b”, “c”]</p>
</li>
<li><p>slice方法的参数是负数时表示倒数计算的位置。</p>
<p>var a = [‘a’, ‘b’, ‘c’];<br>a.slice(-2) // [“b”, “c”]<br>a.slice(-2, -1) // [“b”]</p>
</li>
<li><p>如果参数值大于数组成员的个数，或者第二个参数小于第一个参数，则返回空数组。</p>
<p>var a = [‘a’, ‘b’, ‘c’];<br>a.slice(4) // []<br>a.slice(2, 1) // []</p>
</li>
<li><p><code>slice</code>方法的一个重要应用，是将类似数组的对象转为真正的数组。</p>
<p>Array.prototype.slice.call({ 0: ‘a’, 1: ‘b’, length: 2 })<br>// [‘a’, ‘b’]<br>Array.prototype.slice.call(document.querySelectorAll(“div”));<br>Array.prototype.slice.call(arguments);</p>
</li>
<li><p><code>splice</code>方法用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</p>
<p><code>splice</code>的第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</p>
<p>// 格式<br>arr.splice(index, count_to_remove, addElement1, addElement2, …);<br>// 用法<br>var a = [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’];<br>a.splice(4, 2) // [“e”, “f”]<br>a // [“a”, “b”, “c”, “d”]</p>
</li>
<li><p>如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</p>
<p>var a = [1, 2, 3, 4];<br>a.splice(2) // [3, 4]<br>a // [1, 2]</p>
</li>
<li><p><code>sort</code>方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</p>
</li>
<li><p>如果想让<code>sort</code>方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于<code>0</code>，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。</p>
<p>[10111, 1101, 111].sort(function (a, b) {<br>return a - b;<br>})<br>// [111, 1101, 10111]<br>[<br>{ name: “张三”, age: 30 },<br>{ name: “李四”, age: 24 },<br>{ name: “王五”, age: 28  }<br>].sort(function (o1, o2) {<br>return o1.age - o2.age;<br>})<br>// [<br>//   { name: “李四”, age: 24 },<br>//   { name: “王五”, age: 28  },<br>//   { name: “张三”, age: 30 }<br>// ]</p>
</li>
<li><p><code>map</code>方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。<code>map</code>方法接受一个函数作为参数。该函数调用时，<code>map</code>方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。</p>
<p>var numbers = [1, 2, 3];<br>numbers.map(function (n) {<br>return n + 1;<br>});<br>// [2, 3, 4]</p>
<p>numbers<br>// [1, 2, 3]</p>
<p>[1, 2, 3].map(function(elem, index, arr) {<br>return elem * index;<br>});<br>// [0, 2, 6]</p>
<p><code>map</code>方法不仅可以用于数组，还可以用于字符串，用来遍历字符串的每个字符。但是，不能直接使用，而要通过函数的<code>call</code>方法间接使用，或者先将字符串转为数组，然后使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> upper = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.toUpperCase();</span><br><span class="line">  &#125;;</span><br><span class="line">  [].map.call(<span class="string">'abc'</span>, upper)</span><br><span class="line">  <span class="comment">// [ 'A', 'B', 'C' ]</span></span><br><span class="line">  <span class="comment">// 或者</span></span><br><span class="line">  <span class="string">'abc'</span>.split(<span class="string">''</span>).map(upper)</span><br><span class="line"><span class="comment">// [ 'A', 'B', 'C' ]</span></span><br></pre></td></tr></table></figure>





















</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 陈楚吟
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
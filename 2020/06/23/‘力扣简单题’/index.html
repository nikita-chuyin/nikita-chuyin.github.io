<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="陈楚吟">



<meta name="description" content="数组数组取交集1const duplicatedValues = [...new Set(arr1)].filter(item =&amp;gt; arr2.includes(item))  数组取差集1const diffValues = [...new Set([...arr1,...arr2])].filter(item =&amp;gt; !b.includes(item) || !a.includes(">
<meta name="keywords" content="write myBlog">
<meta property="og:type" content="article">
<meta property="og:title" content="‘力扣简单题’">
<meta property="og:url" content="http://yoursite.com/2020/06/23/‘力扣简单题’/index.html">
<meta property="og:site_name" content="Nikita">
<meta property="og:description" content="数组数组取交集1const duplicatedValues = [...new Set(arr1)].filter(item =&amp;gt; arr2.includes(item))  数组取差集1const diffValues = [...new Set([...arr1,...arr2])].filter(item =&amp;gt; !b.includes(item) || !a.includes(">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://math.jianshu.com/math?formula=f(n)">
<meta property="og:image" content="https://math.jianshu.com/math?formula=f(n-1)">
<meta property="og:image" content="https://math.jianshu.com/math?formula=f(n-2)">
<meta property="og:image" content="https://math.jianshu.com/math?formula=f(n)%20%3D%20f(n-1)%20%2B%20f(n-2)">
<meta property="og:image" content="https://math.jianshu.com/math?formula=f(x)%3D%5Cleft%5C%7B%20%5Cbegin%7Baligned%7D%20%26%200%20%26%20n%3D0%20%5C%5C%20%26%201%20%26%20n%3D1%20%5C%5C%20%26%202%20%26%20n%3D2%20%5C%5C%20%26%20f(n-1)%2Bf(n-2)%20%26%20n%20%3E%202%20%5Cend%7Baligned%7D%20%5Cright.">
<meta property="og:updated_time" content="2020-07-07T14:05:51.562Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="‘力扣简单题’">
<meta name="twitter:description" content="数组数组取交集1const duplicatedValues = [...new Set(arr1)].filter(item =&amp;gt; arr2.includes(item))  数组取差集1const diffValues = [...new Set([...arr1,...arr2])].filter(item =&amp;gt; !b.includes(item) || !a.includes(">
<meta name="twitter:image" content="https://math.jianshu.com/math?formula=f(n)">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Nikita" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>‘力扣简单题’ | Nikita</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">陈楚吟</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不负韶华</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">陈楚吟</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">陈楚吟</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不负韶华</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-‘力扣简单题’" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/23/‘力扣简单题’/" class="article-date">
      <time datetime="2020-06-23T07:43:03.000Z" itemprop="datePublished">2020-06-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ‘力扣简单题’
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="数组取交集"><a href="#数组取交集" class="headerlink" title="数组取交集"></a>数组取交集</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> duplicatedValues = [...new <span class="built_in">Set</span>(arr1)].filter(<span class="function"><span class="params">item</span> =&gt;</span> arr2.includes(item))</span><br></pre></td></tr></table></figure>

<h4 id="数组取差集"><a href="#数组取差集" class="headerlink" title="数组取差集"></a>数组取差集</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> diffValues = [...new <span class="built_in">Set</span>([...arr1,...arr2])].filter(<span class="function"><span class="params">item</span> =&gt;</span> !b.includes(item) || !a.includes(item))</span><br></pre></td></tr></table></figure>

<h4 id="数组转对象"><a href="#数组转对象" class="headerlink" title="数组转对象"></a>数组转对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> newObj = &#123;...arr&#125; <span class="comment">// &#123;0: 1, 1: 2, 2: 3, 3: 4&#125;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="attr">length</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// 对象转数组不能用展开操作符，因为展开操作符必须用在可迭代对象上</span></span><br><span class="line"><span class="keyword">let</span> newArr = [...obj] <span class="comment">// Uncaught TypeError: object is not iterable...</span></span><br><span class="line"><span class="comment">// 可以使用Array.form()将类数组对象转为数组</span></span><br><span class="line"><span class="keyword">let</span> newArr = <span class="built_in">Array</span>.from(obj) <span class="comment">// [0, 1, 2]</span></span><br></pre></td></tr></table></figure>

<h4 id="数组摊平"><a href="#数组摊平" class="headerlink" title="数组摊平"></a>数组摊平</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, [3, [4, 5]]].flat()</span><br><span class="line">// [1, 2, 3, [4, 5]]</span><br><span class="line">[1, 2, [3, [4, 5]]].flat(2)</span><br><span class="line">// [1, 2, 3, 4, 5]</span><br><span class="line">//上面代码中，flat()的参数为2，表示要拉平两层的嵌套数组。</span><br><span class="line">//如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。</span><br><span class="line">[1, [2, [3]]].flat(Infinity)</span><br><span class="line">// [1, 2, 3]</span><br></pre></td></tr></table></figure>

<h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><p><strong>原地修改原数组</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var removeDuplicates = function(nums) &#123;</span><br><span class="line">    // 记录nums元素个数</span><br><span class="line">    let len = nums.length;</span><br><span class="line">    let count = 0;</span><br><span class="line">    //遍历数组元素，若后一项与前一项相同，则复制后面元素到重复位上</span><br><span class="line">    for(var i = 1; i &lt; nums.length; i++)&#123;</span><br><span class="line">        if(nums[i] != nums[i-1])&#123;</span><br><span class="line">            nums[i - count] = nums[i];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return len - count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>不修改原数组</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//数据结构Set数据结构去重。</span><br><span class="line">function removeDuplicates(nums)&#123;</span><br><span class="line">	let arr = [...new Set(nums)];</span><br><span class="line">	return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//利用object对象键值唯一性去重</span><br><span class="line">function removeDuplicates(nums)&#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    let arr = [];</span><br><span class="line">	for(let item of nums)&#123;</span><br><span class="line">		obj[item] = 1;</span><br><span class="line">	&#125;</span><br><span class="line">	for(let key in obj)&#123;</span><br><span class="line">        arr.push(key);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 利用indexOf判断</span><br><span class="line">function removeDuplicates(nums)&#123;</span><br><span class="line">	let arr = [];</span><br><span class="line">	for(let i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">		if(arr.indexOf(nums[i]) == -1)&#123;</span><br><span class="line">			arr.push(nums[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数组移除元素"><a href="#数组移除元素" class="headerlink" title="数组移除元素"></a>数组移除元素</h4><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var removeElement = function (nums, val) &#123;</span><br><span class="line">    // 记录数组元素个数，当匹配到，将最后的元素填到前面来</span><br><span class="line">    var ans = nums.length;</span><br><span class="line">    for(var i = 0; i&lt; ans;)&#123;</span><br><span class="line">        if(nums[i] == val)&#123;</span><br><span class="line">            nums[i] = nums[ans -1];</span><br><span class="line">            ans --;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//最优解</span><br><span class="line">var removeElement = function (nums, val) &#123;</span><br><span class="line">    // for...of循环数组，不等于val的值的存入nums数组中</span><br><span class="line">    let count = 0;</span><br><span class="line">    for(var num of nums)&#123;</span><br><span class="line">        if(num != val)&#123;</span><br><span class="line">            nums[ count++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="移除数组中的元素"><a href="#移除数组中的元素" class="headerlink" title="移除数组中的元素"></a>移除数组中的元素</h4><p>移除数组 arr 中的所有值与 item 相等的元素，<strong>直接在给定的 arr 数组上进行操作</strong>，并将结果返回</p>
<p>示例1</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 2, 3, 4, 2, 2], 2</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 3, 4]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function removeWithoutCopy(arr, item) &#123;</span><br><span class="line">    for(let i = 0; i &lt; arr.length;i++)&#123;</span><br><span class="line">    	if(arr.indexOf(item) == -1) break;</span><br><span class="line">    	if(arr[i] == item)&#123;</span><br><span class="line">    		arr.splice(i,1);</span><br><span class="line">    		i--;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组搜索插入位置"><a href="#数组搜索插入位置" class="headerlink" title="数组搜索插入位置"></a>数组搜索插入位置</h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> var searchInsert = function (nums, target) &#123;</span><br><span class="line">    if (nums.indexOf(target) == -1) &#123;</span><br><span class="line">        nums.push(target);</span><br><span class="line">        nums.sort((a,b) =&gt; a-b);</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.indexOf(target);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="合并两个数组"><a href="#合并两个数组" class="headerlink" title="合并两个数组"></a>合并两个数组</h4><p><strong>改变原数组</strong></p>
<p>给你两个有序整数数组 <em>nums1</em> 和 <em>nums2*，请你将 *nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使 <em>num1</em> 成为一个有序数组。</p>
<p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p>
<p>输出: [1,2,2,3,5,6]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums1</span><br><span class="line"> * @param &#123;number&#125; m</span><br><span class="line"> * @param &#123;number[]&#125; nums2</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead.</span><br><span class="line"> */</span><br><span class="line"> //从返回值为空可知，必须修改nums1中的参数</span><br><span class="line">var merge = function(nums1, m, nums2, n) &#123;</span><br><span class="line">    nums1.splice(m,n,...nums2);</span><br><span class="line">    nums1.sort((a,b) =&gt; a-b)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>不改变原数组</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var merge = function(nums1, m, nums2, n) &#123;</span><br><span class="line">    let arr = [...nums1,...nums2];</span><br><span class="line">    arr.splice(m,n);</span><br><span class="line">    return arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h4><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<p>示例 1：</p>
<p>输入：nums = [2,7,11,15], target = 9<br>输出：[2,7] 或者 [7,2]</p>
<p>示例 2：</p>
<p>输入：nums = [10,26,30,31,47,60], target = 40<br>输出：[10,30] 或者 [30,10]</p>
<p>限制：</p>
<pre><code>1 &lt;= nums.length &lt;= 10^5
1 &lt;= nums[i] &lt;= 10^6</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var twoSum = function (nums, target) &#123;</span><br><span class="line">    let left = 0,</span><br><span class="line">        right = nums.length - 1;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        if (nums[left] + nums[right] == target) &#123;</span><br><span class="line">            return [nums[left], nums[right]];</span><br><span class="line">        &#125; else if (nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var twoSum = function(nums, target) &#123;</span><br><span class="line">    //nums已经排序了，二分法</span><br><span class="line">    let avg= target/2;</span><br><span class="line">    let j;//接近avg的索引下标</span><br><span class="line">    for(let i = 0; i&lt; nums.length; i++)&#123;</span><br><span class="line">        if(avg &gt;= nums[i])&#123;</span><br><span class="line">            j=i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let left=j;</span><br><span class="line">    for(let right=j;right&lt;nums.length;right++)&#123;</span><br><span class="line">        let x = target - nums[right];</span><br><span class="line">        while(left&gt;=0 &amp;&amp; nums[left] &gt; x)&#123;</span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left &lt; 0)break;</span><br><span class="line">        if(nums[left] === x &amp;&amp; left!==right)return [nums[left],nums[right]];</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    return [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h4><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p>示例 1：</p>
<p>输入：target = 9<br>输出：[[2,3,4],[4,5]]</p>
<p>示例 2：</p>
<p>输入：target = 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p>
<p>限制：</p>
<pre><code>1 &lt;= target &lt;= 10^5</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var findContinuousSequence = function(target) &#123;</span><br><span class="line">    ////由规律得，序列中最大值是target的一半+ 或 - 1</span><br><span class="line">    let index = target % 2 ? (target + 1)/2 : target/2;</span><br><span class="line">    </span><br><span class="line">    let res = [];   //存储结果</span><br><span class="line">    let temp = [];   //存储从下标值</span><br><span class="line">    let sum = 0;     //与target作比较</span><br><span class="line">    for(let i = 1; i &lt;= index; i++)&#123;</span><br><span class="line">        temp.push(i);</span><br><span class="line">        sum += i;</span><br><span class="line">        while(sum &gt; target)&#123;</span><br><span class="line">            sum -= temp[0];</span><br><span class="line">            temp.shift();</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum == target)&#123;</span><br><span class="line">            temp.length &gt;= 2 &amp;&amp; res.push([...temp]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h4><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums </span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">//动态规划法(缺点：突然中断，算出来的是已经遍历过的数)</span><br><span class="line">// 定义一个回调方法ans保存结果值，sum为求和后的值，将ans和sum中的最大值赋给ans</span><br><span class="line">var maxSubArray = function(nums)&#123;</span><br><span class="line">    let ans = nums[0];</span><br><span class="line">    let sum = 0;</span><br><span class="line">    for(let num of nums)&#123;</span><br><span class="line">        if(sum &gt; 0)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            sum = num;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h4><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p>
<p>示例:</p>
<p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释: </p>
<p>  滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var maxSlidingWindow = function(nums, k) &#123;</span><br><span class="line">    if(nums.length===0)return [];  //边界值</span><br><span class="line">    let max=[];</span><br><span class="line">    for(let i=0; i+k-1&lt;nums.length;i++)&#123;  </span><br><span class="line">        let m=Math.max(...nums.slice(i,i+k));</span><br><span class="line">        max.push(m);</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h4><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p>
<p>示例 2:</p>
<p>输入: [-1,-100,3,99] 和 k = 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]</p>
<p>说明:</p>
<p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的 原地 算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//改变数组，利用数组的splice的增加删除操作原地操作</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @return &#123;void&#125; Do not return anything, modify nums in-place instead.</span><br><span class="line"> */</span><br><span class="line">var rotate = function(nums,k)&#123;</span><br><span class="line">    nums.splice(0,0,...nums.splice(nums.length-k));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="字符异位词分组"><a href="#字符异位词分组" class="headerlink" title="字符异位词分组"></a>字符异位词分组</h4><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p>示例:</p>
<p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]</p>
<p>说明：</p>
<p>所有输入均为小写字母。<br>不考虑答案输出的顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string[]&#125; strs</span><br><span class="line"> * @return &#123;string[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var groupAnagrams = function(strs) &#123;</span><br><span class="line">    // 利用哈希表存储，键值唯一</span><br><span class="line">    let hash = new Map();</span><br><span class="line">    for(let  i = 0; i &lt; strs.length;i++)&#123;</span><br><span class="line">        if(hash.has(str))&#123;</span><br><span class="line">            let temp = hash.get(str);</span><br><span class="line">            temp.push(strs[i]);</span><br><span class="line">            hash.set(str,temp);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            hash.set(str,[strs]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return [...hash.values()]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>#### </p>
<h4 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h4><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>

<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p>将可能出现的情况存到map中，定义一个变量存返回值。优先判断是否符合两个的字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">var romanToInt = function (s) &#123;</span><br><span class="line">    let map = &#123;</span><br><span class="line">        I : 1,</span><br><span class="line">        IV: 4,</span><br><span class="line">        V: 5,</span><br><span class="line">        IX: 9,</span><br><span class="line">        X: 10,</span><br><span class="line">        XL: 40,</span><br><span class="line">        L: 50,</span><br><span class="line">        XC: 90,</span><br><span class="line">        C: 100,</span><br><span class="line">        CD: 400,</span><br><span class="line">        D: 500,</span><br><span class="line">        CM: 900,</span><br><span class="line">        M: 1000</span><br><span class="line">    &#125;</span><br><span class="line">    let ans = 0;</span><br><span class="line">    for(var i = 0; i &lt; s.length;)&#123;</span><br><span class="line">        if(i + 1 &lt; s.length &amp;&amp; map[s.substring(i,i+2)])&#123;</span><br><span class="line">            ans += map[s.substring(i,i+2)];</span><br><span class="line">            i += 2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ans += map[s.substring(i,i+1)];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="数组中重复数字"><a href="#数组中重复数字" class="headerlink" title="数组中重复数字"></a>数组中重复数字</h4><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>示例 1：</p>
<p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 利用向前遍历的与向后遍历的下标值不同找出重复值</span></span><br><span class="line">        <span class="keyword">if</span>(nums.lastIndexOf(nums[i]) != i)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用set,因为set自动忽略重复元素，遍历数组中元素，若长度未增加，则输出当前元素</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> s=<span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> nums)&#123;</span><br><span class="line">        <span class="keyword">var</span> curLenth=s.size;</span><br><span class="line">        s.add(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(s.size==curLenth)</span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="二维数组的查找"><a href="#二维数组的查找" class="headerlink" title="二维数组的查找"></a>二维数组的查找</h4><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p>
<p>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[][]&#125; matrix</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findNumberIn2DArray = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> matrix.flat(<span class="literal">Infinity</span>).includes(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[][]&#125; matrix</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 从左上角看，其上的数值都比该值小，右边的数值都比该值大</span></span><br><span class="line"><span class="keyword">var</span> findNumberIn2DArray = <span class="function"><span class="keyword">function</span> (<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> y = matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &lt; matrix[<span class="number">0</span>].length  &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[y][x] &gt; target) &#123;</span><br><span class="line">            y--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[y][x] &lt; target) &#123;</span><br><span class="line">            x++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h4 id="字符串数组中的最长公共前缀"><a href="#字符串数组中的最长公共前缀" class="headerlink" title="字符串数组中的最长公共前缀"></a>字符串数组中的最长公共前缀</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">编写一个函数来查找字符串数组中的最长公共前缀。</span><br><span class="line"></span><br><span class="line">如果不存在公共前缀，返回空字符串 &quot;&quot;。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param &#123;string[]&#125; strs</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line"> var longestCommonPrefix = function(strs) &#123;</span><br><span class="line">    if(strs.length == 0) return &apos;&apos;;</span><br><span class="line">    let ans = strs[0];</span><br><span class="line">    for(let i = 0;i &lt; strs.length;i++)&#123;</span><br><span class="line">        let  j = 0;</span><br><span class="line">        for(;j &lt; ans.length &amp;&amp; j &lt; strs[i].length;j++)&#123;</span><br><span class="line">            if(ans[j] != strs[i][j]) break;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans.substr(0,j);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br><span class="line">let strs =  [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">console.log(longestCommonPrefix(strs));</span><br></pre></td></tr></table></figure>

<h4 id="有效字符串"><a href="#有效字符串" class="headerlink" title="有效字符串"></a>有效字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">给定一个只包括 &apos;(&apos;，&apos;)&apos;，&apos;&#123;&apos;，&apos;&#125;&apos;，&apos;[&apos;，&apos;]&apos; 的字符串，判断字符串是否有效。</span><br><span class="line"></span><br><span class="line">有效字符串需满足：</span><br><span class="line"></span><br><span class="line">左括号必须用相同类型的右括号闭合。</span><br><span class="line">左括号必须以正确的顺序闭合。</span><br><span class="line">注意空字符串可被认为是有效字符串。</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    边遍历便匹配，即遇到的第一个右括号必须与数组中最后一个元素匹配，否则无效。</span><br><span class="line">    匹配完成后从数组中删除此元素。</span><br><span class="line">    @param &#123;string&#125; s</span><br><span class="line">    @return &#123;boolean&#125;</span><br><span class="line">*/</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line"> var isValid = function(s)&#123;</span><br><span class="line">    //构建一个map结构的对象</span><br><span class="line">    let map = &#123;</span><br><span class="line">        &quot;(&quot;: &quot;)&quot;,</span><br><span class="line">        &quot;&#123;&quot;: &quot;&#125;&quot;,</span><br><span class="line">        &quot;[&quot;: &quot;]&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    let leftArr = []; //用于存放左括号</span><br><span class="line">    for(let ch of s)&#123;</span><br><span class="line">        if(ch in map) leftArr.push(ch);</span><br><span class="line">        else&#123;</span><br><span class="line">            if(ch != map[leftArr.pop()])&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return !leftArr.length;   //避免都是左括号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串中找最大数字"><a href="#字符串中找最大数字" class="headerlink" title="字符串中找最大数字"></a>字符串中找最大数字</h4><p> 输入一串只有数字和字母的字符串，输出该字符串中最大的数字</p>
<p>输入：hellowolrd520hellowor</p>
<p>ld1314</p>
<p>输出：1314 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let str = &apos;hellowolrd520helloworld1314&apos;;</span><br><span class="line"></span><br><span class="line">let reg = /\d+/g;</span><br><span class="line"></span><br><span class="line">let arr = str.match(reg);</span><br><span class="line"></span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">let max = Math.max(...arr);</span><br><span class="line"></span><br><span class="line">console.log(max);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let str = &apos;hellowolrd520helloworld1314&apos;;</span><br><span class="line"></span><br><span class="line">let reg = /[a-z]+/g;</span><br><span class="line"></span><br><span class="line">let arr = str.split(reg);</span><br><span class="line"></span><br><span class="line">let max = Math.max(...arr);</span><br><span class="line"></span><br><span class="line">console.log(max);</span><br></pre></td></tr></table></figure>

<h4 id="最后一个单词的长度"><a href="#最后一个单词的长度" class="headerlink" title="最后一个单词的长度"></a>最后一个单词的长度</h4><p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<p>说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var lengthOfLastWord = function(s) &#123;</span><br><span class="line">    // 去除字符串两边的空格</span><br><span class="line">    s = s.trim();</span><br><span class="line">    let arr = s.split(&apos; &apos;);</span><br><span class="line">    let len = arr.length;</span><br><span class="line">    if(len == 0) return 0;</span><br><span class="line">    return arr[len - 1].length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h4><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p>示例 1：</p>
<p>输入: “the sky is blue”<br>输出: “blue is sky the”</p>
<p>示例 2：</p>
<p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
<p>示例 3：</p>
<p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
<p>说明：</p>
<pre><code>无空格字符构成一个单词。
输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//先去空格（此步可省），分割为字符串数组，去除多余空格，翻转后转为字符串</span><br><span class="line">var reverseWords = function(s) &#123;</span><br><span class="line">    return s.trim().split(&apos; &apos;).filter(x =&gt; !!x).reverse().join(&apos; &apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="颠倒二进制"><a href="#颠倒二进制" class="headerlink" title="颠倒二进制"></a>颠倒二进制</h4><p>颠倒给定的 32 位无符号整数的二进制位。</p>
<p>示例 1：</p>
<p>输入: 00000010100101000001111010011100<br>输出: 00111001011110000010100101000000<br>解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，<br>      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</p>
<p>示例 2：</p>
<p>输入：11111111111111111111111111111101<br>输出：10111111111111111111111111111111<br>解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，<br>      因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。 </p>
<p>提示：</p>
<pre><code>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</code></pre><p>进阶:<br>如果多次调用这个函数，你将如何优化你的算法？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//利用字符串的toString方法转为二进制数</span><br><span class="line">var reverseBits = function(n) &#123;</span><br><span class="line">	//二进制以0b开头</span><br><span class="line">    return +(&apos;0b&apos;+n.toString(2).padStart(32,0).split(&apos;&apos;).reverse().join(&apos;&apos;))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h4><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>示例 1：</p>
<p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/\s/g</span>,<span class="string">'%20'</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为字符串是不可变的，所以如果直接采用从头到尾遍历原字符串检查空格，并且做替换。那么每次检查到空格后，都需要重新生成字符串。整个过程时间复杂度是 O(N^2)。</p>
<p>优化的关键：提前计算替换后的字符串的长度，避免每次都对字符串做改动。</p>
<p>整体思路如下：</p>
<pre><code>遍历原字符串，统计空格和非空格字符个数，计算替换后的新字符的长度
准备两个指针，指针 i 指向原字符串，指针 j 指向新字符串
i 从头开始遍历原字符串
    str[i]是非空格，那么将 i 指向的字符放入新字符串的 j 位置。i 和 j 都增加 1。
    str[i]是空格，那么 j 指向的位置依次填入%20。i 增加 1，j 增加 3。</code></pre><p>时间复杂度是 O(N)。因为需要对新字符串开辟容器，空间复杂度是 O(N)。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function ListNode(val)&#123;</span><br><span class="line">	this.val = val;</span><br><span class="line">	this.next = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="合并两个排序链表"><a href="#合并两个排序链表" class="headerlink" title="合并两个排序链表"></a>合并两个排序链表</h4><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">&gt; 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var mergeTwoLists = function(l1,l2)&#123;</span><br><span class="line">	if(l1 == null)&#123;</span><br><span class="line">		return l2;</span><br><span class="line">	&#125;</span><br><span class="line">	if(l2 == null)&#123;</span><br><span class="line">		return l1;</span><br><span class="line">	&#125;</span><br><span class="line">	if(l1.val &lt; l2.val)&#123;</span><br><span class="line">		l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">		return l1;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">		return l2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除排序列表中的重复元素"><a href="#删除排序列表中的重复元素" class="headerlink" title="删除排序列表中的重复元素"></a>删除排序列表中的重复元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var deleteDuplicates = function(head) &#123;</span><br><span class="line">    let cur = head;</span><br><span class="line">    while(cur &amp;&amp; cur.next)&#123;</span><br><span class="line">        if(cur.val == cur.next.val)&#123;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var reverseList = function(head) &#123;</span><br><span class="line">    let prev = null;</span><br><span class="line">    let curr = head;</span><br><span class="line">    let cnext = null;</span><br><span class="line">    while (curr !== null) &#123;</span><br><span class="line">        cnext = curr.next;</span><br><span class="line">        if (prev === null) &#123;</span><br><span class="line">            curr.next = null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = cnext;</span><br><span class="line">    &#125;</span><br><span class="line">    return prev</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代法</p>
<p>从前到后开始反转，我们需要三个指针，第一个指针指向当前头结点 head，第二个指针指向第二个节点 curP（当前结点）,第三个指针为保存下一个节点的临时节点 temp。</p>
<p>1、反转顺序为，先保存下一节点。</p>
<p>2、然后让当前结点的指向前一节点。</p>
<p>3、最后移动当前结点到下一结点。（head 头节点一开始初始化指向 null）。</p>
<p>4、重复该循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var reverseList = function(head)&#123;</span><br><span class="line">    if(head == null &amp;&amp; head.next)  return head;</span><br><span class="line">    let curNode = head.next;</span><br><span class="line">    head.next = null;</span><br><span class="line">    let temp = null;</span><br><span class="line">    while(curNode != null)&#123;</span><br><span class="line">        temp = curNode.next;</span><br><span class="line">        curNode.next = head;</span><br><span class="line">        head = curNode;</span><br><span class="line">        curNode = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除链表中的值"><a href="#删除链表中的值" class="headerlink" title="删除链表中的值"></a>删除链表中的值</h4><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>注意：此题对比原题有改动</p>
<p>示例 1:</p>
<p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
<p>示例 2:</p>
<p>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.next = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @param &#123;number&#125; val</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> */</span><br><span class="line">var deleteNode = function(head, val) &#123;</span><br><span class="line">    let current = head;</span><br><span class="line">    let prev = null;</span><br><span class="line">    while(current.val != val)&#123;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(current == head)&#123;</span><br><span class="line">        head = current.next;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        prev.next = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h4><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.next = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> */</span><br><span class="line">var getKthFromEnd = function(head, k) &#123;</span><br><span class="line">    let length = 0;</span><br><span class="line">    let current = head;</span><br><span class="line">    let count = 0;</span><br><span class="line">    while(current)&#123;</span><br><span class="line">        length++;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    current = head;</span><br><span class="line">    while(count != length - k)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return current;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<pre><code>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</code></pre><p>示例 1:</p>
<p>给定二叉树 [3,9,20,null,null,15,7]</p>
<pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7</p>
<p>返回 true 。</p>
<p>示例 2:</p>
<p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<pre><code>   1
  / \
 2   2
/ \</code></pre><p>   3   3<br>  / <br> 4   4</p>
<p>返回 false 。</p>
<p>核心思路：<br>1，从左到右递归树的节点，记录节点的最大深度<br>2，在记录节点的同时对该树的节点的左子树与右子树的最大深度做一次对比，如果差值超过1则返回false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">function isNodeBalance(node)&#123;</span><br><span class="line">    if(!node) return 0;</span><br><span class="line">    let left = isNodeBalance(node.left);</span><br><span class="line">    let right = isNodeBalance(node.right);</span><br><span class="line">    if(left &lt; 0 || right &lt; 0)&#123;</span><br><span class="line">        // 短路机制，有一个子树不满足情况就返回</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if(Math.abs(left - right) &gt; 1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return Math.max(left,right) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var isBalanced = function(root)&#123;</span><br><span class="line">    let ret = isNodeBalance(root);</span><br><span class="line">    if(ret &gt;= 0)  return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断B树是否为A的子树"><a href="#判断B树是否为A的子树" class="headerlink" title="判断B树是否为A的子树"></a>判断B树是否为A的子树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; A</span><br><span class="line"> * @param &#123;TreeNode&#125; B</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isSubStructure = function(A, B) &#123;</span><br><span class="line">    // 题目约定：约定空树不是任意一个树的子结构</span><br><span class="line">    if (!A || !B) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        isSubTree(A, B) ||</span><br><span class="line">        isSubStructure(A.left, B) ||</span><br><span class="line">        isSubStructure(A.right, B)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function isSubTree(pRoot1, pRoot2) &#123;</span><br><span class="line">    // B树遍历完了，说明B是A的子结构</span><br><span class="line">    if (!pRoot2) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // A遍历完了，但是B还没有遍历完，那么B肯定不是A的子结构</span><br><span class="line">    if (!pRoot1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (pRoot1.val !== pRoot2.val) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        isSubTree(pRoot1.left, pRoot2.left) &amp;&amp;</span><br><span class="line">        isSubTree(pRoot1.right, pRoot2.right)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="层序遍历二叉树"><a href="#层序遍历二叉树" class="headerlink" title="层序遍历二叉树"></a>层序遍历二叉树</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//层序遍历</span><br><span class="line">   let levelOrderTraversal = function(root)&#123;</span><br><span class="line">       if(!root) return false;   //头节点为空返回false</span><br><span class="line">       let result = [];   //创建一个数组存放结果</span><br><span class="line">       let tree = [];    //创建一个数组存放二叉树</span><br><span class="line">       tree.push(root);    //先传入头节点</span><br><span class="line">       while(tree.length)&#123;       //当tree数组长度不为空</span><br><span class="line">           let node = tree.shift();     //将数组中的第一个节点放到node中</span><br><span class="line">           result.push(node.key);         // 将node节点的值放入result中</span><br><span class="line">           if(node.left)&#123;                 //如果node的左节点不为空，就将左节点压入tree数组中</span><br><span class="line">               tree.push(node.left);</span><br><span class="line">           &#125;</span><br><span class="line">           if(node.right)&#123;                //如果node的右节点不为空，就将左节点压入tree数组中</span><br><span class="line">               tree.push(node.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="之字形遍历"><a href="#之字形遍历" class="headerlink" title="之字形遍历"></a>之字形遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">借助 level 变量标记层数，当 level 为偶数的时候，镜像翻转遍历结果。代码实现如下：</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var levelOrder = function(root) &#123;</span><br><span class="line">    if (!root) return [];</span><br><span class="line">    const queue = [root];</span><br><span class="line">    const res = [];</span><br><span class="line">    let level = 0; // 代表当前层数</span><br><span class="line">    while (queue.length) &#123;</span><br><span class="line">        res[level] = []; // 第level层的遍历结果</span><br><span class="line"></span><br><span class="line">        let levelNum = queue.length; // 第level层的节点数量</span><br><span class="line">        while (levelNum--) &#123;</span><br><span class="line">            const front = queue.shift();</span><br><span class="line">            res[level].push(front.val);</span><br><span class="line">            if (front.left) queue.push(front.left);</span><br><span class="line">            if (front.right) queue.push(front.right);</span><br><span class="line">        &#125;</span><br><span class="line">        // 行号是偶数时，翻转当前层的遍历结果</span><br><span class="line">        if (level % 2) &#123;</span><br><span class="line">            res[level].reverse();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h4><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<pre><code>4</code></pre><p>   /   <br>  2     7<br> / \   / <br>1   3 6   9<br>镜像输出：</p>
<pre><code>4</code></pre><p>   /   <br>  7     2<br> / \   / <br>9   6 3   1</p>
<p>示例 1：</p>
<p>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;TreeNode&#125;</span><br><span class="line"> */</span><br><span class="line">var mirrorTree = function(root) &#123;</span><br><span class="line">    if(!root) return root;</span><br><span class="line"></span><br><span class="line">    // 交换左右节点</span><br><span class="line">    let leftCopy = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = leftCopy;</span><br><span class="line"></span><br><span class="line">    // 对左右节点进行同样的操作</span><br><span class="line">    mirrorTree(root.left);</span><br><span class="line">    mirrorTree(root.right);</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isMirror(root,root);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isMirror = <span class="function"><span class="keyword">function</span>(<span class="params">node1,node2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果两个节点都是null的，势必是对称的</span></span><br><span class="line">    <span class="keyword">if</span>(!node1 &amp;&amp; !node2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果其中一个为null，另一个不为null，则不是对称的</span></span><br><span class="line">    <span class="keyword">if</span>(!node1 || !node2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node1.val == node2.val &amp;&amp; isMirror(node1.left,node2.right) &amp;&amp; isMirror(node1.right,node2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><h4 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h4><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<p>示例 1:</p>
<p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var isMatch = function(s, p) &#123;</span><br><span class="line">    return new RegExp(&quot;^&quot; + p + &quot;$&quot;, &quot;g&quot;).test(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h4><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”及”-1E-16”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var isNumber = function(s) &#123;</span><br><span class="line">    var point = s.match(/\./g);</span><br><span class="line">    if((point &amp;&amp; point.length&gt;1) || !/\d/.test(s))&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    s = s.replace(/^\s*|\s*$/g,&quot;&quot;);   //消除前后空格</span><br><span class="line">    </span><br><span class="line">    if(!/e/i.test(s))&#123;  //不含e的: 正负+整数+点+小数随意搭配 </span><br><span class="line">        return /^[\+\-]?(\d*\.?\d*)$/i.test(s); </span><br><span class="line">    &#125;else&#123;              //含e的: 正负+ (整数+点+小数) 随意搭配 +e+ 正负可带可不带+ 数字一定要带  </span><br><span class="line">        return /^[\+\-]?((\d+\.?\d*)|(\d*\.?\d+))e[\+\-]?\d+$/i.test(s)</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h2><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">实现数组的sort((a,b) =&gt; a-b);</span><br><span class="line">function Bubble_sort(arr)&#123;</span><br><span class="line">let len = arr.length;</span><br><span class="line">	for(let p = len - 1; p &gt;= 0;p--)&#123;</span><br><span class="line">	let flag = 0;    //标记交换</span><br><span class="line">		for(let i = 0; i &lt; p; i++)&#123;   //一趟冒泡</span><br><span class="line">			if(arr[i] &gt; arr[i+1])&#123;</span><br><span class="line">				swap(arr[i],arr[i+1]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag == 0)  break;   //全程无交换</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好情况：顺序 T = O(N)</p>
<p>最坏情况： 逆序 T = O(pow(N,2)) </p>
<h4 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a>从上到下打印二叉树</h4><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7</p>
<p>返回：</p>
<p>[3,9,20,15,7]</p>
<p>提示：</p>
<pre><code>节点总数 &lt;= 1000</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var levelOrder = function(root) &#123;</span><br><span class="line">	//判断是否为空树</span><br><span class="line">    if(!root)&#123;</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line">    let data = [];</span><br><span class="line">    //将头节点放到队列中</span><br><span class="line">    let queue = [root];</span><br><span class="line">    while(queue.length != 0)&#123;</span><br><span class="line">        let first = queue.shift();</span><br><span class="line">        data.push(first.val);</span><br><span class="line">        first.left &amp;&amp; queue.push(first.left);</span><br><span class="line">        first.right &amp;&amp; queue.push(first.right);</span><br><span class="line">    &#125;</span><br><span class="line">    return data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h4 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a>圆圈中最后剩下的数字</h4><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @param &#123;number&#125; m</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var lastRemaining = function(n, m) &#123;</span><br><span class="line">    let ans = 0;</span><br><span class="line">    for(let i = 2; i &lt;= n; i++)&#123;</span><br><span class="line">        ans = (ans + m) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="股票最大利润"><a href="#股票最大利润" class="headerlink" title="股票最大利润"></a>股票最大利润</h4><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<p>示例 1:</p>
<p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p>
<p>示例 2:</p>
<p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; prices</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var maxProfit = function(prices) &#123;</span><br><span class="line">    //此问题的实质就是找到两个差值最大的数，前提是小的在前，大的在后</span><br><span class="line">    //要把此问题的时间复杂度控制在O(n-1)并不难</span><br><span class="line">    let profits = 0;</span><br><span class="line">    let min = prices[0];</span><br><span class="line">    const len = prices.length;</span><br><span class="line">    for(let i = 1; i &lt; len; i ++) &#123;</span><br><span class="line">        min = Math.min(min, prices[i]);</span><br><span class="line">        profits = Math.max(profits, prices[i] - min);</span><br><span class="line">    &#125;</span><br><span class="line">    return profits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="游戏必败问题"><a href="#游戏必败问题" class="headerlink" title="游戏必败问题"></a>游戏必败问题</h4><p>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p>
<p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p>
<p>示例:</p>
<p>输入: 4<br>输出: false<br>解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；<br>     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</p>
<p><strong>Nim 游戏</strong></p>
<p>如果堆中石头的数量 nnn 不能被 444 整除，那么你总是可以赢得 Nim 游戏的胜利。</p>
<p>推理</p>
<p>让我们考虑一些小例子。显而易见的是，如果石头堆中只有一块、两块、或是三块石头，那么在你的回合，你就可以把全部石子拿走，从而在游戏中取胜。而如果就像题目描述那样，堆中恰好有四块石头，你就会失败。因为在这种情况下不管你取走多少石头，总会为你的对手留下几块，使得他可以在游戏中打败你。因此，要想获胜，在你的回合中，必须避免石头堆中的石子数为 4 的情况。</p>
<p>同样地，如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，以确保在再一次轮到你的时候，你会面对四块石头。</p>
<p>显然，它以相同的模式不断重复 n=4,8,12,16,…n=4,8,12,16,\dotsn=4,8,12,16,…，基本可以看出是 4的倍数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var canWinNim = function(n) &#123;</span><br><span class="line">    return !!(n % 4);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="url解析"><a href="#url解析" class="headerlink" title="url解析"></a>url解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function parseUrl(url) &#123;</span><br><span class="line">    let s = url.split(&apos;?&apos;)[0];</span><br><span class="line">    let str = url.split(&apos;?&apos;)[1];</span><br><span class="line">    let items = str.split(&apos;&amp;&apos;);</span><br><span class="line">    let res = &#123;&#125;;</span><br><span class="line">    let result = &#123;&#125;;</span><br><span class="line">    let arr = s.split(&quot;://&quot;);</span><br><span class="line">    result[&apos;protocol&apos;] = arr[0];</span><br><span class="line">    result[&apos;host&apos;] = arr[1].substr(0, arr[1].indexOf(&apos;/&apos;));</span><br><span class="line">    if(arr[1].indexOf(&apos;/&apos;) != arr[1].length - 1)&#123;</span><br><span class="line">        result[&apos;path&apos;] = arr[1].substr(arr[1].indexOf(&apos;/&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0, len = items.length; i &lt; len; ++i) &#123;</span><br><span class="line">        res = items[i].split(&apos;=&apos;);</span><br><span class="line">        result[res[0]] = res[1];</span><br><span class="line">        if(res[1].split(&apos;#&apos;).length &gt; 1)&#123;</span><br><span class="line">            result[res[0]] = res[1].split(&apos;#&apos;)[0];</span><br><span class="line">            result[&apos;hash&apos;] = res[1].split(&apos;#&apos;)[1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return JSON.stringify(result).replace(/\&quot;/g,&quot;&apos;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读取一行输入：read_line()，输出一行：print(something)，注意使用print函数输出时，末尾自动带有换行符，无需自己添加；</strong></p>
<ul>
<li>读取size个字符：gets(size)<br>将读取至多size个字符，当还未达到size个时如果遇到回车或结束符，会提前结束。回车符可能会包含在返回值中。</li>
<li>输出信息：printsth(sth, …)<br>往控制台输出sth，当有多个参数时，空格分隔；最后<strong>不</strong>加回车。</li>
<li>输出一行：print(sth, …) console.error(sth, …) console.debug(sth, …) console.info(sth, …) console.log(sth, …)<br>往控制台输出sth，当有多个参数时，空格分隔；最后加回车。</li>
<li>读取一个（长）整数：readInt()<br>从控制台读取一个（长）整数。</li>
<li>读取一个浮点型：readDouble()<br>从控制台读取一个浮点型。</li>
<li>读取一行输入：read_line()</li>
</ul>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h4 id="模拟-sqrt的整数部分"><a href="#模拟-sqrt的整数部分" class="headerlink" title="模拟 sqrt的整数部分"></a>模拟 sqrt的整数部分</h4><p>计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var mySqrt = function(x)&#123;</span><br><span class="line">	return Math.trunc(Math.sqrt(x));</span><br><span class="line">&#125;</span><br><span class="line">//es6新增的去除一个数的小数部分，</span><br><span class="line">非数值的话会先将其转为数值，</span><br><span class="line">控制和无法截取整数的值，返回NaN</span><br></pre></td></tr></table></figure>

<h4 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a>判断素数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function sushu(n)&#123;</span><br><span class="line">    if(n == 0 || n == 1)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n ==  2)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    for(var i = 2; i &lt;= Math.round(Math.sqrt(n));i++)&#123;</span><br><span class="line">        if(n % i == 0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历n内的素数"><a href="#遍历n内的素数" class="headerlink" title="遍历n内的素数"></a>遍历n内的素数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getSushu(n)&#123;</span><br><span class="line">	//存放素数的数组</span><br><span class="line">	var arr = [];</span><br><span class="line">	for(var i = 2; i &lt; n; i++)&#123;</span><br><span class="line">		if(sushu(i))&#123;</span><br><span class="line">			arr.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(...arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="值加一"><a href="#值加一" class="headerlink" title="值加一"></a>值加一</h4><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>示例 1:</p>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。</p>
<p>示例 2:</p>
<p>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; digits</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> */</span><br><span class="line">var plusOne = function(digits) &#123;</span><br><span class="line">    let str = Number(digits.join(&apos;&apos;)) + 1;</span><br><span class="line">    let arr = str.toString().split(&apos;&apos;);</span><br><span class="line">    return arr;</span><br><span class="line"> &#125;;</span><br><span class="line"> //当数字位达32位及以上时，数值相加有问题</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var plusOne = function(digits) &#123;</span><br><span class="line">    return BigInt(BigInt(digits.join(&apos;&apos;)) + 1n).toString().split(&apos;&apos;)</span><br><span class="line">&#125;;</span><br><span class="line">//利用BigInt解决数字边界问题</span><br><span class="line">//要创建BigInt，只需在整数的末尾追加n即可</span><br></pre></td></tr></table></figure>

<h4 id="递增求和"><a href="#递增求和" class="headerlink" title="递增求和"></a>递增求和</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sumNums = function(n) &#123;</span><br><span class="line">    return (1+n)*n/2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var sumNums = function(n) &#123;</span><br><span class="line">    return multi(n, n+1, 0) &gt;&gt; 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function multi(a, b, sum) &#123;</span><br><span class="line">    if (b === 0) return sum</span><br><span class="line"></span><br><span class="line">    if (b &amp; 1) return multi(a, b-1, sum + a)</span><br><span class="line">    return multi(a + a, b &gt;&gt; 1, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</p>
<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<p>输入：n = 2<br>输出：1</p>
<p>示例 2：</p>
<p>输入：n = 5<br>输出：5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line"> var fib = function(n)&#123;</span><br><span class="line"> 	// 1.非常普通，没有优化的递归</span><br><span class="line"> 	//优点：非常容易想到，fib在不加额外参	  数且不引入外部变量的情况下只能这么调用自身</span><br><span class="line">    //缺点：fib会重复计算之前的项，计算结果是一次性的，极其浪费时间和空间，在本题必定超时，完全无法通过</span><br><span class="line">	/*</span><br><span class="line">	if(n&lt;=1) return n;</span><br><span class="line">	return (fib(n-1) + fib(n-2)) % 1000000007;</span><br><span class="line">	*/</span><br><span class="line">	// 2.普通的尾递归+ES6尾调用优化解法</span><br><span class="line">	// 优点：不创建心得栈帧，现有栈帧被重复利用，不会爆栈，性能比未经优化的递归明显提高</span><br><span class="line">	// 缺点：需要反复清除栈帧的数据，性能不如下面的循环解法。</span><br><span class="line">	/* &apos;use strict&apos;;</span><br><span class="line">	function f(n,a=1,b=1)&#123;</span><br><span class="line">		if(n &lt;= 1) return n;</span><br><span class="line">		if(n == 2) return b;</span><br><span class="line">		return f(n-1,b,(a+b)%100000007);  //最后一步调用自身，将数据处理的步骤变成参数的变化</span><br><span class="line">	&#125;</span><br><span class="line">	return f(n);</span><br><span class="line">	*/</span><br><span class="line">	 //4.很好的循环计算解法</span><br><span class="line"></span><br><span class="line">    //优点：每一次计算结果都能得到利用，易于理解，只保存前两个计算结果，性能最优</span><br><span class="line">    //缺点：没有明显的缺点，在本题中记得看清题目中取模的要求</span><br><span class="line"></span><br><span class="line">    //注：其他题解有提到，但这题不需要用到新的BigInt类型，取模就是为了防止结果溢出，</span><br><span class="line">    //而且中间计算结果也达不到 Number.MAX_SAFE_INTEGER (9007199254740991) 的量级</span><br><span class="line">    //变量c不是必要的，可以直接用代数方法或ES6解构赋值做进一步优化，这种循环解法也可以看做是一种动态规划解法</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        if(n&lt;=1)return n;</span><br><span class="line">        let a=b=1,c=0;</span><br><span class="line">        while(n--&gt;0)&#123;</span><br><span class="line"></span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">            c = (a + b) % 1000000007;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h4><p>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级的台阶总共有多少种跳法？</p>
<p>答题思路</p>
<ol>
<li>如果只有1级台阶，那显然只有一种跳法</li>
<li>如果有2级台阶，那么就有2种跳法，一种是分2次跳。每次跳1级，另一种就是一次跳2级</li>
<li>如果台阶级数大于2，设为n的话，这时我们把n级台阶时的跳法看成n的函数，记为<img src="https://math.jianshu.com/math?formula=f(n)" alt="f(n)">,第一次跳的时候有2种不同的选择：一是第一次跳一级，此时跳法的数目等于后面剩下的n-1级台阶的跳法数目，即为<img src="https://math.jianshu.com/math?formula=f(n-1)" alt="f(n-1)">,二是第一次跳二级，此时跳法的数目等于后面剩下的n-2级台阶的跳法数目，即为<img src="https://math.jianshu.com/math?formula=f(n-2)" alt="f(n-2)">,因此n级台阶的不同跳法的总数为<img src="https://math.jianshu.com/math?formula=f(n)%20%3D%20f(n-1)%20%2B%20f(n-2)" alt="f(n) = f(n-1) + f(n-2)">，不难看出就是斐波那契数列</li>
</ol>
<p>数学函数表示如下<img src="https://math.jianshu.com/math?formula=f(x)%3D%5Cleft%5C%7B%20%5Cbegin%7Baligned%7D%20%26%200%20%26%20n%3D0%20%5C%5C%20%26%201%20%26%20n%3D1%20%5C%5C%20%26%202%20%26%20n%3D2%20%5C%5C%20%26%20f(n-1)%2Bf(n-2)%20%26%20n%20%3E%202%20%5Cend%7Baligned%7D%20%5Cright." alt="f(x)=\left\{ \begin{aligned} &amp; 0 &amp; n=0 \\ &amp; 1 &amp; n=1 \\ &amp; 2 &amp; n=2 \\ &amp; f(n-1)+f(n-2) &amp; n &gt; 2 \end{aligned} \right."></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numWays = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( n&lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">let</span> dp = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">const</span> ModNum = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">		dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]) % ModNum;</span><br><span class="line">	&#125;nx</span><br><span class="line">	<span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2020/06/23/‘力扣简单题’/">‘力扣简单题’</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">陈楚吟</a></p>
        <p><span>发布时间:</span>2020-06-23, 15:43:03</p>
        <p><span>最后更新:</span>2020-07-07, 22:05:51</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2020/06/23/‘力扣简单题’/" title="‘力扣简单题’">http://yoursite.com/2020/06/23/‘力扣简单题’/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2020/06/23/‘力扣简单题’/　　作者: 陈楚吟" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2020/06/23/数组中的reduce/">
                    数组中的reduce
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2020/06/20/vue小技巧/">
                    vue小技巧
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数组取交集"><span class="toc-number">1.0.1.</span> <span class="toc-text">数组取交集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组取差集"><span class="toc-number">1.0.2.</span> <span class="toc-text">数组取差集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组转对象"><span class="toc-number">1.0.3.</span> <span class="toc-text">数组转对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组摊平"><span class="toc-number">1.0.4.</span> <span class="toc-text">数组摊平</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组去重"><span class="toc-number">1.0.5.</span> <span class="toc-text">数组去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组移除元素"><span class="toc-number">1.0.6.</span> <span class="toc-text">数组移除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#移除数组中的元素"><span class="toc-number">1.0.7.</span> <span class="toc-text">移除数组中的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组搜索插入位置"><span class="toc-number">1.0.8.</span> <span class="toc-text">数组搜索插入位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#合并两个数组"><span class="toc-number">1.0.9.</span> <span class="toc-text">合并两个数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#和为s的两个数字"><span class="toc-number">1.0.10.</span> <span class="toc-text">和为s的两个数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#和为s的连续正数序列"><span class="toc-number">1.0.11.</span> <span class="toc-text">和为s的连续正数序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最大子序和"><span class="toc-number">1.0.12.</span> <span class="toc-text">最大子序和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#滑动窗口最大值"><span class="toc-number">1.0.13.</span> <span class="toc-text">滑动窗口最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#旋转数组"><span class="toc-number">1.0.14.</span> <span class="toc-text">旋转数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符异位词分组"><span class="toc-number">1.0.15.</span> <span class="toc-text">字符异位词分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#罗马数字转整数"><span class="toc-number">1.0.16.</span> <span class="toc-text">罗马数字转整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组中重复数字"><span class="toc-number">1.0.17.</span> <span class="toc-text">数组中重复数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二维数组的查找"><span class="toc-number">1.0.18.</span> <span class="toc-text">二维数组的查找</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-number">2.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串数组中的最长公共前缀"><span class="toc-number">2.0.1.</span> <span class="toc-text">字符串数组中的最长公共前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有效字符串"><span class="toc-number">2.0.2.</span> <span class="toc-text">有效字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串中找最大数字"><span class="toc-number">2.0.3.</span> <span class="toc-text">字符串中找最大数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最后一个单词的长度"><span class="toc-number">2.0.4.</span> <span class="toc-text">最后一个单词的长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#翻转单词顺序"><span class="toc-number">2.0.5.</span> <span class="toc-text">翻转单词顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#颠倒二进制"><span class="toc-number">2.0.6.</span> <span class="toc-text">颠倒二进制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#替换空格"><span class="toc-number">2.0.7.</span> <span class="toc-text">替换空格</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表"><span class="toc-number">3.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#合并两个排序链表"><span class="toc-number">3.0.1.</span> <span class="toc-text">合并两个排序链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除排序列表中的重复元素"><span class="toc-number">3.0.2.</span> <span class="toc-text">删除排序列表中的重复元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反转链表"><span class="toc-number">3.0.3.</span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除链表中的值"><span class="toc-number">3.0.4.</span> <span class="toc-text">删除链表中的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链表中倒数第k个节点"><span class="toc-number">3.0.5.</span> <span class="toc-text">链表中倒数第k个节点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树"><span class="toc-number">4.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#平衡二叉树"><span class="toc-number">4.0.1.</span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#判断B树是否为A的子树"><span class="toc-number">4.0.2.</span> <span class="toc-text">判断B树是否为A的子树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#层序遍历二叉树"><span class="toc-number">4.0.3.</span> <span class="toc-text">层序遍历二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#之字形遍历"><span class="toc-number">4.0.4.</span> <span class="toc-text">之字形遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉树的镜像"><span class="toc-number">4.0.5.</span> <span class="toc-text">二叉树的镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对称的二叉树"><span class="toc-number">4.0.6.</span> <span class="toc-text">对称的二叉树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正则"><span class="toc-number">5.</span> <span class="toc-text">正则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#正则表达式匹配"><span class="toc-number">5.0.1.</span> <span class="toc-text">正则表达式匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#表示数值的字符串"><span class="toc-number">5.0.2.</span> <span class="toc-text">表示数值的字符串</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简单排序"><span class="toc-number">6.</span> <span class="toc-text">简单排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#冒泡排序"><span class="toc-number">6.0.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从上到下打印二叉树"><span class="toc-number">6.0.2.</span> <span class="toc-text">从上到下打印二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他"><span class="toc-number">6.0.3.</span> <span class="toc-text">其他</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#圆圈中最后剩下的数字"><span class="toc-number">6.0.4.</span> <span class="toc-text">圆圈中最后剩下的数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#股票最大利润"><span class="toc-number">6.0.5.</span> <span class="toc-text">股票最大利润</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#游戏必败问题"><span class="toc-number">6.0.6.</span> <span class="toc-text">游戏必败问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#url解析"><span class="toc-number">6.0.7.</span> <span class="toc-text">url解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math"><span class="toc-number">7.</span> <span class="toc-text">Math</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#模拟-sqrt的整数部分"><span class="toc-number">7.0.1.</span> <span class="toc-text">模拟 sqrt的整数部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#判断素数"><span class="toc-number">7.0.2.</span> <span class="toc-text">判断素数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#遍历n内的素数"><span class="toc-number">7.0.3.</span> <span class="toc-text">遍历n内的素数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#值加一"><span class="toc-number">7.0.4.</span> <span class="toc-text">值加一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#递增求和"><span class="toc-number">7.0.5.</span> <span class="toc-text">递增求和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#斐波那契数列"><span class="toc-number">7.0.6.</span> <span class="toc-text">斐波那契数列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#青蛙跳台阶问题"><span class="toc-number">7.0.7.</span> <span class="toc-text">青蛙跳台阶问题</span></a></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"‘力扣简单题’　| Nikita　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2020/06/23/数组中的reduce/" title="上一篇: 数组中的reduce">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2020/06/20/vue小技巧/" title="下一篇: vue小技巧">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/07/26/项目中的业务需求/">项目中的业务需求</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/26/js中的Blod对象/">js中的Blod对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/25/vue中的插槽slot/">vue中的插槽slot</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/19/vue-config-js配置文件详解/">vue.config.js配置文件详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/10/代理/">代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/09/浏览器发请求的几种方式/">浏览器发请求的几种方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/html技巧/">html技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/26/js技巧/">js技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/25/css技术技巧/">css技术技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/数组中的reduce/">数组中的reduce</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/‘力扣简单题’/">‘力扣简单题’</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/vue小技巧/">vue小技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/vue的面试/">vue的面试</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/18/学习vuex/">学习vuex</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/同源策略/">同源策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/typescript/">typescript</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/jquery/">jquery</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/js动画篇/">js动画篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/js精研/">js精研</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/js基础/">js基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/刷题笔记/">刷题笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/11/前端cookie解读/">前端cookie解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/04/前端经验/">前端经验</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/22/linux学习/">linux学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/10/pandas之excel/">pandas之excel</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/09/HTML5和CSS3/">HTML5和CSS3</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/08/爬虫/">爬虫</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/07/python的学习/">python的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/30/AJAX学习/">AJAX学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/30/node进阶/">node进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/30/http进阶/">http进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/ES6的学习/">ES6的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/vue学习中的问题/">vue学习中的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/27/计算机网络/">计算机网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/27/数据结构与算法/">数据结构与算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/07/前端面试/">前端面试</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/06/http的学习/">http的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/课程表制作/">课程表制作</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/CSS3/">CSS3</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/Grid布局/">Grid布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/CSS3高阶/">CSS3高阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/HTML5基础下-陈楚吟/">HTML5基础下--陈楚吟</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/HTML5基础上-陈楚吟/">HTML5基础上-陈楚吟</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/深入理解css/">深入理解css</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/选择器/">选择器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/vue学习三/">vue学习三</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/vue学习二/">vue学习二</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/vue学习一/">vue学习一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/浅谈canvas和相关实战/">浅谈canvas和相关实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/setTimeout与setInterval区别/">setTimeout与setInterval区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/js中callee和caller/">js中callee和caller</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/行内元素存在间距问题/">行内元素存在间距问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/09/canvas绘制碰撞球动画/">canvas绘制碰撞球动画</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/27/用JavaScript封装栈/">用JavaScript封装栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/26/伪类与伪元素的区区别/">伪类与伪元素的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/17/深入理解包与NPM和package-json深入解读/">深入理解包与NPMM,package.json深入解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/15/JS中外部文件的优势-1/">JS中外部文件的优势</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/03/vue进阶/">vue进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/27/webpack学习/">webpack学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/15/攻克object对象/">攻克object对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/15/qq小程序天坑之旅/">qq小程序天坑之旅</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/27/proto/">proto</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/26/项目开发流程/">项目开发流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/25/事件机制/">事件机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/17/MVVC模型架构/">MVVC模型架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/15/js执行上下文/">js执行上下文</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/15/js中的立即执行函数/">js中的立即执行函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/14/js中的闭包/">js中的闭包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/14/了解浏览器/">了解浏览器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/13/我认识的js原型及原型链/">我认识的js原型及原型链</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/12/深入理解js中的this/">深入理解js中的this</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/12/相对全面的数组/">相对全面的数组去重</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/11/css盒模型集锦/">css盒模型集锦</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 陈楚吟
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="陈楚吟">



<meta name="description" content="在线工具库：https://123.w3cschool.cn/webtools 一 . js简介1.概念 javascript是世界上最流行的脚本语言。js是属于web的语言，他适合与PC，笔记本电脑，平板电脑和移动电话。ja被设计成向HTNL页面增加交互性。 脚本语言：指的是他不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”   通过嵌入HTML来实现各种酷炫">
<meta name="keywords" content="write myBlog">
<meta property="og:type" content="article">
<meta property="og:title" content="js基础">
<meta property="og:url" content="http://yoursite.com/2020/06/17/js基础/index.html">
<meta property="og:site_name" content="Nikita">
<meta property="og:description" content="在线工具库：https://123.w3cschool.cn/webtools 一 . js简介1.概念 javascript是世界上最流行的脚本语言。js是属于web的语言，他适合与PC，笔记本电脑，平板电脑和移动电话。ja被设计成向HTNL页面增加交互性。 脚本语言：指的是他不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”   通过嵌入HTML来实现各种酷炫">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://7n.w3cschool.cn/statics/images/course/pic_htmltree.gif">
<meta property="og:image" content="https://7n.w3cschool.cn/attachments/image/20160809/1470709730442234.gif">
<meta property="og:image" content="https://7n.w3cschool.cn/attachments/image/20160809/1470710444592947.gif">
<meta property="og:image" content="https://7n.w3cschool.cn/statics/images/course/pic_htmltree.gif">
<meta property="og:image" content="https://7n.w3cschool.cn/attachments/image/20160809/1470709730442234.gif">
<meta property="og:image" content="https://7n.w3cschool.cn/attachments/image/20160809/1470710444592947.gif">
<meta property="og:image" content="https://7n.w3cschool.cn/statics/images/course/pic_htmltree.gif">
<meta property="og:image" content="https://7n.w3cschool.cn/attachments/image/20160809/1470709730442234.gif">
<meta property="og:image" content="https://7n.w3cschool.cn/attachments/image/20160809/1470710444592947.gif">
<meta property="og:updated_time" content="2020-06-17T07:17:23.957Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="js基础">
<meta name="twitter:description" content="在线工具库：https://123.w3cschool.cn/webtools 一 . js简介1.概念 javascript是世界上最流行的脚本语言。js是属于web的语言，他适合与PC，笔记本电脑，平板电脑和移动电话。ja被设计成向HTNL页面增加交互性。 脚本语言：指的是他不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”   通过嵌入HTML来实现各种酷炫">
<meta name="twitter:image" content="https://7n.w3cschool.cn/statics/images/course/pic_htmltree.gif">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Nikita" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>js基础 | Nikita</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">陈楚吟</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不负韶华</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">陈楚吟</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">陈楚吟</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不负韶华</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-js基础" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/17/js基础/" class="article-date">
      <time datetime="2020-06-17T07:14:31.000Z" itemprop="datePublished">2020-06-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      js基础
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在线工具库：<a href="https://123.w3cschool.cn/webtools" target="_blank" rel="noopener">https://123.w3cschool.cn/webtools</a></p>
<h2 id="一-js简介"><a href="#一-js简介" class="headerlink" title="一 . js简介"></a>一 . js简介</h2><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><ul>
<li>javascript是<strong>世界上最流行的脚本语言</strong>。js是属于web的语言，他适合与PC，笔记本电脑，平板电脑和移动电话。ja被设计成向HTNL页面增加交互性。<ul>
<li>脚本语言：指的是他不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”</li>
</ul>
</li>
<li>通过嵌入HTML来实现各种酷炫的动态效果，为用户提供赏心悦目的浏览效果。所有现代的 HTML 页面都使用 JavaScript，可以用于改进设计、验证表单、检测浏览器、创建cookies等。</li>
<li>javaScript 是一种轻量级的编程语言。JavaScript 是可插入 HTML 页面的编程代码。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</li>
<li>javascript也是一种<strong>嵌入式（embedded）语言</strong>。它本身提供的核心语法不算很多，只是用来做一些数学和逻辑运算。js本身不提供任何与I/O(输入/输出）相关的API，主要靠宿主环境（host）提供，所以js只适合嵌入更大型的应用程序环境，去调用宿主环境提供的底层API。目前，已经嵌入JavaScript的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是Node项目</li>
<li>从语法角度看，javascript语言是一种“对象模型”语言。各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过js控制这些功能。但是，js并不是纯粹的“面型对象语言”，还支持其他编程范式（比如函数式编程）</li>
</ul>
<h4 id="2-支持编译运行。"><a href="#2-支持编译运行。" class="headerlink" title="2.支持编译运行。"></a>2.<strong>支持编译运行。</strong></h4><ul>
<li>JavaScript 语言本身，虽然是一种解释型语言，但是在现代浏览器中，JavaScript 都是编译后运行。程序会被高度优化，运行效率接近二进制程序。而且，JavaScript 引擎正在快速发展，性能将越来越好。</li>
<li>此外，还有一种 WebAssembly 格式，它是 JavaScript 引擎的中间码格式，全部都是二进制代码。由于跳过了编译步骤，可以达到接近原生二进制代码的运行速度。各种语言（主要是 C 和 C++）通过编译成 WebAssembly，就可以在浏览器里面运行。</li>
</ul>
<h4 id="3-事件驱动和非阻塞式设计"><a href="#3-事件驱动和非阻塞式设计" class="headerlink" title="3.事件驱动和非阻塞式设计"></a>3.事件驱动和非阻塞式设计</h4><ul>
<li>JavaScript 程序可以采用事件驱动（event-driven）和非阻塞式（non-blocking）设计，在服务器端适合高并发环境，普通的硬件就可以承受很大的访问量。</li>
</ul>
<h4 id="4-javascript与java的关系"><a href="#4-javascript与java的关系" class="headerlink" title="4.javascript与java的关系"></a>4.javascript与java的关系</h4><table>
<thead>
<tr>
<th>Java</th>
<th>javascript</th>
</tr>
</thead>
<tbody><tr>
<td>强类型</td>
<td>弱类型（同一变量可以存放不同类型的变量（但是始终存放同一类型是良好的编码习惯）</td>
</tr>
</tbody></table>
<p>必须在JAVA虚拟机上运行，且事先需要进行编译    不依托编辑器，在浏览器就可以实现，边解释边执行</p>
<h2 id="二-输出"><a href="#二-输出" class="headerlink" title="二 . 输出"></a>二 . 输出</h2><h4 id="1-直接写入HTML输出流"><a href="#1-直接写入HTML输出流" class="headerlink" title="1.直接写入HTML输出流"></a>1.直接写入HTML输出流</h4><p>document.write(“输出内容”);  将内容写入HTML<strong>文档</strong>中</p>
<ul>
<li>你只能在HTNL输出中使用document.write。如果在文档加载完成后使用该方法，会覆盖整个文档。</li>
</ul>
<h4 id="2-弹出警告框alert"><a href="#2-弹出警告框alert" class="headerlink" title="2.弹出警告框alert"></a>2.弹出警告框alert</h4><p>window.alert（“输出内容”）；</p>
<h4 id="3-在指定位置输出innerHTML"><a href="#3-在指定位置输出innerHTML" class="headerlink" title="3.在指定位置输出innerHTML"></a>3.在指定位置输出innerHTML</h4><p>var  x=document.getElementById(“id名”)；//使用id属性查找元素</p>
<p>x.innerHTML=”输出内容”;//改变内容，写入到HTML<strong>元素</strong></p>
<h4 id="4-在控制台上输出"><a href="#4-在控制台上输出" class="headerlink" title="4.在控制台上输出"></a>4.在控制台上输出</h4><p>console.log(‘输出内容’)；</p>
<p>1、console.log 用于输出普通信息</p>
<p>2、console.info 用于输出提示性信息</p>
<p>3、console.error用于输出错误信息</p>
<p>4、console.warn用于输出警示信息</p>
<p>5、console.debug用于输出调试信息</p>
<p>可以通过在控制台输入console.clear()来实现清空控制台信息。</p>
<p><a href="https://jingyan.baidu.com/article/6dad507505f714a123e36e8a.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/6dad507505f714a123e36e8a.html</a></p>
<h2 id="三-js基本语法"><a href="#三-js基本语法" class="headerlink" title="三 . js基本语法"></a>三 . js基本语法</h2><h4 id="1-语句"><a href="#1-语句" class="headerlink" title="1.语句"></a>1.语句</h4><ul>
<li>js程序执行单位为行，也就是一行一行地执行一般，每一行就是一个语句。语句是为了完成某种任务而进行的操作（赋值语句），语句以分号结束，分号前没有任何内容，js引擎将其视为空语句</li>
<li>表达式（需要得出结果）不需要分号结尾，不然js引擎会将其视为语句，这样会产生一些没有意义的语句</li>
</ul>
<h4 id="2-js用法"><a href="#2-js用法" class="headerlink" title="2.js用法"></a>2.js用法</h4><ul>
<li>HTML脚本必须位于<script>和</script>标签之间，脚本可放置在body或head标签中</li>
<li>如需在HTML页面中插入脚本，请使用script标签，他会告诉js在何处开始和结束</li>
<li>引入外部脚本<script src></script></li>
</ul>
<h5 id="js区分大小写"><a href="#js区分大小写" class="headerlink" title="js区分大小写"></a>js区分大小写</h5><h4 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h4><ul>
<li>局部变量不声明变量，即不写var，会自动创建全局变量；如果使用<code>var</code>重新声明一个已经存在的变量，是无效的。但第二次声明的时候还进行了赋值，则会覆盖掉前面的值。</li>
<li>如果一个变量没有声明就直接使用，js会报错，告诉你变量未定义</li>
<li>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</li>
<li>变量是一个名称，字面量是一个值</li>
<li>JavaScript 标识符必须以字母、下划线（_）或美元符（$）开始。后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的，以便 JavaScript 可以轻易区分开标识符和数字）。</li>
<li>undefined：声明变量却没赋值的变量，表示“无定义”</li>
<li>单行用   / /   注释，多行注释用 /*   */ </li>
<li>当您向变量分配文本值时，应该用双引号或单引号包围这个值。当您向变量赋的值是数值时，不要使用引号。如果您用引号包围数值，该值会被作为文本来处理。</li>
</ul>
<h5 id="1-变量类型"><a href="#1-变量类型" class="headerlink" title="1 .变量类型"></a>1 .变量类型</h5><ul>
<li>值类型<ul>
<li>占用空间固定，保存在栈中</li>
<li>保存复制的是值本身</li>
<li>使用typeof检测数据的类型</li>
<li>基本类型数据是值类型</li>
</ul>
</li>
<li>引用类型<ul>
<li>占用空间不固定，保存在堆中</li>
<li>保存和复制的是指向对象的一个指针</li>
<li>使用instanceof检测数据的类型</li>
<li>使用new（）方法构造出来的对象是引用型的</li>
</ul>
</li>
</ul>
<h5 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2.作用域"></a>2.作用域</h5><ul>
<li>全局变量<ul>
<li>在函数体外定义的变量或者在函数体内部定义的无var的变量</li>
<li>在任何位置都可以调用</li>
</ul>
</li>
<li>局部变量<ul>
<li>在函数体内部用var声明的变量或函数的参数变量</li>
<li>在当前函数体内部调用</li>
</ul>
</li>
<li>优先级<ul>
<li>同名全局变量 &gt; 参数变量 &gt; 局部变量 &gt; 全局变量</li>
</ul>
</li>
<li>特性<ul>
<li>忽略块级作用域</li>
<li>全局变量是全局对象的属性</li>
<li>局部变量是调用对象的属性</li>
<li>作用域链<ul>
<li>内层函数可以访问外层函数的局部变量</li>
<li>外层函数不能访问内层函数局部变量</li>
</ul>
</li>
<li>生命周期<ul>
<li>全局变量：除非被显示删除，否则一直存在</li>
<li>局部变量：自声明起至函数运行完毕或者显示删除</li>
<li>收回机制<ul>
<li>标记清除，引用计数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4.数据类型"></a>4.数据类型</h4><h5 id="1-数字-Number"><a href="#1-数字-Number" class="headerlink" title="1.数字 Number"></a>1.数字 Number</h5><h5 id="2-字符串String"><a href="#2-字符串String" class="headerlink" title="2.字符串String"></a>2.字符串String</h5><ul>
<li><p>由0个或多个16位Unicode字符组成</p>
</li>
<li><p>单引号与双引号不能交叉使用</p>
</li>
<li><p>使用length属性访问字符串长度</p>
<ul>
<li>转义字符算一个字符</li>
<li>无法精确返回双字节字符长度</li>
</ul>
</li>
<li><p>字符串一旦被创建，其值将不能修改，若要改变必须销毁原有字符串</p>
</li>
<li><p>不要创建 String 对象。它会拖慢执行速度，并可能产生其他副作用</p>
</li>
<li><p>类型转换</p>
<ul>
<li><p>toString（）使用类型</p>
<p>​     1.number</p>
<p>​     2.boolean</p>
<p>​     3.string</p>
<p>​     4.object</p>
</li>
<li><p>eval()：计算字符串表达式的值并以数值形式返回</p>
</li>
</ul>
</li>
</ul>
<h5 id="3-布尔Boolean"><a href="#3-布尔Boolean" class="headerlink" title="3.布尔Boolean"></a>3.布尔Boolean</h5><ul>
<li><p>任何值和布尔值比较时，<strong>两边都会转化为Number类型</strong></p>
</li>
<li><p>[0]用if判断的时候为true，和布尔值比较的时候转换为0。{x:0}用if判断的时候为true，和布尔值比较的时候转换为NaN</p>
</li>
<li><p>转换为true</p>
<ul>
<li>任何非空字符串</li>
<li>任何非0的数值</li>
<li>数组和对象（包括空数组和空对象）</li>
</ul>
</li>
<li><p>转换为false</p>
<ul>
<li>空字符串</li>
<li>0和NaN</li>
<li>null和undefined</li>
</ul>
</li>
</ul>
<h5 id="4-数组Array"><a href="#4-数组Array" class="headerlink" title="4.数组Array"></a>4.数组Array</h5><ul>
<li><p>对象Object</p>
</li>
<li><p>空Null</p>
<ul>
<li>逻辑上null表示一个空对象的指针，使用typeof检测时会返回object</li>
</ul>
</li>
<li><p>未定义Undefined</p>
<ul>
<li>使用var声明变量但未初始化</li>
<li>区分空对象指针与尚未定义的变量</li>
<li>对未初始化的变量及未声明的变量使用typeof运算符均会返回undefined</li>
</ul>
</li>
<li><h5 id="undefined与null的关系"><a href="#undefined与null的关系" class="headerlink" title="undefined与null的关系"></a>undefined与null的关系</h5><ul>
<li>undefined派生于null因此在使用“==”进行比较的时候会返回true</li>
<li>没有必要将变量值声明为undefined</li>
<li>声明空对象的时候应将其值赋值为null</li>
</ul>
</li>
</ul>
<h5 id="5-非数值NaN-Not-a-Number"><a href="#5-非数值NaN-Not-a-Number" class="headerlink" title="5.非数值NaN(Not a Number)"></a>5.非数值NaN(Not a Number)</h5><ul>
<li><p>任何涉及NaN的操作都将返回NaN</p>
</li>
<li><h6 id="NaN与任何数值都不相等包括自身"><a href="#NaN与任何数值都不相等包括自身" class="headerlink" title="NaN与任何数值都不相等包括自身"></a>NaN与任何数值都不相等包括自身</h6></li>
<li><p>检测isNaN（）</p>
<ul>
<li>可转换成数值false</li>
<li>不可转换成数值true</li>
</ul>
</li>
</ul>
<h5 id="6-未定义undefined"><a href="#6-未定义undefined" class="headerlink" title="6.未定义undefined"></a>6.未定义undefined</h5><ul>
<li>变量声明了却没有赋值</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于undefined</li>
<li>对象没有赋值的属性</li>
<li>函数没有返回值，默认返回undefined</li>
</ul>
<h4 id="5-数值转换"><a href="#5-数值转换" class="headerlink" title="5.数值转换"></a>5.数值转换</h4><h5 id="1-Number"><a href="#1-Number" class="headerlink" title="1.Number()"></a>1.Number()</h5><ul>
<li>Boolean——(true  1)(false  0)</li>
<li>null——0</li>
<li>undefined / { }———NaN    (<code>null</code>是一个表示”无”的对象，转为数值时为<code>0</code>；<code>undefined</code>是一个表示”无”的原始值，转为数值时为<code>NaN</code>)</li>
<li>String除数字和空字符串（0）外，其余都是NaN</li>
</ul>
<h5 id="2-解析parseInt（“要解析的字符串”，转换时使用的基数）"><a href="#2-解析parseInt（“要解析的字符串”，转换时使用的基数）" class="headerlink" title="2.解析parseInt（“要解析的字符串”，转换时使用的基数）"></a>2.解析parseInt（“要解析的字符串”，转换时使用的基数）</h5><ul>
<li>忽略前置空格</li>
<li>直接找到第一个非空格字符<ul>
<li>NaN：不是数字字符或符号</li>
<li>如果是数字字符解析所有后续字符，或一直解析直到遇到非数字字符便结束</li>
</ul>
</li>
</ul>
<h5 id="3-parseFloat（）"><a href="#3-parseFloat（）" class="headerlink" title="3.parseFloat（）"></a>3.parseFloat（）</h5><ul>
<li>从第一个字符开始解析，遇到无效浮点格式后结束</li>
<li>只有第一个小数点有效，忽略前导0</li>
<li>十六进制数始终为0，没有小数点或小数点后全0</li>
</ul>
<h4 id="6-对象object"><a href="#6-对象object" class="headerlink" title="6.对象object"></a>6.对象object</h4><ul>
<li>一组数据或功能的集合</li>
<li>声明 var  o=new Object（）</li>
<li>属性和方法<ul>
<li>Constructor：保存用于创建当前对象的函数</li>
<li>hasOwnProperty（propertyName）：检测给定属性在当前对象实例中是否存在</li>
<li>isPrototypeOf（object）检测传入的对象是否为另一个对象的原型</li>
<li>propertyisEnumerable（propertyName）检测给定属性是否能用for-in语句枚举</li>
<li>toLocalString（）返回对象的字符串表示，该字符串与执行环境的地区对应</li>
<li>toString（）返回对象的字符串表示</li>
<li>valueOf（）返回对象的字符串，数值或布尔值表示；通常和toString（）的值相同</li>
</ul>
</li>
</ul>
<h5 id="https-blog-csdn-net-IT-10-article-details-81806665"><a href="#https-blog-csdn-net-IT-10-article-details-81806665" class="headerlink" title="https://blog.csdn.net/IT_10/article/details/81806665"></a><a href="https://blog.csdn.net/IT_10/article/details/81806665" target="_blank" rel="noopener">https://blog.csdn.net/IT_10/article/details/81806665</a></h5><h2 id="四-数据类型的概述"><a href="#四-数据类型的概述" class="headerlink" title="四 . 数据类型的概述"></a>四 . 数据类型的概述</h2><h4 id="1-六大数据类型（number-string-boolean-undefined-null-onject"><a href="#1-六大数据类型（number-string-boolean-undefined-null-onject" class="headerlink" title="1.六大数据类型（number,string,boolean,undefined,null,onject)"></a>1.六大数据类型（number,string,boolean,undefined,null,onject)</h4><ul>
<li>原始类型（primitive type）<ul>
<li>不能再细分，最基本的数据类型</li>
<li>number，string，boolean</li>
</ul>
</li>
<li>合成类型（complex type）<ul>
<li>可看作一个存放多个原始类型值的容器</li>
<li>狭义对象（object），数组（array），函数（function）</li>
</ul>
</li>
<li>undefined和null一般将他们看成两个特殊值</li>
<li>狭义的对象（object）和数组是两种不同的数据组合方式，而函数其实是处理数据的方法。js把函数当成一种数据类型，可以像其他类型的数据一样，进行赋值和传递，这为编程带来了很大的灵活性，体现了js作为“函数式语言”的本质</li>
<li>js的所有数据都可以视为广义的对象。不仅数组和函数属于对象，就连原始值也可用对象方式调用，（不过都是隐式转换，就像输入数值都会隐式转换成字符串数值一样）</li>
</ul>
<h4 id="2-确定值是什么类型的几种方法"><a href="#2-确定值是什么类型的几种方法" class="headerlink" title="2.确定值是什么类型的几种方法"></a>2.确定值是什么类型的几种方法</h4><h6 id="1-typeof运算符"><a href="#1-typeof运算符" class="headerlink" title="1.typeof运算符"></a>1.typeof运算符</h6><ul>
<li>typeof 123     //“number”</li>
<li>typeof  ‘123’   //“string”</li>
<li>typeof   false  //“boolean”</li>
<li>function  f（）{}  typeof  f   //“function”</li>
<li>typeof   undefined   //“undefined”（利用这一点，可用来检查一个没有申明的变量而不报错）</li>
<li>typeof   window / { } / [ ]  / null    //“object”（表明数组本质上只是一种特殊的对象。<code>null</code>的类型也是<code>object</code>，这是由于历史原因造成的）</li>
</ul>
<h6 id="2-instanceof运算符"><a href="#2-instanceof运算符" class="headerlink" title="2.instanceof运算符"></a>2.instanceof运算符</h6><ul>
<li>解决typeof没法区分数组和对象的缺陷</li>
<li>{}/[] instanceof  Object/Array     //true</li>
<li>(function(0{}))   instanceof  Function     //true</li>
<li>原始类型   instanceof    各种类型     //一般都是false</li>
</ul>
<h6 id="3-Object-prototype-toString方法"><a href="#3-Object-prototype-toString方法" class="headerlink" title="3.Object.prototype.toString方法"></a>3.Object.prototype.toString方法</h6><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call([1,2,3])</span><br><span class="line">   &apos;[object Array]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="4-应用typeof方法写方法"><a href="#4-应用typeof方法写方法" class="headerlink" title="4.应用typeof方法写方法"></a>4.应用typeof方法写方法</h6><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var toType = function(obj) &#123;</span><br><span class="line">   return (&#123;&#125;).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">toType(&#123;a: 4&#125;) // &quot;object&quot;</span><br><span class="line">   toType([1, 2, 3]) // &quot;array&quot;</span><br><span class="line">   (function() &#123; return toType(arguments) &#125;()) // &quot;arguments&quot;</span><br><span class="line">   toType(new ReferenceError()) // &quot;error&quot;</span><br><span class="line">   toType(new Date()) // &quot;date&quot;</span><br><span class="line">   toType(/a-z/) // &quot;regexp&quot;</span><br><span class="line">   toType(Math) // &quot;math&quot;</span><br><span class="line">   toType(JSON) // &quot;json&quot;</span><br><span class="line">   toType(new Number(4)) // &quot;number&quot;</span><br><span class="line">   toType(new String(&quot;abc&quot;)) // &quot;string&quot;</span><br><span class="line">   toType(new Boolean(true)) // &quot;boolean&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2011/11/improving-typeof.html" target="_blank" rel="noopener">Improving the JavaScript typeof operator</a></li>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2013/01/categorizing-values.html" target="_blank" rel="noopener">Categorizing values in JavaScript</a></li>
</ul>
<h2 id="五-JavaScript函数"><a href="#五-JavaScript函数" class="headerlink" title="五 . JavaScript函数"></a>五 . JavaScript函数</h2><h4 id="1-定义方法"><a href="#1-定义方法" class="headerlink" title="1.定义方法"></a>1.定义方法</h4><ul>
<li>静态方法function function nane（){执行代码}</li>
<li>动态匿名方法  var 函数名=new Function([“虚参数列表”]，“函数体”)；</li>
<li>直接量方法  函数名=function（【虚参列表】）{函数体}</li>
</ul>
<h4 id="2-调用方法"><a href="#2-调用方法" class="headerlink" title="2.调用方法"></a>2.调用方法</h4><ul>
<li><p>函数作为对象方法调用，会使得 <strong>this</strong> 的值成为对象本身。</p>
</li>
<li><p><strong>call()</strong>（传入的参数是一系列的参数值，但是从第二个参数开始） 和 <strong>apply()</strong> （传入的参数只能是由各参数值组成的数组）是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身。</p>
</li>
<li><p>在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 <strong>this</strong> 的值， 即使该参数不是一个对象。</p>
</li>
<li><p>在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。</p>
</li>
<li><p>在 HTML 中默认的全局对象是 HTML 页面本身，所以函数是属于 HTML 页面。</p>
</li>
<li><p>在浏览器中的页面对象是浏览器窗口(window 对象)。以上函数会自动变为 window 对象的函数。</p>
</li>
<li><p>直接调用    函数名（实参列表）</p>
</li>
<li><p>在连接中调用   <a href="javascript:函数名()" target="_blank" rel="noopener"></a></p>
</li>
<li><p>在事件中调用     事件类型=“函数名（）”</p>
</li>
<li><p>递归调用（在函数体内部调用自身）   function  函数名(){代码    函数名（）；}</p>
</li>
<li><p>构造函数调用</p>
<ul>
<li><p>构造函数中 <strong>this</strong> 关键字没有任何的值。<br><strong>this</strong> 的值在函数调用时实例化对象(new object)时创建。</p>
</li>
<li><p>如果函数或者方法调用之前带有关键字new，他就构成构造函数调用。凡是没有形参的构造函数调用都可以省略圆括号 var  o=new Object;</p>
</li>
<li><p>立即调用函数（IIFE)</p>
<ul>
<li><p>一对圆括号()是一种运算符，跟在函数名之后，表示调用该函数</p>
</li>
<li><p>(function(){  </p>
<p>statement</p>
<p>}())</p>
</li>
<li><p>上面代码的圆括号的用法，function之前的左圆括号是必需的，因为如果不写这个左圆括号，JavaScript解释器会试图将关键字function解析为函数声明语句。而使用圆括号，JavaScript解释器才会正确地将其解析为函数定义表达式。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3.常用方法"></a>3.常用方法</h4><ul>
<li>apply：将函数作为对象的方法来调用，将参数传递给该方法</li>
<li>call：将函数作为对象的方法来调用，将参数传递给该方法</li>
<li>toString：返回函数的字符串表示</li>
</ul>
<h4 id="4-arguments对象"><a href="#4-arguments对象" class="headerlink" title="4.arguments对象"></a>4.arguments对象</h4><ul>
<li><p>功能：存放实参的参数列表</p>
</li>
<li><p>特性 </p>
<ul>
<li>仅能在函数体内使用</li>
<li>带有下标属性，但并非数组</li>
<li>函数声明时自动初始化</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li><p>length：获取函数实参的长度</p>
</li>
<li><p>callee ：返回当前正在指向的对象</p>
</li>
<li><p>caller：返回调用当前正在执行函数的函数名</p>
</li>
<li><p>name属性：返回紧跟在function关键字后的那个函数名</p>
</li>
<li><p>toString方法返回函数的源码</p>
</li>
<li><p>eval命令的作用是将字符串当作语句执行，eval没有自己的作用域，都是在当前作用域内执行</p>
<p>eval（‘var  a=1’）；</p>
<p>JavaScript规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。</p>
<p>(function(){</p>
<p>  ‘use strict’;</p>
<p>  eval(‘var a=1’);</p>
<p>  console.log(a);  //ReferenceError: a is not defined</p>
<p>})();</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-指针标识"><a href="#5-指针标识" class="headerlink" title="5.指针标识"></a>5.指针标识</h4><ul>
<li><p>this：指向当前操作对象</p>
</li>
<li><p>callee：指向参数集合所属函数</p>
</li>
<li><p>prototype：指向函数附带的原型对象</p>
</li>
<li><p>constructor：指向创建该函数的构造函数</p>
</li>
<li><p>JavaScript 变量的生命期从它们被声明的时间开始。局部变量会在函数运行以后被删除。全局变量会在页面关闭后被删除。</p>
</li>
<li><p>如果您把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。</p>
</li>
</ul>
<h4 id="6-函数变量提升"><a href="#6-函数变量提升" class="headerlink" title="6.函数变量提升"></a>6.函数变量提升</h4><ul>
<li>全局变量用var命令声明，不管在什么位置声明，变量声明都会被提升头部</li>
<li>函数作用域内部也会产生变量提升</li>
</ul>
<h4 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7.闭包"></a>7.<strong>闭包</strong></h4><ul>
<li>JavaScript的函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量，这就是JavaScript的闭包。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。</li>
<li>闭包的另一个用处，是封装对象的私有属性和私有方法。</li>
</ul>
<h4 id="8-数组"><a href="#8-数组" class="headerlink" title="8.数组"></a>8.数组</h4><ul>
<li><p>数组属于一种特殊的对象</p>
</li>
<li><p>数组长度length属性</p>
<ul>
<li>length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。</li>
<li>将数组清空的一个有效方法，就是将length属性设为0。</li>
<li>如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</li>
<li>在ECMAScript 5中，可以用Object.defineProperty() 让数组的length属性变成只读。</li>
</ul>
</li>
<li><p>空位</p>
<ul>
<li>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位   var   arr=【1，，2】</li>
<li>但是，如果最后一个元素后面有逗号，并不会产生空位。数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。</li>
</ul>
</li>
<li><p><strong>类数组对象</strong></p>
<ul>
<li><p>在JavaScript中，有些对象被称为“类数组对象”。意思是，它们看上去很像数组，可以使用length属性，但是它们并不是数组，无法使用一些数组的方法。</p>
</li>
<li><p>由于类数组对象没有继承自Array.prototype，那就不能在它们上面直接调用数组方法。不过我们可以间接的使用Function.call方法调用。</p>
</li>
</ul>
</li>
</ul>
<h2 id="六-JavaScript错误处理机制"><a href="#六-JavaScript错误处理机制" class="headerlink" title="六 . JavaScript错误处理机制"></a>六 . JavaScript错误处理机制</h2><ul>
<li><p>javascript解析或执行时，一旦发生错误，引擎就会自动抛出一个错误对象，js提供一个Error构造函数，所有抛出的错误都是这个构造函数的实例 var  err=new  Error（‘出错了’）；err.message</p>
</li>
<li><p>Erroe对象的属性</p>
<ul>
<li>message：错误提示信息</li>
<li>name：错误名称（非标准属性）</li>
<li>stack：错误的堆栈（非标准属性）</li>
</ul>
</li>
<li><p>Error的六大派生对象</p>
<ul>
<li>SyntaxError：是解析代码时发生的错误（变量名错误或者缺少括号）</li>
<li>ReferenceError：是引用一个不存在的变量时发生的的错误或者将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值（console.log()=1)</li>
<li>RangeError:是当一个值超过有效范围时发生的错误，主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值<ul>
<li>new  Array(-1)</li>
<li>(1234).toExponential(21)//toExponential()  argument  must  be  between  0  and  20</li>
</ul>
</li>
<li>TypeError:是参数或变量不是预期类型时发生的错误。比如，对字符串，布尔值，数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数  new 123</li>
<li>URIError：是URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI（），decodeURI（），encodeURIComponent（），decodeURIComponent（），escape（），unescape（）</li>
<li>EvalError:函数没有被正确执行时抛出EvalError错误，该错误类型已不再ES5中出现，只是为了与以前代码兼容</li>
</ul>
</li>
<li><p>自定义错误</p>
<p>function UserError(message){</p>
<p>this.message=message ||”默认信息”；</p>
<p>this.name=”UserError”;}</p>
<p>UserError.prototype=new  Error();</p>
<p>UserError.prototype.constructor=UserError;</p>
</li>
<li><p>throw语句：作用是中断程序执行，抛出一个意外或错误，他接受一个表达式作为参数，可以抛出各种值</p>
</li>
</ul>
<h2 id="七-JavaScript-JSON"><a href="#七-JavaScript-JSON" class="headerlink" title="七 . JavaScript  JSON"></a>七 . JavaScript  JSON</h2><ul>
<li><p>JSON英文全称JavaScript  Object  Notation</p>
</li>
<li><p>是一种易于理解的独立的语言，也是一种轻量级的数据交换格式</p>
</li>
<li><p>JSON使用JavaScript语法，但是JSON格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据传递格式</p>
</li>
<li><p>语法规则</p>
<ul>
<li>数据以键值对形式出现</li>
<li>数据由逗号分隔</li>
<li>大括号保存对象</li>
<li>方括号保存数组</li>
</ul>
</li>
<li><p>通常我们从服务器中读取JSON数据，并在网页中显示数据</p>
</li>
<li><p>JSON字符串转换为js对象</p>
<ul>
<li><p>创建js字符串，字符串为JSON格式的数据</p>
<p>var text = ‘{ “employees” : [‘ +<br>‘{ “firstName”:”John” , “lastName”:”Doe” },’ +<br>‘{ “firstName”:”Anna” , “lastName”:”Smith” },’ +<br>‘{ “firstName”:”Peter” , “lastName”:”Jones” } ]}’;</p>
</li>
<li><p>然后使用js内置函数JSON.parse（）将字符串转化为js对象</p>
</li>
<li><p>var  obj=JSON.parse（text）；</p>
</li>
<li><p>最后在你的页面使用js对象</p>
</li>
</ul>
</li>
</ul>
<h2 id="八-JavaScript：void（0）的含义"><a href="#八-JavaScript：void（0）的含义" class="headerlink" title="八 . JavaScript：void（0）的含义"></a>八 . JavaScript：void（0）的含义</h2><ul>
<li><p>void关键字是js中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值</p>
<p><a href="javascript:void(alert('Warning!!!'))" target="_blank" rel="noopener">点我!</a></p>
</li>
<li><h6 id="href-”-”与href-”javascript-void-0-”的区别"><a href="#href-”-”与href-”javascript-void-0-”的区别" class="headerlink" title="href=”#”与href=”javascript:void(0)”的区别"></a>href=”#”与href=”javascript:void(0)”的区别</h6><p><strong>#</strong> 包含了一个位置信息，默认的锚是<strong>#top</strong> 也就是网页的上端。</p>
<p>而javascript:void(0), 仅仅表示一个死链接。</p>
<p>在页面很长的时候会使用 <strong>#</strong> 来定位页面的具体位置，格式为：<strong># + id</strong>。</p>
<p>如果你要定义一个死链接请使用 javascript:void(0) 。</p>
</li>
<li><p>void()仅仅是代表不返回任何值，但是括号内的表达式还是要运行</p>
</li>
</ul>
<h2 id="九-命名规范"><a href="#九-命名规范" class="headerlink" title="九 . 命名规范"></a>九 . 命名规范</h2><ul>
<li><p>变量名应该区分大小写，允许包含字母、数字、美元符号($)和下划线，但第一个字符不允许是数字，不允许包含空格和其他标点符号；</p>
</li>
<li><p>变量命名长度应该尽可能的短，并抓住要点，尽量在变量名中体现出值的类型；</p>
</li>
<li><p>变量名的命名应该是有意义的；</p>
</li>
<li><p>变量名不能为JavaScript中的关键词、保留字全名；</p>
</li>
<li><p>变量名命名方法常见的有匈牙利命名法、驼峰命名法和帕斯卡命名法。</p>
</li>
<li><h6 id="空格与运算符"><a href="#空格与运算符" class="headerlink" title="空格与运算符"></a>空格与运算符</h6><p>通常运算符 ( = + - * / ) 前后需要添加空格:</p>
</li>
<li><h6 id="代码缩进"><a href="#代码缩进" class="headerlink" title="代码缩进"></a>代码缩进</h6><p>通常使用 4 个空格符号来缩进代码块：</p>
<p>注意:不推荐使用 TAB 键来缩进，因为不同编辑器 TAB 键的解析不一样。</p>
</li>
<li><p>复杂语句的通用规则:</p>
<ul>
<li>一条语句通常以分号作为结束符。</li>
<li>将左花括号放在第一行的结尾。</li>
<li>左花括号前添加一空格。</li>
<li>将右花括号独立放在一行。</li>
<li>不要以分号结束一个复杂的声明。</li>
</ul>
</li>
<li><p>对象定义的规则:</p>
<ul>
<li>将左花括号与类名放在同一行。</li>
<li>冒号与属性值间有个空格。</li>
<li>字符串使用双引号，数字不需要。</li>
<li>最后一个属性-值对后面不要添加逗号。</li>
<li>将右花括号独立放在一行，并以分号作为结束符号。</li>
</ul>
</li>
<li><h6 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h6><ul>
<li>变量和函数为驼峰法（ <strong>camelCase</strong>）</li>
<li>全局变量为大写 (<strong>UPPERCASE</strong> )</li>
<li>常量 (如 PI) 为大写 (<strong>UPPERCASE</strong> )</li>
</ul>
</li>
</ul>
<h2 id="十-文档对象模型HTML-DOM"><a href="#十-文档对象模型HTML-DOM" class="headerlink" title="十.文档对象模型HTML DOM"></a>十.文档对象模型HTML DOM</h2><p><img src="https://7n.w3cschool.cn/statics/images/course/pic_htmltree.gif" alt="DOM HTML tree"></p>
<ul>
<li>通过可编程的对象模型，js能够改变页面中的所有HTML元素，属性，CSS样式，能对页面中的所有事件作出反应</li>
</ul>
<h4 id="1-找HTML元素"><a href="#1-找HTML元素" class="headerlink" title="1.找HTML元素"></a>1.找HTML元素</h4><ul>
<li>通过id    document.getElementById(“id值”);</li>
<li>通过标签名   document.getElementByTagName(“标签名”);</li>
<li>通过类名    document.getElementByClassName(“类名”)；</li>
</ul>
<h4 id="2-节点指针"><a href="#2-节点指针" class="headerlink" title="2.节点指针"></a>2.节点指针</h4><ul>
<li>firstChild ：获取元素的首个子节点</li>
<li>lastChild ：获取元素的最后一个子节点</li>
<li>父节点.childNodes ：获取元素的子节点列表</li>
<li>兄弟节点.previousSibling：获取已知节点的前一个节点</li>
<li>兄弟节点.nextSibling ： 获取已知节点的后一个节点</li>
<li>子节点.parentNode :获取已知节点的父节点</li>
</ul>
<h4 id="3-创建节点"><a href="#3-创建节点" class="headerlink" title="3.创建节点"></a>3.创建节点</h4><ul>
<li>创建元素节点    document.createElement(元素标签)</li>
<li>创建属性节点     document.createAttribute(元素属性)</li>
<li>创建文本节点     document.createTextNode(文本内容)</li>
</ul>
<h4 id="4-插入节点"><a href="#4-插入节点" class="headerlink" title="4.插入节点"></a>4.插入节点</h4><ul>
<li>向节点的子节点列表的末尾添加新的子节点           appendChild（所添加的新节点）</li>
<li>在已知的子节点前插入一个新的子节点      insertBefore（所要添加的新节点，已知节点）</li>
</ul>
<p><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470709730442234.gif" alt="img"></p>
<h4 id="5-改变HTML元素样式"><a href="#5-改变HTML元素样式" class="headerlink" title="5.改变HTML元素样式"></a>5.改变HTML元素样式</h4><p>document.getElementById(id).style.property=new style;</p>
<h4 id="6-添加监听事件"><a href="#6-添加监听事件" class="headerlink" title="6.添加监听事件"></a>6.添加监听事件</h4><p>element.addEventListener(event,function,useCapture);</p>
<p>第一个参数就是事件的类型（如“click”或“mousedown”。注意不要使用“on”前缀，是“click”而非“onclick”）</p>
<p>第二个参数就是事件触发时调用的函数</p>
<p>第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的</p>
<h4 id="7-事件冒泡或事件捕获"><a href="#7-事件冒泡或事件捕获" class="headerlink" title="7.事件冒泡或事件捕获"></a>7.事件冒泡或事件捕获</h4><p>事件传递有两种方式：冒泡与捕获。</p>
<p>事件传递定义了元素事件触发的顺序。 如果你将 </p><p> 元素插入到 <div> 元素中，用户点击 <p> 元素, 哪个元素的 “click” 事件先被触发呢？</p>
<p>在冒泡中，内部元素的事件会先被触发，然后再触发外部元素，即： </p><p> 元素的点击事件先触发，然后会触发 <div> 元素的点击事件。</div></p>
<p>在捕获中，外部元素的事件会先被触发</p>
<p><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470710444592947.gif" alt="img"></p>
<p>在线工具库：<a href="https://123.w3cschool.cn/webtools" target="_blank" rel="noopener">https://123.w3cschool.cn/webtools</a></p>
<h2 id="一-js简介-1"><a href="#一-js简介-1" class="headerlink" title="一 . js简介"></a>一 . js简介</h2><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1.概念"></a>1.概念</h4><ul>
<li>javascript是<strong>世界上最流行的脚本语言</strong>。js是属于web的语言，他适合与PC，笔记本电脑，平板电脑和移动电话。ja被设计成向HTNL页面增加交互性。<ul>
<li>脚本语言：指的是他不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”</li>
</ul>
</li>
<li>通过嵌入HTML来实现各种酷炫的动态效果，为用户提供赏心悦目的浏览效果。所有现代的 HTML 页面都使用 JavaScript，可以用于改进设计、验证表单、检测浏览器、创建cookies等。</li>
<li>javaScript 是一种轻量级的编程语言。JavaScript 是可插入 HTML 页面的编程代码。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</li>
<li>javascript也是一种<strong>嵌入式（embedded）语言</strong>。它本身提供的核心语法不算很多，只是用来做一些数学和逻辑运算。js本身不提供任何与I/O(输入/输出）相关的API，主要靠宿主环境（host）提供，所以js只适合嵌入更大型的应用程序环境，去调用宿主环境提供的底层API。目前，已经嵌入JavaScript的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是Node项目</li>
<li>从语法角度看，javascript语言是一种“对象模型”语言。各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过js控制这些功能。但是，js并不是纯粹的“面型对象语言”，还支持其他编程范式（比如函数式编程）</li>
</ul>
<h4 id="2-支持编译运行。-1"><a href="#2-支持编译运行。-1" class="headerlink" title="2.支持编译运行。"></a>2.<strong>支持编译运行。</strong></h4><ul>
<li>JavaScript 语言本身，虽然是一种解释型语言，但是在现代浏览器中，JavaScript 都是编译后运行。程序会被高度优化，运行效率接近二进制程序。而且，JavaScript 引擎正在快速发展，性能将越来越好。</li>
<li>此外，还有一种 WebAssembly 格式，它是 JavaScript 引擎的中间码格式，全部都是二进制代码。由于跳过了编译步骤，可以达到接近原生二进制代码的运行速度。各种语言（主要是 C 和 C++）通过编译成 WebAssembly，就可以在浏览器里面运行。</li>
</ul>
<h4 id="3-事件驱动和非阻塞式设计-1"><a href="#3-事件驱动和非阻塞式设计-1" class="headerlink" title="3.事件驱动和非阻塞式设计"></a>3.事件驱动和非阻塞式设计</h4><ul>
<li>JavaScript 程序可以采用事件驱动（event-driven）和非阻塞式（non-blocking）设计，在服务器端适合高并发环境，普通的硬件就可以承受很大的访问量。</li>
</ul>
<h4 id="4-javascript与java的关系-1"><a href="#4-javascript与java的关系-1" class="headerlink" title="4.javascript与java的关系"></a>4.javascript与java的关系</h4><table>
<thead>
<tr>
<th>Java</th>
<th>javascript</th>
</tr>
</thead>
<tbody><tr>
<td>强类型</td>
<td>弱类型（同一变量可以存放不同类型的变量（但是始终存放同一类型是良好的编码习惯）</td>
</tr>
</tbody></table>
<p>必须在JAVA虚拟机上运行，且事先需要进行编译    不依托编辑器，在浏览器就可以实现，边解释边执行</p>
<h2 id="二-输出-1"><a href="#二-输出-1" class="headerlink" title="二 . 输出"></a>二 . 输出</h2><h4 id="1-直接写入HTML输出流-1"><a href="#1-直接写入HTML输出流-1" class="headerlink" title="1.直接写入HTML输出流"></a>1.直接写入HTML输出流</h4><p>document.write(“输出内容”);  将内容写入HTML<strong>文档</strong>中</p>
<ul>
<li>你只能在HTNL输出中使用document.write。如果在文档加载完成后使用该方法，会覆盖整个文档。</li>
</ul>
<h4 id="2-弹出警告框alert-1"><a href="#2-弹出警告框alert-1" class="headerlink" title="2.弹出警告框alert"></a>2.弹出警告框alert</h4><p>window.alert（“输出内容”）；</p>
<h4 id="3-在指定位置输出innerHTML-1"><a href="#3-在指定位置输出innerHTML-1" class="headerlink" title="3.在指定位置输出innerHTML"></a>3.在指定位置输出innerHTML</h4><p>var  x=document.getElementById(“id名”)；//使用id属性查找元素</p>
<p>x.innerHTML=”输出内容”;//改变内容，写入到HTML<strong>元素</strong></p>
<h4 id="4-在控制台上输出-1"><a href="#4-在控制台上输出-1" class="headerlink" title="4.在控制台上输出"></a>4.在控制台上输出</h4><p>console.log(‘输出内容’)；</p>
<p>1、console.log 用于输出普通信息</p>
<p>2、console.info 用于输出提示性信息</p>
<p>3、console.error用于输出错误信息</p>
<p>4、console.warn用于输出警示信息</p>
<p>5、console.debug用于输出调试信息</p>
<p>可以通过在控制台输入console.clear()来实现清空控制台信息。</p>
<p><a href="https://jingyan.baidu.com/article/6dad507505f714a123e36e8a.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/6dad507505f714a123e36e8a.html</a></p>
<h2 id="三-js基本语法-1"><a href="#三-js基本语法-1" class="headerlink" title="三 . js基本语法"></a>三 . js基本语法</h2><h4 id="1-语句-1"><a href="#1-语句-1" class="headerlink" title="1.语句"></a>1.语句</h4><ul>
<li>js程序执行单位为行，也就是一行一行地执行一般，每一行就是一个语句。语句是为了完成某种任务而进行的操作（赋值语句），语句以分号结束，分号前没有任何内容，js引擎将其视为空语句</li>
<li>表达式（需要得出结果）不需要分号结尾，不然js引擎会将其视为语句，这样会产生一些没有意义的语句</li>
</ul>
<h4 id="2-js用法-1"><a href="#2-js用法-1" class="headerlink" title="2.js用法"></a>2.js用法</h4><ul>
<li>HTML脚本必须位于<script>和</script>标签之间，脚本可放置在body或head标签中</li>
<li>如需在HTML页面中插入脚本，请使用script标签，他会告诉js在何处开始和结束</li>
<li>引入外部脚本<script src></script></li>
</ul>
<h5 id="js区分大小写-1"><a href="#js区分大小写-1" class="headerlink" title="js区分大小写"></a>js区分大小写</h5><h4 id="3-变量-1"><a href="#3-变量-1" class="headerlink" title="3.变量"></a>3.变量</h4><ul>
<li>局部变量不声明变量，即不写var，会自动创建全局变量；如果使用<code>var</code>重新声明一个已经存在的变量，是无效的。但第二次声明的时候还进行了赋值，则会覆盖掉前面的值。</li>
<li>如果一个变量没有声明就直接使用，js会报错，告诉你变量未定义</li>
<li>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</li>
<li>变量是一个名称，字面量是一个值</li>
<li>JavaScript 标识符必须以字母、下划线（_）或美元符（$）开始。后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的，以便 JavaScript 可以轻易区分开标识符和数字）。</li>
<li>undefined：声明变量却没赋值的变量，表示“无定义”</li>
<li>单行用   / /   注释，多行注释用 /*   */ </li>
<li>当您向变量分配文本值时，应该用双引号或单引号包围这个值。当您向变量赋的值是数值时，不要使用引号。如果您用引号包围数值，该值会被作为文本来处理。</li>
</ul>
<h5 id="1-变量类型-1"><a href="#1-变量类型-1" class="headerlink" title="1 .变量类型"></a>1 .变量类型</h5><ul>
<li>值类型<ul>
<li>占用空间固定，保存在栈中</li>
<li>保存复制的是值本身</li>
<li>使用typeof检测数据的类型</li>
<li>基本类型数据是值类型</li>
</ul>
</li>
<li>引用类型<ul>
<li>占用空间不固定，保存在堆中</li>
<li>保存和复制的是指向对象的一个指针</li>
<li>使用instanceof检测数据的类型</li>
<li>使用new（）方法构造出来的对象是引用型的</li>
</ul>
</li>
</ul>
<h5 id="2-作用域-1"><a href="#2-作用域-1" class="headerlink" title="2.作用域"></a>2.作用域</h5><ul>
<li>全局变量<ul>
<li>在函数体外定义的变量或者在函数体内部定义的无var的变量</li>
<li>在任何位置都可以调用</li>
</ul>
</li>
<li>局部变量<ul>
<li>在函数体内部用var声明的变量或函数的参数变量</li>
<li>在当前函数体内部调用</li>
</ul>
</li>
<li>优先级<ul>
<li>同名全局变量 &gt; 参数变量 &gt; 局部变量 &gt; 全局变量</li>
</ul>
</li>
<li>特性<ul>
<li>忽略块级作用域</li>
<li>全局变量是全局对象的属性</li>
<li>局部变量是调用对象的属性</li>
<li>作用域链<ul>
<li>内层函数可以访问外层函数的局部变量</li>
<li>外层函数不能访问内层函数局部变量</li>
</ul>
</li>
<li>生命周期<ul>
<li>全局变量：除非被显示删除，否则一直存在</li>
<li>局部变量：自声明起至函数运行完毕或者显示删除</li>
<li>收回机制<ul>
<li>标记清除，引用计数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-数据类型-1"><a href="#4-数据类型-1" class="headerlink" title="4.数据类型"></a>4.数据类型</h4><h5 id="1-数字-Number-1"><a href="#1-数字-Number-1" class="headerlink" title="1.数字 Number"></a>1.数字 Number</h5><h5 id="2-字符串String-1"><a href="#2-字符串String-1" class="headerlink" title="2.字符串String"></a>2.字符串String</h5><ul>
<li><p>由0个或多个16位Unicode字符组成</p>
</li>
<li><p>单引号与双引号不能交叉使用</p>
</li>
<li><p>使用length属性访问字符串长度</p>
<ul>
<li>转义字符算一个字符</li>
<li>无法精确返回双字节字符长度</li>
</ul>
</li>
<li><p>字符串一旦被创建，其值将不能修改，若要改变必须销毁原有字符串</p>
</li>
<li><p>不要创建 String 对象。它会拖慢执行速度，并可能产生其他副作用</p>
</li>
<li><p>类型转换</p>
<ul>
<li><p>toString（）使用类型</p>
<p>​     1.number</p>
<p>​     2.boolean</p>
<p>​     3.string</p>
<p>​     4.object</p>
</li>
<li><p>eval()：计算字符串表达式的值并以数值形式返回</p>
</li>
</ul>
</li>
</ul>
<h5 id="3-布尔Boolean-1"><a href="#3-布尔Boolean-1" class="headerlink" title="3.布尔Boolean"></a>3.布尔Boolean</h5><ul>
<li><p>任何值和布尔值比较时，<strong>两边都会转化为Number类型</strong></p>
</li>
<li><p>[0]用if判断的时候为true，和布尔值比较的时候转换为0。{x:0}用if判断的时候为true，和布尔值比较的时候转换为NaN</p>
</li>
<li><p>转换为true</p>
<ul>
<li>任何非空字符串</li>
<li>任何非0的数值</li>
<li>数组和对象（包括空数组和空对象）</li>
</ul>
</li>
<li><p>转换为false</p>
<ul>
<li>空字符串</li>
<li>0和NaN</li>
<li>null和undefined</li>
</ul>
</li>
</ul>
<h5 id="4-数组Array-1"><a href="#4-数组Array-1" class="headerlink" title="4.数组Array"></a>4.数组Array</h5><ul>
<li><p>对象Object</p>
</li>
<li><p>空Null</p>
<ul>
<li>逻辑上null表示一个空对象的指针，使用typeof检测时会返回object</li>
</ul>
</li>
<li><p>未定义Undefined</p>
<ul>
<li>使用var声明变量但未初始化</li>
<li>区分空对象指针与尚未定义的变量</li>
<li>对未初始化的变量及未声明的变量使用typeof运算符均会返回undefined</li>
</ul>
</li>
<li><h5 id="undefined与null的关系-1"><a href="#undefined与null的关系-1" class="headerlink" title="undefined与null的关系"></a>undefined与null的关系</h5><ul>
<li>undefined派生于null因此在使用“==”进行比较的时候会返回true</li>
<li>没有必要将变量值声明为undefined</li>
<li>声明空对象的时候应将其值赋值为null</li>
</ul>
</li>
</ul>
<h5 id="5-非数值NaN-Not-a-Number-1"><a href="#5-非数值NaN-Not-a-Number-1" class="headerlink" title="5.非数值NaN(Not a Number)"></a>5.非数值NaN(Not a Number)</h5><ul>
<li><p>任何涉及NaN的操作都将返回NaN</p>
</li>
<li><h6 id="NaN与任何数值都不相等包括自身-1"><a href="#NaN与任何数值都不相等包括自身-1" class="headerlink" title="NaN与任何数值都不相等包括自身"></a>NaN与任何数值都不相等包括自身</h6></li>
<li><p>检测isNaN（）</p>
<ul>
<li>可转换成数值false</li>
<li>不可转换成数值true</li>
</ul>
</li>
</ul>
<h5 id="6-未定义undefined-1"><a href="#6-未定义undefined-1" class="headerlink" title="6.未定义undefined"></a>6.未定义undefined</h5><ul>
<li>变量声明了却没有赋值</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于undefined</li>
<li>对象没有赋值的属性</li>
<li>函数没有返回值，默认返回undefined</li>
</ul>
<h4 id="5-数值转换-1"><a href="#5-数值转换-1" class="headerlink" title="5.数值转换"></a>5.数值转换</h4><h5 id="1-Number-1"><a href="#1-Number-1" class="headerlink" title="1.Number()"></a>1.Number()</h5><ul>
<li>Boolean——(true  1)(false  0)</li>
<li>null——0</li>
<li>undefined / { }———NaN    (<code>null</code>是一个表示”无”的对象，转为数值时为<code>0</code>；<code>undefined</code>是一个表示”无”的原始值，转为数值时为<code>NaN</code>)</li>
<li>String除数字和空字符串（0）外，其余都是NaN</li>
</ul>
<h5 id="2-解析parseInt（“要解析的字符串”，转换时使用的基数）-1"><a href="#2-解析parseInt（“要解析的字符串”，转换时使用的基数）-1" class="headerlink" title="2.解析parseInt（“要解析的字符串”，转换时使用的基数）"></a>2.解析parseInt（“要解析的字符串”，转换时使用的基数）</h5><ul>
<li>忽略前置空格</li>
<li>直接找到第一个非空格字符<ul>
<li>NaN：不是数字字符或符号</li>
<li>如果是数字字符解析所有后续字符，或一直解析直到遇到非数字字符便结束</li>
</ul>
</li>
</ul>
<h5 id="3-parseFloat（）-1"><a href="#3-parseFloat（）-1" class="headerlink" title="3.parseFloat（）"></a>3.parseFloat（）</h5><ul>
<li>从第一个字符开始解析，遇到无效浮点格式后结束</li>
<li>只有第一个小数点有效，忽略前导0</li>
<li>十六进制数始终为0，没有小数点或小数点后全0</li>
</ul>
<h4 id="6-对象object-1"><a href="#6-对象object-1" class="headerlink" title="6.对象object"></a>6.对象object</h4><ul>
<li>一组数据或功能的集合</li>
<li>声明 var  o=new Object（）</li>
<li>属性和方法<ul>
<li>Constructor：保存用于创建当前对象的函数</li>
<li>hasOwnProperty（propertyName）：检测给定属性在当前对象实例中是否存在</li>
<li>isPrototypeOf（object）检测传入的对象是否为另一个对象的原型</li>
<li>propertyisEnumerable（propertyName）检测给定属性是否能用for-in语句枚举</li>
<li>toLocalString（）返回对象的字符串表示，该字符串与执行环境的地区对应</li>
<li>toString（）返回对象的字符串表示</li>
<li>valueOf（）返回对象的字符串，数值或布尔值表示；通常和toString（）的值相同</li>
</ul>
</li>
</ul>
<h5 id="https-blog-csdn-net-IT-10-article-details-81806665-1"><a href="#https-blog-csdn-net-IT-10-article-details-81806665-1" class="headerlink" title="https://blog.csdn.net/IT_10/article/details/81806665"></a><a href="https://blog.csdn.net/IT_10/article/details/81806665" target="_blank" rel="noopener">https://blog.csdn.net/IT_10/article/details/81806665</a></h5><h2 id="四-数据类型的概述-1"><a href="#四-数据类型的概述-1" class="headerlink" title="四 . 数据类型的概述"></a>四 . 数据类型的概述</h2><h4 id="1-六大数据类型（number-string-boolean-undefined-null-onject-1"><a href="#1-六大数据类型（number-string-boolean-undefined-null-onject-1" class="headerlink" title="1.六大数据类型（number,string,boolean,undefined,null,onject)"></a>1.六大数据类型（number,string,boolean,undefined,null,onject)</h4><ul>
<li>原始类型（primitive type）<ul>
<li>不能再细分，最基本的数据类型</li>
<li>number，string，boolean</li>
</ul>
</li>
<li>合成类型（complex type）<ul>
<li>可看作一个存放多个原始类型值的容器</li>
<li>狭义对象（object），数组（array），函数（function）</li>
</ul>
</li>
<li>undefined和null一般将他们看成两个特殊值</li>
<li>狭义的对象（object）和数组是两种不同的数据组合方式，而函数其实是处理数据的方法。js把函数当成一种数据类型，可以像其他类型的数据一样，进行赋值和传递，这为编程带来了很大的灵活性，体现了js作为“函数式语言”的本质</li>
<li>js的所有数据都可以视为广义的对象。不仅数组和函数属于对象，就连原始值也可用对象方式调用，（不过都是隐式转换，就像输入数值都会隐式转换成字符串数值一样）</li>
</ul>
<h4 id="2-确定值是什么类型的几种方法-1"><a href="#2-确定值是什么类型的几种方法-1" class="headerlink" title="2.确定值是什么类型的几种方法"></a>2.确定值是什么类型的几种方法</h4><h6 id="1-typeof运算符-1"><a href="#1-typeof运算符-1" class="headerlink" title="1.typeof运算符"></a>1.typeof运算符</h6><ul>
<li>typeof 123     //“number”</li>
<li>typeof  ‘123’   //“string”</li>
<li>typeof   false  //“boolean”</li>
<li>function  f（）{}  typeof  f   //“function”</li>
<li>typeof   undefined   //“undefined”（利用这一点，可用来检查一个没有申明的变量而不报错）</li>
<li>typeof   window / { } / [ ]  / null    //“object”（表明数组本质上只是一种特殊的对象。<code>null</code>的类型也是<code>object</code>，这是由于历史原因造成的）</li>
</ul>
<h6 id="2-instanceof运算符-1"><a href="#2-instanceof运算符-1" class="headerlink" title="2.instanceof运算符"></a>2.instanceof运算符</h6><ul>
<li>解决typeof没法区分数组和对象的缺陷</li>
<li>{}/[] instanceof  Object/Array     //true</li>
<li>(function(0{}))   instanceof  Function     //true</li>
<li>原始类型   instanceof    各种类型     //一般都是false</li>
</ul>
<h6 id="3-Object-prototype-toString方法-1"><a href="#3-Object-prototype-toString方法-1" class="headerlink" title="3.Object.prototype.toString方法"></a>3.Object.prototype.toString方法</h6><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call([1,2,3])</span><br><span class="line">   &apos;[object Array]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="4-应用typeof方法写方法-1"><a href="#4-应用typeof方法写方法-1" class="headerlink" title="4.应用typeof方法写方法"></a>4.应用typeof方法写方法</h6><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var toType = function(obj) &#123;</span><br><span class="line">   return (&#123;&#125;).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">toType(&#123;a: 4&#125;) // &quot;object&quot;</span><br><span class="line">   toType([1, 2, 3]) // &quot;array&quot;</span><br><span class="line">   (function() &#123; return toType(arguments) &#125;()) // &quot;arguments&quot;</span><br><span class="line">   toType(new ReferenceError()) // &quot;error&quot;</span><br><span class="line">   toType(new Date()) // &quot;date&quot;</span><br><span class="line">   toType(/a-z/) // &quot;regexp&quot;</span><br><span class="line">   toType(Math) // &quot;math&quot;</span><br><span class="line">   toType(JSON) // &quot;json&quot;</span><br><span class="line">   toType(new Number(4)) // &quot;number&quot;</span><br><span class="line">   toType(new String(&quot;abc&quot;)) // &quot;string&quot;</span><br><span class="line">   toType(new Boolean(true)) // &quot;boolean&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2011/11/improving-typeof.html" target="_blank" rel="noopener">Improving the JavaScript typeof operator</a></li>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2013/01/categorizing-values.html" target="_blank" rel="noopener">Categorizing values in JavaScript</a></li>
</ul>
<h2 id="五-JavaScript函数-1"><a href="#五-JavaScript函数-1" class="headerlink" title="五 . JavaScript函数"></a>五 . JavaScript函数</h2><h4 id="1-定义方法-1"><a href="#1-定义方法-1" class="headerlink" title="1.定义方法"></a>1.定义方法</h4><ul>
<li>静态方法function function nane（){执行代码}</li>
<li>动态匿名方法  var 函数名=new Function([“虚参数列表”]，“函数体”)；</li>
<li>直接量方法  函数名=function（【虚参列表】）{函数体}</li>
</ul>
<h4 id="2-调用方法-1"><a href="#2-调用方法-1" class="headerlink" title="2.调用方法"></a>2.调用方法</h4><ul>
<li><p>函数作为对象方法调用，会使得 <strong>this</strong> 的值成为对象本身。</p>
</li>
<li><p><strong>call()</strong>（传入的参数是一系列的参数值，但是从第二个参数开始） 和 <strong>apply()</strong> （传入的参数只能是由各参数值组成的数组）是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身。</p>
</li>
<li><p>在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 <strong>this</strong> 的值， 即使该参数不是一个对象。</p>
</li>
<li><p>在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。</p>
</li>
<li><p>在 HTML 中默认的全局对象是 HTML 页面本身，所以函数是属于 HTML 页面。</p>
</li>
<li><p>在浏览器中的页面对象是浏览器窗口(window 对象)。以上函数会自动变为 window 对象的函数。</p>
</li>
<li><p>直接调用    函数名（实参列表）</p>
</li>
<li><p>在连接中调用   <a href="javascript:函数名()" target="_blank" rel="noopener"></a></p>
</li>
<li><p>在事件中调用     事件类型=“函数名（）”</p>
</li>
<li><p>递归调用（在函数体内部调用自身）   function  函数名(){代码    函数名（）；}</p>
</li>
<li><p>构造函数调用</p>
<ul>
<li><p>构造函数中 <strong>this</strong> 关键字没有任何的值。<br><strong>this</strong> 的值在函数调用时实例化对象(new object)时创建。</p>
</li>
<li><p>如果函数或者方法调用之前带有关键字new，他就构成构造函数调用。凡是没有形参的构造函数调用都可以省略圆括号 var  o=new Object;</p>
</li>
<li><p>立即调用函数（IIFE)</p>
<ul>
<li><p>一对圆括号()是一种运算符，跟在函数名之后，表示调用该函数</p>
</li>
<li><p>(function(){  </p>
<p>statement</p>
<p>}())</p>
</li>
<li><p>上面代码的圆括号的用法，function之前的左圆括号是必需的，因为如果不写这个左圆括号，JavaScript解释器会试图将关键字function解析为函数声明语句。而使用圆括号，JavaScript解释器才会正确地将其解析为函数定义表达式。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-常用方法-1"><a href="#3-常用方法-1" class="headerlink" title="3.常用方法"></a>3.常用方法</h4><ul>
<li>apply：将函数作为对象的方法来调用，将参数传递给该方法</li>
<li>call：将函数作为对象的方法来调用，将参数传递给该方法</li>
<li>toString：返回函数的字符串表示</li>
</ul>
<h4 id="4-arguments对象-1"><a href="#4-arguments对象-1" class="headerlink" title="4.arguments对象"></a>4.arguments对象</h4><ul>
<li><p>功能：存放实参的参数列表</p>
</li>
<li><p>特性 </p>
<ul>
<li>仅能在函数体内使用</li>
<li>带有下标属性，但并非数组</li>
<li>函数声明时自动初始化</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li><p>length：获取函数实参的长度</p>
</li>
<li><p>callee ：返回当前正在指向的对象</p>
</li>
<li><p>caller：返回调用当前正在执行函数的函数名</p>
</li>
<li><p>name属性：返回紧跟在function关键字后的那个函数名</p>
</li>
<li><p>toString方法返回函数的源码</p>
</li>
<li><p>eval命令的作用是将字符串当作语句执行，eval没有自己的作用域，都是在当前作用域内执行</p>
<p>eval（‘var  a=1’）；</p>
<p>JavaScript规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。</p>
<p>(function(){</p>
<p>  ‘use strict’;</p>
<p>  eval(‘var a=1’);</p>
<p>  console.log(a);  //ReferenceError: a is not defined</p>
<p>})();</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-指针标识-1"><a href="#5-指针标识-1" class="headerlink" title="5.指针标识"></a>5.指针标识</h4><ul>
<li><p>this：指向当前操作对象</p>
</li>
<li><p>callee：指向参数集合所属函数</p>
</li>
<li><p>prototype：指向函数附带的原型对象</p>
</li>
<li><p>constructor：指向创建该函数的构造函数</p>
</li>
<li><p>JavaScript 变量的生命期从它们被声明的时间开始。局部变量会在函数运行以后被删除。全局变量会在页面关闭后被删除。</p>
</li>
<li><p>如果您把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。</p>
</li>
</ul>
<h4 id="6-函数变量提升-1"><a href="#6-函数变量提升-1" class="headerlink" title="6.函数变量提升"></a>6.函数变量提升</h4><ul>
<li>全局变量用var命令声明，不管在什么位置声明，变量声明都会被提升头部</li>
<li>函数作用域内部也会产生变量提升</li>
</ul>
<h4 id="7-闭包-1"><a href="#7-闭包-1" class="headerlink" title="7.闭包"></a>7.<strong>闭包</strong></h4><ul>
<li>JavaScript的函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量，这就是JavaScript的闭包。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。</li>
<li>闭包的另一个用处，是封装对象的私有属性和私有方法。</li>
</ul>
<h4 id="8-数组-1"><a href="#8-数组-1" class="headerlink" title="8.数组"></a>8.数组</h4><ul>
<li><p>数组属于一种特殊的对象</p>
</li>
<li><p>数组长度length属性</p>
<ul>
<li>length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。</li>
<li>将数组清空的一个有效方法，就是将length属性设为0。</li>
<li>如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</li>
<li>在ECMAScript 5中，可以用Object.defineProperty() 让数组的length属性变成只读。</li>
</ul>
</li>
<li><p>空位</p>
<ul>
<li>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位   var   arr=【1，，2】</li>
<li>但是，如果最后一个元素后面有逗号，并不会产生空位。数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。</li>
</ul>
</li>
<li><p><strong>类数组对象</strong></p>
<ul>
<li><p>在JavaScript中，有些对象被称为“类数组对象”。意思是，它们看上去很像数组，可以使用length属性，但是它们并不是数组，无法使用一些数组的方法。</p>
</li>
<li><p>由于类数组对象没有继承自Array.prototype，那就不能在它们上面直接调用数组方法。不过我们可以间接的使用Function.call方法调用。</p>
</li>
</ul>
</li>
</ul>
<h2 id="六-JavaScript错误处理机制-1"><a href="#六-JavaScript错误处理机制-1" class="headerlink" title="六 . JavaScript错误处理机制"></a>六 . JavaScript错误处理机制</h2><ul>
<li><p>javascript解析或执行时，一旦发生错误，引擎就会自动抛出一个错误对象，js提供一个Error构造函数，所有抛出的错误都是这个构造函数的实例 var  err=new  Error（‘出错了’）；err.message</p>
</li>
<li><p>Erroe对象的属性</p>
<ul>
<li>message：错误提示信息</li>
<li>name：错误名称（非标准属性）</li>
<li>stack：错误的堆栈（非标准属性）</li>
</ul>
</li>
<li><p>Error的六大派生对象</p>
<ul>
<li>SyntaxError：是解析代码时发生的错误（变量名错误或者缺少括号）</li>
<li>ReferenceError：是引用一个不存在的变量时发生的的错误或者将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值（console.log()=1)</li>
<li>RangeError:是当一个值超过有效范围时发生的错误，主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值<ul>
<li>new  Array(-1)</li>
<li>(1234).toExponential(21)//toExponential()  argument  must  be  between  0  and  20</li>
</ul>
</li>
<li>TypeError:是参数或变量不是预期类型时发生的错误。比如，对字符串，布尔值，数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数  new 123</li>
<li>URIError：是URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI（），decodeURI（），encodeURIComponent（），decodeURIComponent（），escape（），unescape（）</li>
<li>EvalError:函数没有被正确执行时抛出EvalError错误，该错误类型已不再ES5中出现，只是为了与以前代码兼容</li>
</ul>
</li>
<li><p>自定义错误</p>
<p>function UserError(message){</p>
<p>this.message=message ||”默认信息”；</p>
<p>this.name=”UserError”;}</p>
<p>UserError.prototype=new  Error();</p>
<p>UserError.prototype.constructor=UserError;</p>
</li>
<li><p>throw语句：作用是中断程序执行，抛出一个意外或错误，他接受一个表达式作为参数，可以抛出各种值</p>
</li>
</ul>
<h2 id="七-JavaScript-JSON-1"><a href="#七-JavaScript-JSON-1" class="headerlink" title="七 . JavaScript  JSON"></a>七 . JavaScript  JSON</h2><ul>
<li><p>JSON英文全称JavaScript  Object  Notation</p>
</li>
<li><p>是一种易于理解的独立的语言，也是一种轻量级的数据交换格式</p>
</li>
<li><p>JSON使用JavaScript语法，但是JSON格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据传递格式</p>
</li>
<li><p>语法规则</p>
<ul>
<li>数据以键值对形式出现</li>
<li>数据由逗号分隔</li>
<li>大括号保存对象</li>
<li>方括号保存数组</li>
</ul>
</li>
<li><p>通常我们从服务器中读取JSON数据，并在网页中显示数据</p>
</li>
<li><p>JSON字符串转换为js对象</p>
<ul>
<li><p>创建js字符串，字符串为JSON格式的数据</p>
<p>var text = ‘{ “employees” : [‘ +<br>‘{ “firstName”:”John” , “lastName”:”Doe” },’ +<br>‘{ “firstName”:”Anna” , “lastName”:”Smith” },’ +<br>‘{ “firstName”:”Peter” , “lastName”:”Jones” } ]}’;</p>
</li>
<li><p>然后使用js内置函数JSON.parse（）将字符串转化为js对象</p>
</li>
<li><p>var  obj=JSON.parse（text）；</p>
</li>
<li><p>最后在你的页面使用js对象</p>
</li>
</ul>
</li>
</ul>
<h2 id="八-JavaScript：void（0）的含义-1"><a href="#八-JavaScript：void（0）的含义-1" class="headerlink" title="八 . JavaScript：void（0）的含义"></a>八 . JavaScript：void（0）的含义</h2><ul>
<li><p>void关键字是js中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值</p>
<p><a href="javascript:void(alert('Warning!!!'))" target="_blank" rel="noopener">点我!</a></p>
</li>
<li><h6 id="href-”-”与href-”javascript-void-0-”的区别-1"><a href="#href-”-”与href-”javascript-void-0-”的区别-1" class="headerlink" title="href=”#”与href=”javascript:void(0)”的区别"></a>href=”#”与href=”javascript:void(0)”的区别</h6><p><strong>#</strong> 包含了一个位置信息，默认的锚是<strong>#top</strong> 也就是网页的上端。</p>
<p>而javascript:void(0), 仅仅表示一个死链接。</p>
<p>在页面很长的时候会使用 <strong>#</strong> 来定位页面的具体位置，格式为：<strong># + id</strong>。</p>
<p>如果你要定义一个死链接请使用 javascript:void(0) 。</p>
</li>
<li><p>void()仅仅是代表不返回任何值，但是括号内的表达式还是要运行</p>
</li>
</ul>
<h2 id="九-命名规范-1"><a href="#九-命名规范-1" class="headerlink" title="九 . 命名规范"></a>九 . 命名规范</h2><ul>
<li><p>变量名应该区分大小写，允许包含字母、数字、美元符号($)和下划线，但第一个字符不允许是数字，不允许包含空格和其他标点符号；</p>
</li>
<li><p>变量命名长度应该尽可能的短，并抓住要点，尽量在变量名中体现出值的类型；</p>
</li>
<li><p>变量名的命名应该是有意义的；</p>
</li>
<li><p>变量名不能为JavaScript中的关键词、保留字全名；</p>
</li>
<li><p>变量名命名方法常见的有匈牙利命名法、驼峰命名法和帕斯卡命名法。</p>
</li>
<li><h6 id="空格与运算符-1"><a href="#空格与运算符-1" class="headerlink" title="空格与运算符"></a>空格与运算符</h6><p>通常运算符 ( = + - * / ) 前后需要添加空格:</p>
</li>
<li><h6 id="代码缩进-1"><a href="#代码缩进-1" class="headerlink" title="代码缩进"></a>代码缩进</h6><p>通常使用 4 个空格符号来缩进代码块：</p>
<p>注意:不推荐使用 TAB 键来缩进，因为不同编辑器 TAB 键的解析不一样。</p>
</li>
<li><p>复杂语句的通用规则:</p>
<ul>
<li>一条语句通常以分号作为结束符。</li>
<li>将左花括号放在第一行的结尾。</li>
<li>左花括号前添加一空格。</li>
<li>将右花括号独立放在一行。</li>
<li>不要以分号结束一个复杂的声明。</li>
</ul>
</li>
<li><p>对象定义的规则:</p>
<ul>
<li>将左花括号与类名放在同一行。</li>
<li>冒号与属性值间有个空格。</li>
<li>字符串使用双引号，数字不需要。</li>
<li>最后一个属性-值对后面不要添加逗号。</li>
<li>将右花括号独立放在一行，并以分号作为结束符号。</li>
</ul>
</li>
<li><h6 id="命名规则-1"><a href="#命名规则-1" class="headerlink" title="命名规则"></a>命名规则</h6><ul>
<li>变量和函数为驼峰法（ <strong>camelCase</strong>）</li>
<li>全局变量为大写 (<strong>UPPERCASE</strong> )</li>
<li>常量 (如 PI) 为大写 (<strong>UPPERCASE</strong> )</li>
</ul>
</li>
</ul>
<h2 id="十-文档对象模型HTML-DOM-1"><a href="#十-文档对象模型HTML-DOM-1" class="headerlink" title="十.文档对象模型HTML DOM"></a>十.文档对象模型HTML DOM</h2><p><img src="https://7n.w3cschool.cn/statics/images/course/pic_htmltree.gif" alt="DOM HTML tree"></p>
<ul>
<li>通过可编程的对象模型，js能够改变页面中的所有HTML元素，属性，CSS样式，能对页面中的所有事件作出反应</li>
</ul>
<h4 id="1-找HTML元素-1"><a href="#1-找HTML元素-1" class="headerlink" title="1.找HTML元素"></a>1.找HTML元素</h4><ul>
<li>通过id    document.getElementById(“id值”);</li>
<li>通过标签名   document.getElementByTagName(“标签名”);</li>
<li>通过类名    document.getElementByClassName(“类名”)；</li>
</ul>
<h4 id="2-节点指针-1"><a href="#2-节点指针-1" class="headerlink" title="2.节点指针"></a>2.节点指针</h4><ul>
<li>firstChild ：获取元素的首个子节点</li>
<li>lastChild ：获取元素的最后一个子节点</li>
<li>父节点.childNodes ：获取元素的子节点列表</li>
<li>兄弟节点.previousSibling：获取已知节点的前一个节点</li>
<li>兄弟节点.nextSibling ： 获取已知节点的后一个节点</li>
<li>子节点.parentNode :获取已知节点的父节点</li>
</ul>
<h4 id="3-创建节点-1"><a href="#3-创建节点-1" class="headerlink" title="3.创建节点"></a>3.创建节点</h4><ul>
<li>创建元素节点    document.createElement(元素标签)</li>
<li>创建属性节点     document.createAttribute(元素属性)</li>
<li>创建文本节点     document.createTextNode(文本内容)</li>
</ul>
<h4 id="4-插入节点-1"><a href="#4-插入节点-1" class="headerlink" title="4.插入节点"></a>4.插入节点</h4><ul>
<li>向节点的子节点列表的末尾添加新的子节点           appendChild（所添加的新节点）</li>
<li>在已知的子节点前插入一个新的子节点      insertBefore（所要添加的新节点，已知节点）</li>
</ul>
<p><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470709730442234.gif" alt="img"></p>
<h4 id="5-改变HTML元素样式-1"><a href="#5-改变HTML元素样式-1" class="headerlink" title="5.改变HTML元素样式"></a>5.改变HTML元素样式</h4><p>document.getElementById(id).style.property=new style;</p>
<h4 id="6-添加监听事件-1"><a href="#6-添加监听事件-1" class="headerlink" title="6.添加监听事件"></a>6.添加监听事件</h4><p>element.addEventListener(event,function,useCapture);</p>
<p>第一个参数就是事件的类型（如“click”或“mousedown”。注意不要使用“on”前缀，是“click”而非“onclick”）</p>
<p>第二个参数就是事件触发时调用的函数</p>
<p>第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的</p>
<h4 id="7-事件冒泡或事件捕获？"><a href="#7-事件冒泡或事件捕获？" class="headerlink" title="7.事件冒泡或事件捕获？"></a>7.事件冒泡或事件捕获？</h4><p>事件传递有两种方式：冒泡与捕获。</p>
<p>事件传递定义了元素事件触发的顺序。 如果你将 </p><p> 元素插入到 <div> 元素中，用户点击 <p> 元素, 哪个元素的 “click” 事件先被触发呢？</p>
<p>在冒泡中，内部元素的事件会先被触发，然后再触发外部元素，即： </p><p> 元素的点击事件先触发，然后会触发 <div> 元素的点击事件。</div></p>
<p>在捕获中，外部元素的事件会先被触发</p>
<p><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470710444592947.gif" alt="img"></p>
<p>在线工具库：<a href="https://123.w3cschool.cn/webtools" target="_blank" rel="noopener">https://123.w3cschool.cn/webtools</a></p>
<h2 id="一-js简介-2"><a href="#一-js简介-2" class="headerlink" title="一 . js简介"></a>一 . js简介</h2><h4 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1.概念"></a>1.概念</h4><ul>
<li>javascript是<strong>世界上最流行的脚本语言</strong>。js是属于web的语言，他适合与PC，笔记本电脑，平板电脑和移动电话。ja被设计成向HTNL页面增加交互性。<ul>
<li>脚本语言：指的是他不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”</li>
</ul>
</li>
<li>通过嵌入HTML来实现各种酷炫的动态效果，为用户提供赏心悦目的浏览效果。所有现代的 HTML 页面都使用 JavaScript，可以用于改进设计、验证表单、检测浏览器、创建cookies等。</li>
<li>javaScript 是一种轻量级的编程语言。JavaScript 是可插入 HTML 页面的编程代码。JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。</li>
<li>javascript也是一种<strong>嵌入式（embedded）语言</strong>。它本身提供的核心语法不算很多，只是用来做一些数学和逻辑运算。js本身不提供任何与I/O(输入/输出）相关的API，主要靠宿主环境（host）提供，所以js只适合嵌入更大型的应用程序环境，去调用宿主环境提供的底层API。目前，已经嵌入JavaScript的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是Node项目</li>
<li>从语法角度看，javascript语言是一种“对象模型”语言。各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过js控制这些功能。但是，js并不是纯粹的“面型对象语言”，还支持其他编程范式（比如函数式编程）</li>
</ul>
<h4 id="2-支持编译运行。-2"><a href="#2-支持编译运行。-2" class="headerlink" title="2.支持编译运行。"></a>2.<strong>支持编译运行。</strong></h4><ul>
<li>JavaScript 语言本身，虽然是一种解释型语言，但是在现代浏览器中，JavaScript 都是编译后运行。程序会被高度优化，运行效率接近二进制程序。而且，JavaScript 引擎正在快速发展，性能将越来越好。</li>
<li>此外，还有一种 WebAssembly 格式，它是 JavaScript 引擎的中间码格式，全部都是二进制代码。由于跳过了编译步骤，可以达到接近原生二进制代码的运行速度。各种语言（主要是 C 和 C++）通过编译成 WebAssembly，就可以在浏览器里面运行。</li>
</ul>
<h4 id="3-事件驱动和非阻塞式设计-2"><a href="#3-事件驱动和非阻塞式设计-2" class="headerlink" title="3.事件驱动和非阻塞式设计"></a>3.事件驱动和非阻塞式设计</h4><ul>
<li>JavaScript 程序可以采用事件驱动（event-driven）和非阻塞式（non-blocking）设计，在服务器端适合高并发环境，普通的硬件就可以承受很大的访问量。</li>
</ul>
<h4 id="4-javascript与java的关系-2"><a href="#4-javascript与java的关系-2" class="headerlink" title="4.javascript与java的关系"></a>4.javascript与java的关系</h4><table>
<thead>
<tr>
<th>Java</th>
<th>javascript</th>
</tr>
</thead>
<tbody><tr>
<td>强类型</td>
<td>弱类型（同一变量可以存放不同类型的变量（但是始终存放同一类型是良好的编码习惯）</td>
</tr>
</tbody></table>
<p>必须在JAVA虚拟机上运行，且事先需要进行编译    不依托编辑器，在浏览器就可以实现，边解释边执行</p>
<h2 id="二-输出-2"><a href="#二-输出-2" class="headerlink" title="二 . 输出"></a>二 . 输出</h2><h4 id="1-直接写入HTML输出流-2"><a href="#1-直接写入HTML输出流-2" class="headerlink" title="1.直接写入HTML输出流"></a>1.直接写入HTML输出流</h4><p>document.write(“输出内容”);  将内容写入HTML<strong>文档</strong>中</p>
<ul>
<li>你只能在HTNL输出中使用document.write。如果在文档加载完成后使用该方法，会覆盖整个文档。</li>
</ul>
<h4 id="2-弹出警告框alert-2"><a href="#2-弹出警告框alert-2" class="headerlink" title="2.弹出警告框alert"></a>2.弹出警告框alert</h4><p>window.alert（“输出内容”）；</p>
<h4 id="3-在指定位置输出innerHTML-2"><a href="#3-在指定位置输出innerHTML-2" class="headerlink" title="3.在指定位置输出innerHTML"></a>3.在指定位置输出innerHTML</h4><p>var  x=document.getElementById(“id名”)；//使用id属性查找元素</p>
<p>x.innerHTML=”输出内容”;//改变内容，写入到HTML<strong>元素</strong></p>
<h4 id="4-在控制台上输出-2"><a href="#4-在控制台上输出-2" class="headerlink" title="4.在控制台上输出"></a>4.在控制台上输出</h4><p>console.log(‘输出内容’)；</p>
<p>1、console.log 用于输出普通信息</p>
<p>2、console.info 用于输出提示性信息</p>
<p>3、console.error用于输出错误信息</p>
<p>4、console.warn用于输出警示信息</p>
<p>5、console.debug用于输出调试信息</p>
<p>可以通过在控制台输入console.clear()来实现清空控制台信息。</p>
<p><a href="https://jingyan.baidu.com/article/6dad507505f714a123e36e8a.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/6dad507505f714a123e36e8a.html</a></p>
<h2 id="三-js基本语法-2"><a href="#三-js基本语法-2" class="headerlink" title="三 . js基本语法"></a>三 . js基本语法</h2><h4 id="1-语句-2"><a href="#1-语句-2" class="headerlink" title="1.语句"></a>1.语句</h4><ul>
<li>js程序执行单位为行，也就是一行一行地执行一般，每一行就是一个语句。语句是为了完成某种任务而进行的操作（赋值语句），语句以分号结束，分号前没有任何内容，js引擎将其视为空语句</li>
<li>表达式（需要得出结果）不需要分号结尾，不然js引擎会将其视为语句，这样会产生一些没有意义的语句</li>
</ul>
<h4 id="2-js用法-2"><a href="#2-js用法-2" class="headerlink" title="2.js用法"></a>2.js用法</h4><ul>
<li>HTML脚本必须位于<script>和</script>标签之间，脚本可放置在body或head标签中</li>
<li>如需在HTML页面中插入脚本，请使用script标签，他会告诉js在何处开始和结束</li>
<li>引入外部脚本<script src></script></li>
</ul>
<h5 id="js区分大小写-2"><a href="#js区分大小写-2" class="headerlink" title="js区分大小写"></a>js区分大小写</h5><h4 id="3-变量-2"><a href="#3-变量-2" class="headerlink" title="3.变量"></a>3.变量</h4><ul>
<li>局部变量不声明变量，即不写var，会自动创建全局变量；如果使用<code>var</code>重新声明一个已经存在的变量，是无效的。但第二次声明的时候还进行了赋值，则会覆盖掉前面的值。</li>
<li>如果一个变量没有声明就直接使用，js会报错，告诉你变量未定义</li>
<li>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</li>
<li>变量是一个名称，字面量是一个值</li>
<li>JavaScript 标识符必须以字母、下划线（_）或美元符（$）开始。后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的，以便 JavaScript 可以轻易区分开标识符和数字）。</li>
<li>undefined：声明变量却没赋值的变量，表示“无定义”</li>
<li>单行用   / /   注释，多行注释用 /*   */ </li>
<li>当您向变量分配文本值时，应该用双引号或单引号包围这个值。当您向变量赋的值是数值时，不要使用引号。如果您用引号包围数值，该值会被作为文本来处理。</li>
</ul>
<h5 id="1-变量类型-2"><a href="#1-变量类型-2" class="headerlink" title="1 .变量类型"></a>1 .变量类型</h5><ul>
<li>值类型<ul>
<li>占用空间固定，保存在栈中</li>
<li>保存复制的是值本身</li>
<li>使用typeof检测数据的类型</li>
<li>基本类型数据是值类型</li>
</ul>
</li>
<li>引用类型<ul>
<li>占用空间不固定，保存在堆中</li>
<li>保存和复制的是指向对象的一个指针</li>
<li>使用instanceof检测数据的类型</li>
<li>使用new（）方法构造出来的对象是引用型的</li>
</ul>
</li>
</ul>
<h5 id="2-作用域-2"><a href="#2-作用域-2" class="headerlink" title="2.作用域"></a>2.作用域</h5><ul>
<li>全局变量<ul>
<li>在函数体外定义的变量或者在函数体内部定义的无var的变量</li>
<li>在任何位置都可以调用</li>
</ul>
</li>
<li>局部变量<ul>
<li>在函数体内部用var声明的变量或函数的参数变量</li>
<li>在当前函数体内部调用</li>
</ul>
</li>
<li>优先级<ul>
<li>同名全局变量 &gt; 参数变量 &gt; 局部变量 &gt; 全局变量</li>
</ul>
</li>
<li>特性<ul>
<li>忽略块级作用域</li>
<li>全局变量是全局对象的属性</li>
<li>局部变量是调用对象的属性</li>
<li>作用域链<ul>
<li>内层函数可以访问外层函数的局部变量</li>
<li>外层函数不能访问内层函数局部变量</li>
</ul>
</li>
<li>生命周期<ul>
<li>全局变量：除非被显示删除，否则一直存在</li>
<li>局部变量：自声明起至函数运行完毕或者显示删除</li>
<li>收回机制<ul>
<li>标记清除，引用计数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-数据类型-2"><a href="#4-数据类型-2" class="headerlink" title="4.数据类型"></a>4.数据类型</h4><h5 id="1-数字-Number-2"><a href="#1-数字-Number-2" class="headerlink" title="1.数字 Number"></a>1.数字 Number</h5><h5 id="2-字符串String-2"><a href="#2-字符串String-2" class="headerlink" title="2.字符串String"></a>2.字符串String</h5><ul>
<li><p>由0个或多个16位Unicode字符组成</p>
</li>
<li><p>单引号与双引号不能交叉使用</p>
</li>
<li><p>使用length属性访问字符串长度</p>
<ul>
<li>转义字符算一个字符</li>
<li>无法精确返回双字节字符长度</li>
</ul>
</li>
<li><p>字符串一旦被创建，其值将不能修改，若要改变必须销毁原有字符串</p>
</li>
<li><p>不要创建 String 对象。它会拖慢执行速度，并可能产生其他副作用</p>
</li>
<li><p>类型转换</p>
<ul>
<li><p>toString（）使用类型</p>
<p>​     1.number</p>
<p>​     2.boolean</p>
<p>​     3.string</p>
<p>​     4.object</p>
</li>
<li><p>eval()：计算字符串表达式的值并以数值形式返回</p>
</li>
</ul>
</li>
</ul>
<h5 id="3-布尔Boolean-2"><a href="#3-布尔Boolean-2" class="headerlink" title="3.布尔Boolean"></a>3.布尔Boolean</h5><ul>
<li><p>任何值和布尔值比较时，<strong>两边都会转化为Number类型</strong></p>
</li>
<li><p>[0]用if判断的时候为true，和布尔值比较的时候转换为0。{x:0}用if判断的时候为true，和布尔值比较的时候转换为NaN</p>
</li>
<li><p>转换为true</p>
<ul>
<li>任何非空字符串</li>
<li>任何非0的数值</li>
<li>数组和对象（包括空数组和空对象）</li>
</ul>
</li>
<li><p>转换为false</p>
<ul>
<li>空字符串</li>
<li>0和NaN</li>
<li>null和undefined</li>
</ul>
</li>
</ul>
<h5 id="4-数组Array-2"><a href="#4-数组Array-2" class="headerlink" title="4.数组Array"></a>4.数组Array</h5><ul>
<li><p>对象Object</p>
</li>
<li><p>空Null</p>
<ul>
<li>逻辑上null表示一个空对象的指针，使用typeof检测时会返回object</li>
</ul>
</li>
<li><p>未定义Undefined</p>
<ul>
<li>使用var声明变量但未初始化</li>
<li>区分空对象指针与尚未定义的变量</li>
<li>对未初始化的变量及未声明的变量使用typeof运算符均会返回undefined</li>
</ul>
</li>
<li><h5 id="undefined与null的关系-2"><a href="#undefined与null的关系-2" class="headerlink" title="undefined与null的关系"></a>undefined与null的关系</h5><ul>
<li>undefined派生于null因此在使用“==”进行比较的时候会返回true</li>
<li>没有必要将变量值声明为undefined</li>
<li>声明空对象的时候应将其值赋值为null</li>
</ul>
</li>
</ul>
<h5 id="5-非数值NaN-Not-a-Number-2"><a href="#5-非数值NaN-Not-a-Number-2" class="headerlink" title="5.非数值NaN(Not a Number)"></a>5.非数值NaN(Not a Number)</h5><ul>
<li><p>任何涉及NaN的操作都将返回NaN</p>
</li>
<li><h6 id="NaN与任何数值都不相等包括自身-2"><a href="#NaN与任何数值都不相等包括自身-2" class="headerlink" title="NaN与任何数值都不相等包括自身"></a>NaN与任何数值都不相等包括自身</h6></li>
<li><p>检测isNaN（）</p>
<ul>
<li>可转换成数值false</li>
<li>不可转换成数值true</li>
</ul>
</li>
</ul>
<h5 id="6-未定义undefined-2"><a href="#6-未定义undefined-2" class="headerlink" title="6.未定义undefined"></a>6.未定义undefined</h5><ul>
<li>变量声明了却没有赋值</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于undefined</li>
<li>对象没有赋值的属性</li>
<li>函数没有返回值，默认返回undefined</li>
</ul>
<h4 id="5-数值转换-2"><a href="#5-数值转换-2" class="headerlink" title="5.数值转换"></a>5.数值转换</h4><h5 id="1-Number-2"><a href="#1-Number-2" class="headerlink" title="1.Number()"></a>1.Number()</h5><ul>
<li>Boolean——(true  1)(false  0)</li>
<li>null——0</li>
<li>undefined / { }———NaN    (<code>null</code>是一个表示”无”的对象，转为数值时为<code>0</code>；<code>undefined</code>是一个表示”无”的原始值，转为数值时为<code>NaN</code>)</li>
<li>String除数字和空字符串（0）外，其余都是NaN</li>
</ul>
<h5 id="2-解析parseInt（“要解析的字符串”，转换时使用的基数）-2"><a href="#2-解析parseInt（“要解析的字符串”，转换时使用的基数）-2" class="headerlink" title="2.解析parseInt（“要解析的字符串”，转换时使用的基数）"></a>2.解析parseInt（“要解析的字符串”，转换时使用的基数）</h5><ul>
<li>忽略前置空格</li>
<li>直接找到第一个非空格字符<ul>
<li>NaN：不是数字字符或符号</li>
<li>如果是数字字符解析所有后续字符，或一直解析直到遇到非数字字符便结束</li>
</ul>
</li>
</ul>
<h5 id="3-parseFloat（）-2"><a href="#3-parseFloat（）-2" class="headerlink" title="3.parseFloat（）"></a>3.parseFloat（）</h5><ul>
<li>从第一个字符开始解析，遇到无效浮点格式后结束</li>
<li>只有第一个小数点有效，忽略前导0</li>
<li>十六进制数始终为0，没有小数点或小数点后全0</li>
</ul>
<h4 id="6-对象object-2"><a href="#6-对象object-2" class="headerlink" title="6.对象object"></a>6.对象object</h4><ul>
<li>一组数据或功能的集合</li>
<li>声明 var  o=new Object（）</li>
<li>属性和方法<ul>
<li>Constructor：保存用于创建当前对象的函数</li>
<li>hasOwnProperty（propertyName）：检测给定属性在当前对象实例中是否存在</li>
<li>isPrototypeOf（object）检测传入的对象是否为另一个对象的原型</li>
<li>propertyisEnumerable（propertyName）检测给定属性是否能用for-in语句枚举</li>
<li>toLocalString（）返回对象的字符串表示，该字符串与执行环境的地区对应</li>
<li>toString（）返回对象的字符串表示</li>
<li>valueOf（）返回对象的字符串，数值或布尔值表示；通常和toString（）的值相同</li>
</ul>
</li>
</ul>
<h5 id="https-blog-csdn-net-IT-10-article-details-81806665-2"><a href="#https-blog-csdn-net-IT-10-article-details-81806665-2" class="headerlink" title="https://blog.csdn.net/IT_10/article/details/81806665"></a><a href="https://blog.csdn.net/IT_10/article/details/81806665" target="_blank" rel="noopener">https://blog.csdn.net/IT_10/article/details/81806665</a></h5><h2 id="四-数据类型的概述-2"><a href="#四-数据类型的概述-2" class="headerlink" title="四 . 数据类型的概述"></a>四 . 数据类型的概述</h2><h4 id="1-六大数据类型（number-string-boolean-undefined-null-onject-2"><a href="#1-六大数据类型（number-string-boolean-undefined-null-onject-2" class="headerlink" title="1.六大数据类型（number,string,boolean,undefined,null,onject)"></a>1.六大数据类型（number,string,boolean,undefined,null,onject)</h4><ul>
<li>原始类型（primitive type）<ul>
<li>不能再细分，最基本的数据类型</li>
<li>number，string，boolean</li>
</ul>
</li>
<li>合成类型（complex type）<ul>
<li>可看作一个存放多个原始类型值的容器</li>
<li>狭义对象（object），数组（array），函数（function）</li>
</ul>
</li>
<li>undefined和null一般将他们看成两个特殊值</li>
<li>狭义的对象（object）和数组是两种不同的数据组合方式，而函数其实是处理数据的方法。js把函数当成一种数据类型，可以像其他类型的数据一样，进行赋值和传递，这为编程带来了很大的灵活性，体现了js作为“函数式语言”的本质</li>
<li>js的所有数据都可以视为广义的对象。不仅数组和函数属于对象，就连原始值也可用对象方式调用，（不过都是隐式转换，就像输入数值都会隐式转换成字符串数值一样）</li>
</ul>
<h4 id="2-确定值是什么类型的几种方法-2"><a href="#2-确定值是什么类型的几种方法-2" class="headerlink" title="2.确定值是什么类型的几种方法"></a>2.确定值是什么类型的几种方法</h4><h6 id="1-typeof运算符-2"><a href="#1-typeof运算符-2" class="headerlink" title="1.typeof运算符"></a>1.typeof运算符</h6><ul>
<li>typeof 123     //“number”</li>
<li>typeof  ‘123’   //“string”</li>
<li>typeof   false  //“boolean”</li>
<li>function  f（）{}  typeof  f   //“function”</li>
<li>typeof   undefined   //“undefined”（利用这一点，可用来检查一个没有申明的变量而不报错）</li>
<li>typeof   window / { } / [ ]  / null    //“object”（表明数组本质上只是一种特殊的对象。<code>null</code>的类型也是<code>object</code>，这是由于历史原因造成的）</li>
</ul>
<h6 id="2-instanceof运算符-2"><a href="#2-instanceof运算符-2" class="headerlink" title="2.instanceof运算符"></a>2.instanceof运算符</h6><ul>
<li>解决typeof没法区分数组和对象的缺陷</li>
<li>{}/[] instanceof  Object/Array     //true</li>
<li>(function(0{}))   instanceof  Function     //true</li>
<li>原始类型   instanceof    各种类型     //一般都是false</li>
</ul>
<h6 id="3-Object-prototype-toString方法-2"><a href="#3-Object-prototype-toString方法-2" class="headerlink" title="3.Object.prototype.toString方法"></a>3.Object.prototype.toString方法</h6><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call([1,2,3])</span><br><span class="line">   &apos;[object Array]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="4-应用typeof方法写方法-2"><a href="#4-应用typeof方法写方法-2" class="headerlink" title="4.应用typeof方法写方法"></a>4.应用typeof方法写方法</h6><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var toType = function(obj) &#123;</span><br><span class="line">   return (&#123;&#125;).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">toType(&#123;a: 4&#125;) // &quot;object&quot;</span><br><span class="line">   toType([1, 2, 3]) // &quot;array&quot;</span><br><span class="line">   (function() &#123; return toType(arguments) &#125;()) // &quot;arguments&quot;</span><br><span class="line">   toType(new ReferenceError()) // &quot;error&quot;</span><br><span class="line">   toType(new Date()) // &quot;date&quot;</span><br><span class="line">   toType(/a-z/) // &quot;regexp&quot;</span><br><span class="line">   toType(Math) // &quot;math&quot;</span><br><span class="line">   toType(JSON) // &quot;json&quot;</span><br><span class="line">   toType(new Number(4)) // &quot;number&quot;</span><br><span class="line">   toType(new String(&quot;abc&quot;)) // &quot;string&quot;</span><br><span class="line">   toType(new Boolean(true)) // &quot;boolean&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2011/11/improving-typeof.html" target="_blank" rel="noopener">Improving the JavaScript typeof operator</a></li>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2013/01/categorizing-values.html" target="_blank" rel="noopener">Categorizing values in JavaScript</a></li>
</ul>
<h2 id="五-JavaScript函数-2"><a href="#五-JavaScript函数-2" class="headerlink" title="五 . JavaScript函数"></a>五 . JavaScript函数</h2><h4 id="1-定义方法-2"><a href="#1-定义方法-2" class="headerlink" title="1.定义方法"></a>1.定义方法</h4><ul>
<li>静态方法function function nane（){执行代码}</li>
<li>动态匿名方法  var 函数名=new Function([“虚参数列表”]，“函数体”)；</li>
<li>直接量方法  函数名=function（【虚参列表】）{函数体}</li>
</ul>
<h4 id="2-调用方法-2"><a href="#2-调用方法-2" class="headerlink" title="2.调用方法"></a>2.调用方法</h4><ul>
<li><p>函数作为对象方法调用，会使得 <strong>this</strong> 的值成为对象本身。</p>
</li>
<li><p><strong>call()</strong>（传入的参数是一系列的参数值，但是从第二个参数开始） 和 <strong>apply()</strong> （传入的参数只能是由各参数值组成的数组）是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身。</p>
</li>
<li><p>在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 <strong>this</strong> 的值， 即使该参数不是一个对象。</p>
</li>
<li><p>在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。</p>
</li>
<li><p>在 HTML 中默认的全局对象是 HTML 页面本身，所以函数是属于 HTML 页面。</p>
</li>
<li><p>在浏览器中的页面对象是浏览器窗口(window 对象)。以上函数会自动变为 window 对象的函数。</p>
</li>
<li><p>直接调用    函数名（实参列表）</p>
</li>
<li><p>在连接中调用   <a href="javascript:函数名()" target="_blank" rel="noopener"></a></p>
</li>
<li><p>在事件中调用     事件类型=“函数名（）”</p>
</li>
<li><p>递归调用（在函数体内部调用自身）   function  函数名(){代码    函数名（）；}</p>
</li>
<li><p>构造函数调用</p>
<ul>
<li><p>构造函数中 <strong>this</strong> 关键字没有任何的值。<br><strong>this</strong> 的值在函数调用时实例化对象(new object)时创建。</p>
</li>
<li><p>如果函数或者方法调用之前带有关键字new，他就构成构造函数调用。凡是没有形参的构造函数调用都可以省略圆括号 var  o=new Object;</p>
</li>
<li><p>立即调用函数（IIFE)</p>
<ul>
<li><p>一对圆括号()是一种运算符，跟在函数名之后，表示调用该函数</p>
</li>
<li><p>(function(){  </p>
<p>statement</p>
<p>}())</p>
</li>
<li><p>上面代码的圆括号的用法，function之前的左圆括号是必需的，因为如果不写这个左圆括号，JavaScript解释器会试图将关键字function解析为函数声明语句。而使用圆括号，JavaScript解释器才会正确地将其解析为函数定义表达式。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-常用方法-2"><a href="#3-常用方法-2" class="headerlink" title="3.常用方法"></a>3.常用方法</h4><ul>
<li>apply：将函数作为对象的方法来调用，将参数传递给该方法</li>
<li>call：将函数作为对象的方法来调用，将参数传递给该方法</li>
<li>toString：返回函数的字符串表示</li>
</ul>
<h4 id="4-arguments对象-2"><a href="#4-arguments对象-2" class="headerlink" title="4.arguments对象"></a>4.arguments对象</h4><ul>
<li><p>功能：存放实参的参数列表</p>
</li>
<li><p>特性 </p>
<ul>
<li>仅能在函数体内使用</li>
<li>带有下标属性，但并非数组</li>
<li>函数声明时自动初始化</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li><p>length：获取函数实参的长度</p>
</li>
<li><p>callee ：返回当前正在指向的对象</p>
</li>
<li><p>caller：返回调用当前正在执行函数的函数名</p>
</li>
<li><p>name属性：返回紧跟在function关键字后的那个函数名</p>
</li>
<li><p>toString方法返回函数的源码</p>
</li>
<li><p>eval命令的作用是将字符串当作语句执行，eval没有自己的作用域，都是在当前作用域内执行</p>
<p>eval（‘var  a=1’）；</p>
<p>JavaScript规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。</p>
<p>(function(){</p>
<p>  ‘use strict’;</p>
<p>  eval(‘var a=1’);</p>
<p>  console.log(a);  //ReferenceError: a is not defined</p>
<p>})();</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-指针标识-2"><a href="#5-指针标识-2" class="headerlink" title="5.指针标识"></a>5.指针标识</h4><ul>
<li><p>this：指向当前操作对象</p>
</li>
<li><p>callee：指向参数集合所属函数</p>
</li>
<li><p>prototype：指向函数附带的原型对象</p>
</li>
<li><p>constructor：指向创建该函数的构造函数</p>
</li>
<li><p>JavaScript 变量的生命期从它们被声明的时间开始。局部变量会在函数运行以后被删除。全局变量会在页面关闭后被删除。</p>
</li>
<li><p>如果您把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。</p>
</li>
</ul>
<h4 id="6-函数变量提升-2"><a href="#6-函数变量提升-2" class="headerlink" title="6.函数变量提升"></a>6.函数变量提升</h4><ul>
<li>全局变量用var命令声明，不管在什么位置声明，变量声明都会被提升头部</li>
<li>函数作用域内部也会产生变量提升</li>
</ul>
<h4 id="7-闭包-2"><a href="#7-闭包-2" class="headerlink" title="7.闭包"></a>7.<strong>闭包</strong></h4><ul>
<li>JavaScript的函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量，这就是JavaScript的闭包。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。</li>
<li>闭包的另一个用处，是封装对象的私有属性和私有方法。</li>
</ul>
<h4 id="8-数组-2"><a href="#8-数组-2" class="headerlink" title="8.数组"></a>8.数组</h4><ul>
<li><p>数组属于一种特殊的对象</p>
</li>
<li><p>数组长度length属性</p>
<ul>
<li>length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。</li>
<li>将数组清空的一个有效方法，就是将length属性设为0。</li>
<li>如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</li>
<li>在ECMAScript 5中，可以用Object.defineProperty() 让数组的length属性变成只读。</li>
</ul>
</li>
<li><p>空位</p>
<ul>
<li>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位   var   arr=【1，，2】</li>
<li>但是，如果最后一个元素后面有逗号，并不会产生空位。数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。</li>
</ul>
</li>
<li><p><strong>类数组对象</strong></p>
<ul>
<li><p>在JavaScript中，有些对象被称为“类数组对象”。意思是，它们看上去很像数组，可以使用length属性，但是它们并不是数组，无法使用一些数组的方法。</p>
</li>
<li><p>由于类数组对象没有继承自Array.prototype，那就不能在它们上面直接调用数组方法。不过我们可以间接的使用Function.call方法调用。</p>
</li>
</ul>
</li>
</ul>
<h2 id="六-JavaScript错误处理机制-2"><a href="#六-JavaScript错误处理机制-2" class="headerlink" title="六 . JavaScript错误处理机制"></a>六 . JavaScript错误处理机制</h2><ul>
<li><p>javascript解析或执行时，一旦发生错误，引擎就会自动抛出一个错误对象，js提供一个Error构造函数，所有抛出的错误都是这个构造函数的实例 var  err=new  Error（‘出错了’）；err.message</p>
</li>
<li><p>Erroe对象的属性</p>
<ul>
<li>message：错误提示信息</li>
<li>name：错误名称（非标准属性）</li>
<li>stack：错误的堆栈（非标准属性）</li>
</ul>
</li>
<li><p>Error的六大派生对象</p>
<ul>
<li>SyntaxError：是解析代码时发生的错误（变量名错误或者缺少括号）</li>
<li>ReferenceError：是引用一个不存在的变量时发生的的错误或者将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值（console.log()=1)</li>
<li>RangeError:是当一个值超过有效范围时发生的错误，主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值<ul>
<li>new  Array(-1)</li>
<li>(1234).toExponential(21)//toExponential()  argument  must  be  between  0  and  20</li>
</ul>
</li>
<li>TypeError:是参数或变量不是预期类型时发生的错误。比如，对字符串，布尔值，数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数  new 123</li>
<li>URIError：是URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI（），decodeURI（），encodeURIComponent（），decodeURIComponent（），escape（），unescape（）</li>
<li>EvalError:函数没有被正确执行时抛出EvalError错误，该错误类型已不再ES5中出现，只是为了与以前代码兼容</li>
</ul>
</li>
<li><p>自定义错误</p>
<p>function UserError(message){</p>
<p>this.message=message ||”默认信息”；</p>
<p>this.name=”UserError”;}</p>
<p>UserError.prototype=new  Error();</p>
<p>UserError.prototype.constructor=UserError;</p>
</li>
<li><p>throw语句：作用是中断程序执行，抛出一个意外或错误，他接受一个表达式作为参数，可以抛出各种值</p>
</li>
</ul>
<h2 id="七-JavaScript-JSON-2"><a href="#七-JavaScript-JSON-2" class="headerlink" title="七 . JavaScript  JSON"></a>七 . JavaScript  JSON</h2><ul>
<li><p>JSON英文全称JavaScript  Object  Notation</p>
</li>
<li><p>是一种易于理解的独立的语言，也是一种轻量级的数据交换格式</p>
</li>
<li><p>JSON使用JavaScript语法，但是JSON格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据传递格式</p>
</li>
<li><p>语法规则</p>
<ul>
<li>数据以键值对形式出现</li>
<li>数据由逗号分隔</li>
<li>大括号保存对象</li>
<li>方括号保存数组</li>
</ul>
</li>
<li><p>通常我们从服务器中读取JSON数据，并在网页中显示数据</p>
</li>
<li><p>JSON字符串转换为js对象</p>
<ul>
<li><p>创建js字符串，字符串为JSON格式的数据</p>
<p>var text = ‘{ “employees” : [‘ +<br>‘{ “firstName”:”John” , “lastName”:”Doe” },’ +<br>‘{ “firstName”:”Anna” , “lastName”:”Smith” },’ +<br>‘{ “firstName”:”Peter” , “lastName”:”Jones” } ]}’;</p>
</li>
<li><p>然后使用js内置函数JSON.parse（）将字符串转化为js对象</p>
</li>
<li><p>var  obj=JSON.parse（text）；</p>
</li>
<li><p>最后在你的页面使用js对象</p>
</li>
</ul>
</li>
</ul>
<h2 id="八-JavaScript：void（0）的含义-2"><a href="#八-JavaScript：void（0）的含义-2" class="headerlink" title="八 . JavaScript：void（0）的含义"></a>八 . JavaScript：void（0）的含义</h2><ul>
<li><p>void关键字是js中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值</p>
<p><a href="javascript:void(alert('Warning!!!'))" target="_blank" rel="noopener">点我!</a></p>
</li>
<li><h6 id="href-”-”与href-”javascript-void-0-”的区别-2"><a href="#href-”-”与href-”javascript-void-0-”的区别-2" class="headerlink" title="href=”#”与href=”javascript:void(0)”的区别"></a>href=”#”与href=”javascript:void(0)”的区别</h6><p><strong>#</strong> 包含了一个位置信息，默认的锚是<strong>#top</strong> 也就是网页的上端。</p>
<p>而javascript:void(0), 仅仅表示一个死链接。</p>
<p>在页面很长的时候会使用 <strong>#</strong> 来定位页面的具体位置，格式为：<strong># + id</strong>。</p>
<p>如果你要定义一个死链接请使用 javascript:void(0) 。</p>
</li>
<li><p>void()仅仅是代表不返回任何值，但是括号内的表达式还是要运行</p>
</li>
</ul>
<h2 id="九-命名规范-2"><a href="#九-命名规范-2" class="headerlink" title="九 . 命名规范"></a>九 . 命名规范</h2><ul>
<li><p>变量名应该区分大小写，允许包含字母、数字、美元符号($)和下划线，但第一个字符不允许是数字，不允许包含空格和其他标点符号；</p>
</li>
<li><p>变量命名长度应该尽可能的短，并抓住要点，尽量在变量名中体现出值的类型；</p>
</li>
<li><p>变量名的命名应该是有意义的；</p>
</li>
<li><p>变量名不能为JavaScript中的关键词、保留字全名；</p>
</li>
<li><p>变量名命名方法常见的有匈牙利命名法、驼峰命名法和帕斯卡命名法。</p>
</li>
<li><h6 id="空格与运算符-2"><a href="#空格与运算符-2" class="headerlink" title="空格与运算符"></a>空格与运算符</h6><p>通常运算符 ( = + - * / ) 前后需要添加空格:</p>
</li>
<li><h6 id="代码缩进-2"><a href="#代码缩进-2" class="headerlink" title="代码缩进"></a>代码缩进</h6><p>通常使用 4 个空格符号来缩进代码块：</p>
<p>注意:不推荐使用 TAB 键来缩进，因为不同编辑器 TAB 键的解析不一样。</p>
</li>
<li><p>复杂语句的通用规则:</p>
<ul>
<li>一条语句通常以分号作为结束符。</li>
<li>将左花括号放在第一行的结尾。</li>
<li>左花括号前添加一空格。</li>
<li>将右花括号独立放在一行。</li>
<li>不要以分号结束一个复杂的声明。</li>
</ul>
</li>
<li><p>对象定义的规则:</p>
<ul>
<li>将左花括号与类名放在同一行。</li>
<li>冒号与属性值间有个空格。</li>
<li>字符串使用双引号，数字不需要。</li>
<li>最后一个属性-值对后面不要添加逗号。</li>
<li>将右花括号独立放在一行，并以分号作为结束符号。</li>
</ul>
</li>
<li><h6 id="命名规则-2"><a href="#命名规则-2" class="headerlink" title="命名规则"></a>命名规则</h6><ul>
<li>变量和函数为驼峰法（ <strong>camelCase</strong>）</li>
<li>全局变量为大写 (<strong>UPPERCASE</strong> )</li>
<li>常量 (如 PI) 为大写 (<strong>UPPERCASE</strong> )</li>
</ul>
</li>
</ul>
<h2 id="十-文档对象模型HTML-DOM-2"><a href="#十-文档对象模型HTML-DOM-2" class="headerlink" title="十.文档对象模型HTML DOM"></a>十.文档对象模型HTML DOM</h2><p><img src="https://7n.w3cschool.cn/statics/images/course/pic_htmltree.gif" alt="DOM HTML tree"></p>
<ul>
<li>通过可编程的对象模型，js能够改变页面中的所有HTML元素，属性，CSS样式，能对页面中的所有事件作出反应</li>
</ul>
<h4 id="1-找HTML元素-2"><a href="#1-找HTML元素-2" class="headerlink" title="1.找HTML元素"></a>1.找HTML元素</h4><ul>
<li>通过id    document.getElementById(“id值”);</li>
<li>通过标签名   document.getElementByTagName(“标签名”);</li>
<li>通过类名    document.getElementByClassName(“类名”)；</li>
</ul>
<h4 id="2-节点指针-2"><a href="#2-节点指针-2" class="headerlink" title="2.节点指针"></a>2.节点指针</h4><ul>
<li>firstChild ：获取元素的首个子节点</li>
<li>lastChild ：获取元素的最后一个子节点</li>
<li>父节点.childNodes ：获取元素的子节点列表</li>
<li>兄弟节点.previousSibling：获取已知节点的前一个节点</li>
<li>兄弟节点.nextSibling ： 获取已知节点的后一个节点</li>
<li>子节点.parentNode :获取已知节点的父节点</li>
</ul>
<h4 id="3-创建节点-2"><a href="#3-创建节点-2" class="headerlink" title="3.创建节点"></a>3.创建节点</h4><ul>
<li>创建元素节点    document.createElement(元素标签)</li>
<li>创建属性节点     document.createAttribute(元素属性)</li>
<li>创建文本节点     document.createTextNode(文本内容)</li>
</ul>
<h4 id="4-插入节点-2"><a href="#4-插入节点-2" class="headerlink" title="4.插入节点"></a>4.插入节点</h4><ul>
<li>向节点的子节点列表的末尾添加新的子节点           appendChild（所添加的新节点）</li>
<li>在已知的子节点前插入一个新的子节点      insertBefore（所要添加的新节点，已知节点）</li>
</ul>
<p><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470709730442234.gif" alt="img"></p>
<h4 id="5-改变HTML元素样式-2"><a href="#5-改变HTML元素样式-2" class="headerlink" title="5.改变HTML元素样式"></a>5.改变HTML元素样式</h4><p>document.getElementById(id).style.property=new style;</p>
<h4 id="6-添加监听事件-2"><a href="#6-添加监听事件-2" class="headerlink" title="6.添加监听事件"></a>6.添加监听事件</h4><p>element.addEventListener(event,function,useCapture);</p>
<p>第一个参数就是事件的类型（如“click”或“mousedown”。注意不要使用“on”前缀，是“click”而非“onclick”）</p>
<p>第二个参数就是事件触发时调用的函数</p>
<p>第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的</p>
<h4 id="7-事件冒泡或事件捕获？-1"><a href="#7-事件冒泡或事件捕获？-1" class="headerlink" title="7.事件冒泡或事件捕获？"></a>7.事件冒泡或事件捕获？</h4><p>事件传递有两种方式：冒泡与捕获。</p>
<p>事件传递定义了元素事件触发的顺序。 如果你将 </p><p> 元素插入到 <div> 元素中，用户点击 <p> 元素, 哪个元素的 “click” 事件先被触发呢？</p>
<p>在冒泡中，内部元素的事件会先被触发，然后再触发外部元素，即： </p><p> 元素的点击事件先触发，然后会触发 <div> 元素的点击事件。</div></p>
<p>在捕获中，外部元素的事件会先被触发</p>
<p><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470710444592947.gif" alt="img"></p>
</div></p></div></p></div></p>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2020/06/17/js基础/">js基础</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">陈楚吟</a></p>
        <p><span>发布时间:</span>2020-06-17, 15:14:31</p>
        <p><span>最后更新:</span>2020-06-17, 15:17:23</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2020/06/17/js基础/" title="js基础">http://yoursite.com/2020/06/17/js基础/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2020/06/17/js基础/　　作者: 陈楚吟" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2020/06/17/js精研/">
                    js精研
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2020/06/13/刷题笔记/">
                    刷题笔记
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-js简介"><span class="toc-number">1.</span> <span class="toc-text">一 . js简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-概念"><span class="toc-number">1.0.1.</span> <span class="toc-text">1.概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-支持编译运行。"><span class="toc-number">1.0.2.</span> <span class="toc-text">2.支持编译运行。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-事件驱动和非阻塞式设计"><span class="toc-number">1.0.3.</span> <span class="toc-text">3.事件驱动和非阻塞式设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-javascript与java的关系"><span class="toc-number">1.0.4.</span> <span class="toc-text">4.javascript与java的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-输出"><span class="toc-number">2.</span> <span class="toc-text">二 . 输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-直接写入HTML输出流"><span class="toc-number">2.0.1.</span> <span class="toc-text">1.直接写入HTML输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-弹出警告框alert"><span class="toc-number">2.0.2.</span> <span class="toc-text">2.弹出警告框alert</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-在指定位置输出innerHTML"><span class="toc-number">2.0.3.</span> <span class="toc-text">3.在指定位置输出innerHTML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-在控制台上输出"><span class="toc-number">2.0.4.</span> <span class="toc-text">4.在控制台上输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-js基本语法"><span class="toc-number">3.</span> <span class="toc-text">三 . js基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-语句"><span class="toc-number">3.0.1.</span> <span class="toc-text">1.语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-js用法"><span class="toc-number">3.0.2.</span> <span class="toc-text">2.js用法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#js区分大小写"><span class="toc-number">3.0.2.1.</span> <span class="toc-text">js区分大小写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-变量"><span class="toc-number">3.0.3.</span> <span class="toc-text">3.变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-变量类型"><span class="toc-number">3.0.3.1.</span> <span class="toc-text">1 .变量类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-作用域"><span class="toc-number">3.0.3.2.</span> <span class="toc-text">2.作用域</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-数据类型"><span class="toc-number">3.0.4.</span> <span class="toc-text">4.数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-数字-Number"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">1.数字 Number</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-字符串String"><span class="toc-number">3.0.4.2.</span> <span class="toc-text">2.字符串String</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-布尔Boolean"><span class="toc-number">3.0.4.3.</span> <span class="toc-text">3.布尔Boolean</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-数组Array"><span class="toc-number">3.0.4.4.</span> <span class="toc-text">4.数组Array</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#undefined与null的关系"><span class="toc-number">3.0.4.5.</span> <span class="toc-text">undefined与null的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-非数值NaN-Not-a-Number"><span class="toc-number">3.0.4.6.</span> <span class="toc-text">5.非数值NaN(Not a Number)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#NaN与任何数值都不相等包括自身"><span class="toc-number">3.0.4.6.1.</span> <span class="toc-text">NaN与任何数值都不相等包括自身</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-未定义undefined"><span class="toc-number">3.0.4.7.</span> <span class="toc-text">6.未定义undefined</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-数值转换"><span class="toc-number">3.0.5.</span> <span class="toc-text">5.数值转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Number"><span class="toc-number">3.0.5.1.</span> <span class="toc-text">1.Number()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-解析parseInt（“要解析的字符串”，转换时使用的基数）"><span class="toc-number">3.0.5.2.</span> <span class="toc-text">2.解析parseInt（“要解析的字符串”，转换时使用的基数）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-parseFloat（）"><span class="toc-number">3.0.5.3.</span> <span class="toc-text">3.parseFloat（）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-对象object"><span class="toc-number">3.0.6.</span> <span class="toc-text">6.对象object</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#https-blog-csdn-net-IT-10-article-details-81806665"><span class="toc-number">3.0.6.1.</span> <span class="toc-text">https://blog.csdn.net/IT_10/article/details/81806665</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-数据类型的概述"><span class="toc-number">4.</span> <span class="toc-text">四 . 数据类型的概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-六大数据类型（number-string-boolean-undefined-null-onject"><span class="toc-number">4.0.1.</span> <span class="toc-text">1.六大数据类型（number,string,boolean,undefined,null,onject)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-确定值是什么类型的几种方法"><span class="toc-number">4.0.2.</span> <span class="toc-text">2.确定值是什么类型的几种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-typeof运算符"><span class="toc-number">4.0.2.0.1.</span> <span class="toc-text">1.typeof运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-instanceof运算符"><span class="toc-number">4.0.2.0.2.</span> <span class="toc-text">2.instanceof运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-Object-prototype-toString方法"><span class="toc-number">4.0.2.0.3.</span> <span class="toc-text">3.Object.prototype.toString方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-应用typeof方法写方法"><span class="toc-number">4.0.2.0.4.</span> <span class="toc-text">4.应用typeof方法写方法</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-JavaScript函数"><span class="toc-number">5.</span> <span class="toc-text">五 . JavaScript函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-定义方法"><span class="toc-number">5.0.1.</span> <span class="toc-text">1.定义方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-调用方法"><span class="toc-number">5.0.2.</span> <span class="toc-text">2.调用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-常用方法"><span class="toc-number">5.0.3.</span> <span class="toc-text">3.常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-arguments对象"><span class="toc-number">5.0.4.</span> <span class="toc-text">4.arguments对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-指针标识"><span class="toc-number">5.0.5.</span> <span class="toc-text">5.指针标识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-函数变量提升"><span class="toc-number">5.0.6.</span> <span class="toc-text">6.函数变量提升</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-闭包"><span class="toc-number">5.0.7.</span> <span class="toc-text">7.闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-数组"><span class="toc-number">5.0.8.</span> <span class="toc-text">8.数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六-JavaScript错误处理机制"><span class="toc-number">6.</span> <span class="toc-text">六 . JavaScript错误处理机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七-JavaScript-JSON"><span class="toc-number">7.</span> <span class="toc-text">七 . JavaScript  JSON</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八-JavaScript：void（0）的含义"><span class="toc-number">8.</span> <span class="toc-text">八 . JavaScript：void（0）的含义</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#href-”-”与href-”javascript-void-0-”的区别"><span class="toc-number">8.0.0.0.1.</span> <span class="toc-text">href=”#”与href=”javascript:void(0)”的区别</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九-命名规范"><span class="toc-number">9.</span> <span class="toc-text">九 . 命名规范</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#空格与运算符"><span class="toc-number">9.0.0.0.1.</span> <span class="toc-text">空格与运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#代码缩进"><span class="toc-number">9.0.0.0.2.</span> <span class="toc-text">代码缩进</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#命名规则"><span class="toc-number">9.0.0.0.3.</span> <span class="toc-text">命名规则</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十-文档对象模型HTML-DOM"><span class="toc-number">10.</span> <span class="toc-text">十.文档对象模型HTML DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-找HTML元素"><span class="toc-number">10.0.1.</span> <span class="toc-text">1.找HTML元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-节点指针"><span class="toc-number">10.0.2.</span> <span class="toc-text">2.节点指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-创建节点"><span class="toc-number">10.0.3.</span> <span class="toc-text">3.创建节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-插入节点"><span class="toc-number">10.0.4.</span> <span class="toc-text">4.插入节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-改变HTML元素样式"><span class="toc-number">10.0.5.</span> <span class="toc-text">5.改变HTML元素样式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-添加监听事件"><span class="toc-number">10.0.6.</span> <span class="toc-text">6.添加监听事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-事件冒泡或事件捕获"><span class="toc-number">10.0.7.</span> <span class="toc-text">7.事件冒泡或事件捕获</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一-js简介-1"><span class="toc-number">11.</span> <span class="toc-text">一 . js简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-概念-1"><span class="toc-number">11.0.1.</span> <span class="toc-text">1.概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-支持编译运行。-1"><span class="toc-number">11.0.2.</span> <span class="toc-text">2.支持编译运行。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-事件驱动和非阻塞式设计-1"><span class="toc-number">11.0.3.</span> <span class="toc-text">3.事件驱动和非阻塞式设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-javascript与java的关系-1"><span class="toc-number">11.0.4.</span> <span class="toc-text">4.javascript与java的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-输出-1"><span class="toc-number">12.</span> <span class="toc-text">二 . 输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-直接写入HTML输出流-1"><span class="toc-number">12.0.1.</span> <span class="toc-text">1.直接写入HTML输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-弹出警告框alert-1"><span class="toc-number">12.0.2.</span> <span class="toc-text">2.弹出警告框alert</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-在指定位置输出innerHTML-1"><span class="toc-number">12.0.3.</span> <span class="toc-text">3.在指定位置输出innerHTML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-在控制台上输出-1"><span class="toc-number">12.0.4.</span> <span class="toc-text">4.在控制台上输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-js基本语法-1"><span class="toc-number">13.</span> <span class="toc-text">三 . js基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-语句-1"><span class="toc-number">13.0.1.</span> <span class="toc-text">1.语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-js用法-1"><span class="toc-number">13.0.2.</span> <span class="toc-text">2.js用法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#js区分大小写-1"><span class="toc-number">13.0.2.1.</span> <span class="toc-text">js区分大小写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-变量-1"><span class="toc-number">13.0.3.</span> <span class="toc-text">3.变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-变量类型-1"><span class="toc-number">13.0.3.1.</span> <span class="toc-text">1 .变量类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-作用域-1"><span class="toc-number">13.0.3.2.</span> <span class="toc-text">2.作用域</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-数据类型-1"><span class="toc-number">13.0.4.</span> <span class="toc-text">4.数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-数字-Number-1"><span class="toc-number">13.0.4.1.</span> <span class="toc-text">1.数字 Number</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-字符串String-1"><span class="toc-number">13.0.4.2.</span> <span class="toc-text">2.字符串String</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-布尔Boolean-1"><span class="toc-number">13.0.4.3.</span> <span class="toc-text">3.布尔Boolean</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-数组Array-1"><span class="toc-number">13.0.4.4.</span> <span class="toc-text">4.数组Array</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#undefined与null的关系-1"><span class="toc-number">13.0.4.5.</span> <span class="toc-text">undefined与null的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-非数值NaN-Not-a-Number-1"><span class="toc-number">13.0.4.6.</span> <span class="toc-text">5.非数值NaN(Not a Number)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#NaN与任何数值都不相等包括自身-1"><span class="toc-number">13.0.4.6.1.</span> <span class="toc-text">NaN与任何数值都不相等包括自身</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-未定义undefined-1"><span class="toc-number">13.0.4.7.</span> <span class="toc-text">6.未定义undefined</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-数值转换-1"><span class="toc-number">13.0.5.</span> <span class="toc-text">5.数值转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Number-1"><span class="toc-number">13.0.5.1.</span> <span class="toc-text">1.Number()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-解析parseInt（“要解析的字符串”，转换时使用的基数）-1"><span class="toc-number">13.0.5.2.</span> <span class="toc-text">2.解析parseInt（“要解析的字符串”，转换时使用的基数）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-parseFloat（）-1"><span class="toc-number">13.0.5.3.</span> <span class="toc-text">3.parseFloat（）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-对象object-1"><span class="toc-number">13.0.6.</span> <span class="toc-text">6.对象object</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#https-blog-csdn-net-IT-10-article-details-81806665-1"><span class="toc-number">13.0.6.1.</span> <span class="toc-text">https://blog.csdn.net/IT_10/article/details/81806665</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-数据类型的概述-1"><span class="toc-number">14.</span> <span class="toc-text">四 . 数据类型的概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-六大数据类型（number-string-boolean-undefined-null-onject-1"><span class="toc-number">14.0.1.</span> <span class="toc-text">1.六大数据类型（number,string,boolean,undefined,null,onject)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-确定值是什么类型的几种方法-1"><span class="toc-number">14.0.2.</span> <span class="toc-text">2.确定值是什么类型的几种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-typeof运算符-1"><span class="toc-number">14.0.2.0.1.</span> <span class="toc-text">1.typeof运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-instanceof运算符-1"><span class="toc-number">14.0.2.0.2.</span> <span class="toc-text">2.instanceof运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-Object-prototype-toString方法-1"><span class="toc-number">14.0.2.0.3.</span> <span class="toc-text">3.Object.prototype.toString方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-应用typeof方法写方法-1"><span class="toc-number">14.0.2.0.4.</span> <span class="toc-text">4.应用typeof方法写方法</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-JavaScript函数-1"><span class="toc-number">15.</span> <span class="toc-text">五 . JavaScript函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-定义方法-1"><span class="toc-number">15.0.1.</span> <span class="toc-text">1.定义方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-调用方法-1"><span class="toc-number">15.0.2.</span> <span class="toc-text">2.调用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-常用方法-1"><span class="toc-number">15.0.3.</span> <span class="toc-text">3.常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-arguments对象-1"><span class="toc-number">15.0.4.</span> <span class="toc-text">4.arguments对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-指针标识-1"><span class="toc-number">15.0.5.</span> <span class="toc-text">5.指针标识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-函数变量提升-1"><span class="toc-number">15.0.6.</span> <span class="toc-text">6.函数变量提升</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-闭包-1"><span class="toc-number">15.0.7.</span> <span class="toc-text">7.闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-数组-1"><span class="toc-number">15.0.8.</span> <span class="toc-text">8.数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六-JavaScript错误处理机制-1"><span class="toc-number">16.</span> <span class="toc-text">六 . JavaScript错误处理机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七-JavaScript-JSON-1"><span class="toc-number">17.</span> <span class="toc-text">七 . JavaScript  JSON</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八-JavaScript：void（0）的含义-1"><span class="toc-number">18.</span> <span class="toc-text">八 . JavaScript：void（0）的含义</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#href-”-”与href-”javascript-void-0-”的区别-1"><span class="toc-number">18.0.0.0.1.</span> <span class="toc-text">href=”#”与href=”javascript:void(0)”的区别</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九-命名规范-1"><span class="toc-number">19.</span> <span class="toc-text">九 . 命名规范</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#空格与运算符-1"><span class="toc-number">19.0.0.0.1.</span> <span class="toc-text">空格与运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#代码缩进-1"><span class="toc-number">19.0.0.0.2.</span> <span class="toc-text">代码缩进</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#命名规则-1"><span class="toc-number">19.0.0.0.3.</span> <span class="toc-text">命名规则</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十-文档对象模型HTML-DOM-1"><span class="toc-number">20.</span> <span class="toc-text">十.文档对象模型HTML DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-找HTML元素-1"><span class="toc-number">20.0.1.</span> <span class="toc-text">1.找HTML元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-节点指针-1"><span class="toc-number">20.0.2.</span> <span class="toc-text">2.节点指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-创建节点-1"><span class="toc-number">20.0.3.</span> <span class="toc-text">3.创建节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-插入节点-1"><span class="toc-number">20.0.4.</span> <span class="toc-text">4.插入节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-改变HTML元素样式-1"><span class="toc-number">20.0.5.</span> <span class="toc-text">5.改变HTML元素样式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-添加监听事件-1"><span class="toc-number">20.0.6.</span> <span class="toc-text">6.添加监听事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-事件冒泡或事件捕获？"><span class="toc-number">20.0.7.</span> <span class="toc-text">7.事件冒泡或事件捕获？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一-js简介-2"><span class="toc-number">21.</span> <span class="toc-text">一 . js简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-概念-2"><span class="toc-number">21.0.1.</span> <span class="toc-text">1.概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-支持编译运行。-2"><span class="toc-number">21.0.2.</span> <span class="toc-text">2.支持编译运行。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-事件驱动和非阻塞式设计-2"><span class="toc-number">21.0.3.</span> <span class="toc-text">3.事件驱动和非阻塞式设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-javascript与java的关系-2"><span class="toc-number">21.0.4.</span> <span class="toc-text">4.javascript与java的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-输出-2"><span class="toc-number">22.</span> <span class="toc-text">二 . 输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-直接写入HTML输出流-2"><span class="toc-number">22.0.1.</span> <span class="toc-text">1.直接写入HTML输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-弹出警告框alert-2"><span class="toc-number">22.0.2.</span> <span class="toc-text">2.弹出警告框alert</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-在指定位置输出innerHTML-2"><span class="toc-number">22.0.3.</span> <span class="toc-text">3.在指定位置输出innerHTML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-在控制台上输出-2"><span class="toc-number">22.0.4.</span> <span class="toc-text">4.在控制台上输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-js基本语法-2"><span class="toc-number">23.</span> <span class="toc-text">三 . js基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-语句-2"><span class="toc-number">23.0.1.</span> <span class="toc-text">1.语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-js用法-2"><span class="toc-number">23.0.2.</span> <span class="toc-text">2.js用法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#js区分大小写-2"><span class="toc-number">23.0.2.1.</span> <span class="toc-text">js区分大小写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-变量-2"><span class="toc-number">23.0.3.</span> <span class="toc-text">3.变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-变量类型-2"><span class="toc-number">23.0.3.1.</span> <span class="toc-text">1 .变量类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-作用域-2"><span class="toc-number">23.0.3.2.</span> <span class="toc-text">2.作用域</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-数据类型-2"><span class="toc-number">23.0.4.</span> <span class="toc-text">4.数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-数字-Number-2"><span class="toc-number">23.0.4.1.</span> <span class="toc-text">1.数字 Number</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-字符串String-2"><span class="toc-number">23.0.4.2.</span> <span class="toc-text">2.字符串String</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-布尔Boolean-2"><span class="toc-number">23.0.4.3.</span> <span class="toc-text">3.布尔Boolean</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-数组Array-2"><span class="toc-number">23.0.4.4.</span> <span class="toc-text">4.数组Array</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#undefined与null的关系-2"><span class="toc-number">23.0.4.5.</span> <span class="toc-text">undefined与null的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-非数值NaN-Not-a-Number-2"><span class="toc-number">23.0.4.6.</span> <span class="toc-text">5.非数值NaN(Not a Number)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#NaN与任何数值都不相等包括自身-2"><span class="toc-number">23.0.4.6.1.</span> <span class="toc-text">NaN与任何数值都不相等包括自身</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-未定义undefined-2"><span class="toc-number">23.0.4.7.</span> <span class="toc-text">6.未定义undefined</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-数值转换-2"><span class="toc-number">23.0.5.</span> <span class="toc-text">5.数值转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Number-2"><span class="toc-number">23.0.5.1.</span> <span class="toc-text">1.Number()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-解析parseInt（“要解析的字符串”，转换时使用的基数）-2"><span class="toc-number">23.0.5.2.</span> <span class="toc-text">2.解析parseInt（“要解析的字符串”，转换时使用的基数）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-parseFloat（）-2"><span class="toc-number">23.0.5.3.</span> <span class="toc-text">3.parseFloat（）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-对象object-2"><span class="toc-number">23.0.6.</span> <span class="toc-text">6.对象object</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#https-blog-csdn-net-IT-10-article-details-81806665-2"><span class="toc-number">23.0.6.1.</span> <span class="toc-text">https://blog.csdn.net/IT_10/article/details/81806665</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-数据类型的概述-2"><span class="toc-number">24.</span> <span class="toc-text">四 . 数据类型的概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-六大数据类型（number-string-boolean-undefined-null-onject-2"><span class="toc-number">24.0.1.</span> <span class="toc-text">1.六大数据类型（number,string,boolean,undefined,null,onject)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-确定值是什么类型的几种方法-2"><span class="toc-number">24.0.2.</span> <span class="toc-text">2.确定值是什么类型的几种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-typeof运算符-2"><span class="toc-number">24.0.2.0.1.</span> <span class="toc-text">1.typeof运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-instanceof运算符-2"><span class="toc-number">24.0.2.0.2.</span> <span class="toc-text">2.instanceof运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-Object-prototype-toString方法-2"><span class="toc-number">24.0.2.0.3.</span> <span class="toc-text">3.Object.prototype.toString方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-应用typeof方法写方法-2"><span class="toc-number">24.0.2.0.4.</span> <span class="toc-text">4.应用typeof方法写方法</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-JavaScript函数-2"><span class="toc-number">25.</span> <span class="toc-text">五 . JavaScript函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-定义方法-2"><span class="toc-number">25.0.1.</span> <span class="toc-text">1.定义方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-调用方法-2"><span class="toc-number">25.0.2.</span> <span class="toc-text">2.调用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-常用方法-2"><span class="toc-number">25.0.3.</span> <span class="toc-text">3.常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-arguments对象-2"><span class="toc-number">25.0.4.</span> <span class="toc-text">4.arguments对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-指针标识-2"><span class="toc-number">25.0.5.</span> <span class="toc-text">5.指针标识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-函数变量提升-2"><span class="toc-number">25.0.6.</span> <span class="toc-text">6.函数变量提升</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-闭包-2"><span class="toc-number">25.0.7.</span> <span class="toc-text">7.闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-数组-2"><span class="toc-number">25.0.8.</span> <span class="toc-text">8.数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六-JavaScript错误处理机制-2"><span class="toc-number">26.</span> <span class="toc-text">六 . JavaScript错误处理机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七-JavaScript-JSON-2"><span class="toc-number">27.</span> <span class="toc-text">七 . JavaScript  JSON</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八-JavaScript：void（0）的含义-2"><span class="toc-number">28.</span> <span class="toc-text">八 . JavaScript：void（0）的含义</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#href-”-”与href-”javascript-void-0-”的区别-2"><span class="toc-number">28.0.0.0.1.</span> <span class="toc-text">href=”#”与href=”javascript:void(0)”的区别</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九-命名规范-2"><span class="toc-number">29.</span> <span class="toc-text">九 . 命名规范</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#空格与运算符-2"><span class="toc-number">29.0.0.0.1.</span> <span class="toc-text">空格与运算符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#代码缩进-2"><span class="toc-number">29.0.0.0.2.</span> <span class="toc-text">代码缩进</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#命名规则-2"><span class="toc-number">29.0.0.0.3.</span> <span class="toc-text">命名规则</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十-文档对象模型HTML-DOM-2"><span class="toc-number">30.</span> <span class="toc-text">十.文档对象模型HTML DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-找HTML元素-2"><span class="toc-number">30.0.1.</span> <span class="toc-text">1.找HTML元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-节点指针-2"><span class="toc-number">30.0.2.</span> <span class="toc-text">2.节点指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-创建节点-2"><span class="toc-number">30.0.3.</span> <span class="toc-text">3.创建节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-插入节点-2"><span class="toc-number">30.0.4.</span> <span class="toc-text">4.插入节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-改变HTML元素样式-2"><span class="toc-number">30.0.5.</span> <span class="toc-text">5.改变HTML元素样式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-添加监听事件-2"><span class="toc-number">30.0.6.</span> <span class="toc-text">6.添加监听事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-事件冒泡或事件捕获？-1"><span class="toc-number">30.0.7.</span> <span class="toc-text">7.事件冒泡或事件捕获？</span></a></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"js基础　| Nikita　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2020/06/17/js精研/" title="上一篇: js精研">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2020/06/13/刷题笔记/" title="下一篇: 刷题笔记">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/数组中的reduce/">数组中的reduce</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/‘力扣简单题’/">‘力扣简单题’</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/vue小技巧/">vue小技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/vue的面试/">vue的面试</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/18/学习vuex/">学习vuex</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/同源策略/">同源策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/typescript/">typescript</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/jquery/">jquery</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/js动画篇/">js动画篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/js精研/">js精研</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/js基础/">js基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/刷题笔记/">刷题笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/11/前端cookie解读/">前端cookie解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/04/前端经验/">前端经验</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/22/linux学习/">linux学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/10/pandas之excel/">pandas之excel</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/09/HTML5和CSS3/">HTML5和CSS3</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/08/爬虫/">爬虫</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/07/python的学习/">python的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/30/AJAX学习/">AJAX学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/30/node进阶/">node进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/30/http进阶/">http进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/ES6的学习/">ES6的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/vue学习中的问题/">vue学习中的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/27/计算机网络/">计算机网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/27/数据结构与算法/">数据结构与算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/07/前端面试/">前端面试</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/06/http的学习/">http的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/课程表制作/">课程表制作</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/CSS3/">CSS3</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/Grid布局/">Grid布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/CSS3高阶/">CSS3高阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/HTML5基础下-陈楚吟/">HTML5基础下--陈楚吟</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/HTML5基础上-陈楚吟/">HTML5基础上-陈楚吟</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/深入理解css/">深入理解css</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/选择器/">选择器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/vue学习三/">vue学习三</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/vue学习二/">vue学习二</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/vue学习一/">vue学习一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/浅谈canvas和相关实战/">浅谈canvas和相关实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/setTimeout与setInterval区别/">setTimeout与setInterval区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/js中callee和caller/">js中callee和caller</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/行内元素存在间距问题/">行内元素存在间距问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/09/canvas绘制碰撞球动画/">canvas绘制碰撞球动画</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/27/用JavaScript封装栈/">用JavaScript封装栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/26/伪类与伪元素的区区别/">伪类与伪元素的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/17/深入理解包与NPM和package-json深入解读/">深入理解包与NPMM,package.json深入解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/15/JS中外部文件的优势-1/">JS中外部文件的优势</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/03/vue进阶/">vue进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/27/webpack学习/">webpack学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/15/攻克object对象/">攻克object对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/15/qq小程序天坑之旅/">qq小程序天坑之旅</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/27/proto/">proto</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/26/项目开发流程/">项目开发流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/25/事件机制/">事件机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/17/MVVC模型架构/">MVVC模型架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/15/js执行上下文/">js执行上下文</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/15/js中的立即执行函数/">js中的立即执行函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/14/js中的闭包/">js中的闭包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/14/了解浏览器/">了解浏览器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/13/我认识的js原型及原型链/">我认识的js原型及原型链</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/12/深入理解js中的this/">深入理解js中的this</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/12/相对全面的数组/">相对全面的数组去重</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/11/css盒模型集锦/">css盒模型集锦</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 陈楚吟
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="陈楚吟">



<meta name="description" content="面试HTML5what 是一套包含HTMML,CSS,JS在内的技术组合，它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务。  优  网络标准统一，HTML5本身是由W3C推荐出来的。    多设备，跨平台，即时更新。    提高可用性和改进用户的友好体验。    有几个新的标签将有利于开发者定义重要的内容。    可以给站点带来更多的多媒体元素。    可以很好的替代Flash和Silv">
<meta name="keywords" content="write myBlog">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试">
<meta property="og:url" content="http://yoursite.com/2020/04/07/前端面试/index.html">
<meta property="og:site_name" content="Nikita">
<meta property="og:description" content="面试HTML5what 是一套包含HTMML,CSS,JS在内的技术组合，它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务。  优  网络标准统一，HTML5本身是由W3C推荐出来的。    多设备，跨平台，即时更新。    提高可用性和改进用户的友好体验。    有几个新的标签将有利于开发者定义重要的内容。    可以给站点带来更多的多媒体元素。    可以很好的替代Flash和Silv">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-04-29T06:26:08.581Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端面试">
<meta name="twitter:description" content="面试HTML5what 是一套包含HTMML,CSS,JS在内的技术组合，它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务。  优  网络标准统一，HTML5本身是由W3C推荐出来的。    多设备，跨平台，即时更新。    提高可用性和改进用户的友好体验。    有几个新的标签将有利于开发者定义重要的内容。    可以给站点带来更多的多媒体元素。    可以很好的替代Flash和Silv">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Nikita" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>前端面试 | Nikita</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">陈楚吟</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不负韶华</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">陈楚吟</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">陈楚吟</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不负韶华</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-前端面试" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/07/前端面试/" class="article-date">
      <time datetime="2020-04-07T14:26:30.000Z" itemprop="datePublished">2020-04-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      前端面试
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><ul>
<li>是一套包含HTMML,CSS,JS在内的技术组合，它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务。</li>
</ul>
<h3 id="优"><a href="#优" class="headerlink" title="优"></a>优</h3><ul>
<li><ol>
<li>网络标准统一，HTML5本身是由W3C推荐出来的。</li>
</ol>
</li>
<li><ol start="2">
<li>多设备，跨平台，即时更新。</li>
</ol>
</li>
<li><ol start="3">
<li>提高可用性和改进用户的友好体验。</li>
</ol>
</li>
<li><ol start="4">
<li>有几个新的标签将有利于开发者定义重要的内容。</li>
</ol>
</li>
<li><ol start="5">
<li>可以给站点带来更多的多媒体元素。</li>
</ol>
</li>
<li><ol start="6">
<li>可以很好的替代Flash和Silverlight。</li>
</ol>
</li>
<li><ol start="7">
<li>涉及到网站的抓取和索引时，对于SEO很友好。</li>
</ol>
</li>
<li><ol start="8">
<li>被大量应用于移动应用程序和游戏。</li>
</ol>
</li>
</ul>
<h3 id="缺"><a href="#缺" class="headerlink" title="缺"></a>缺</h3><ul>
<li><ol>
<li>安全性：websocket和透明代理的实现有严重安全问题，webstorage和websocket这样的功能很容易被黑客利用来盗取用户的信息与资料。</li>
</ol>
</li>
<li><ol start="2">
<li>完善性：许多特性浏览器的支持程度不一样。</li>
</ol>
</li>
<li><ol start="3">
<li>技术门槛：HTML5简化了开发者学习，像web worker、web socket、web storage等新特性，后台甚至浏览器原理的知识。</li>
</ol>
</li>
<li><ol start="4">
<li>性能：某些平台上的引擎问题导致HTML5性能低下。</li>
</ol>
</li>
<li><ol start="5">
<li>浏览器兼容性：最大缺点，IE9以下浏览器几乎全军覆没。</li>
</ol>
</li>
</ul>
<h3 id="Doctype作用"><a href="#Doctype作用" class="headerlink" title="Doctype作用"></a>Doctype作用</h3><ul>
<li><ol>
<li>声明位于文档最前面，处于标签之前，告知浏览器的解析器以何种方式解析文档。</li>
</ol>
</li>
<li><ol start="2">
<li>严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。</li>
</ol>
</li>
<li><ol start="3">
<li>在混杂模式中，页面以宽松的方式向后兼容的方式显示。模拟老式浏览器的行为防止站点无法工作。</li>
</ol>
</li>
<li><ol start="4">
<li>Doctype不存在或格式不正确会导致文档以混杂模式呈现。</li>
</ol>
</li>
</ul>
<h3 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h3><ul>
<li><ol>
<li>去掉或样式丢失的时候能让页面呈现清晰的结构</li>
</ol>
<ul>
<li>：html本身是没有表现的，我们看到例如h1是粗体，字体大小2em，加粗；strong是加粗的，不要认为这是html的表现，这些其实html默认的css样式在起作用，所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语义化的HTML结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达html的语义，可以说浏览器的默认样式和语义化的HTML结构是不可分割的。</li>
</ul>
</li>
<li><ol start="2">
<li>屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页.</li>
</ol>
<ul>
<li>例如,如果你使用的含语义的标记,屏幕阅读器就会“逐个拼出”你的单词,而不是试着去对它完整发音.</li>
</ul>
</li>
<li><ol start="3">
<li>PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）.使用语义标记可以确保这些设备以一种有意义的方式来渲染网页.理想情况下,观看设备的任务是符合设备本身的条件来渲染网页.语义标记为设备提供了所需的相关信息,就省去了你自己去考虑所有可能的显示情况（包括现有的或者将来新的设备）.</li>
</ol>
<ul>
<li>例如,一部手机可以选择使一段标记了标题的文字以粗体显示.而掌上电脑可能会以比较大的字体来显示.无论哪种方式一旦你对文本标记为标题,您就可以确信读取设备将根据其自身的条件来合适地显示页面.</li>
</ul>
</li>
<li><ol start="4">
<li>搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重.</li>
</ol>
<ul>
<li><ol start="5">
<li>你的页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记,而只注重语义标记.因此,如果页面文件的标题被标记,而不是,那么这个页面在搜索结果的位置可能会比较靠后.除了提升易用性外,语义标记有利于正确使用CSS和JavaScript,因为其本身提供了许多“钩钩”来应用页面的样式与行为.SEO主要还是靠你网站的内容和外部链接的。</li>
</ol>
</li>
</ul>
</li>
<li><ol start="6">
<li>便于团队开发和维护</li>
</ol>
</li>
<li><p>W3C给我们定了一个很好的标准，在团队中大家都遵循这个标准，可以减少很多差异化的东西，方便开发和维护，提高开发效率，甚至实现模块化开发。</p>
</li>
</ul>
<h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><ul>
<li><p>媒体查询</p>
</li>
<li><p>百分比</p>
<ul>
<li>%单位是依赖于元素的祖先元素。</li>
</ul>
</li>
<li><p>rem</p>
<ul>
<li><p>rem与em区别</p>
<ul>
<li>rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。</li>
<li>作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值设置font-size的值实现当屏幕分辨率变化时让元素也变化，以前的天猫tmall就使用这种办法</li>
<li>em是文本相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)</li>
<li>em（font size of the element）是指相对于父元素的字体大小的单位。它与rem之间其实很相似，区别在。（相对是的HTML元素的字体大，默认16px）</li>
<li><strong>em与rem的重要区别：</strong> 它们计算的规则一个是依赖父元素另一个是依赖根元素计算</li>
</ul>
</li>
<li><p>通过 rem 单位来实现适配，需要内嵌一段脚本去动态计算根元素大小。</p>
</li>
</ul>
</li>
<li><p>vw/vh</p>
<ul>
<li><p>使用纯CSS视口单位来自行自适应，虽然现在的兼容性还没法完全能够接受</p>
</li>
<li><p>依赖于视口的尺寸，根据视口尺寸的百分比来定义的</p>
<ul>
<li>vw : 1vw 等于视口宽度的1%</li>
<li>vh : 1vh 等于视口高度的1%</li>
<li>vmin : 选取 vw 和 vh 中最小的那个</li>
<li>vmax : 选取 vw 和 vh 中最大的那个</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="出现css阻塞地方"><a href="#出现css阻塞地方" class="headerlink" title="出现css阻塞地方"></a>出现css阻塞地方</h3><ul>
<li><ol>
<li>当css后面跟着嵌入的js时，该css就会出现阻塞后面资源下载的情况，而当把嵌入JS放到css前面就不会出现阻塞。</li>
</ol>
</li>
<li><ol start="2">
<li>根本原因是浏览器会维持html中css与js的顺序，样式表必须在嵌入的js执行前先加载解析完。但嵌入的js会阻塞后面资源的下载，所以就会出现上面CSS阻塞下载的情况。</li>
</ol>
</li>
</ul>
<h3 id="优化css性能"><a href="#优化css性能" class="headerlink" title="优化css性能"></a>优化css性能</h3><ul>
<li><ul>
<li>减少首次有效绘制时间，只将渲染首屏内容的关键css内联到HTML中（Github上有一个项目Critical CSS可确定哪些内容是首屏关键样式），但内联css不会进行缓存，每次需重新下载。</li>
</ul>
</li>
<li><ul>
<li>剩下的css由外部异步加载导入并启动缓存。异步加载方式：</li>
</ul>
<ul>
<li><ul>
<li>使用js动态动态创建样式表link并插入到DOM中</li>
</ul>
</li>
<li><ul>
<li>将link元素的media属性设置为用户浏览器不匹配的媒体类型。因为对浏览器来说，如果样式表不适合当前媒体类型，其优先级会被放低，会在不阻塞页面渲染情况下再进行下载，但在文件加载完成后将media的值设为screen或all  <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;mystyle.css&quot; media=&quot;noexist&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>文件压缩，只会去除无用的空格。</li>
</ul>
</li>
<li><ul>
<li>去除无用的css。编写代码时，尽量提取公共类，减少重复。</li>
</ul>
</li>
<li><ul>
<li>有选择的使用选择器</li>
</ul>
<ul>
<li>保持简单，不要嵌套过多过于复杂的选择器。</li>
<li><ul>
<li>通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。</li>
</ul>
</li>
</ul>
</li>
<li><p>减少重排和重绘</p>
<ul>
<li><ul>
<li>触发重排：font-size、font-family、元素内外边距，通过js改变css类，通过js获取DOM元素位置的相关属性、css伪类激活，滚动滚动条或改变窗口大小。   <strong>优先使用flex弹性布局</strong>。</li>
</ul>
</li>
<li><ul>
<li>触发重绘：改变元素的外观（如color，background，visibility等属性）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="css预处理"><a href="#css预处理" class="headerlink" title="css预处理"></a>css预处理</h3><ul>
<li><ul>
<li>css预处理器是一种专门的编程语言，用来为css增加一些变成特性（css本身不是编程语言）不需要考虑浏览器兼容问题，因为css预处理器最终编译和输出的仍是标准的css样式。</li>
</ul>
</li>
<li><ul>
<li>可在css预处理器中使用变量，简单逻辑判断，函数等基本编程技巧。有合理的样式复用机制。</li>
</ul>
</li>
<li>less，sass</li>
</ul>
<h3 id="浮动的原理和工作方式"><a href="#浮动的原理和工作方式" class="headerlink" title="浮动的原理和工作方式"></a>浮动的原理和工作方式</h3><ul>
<li><ul>
<li>浮动元素是脱离文档流的，不占据空间。浮动元素碰到包含他的元素的边框或其他浮动元素的边框会停下来。</li>
</ul>
</li>
<li><ul>
<li>引发问题：</li>
</ul>
<ul>
<li><ul>
<li>父元素的高度无法撑开，影响与父元素同级的元素。</li>
</ul>
</li>
<li><ul>
<li>与浮动元素同级的非浮动元素紧跟其后。</li>
</ul>
</li>
<li><ul>
<li>若非第一个元素浮动，则该元素之前的元素也需要紧跟其后，否则会影响页面的显示的结构。</li>
</ul>
</li>
</ul>
</li>
<li><p>清除浮动：</p>
<ul>
<li><ul>
<li>在所有浮动标签后面使用<strong>空标签</strong>清除浮动，定义css clear：both；弊端是增加无意义的标签。</li>
</ul>
</li>
<li><ul>
<li>给浮动元素的<strong>父标签</strong>添加css属性，overflow：auto；</li>
</ul>
</li>
<li><ul>
<li>非IE浏览器者使用<strong>伪元素</strong>清除浮动，不过要设置伪对象height：0；否则该元素高度要比实际高出若干像素。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="link与-import区别"><a href="#link与-import区别" class="headerlink" title="link与@import区别"></a>link与@import区别</h3><ul>
<li><ul>
<li>link是HTML标签无兼容问题，页面被加载时，link会同时被加载。</li>
</ul>
</li>
<li><ul>
<li>@import由css提供，但只在IE5以上才能识别，且引用的css会等到页面被加载完再加载。</li>
</ul>
</li>
</ul>
<h3 id="absolute与fixed区别"><a href="#absolute与fixed区别" class="headerlink" title="absolute与fixed区别"></a>absolute与fixed区别</h3><ul>
<li><p>共同点：</p>
<ul>
<li><ol>
<li>改变行内元素的呈现方式，display被置为inline-block；</li>
</ol>
</li>
<li><ol start="2">
<li>让元素脱离普通流，不占据空间；</li>
</ol>
</li>
<li><ol start="3">
<li>默认会覆盖到非定位元素上。</li>
</ol>
</li>
</ul>
</li>
<li><p>不同点：</p>
<ul>
<li><ol>
<li>absolute的根元素是可以设置的，而fixed的根元素固定为浏览器。</li>
</ol>
</li>
<li><ol start="2">
<li>当你滚动网页时，fixed元素与浏览器窗口之间的距离是不变的。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="src与href区别"><a href="#src与href区别" class="headerlink" title="src与href区别"></a>src与href区别</h3><ul>
<li>src用于替换当前元素，href用于在当前文档和引用资源间确立联系。</li>
<li>src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在的位置，请求src资源时会将其指向的资源下载并应用到文档中。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也是如此，类似于将所指资源嵌入当前标签内，这也是为啥要将js脚本放在底部而不是头部。</li>
<li>href指向网络资源所在的位置，建立和当前元素之间的链接，如果我们在文档中添加<code>&lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot; /&gt;</code>，那浏览器就会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css而不是使用@import方式。</li>
</ul>
<h3 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap"></a>bootstrap</h3><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="js继承及对象共享"><a href="#js继承及对象共享" class="headerlink" title="js继承及对象共享"></a>js继承及对象共享</h3><ul>
<li>1.利用原型来继承,通过增加一个空的函数来避免原型链上的对象共享</li>
<li>1.利用原型来继承,通过增加一个空的函数来避免原型链上的对象共享<pre><code>var a = {name：“小明”}；
    var b = cloneObj(a);
     function cloneObj(obj){
            var f = function(){};
            f.prototype = obj;
            return new f();
    }</code></pre></li>
</ul>
<p>2.使用extend，多用于插件封装</p>
<p>示例：</p>
<p>Var item={name:”olive”,age:23};</p>
<p>Var item1={name:”Momo”,sex:”gril”};</p>
<p>Var result=$.extend({},item,item1);</p>
<p>结果：</p>
<p>Result={name:”Momo”,age:23,sex:”gril”};</p>
<h3 id="js阻塞"><a href="#js阻塞" class="headerlink" title="js阻塞"></a>js阻塞</h3><ul>
<li><p>why</p>
<ul>
<li><ul>
<li>所有浏览器在下载JS时会阻塞一切其他活动，比如资源的下载，内容的呈现等等。直到JS下载，解析，执行完才开始继续并行下载其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载JS，但是JS下载仍会阻塞其他资源的下载，如图片或css文件。</li>
</ul>
</li>
<li><ul>
<li>由于浏览器为了防止JS修改DOM树，需要重新构建DOM树的情况，所以就会阻塞其他的下载和呈现。</li>
</ul>
</li>
<li><ul>
<li>同时嵌入的脚本会阻塞所有内容的呈现，而由外引入的脚本只会阻塞其后内容的呈现，2种方式都会阻塞其后资源的下载，但是外部引入的脚本可将引入标签写在页面最后就可避免此种情况。</li>
</ul>
</li>
</ul>
</li>
<li><p>how to do</p>
<ul>
<li><p>嵌入脚本</p>
<ul>
<li><ol>
<li>放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。</li>
</ol>
</li>
<li><ol start="2">
<li>如果嵌入JS放在head中，请把嵌入JS放在CSS头部。</li>
</ol>
</li>
<li><ol start="3">
<li>使用 defer（只支持IE）</li>
</ol>
</li>
<li><ol start="4">
<li>不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用 setTimeout 来调用</li>
</ol>
</li>
</ul>
</li>
<li><ol>
<li>将脚本放在底部。<link>还是放在head中，用以保证在js加载前，能加载出正常显示的页面。<script>标签放在</body>前。</li>
</ol>
</li>
<li><ol start="2">
<li>阻塞脚本：由于每个<script>标签下载时阻塞页面解析过程，所以限制页面的<script>总数也可以改善性能。适用于内联脚本和外部脚本。</li>
</ol>
</li>
<li><ol start="3">
<li>非阻塞脚本：等页面完成加载后，再加载js代码。也就是，在 window.onload 事件发出后开始下载代码。</li>
</ol>
</li>
<li><ol start="4">
<li>defer属性：支持IE4和fierfox3.5更高版本浏览器</li>
</ol>
</li>
<li><ol start="5">
<li>动态脚本元素：文档对象模型（DOM）允许你使用js动态创建HTML的几乎全部文档内容。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li><ul>
<li>what：闭包是可以读取其他函数内部变量的函数，本质是将函数内部和外部连接起来的一座桥梁。</li>
</ul>
</li>
<li><ul>
<li>advantage：可读取函数内部的变量，可让这些变量的值始终保持在内存中。</li>
</ul>
</li>
<li><ul>
<li>disadvantage：内存消耗大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。故在退出函数之前，将不使用的局部变量全部删除。闭包会在父函数外部改变父函数内部变量的值。</li>
</ul>
</li>
</ul>
<h3 id="AJAX（同源策略）"><a href="#AJAX（同源策略）" class="headerlink" title="AJAX（同源策略）"></a>AJAX（同源策略）</h3><ul>
<li><p>Ajax与Flash的优缺点</p>
<ul>
<li><p>AJAX</p>
<ul>
<li>优：<br>1.可搜索性 2.开放性 3.费用 4.易用性 5.易于开发。</li>
<li>缺：<br>它可能破坏浏览器的后退功能 2.使用动态页面更新使得用户难于将某个特定的状态保存到收藏夹中 ，不过这些都有相关方法解决。</li>
</ul>
</li>
<li><p>flash</p>
<ul>
<li>优势：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>1.多媒体处理 2.兼容性 3.矢量图形 4.客户端资源调度<br>        - 劣势：</p>
<p>1.二进制格式 2.格式私有 3.flash 文件经常会很大，用户第一次使用的时候需要忍耐较长的等待时间 4.性能问题</p>
<ul>
<li><p>ajax请求的过程</p>
<ul>
<li><ol>
<li>创建XMLHttpRequest对象，也就是创建一个异步调用对象。</li>
</ol>
</li>
<li><ol start="2">
<li>创建一个新的HTTP请求，并指定该HTTP请求的方法，URL及验证信息。</li>
</ol>
</li>
<li><ol start="3">
<li>设置响应HTTP请求状态变化的函数.</li>
</ol>
</li>
<li><ol start="4">
<li>发送HTTP请求。</li>
</ol>
</li>
<li><ol start="5">
<li>获取异步调用返回的数据。</li>
</ol>
</li>
<li><ol start="6">
<li>使用 JS 和 DOM 实现局部刷新。</li>
</ol>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><ol>
<li>通过异步模式提升用户体验。</li>
</ol>
</li>
<li><ol start="2">
<li>优化了浏览器与服务器之间的传输，减少不必要的数据往返，减少了带宽占用。</li>
</ol>
</li>
<li><ol start="3">
<li>Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</li>
</ol>
</li>
<li><ol start="4">
<li>Ajax可实现局部刷新，即动态不刷新。</li>
</ol>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><ol>
<li>Ajax不支持浏览器back按钮。</li>
</ol>
</li>
<li><ol start="2">
<li>安全问题：Ajax暴漏了与服务器间交互的细节。</li>
</ol>
</li>
<li><ol start="3">
<li>对搜索引擎的支持比较弱。</li>
</ol>
</li>
<li><ol start="4">
<li>破坏程序的异常机制。</li>
</ol>
</li>
<li><ol start="5">
<li>不容易调试。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h3><h3 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h3><ul>
<li><p>使用场景</p>
<ul>
<li><ol>
<li>实时应用：如在线聊天，实时通知推送等（socket.io);</li>
</ol>
</li>
<li><ol start="2">
<li>分布式应用：通过高效的并行I/O使用已有的数据；</li>
</ol>
</li>
<li><ol start="3">
<li>工具类应用：海量的工具，小到前端压缩部署（如grunt），大到桌面应用程序。</li>
</ol>
</li>
<li><ol start="4">
<li>游戏类应用：游戏对实时和并发有很高的要求；</li>
</ol>
</li>
<li><ol start="5">
<li>利用稳定接口提升web渲染能力；</li>
</ol>
</li>
<li><ol start="6">
<li>前后后端编程语言环境统一：前端人员可快速切入到服务器端的开发；</li>
</ol>
</li>
</ul>
</li>
<li><p>what</p>
<ul>
<li>NodeJS是基于Event Loop（事件循环）和Callback（回调）把单线程的效率发挥到极致（会让人感觉实现了多线程），使有限的资源（CPU,内存，网络资源）利用最大化。</li>
</ul>
</li>
<li><p>优</p>
<ul>
<li><ol>
<li>因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在node上的代理服务器相比其他技术实现的服务器表现要好得多。</li>
</ol>
</li>
<li><ol start="2">
<li>与node代理服务器交互的客户端代码是由js语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的。</li>
</ol>
</li>
</ul>
</li>
<li><p>缺</p>
<ul>
<li><ol>
<li>Node是单线程，处理CPU密集型吃力，不过可将密集拆分。</li>
</ol>
</li>
<li><ol start="2">
<li>只支持单核CPU,不能充分利用CPU。</li>
</ol>
</li>
<li><ol start="3">
<li>可靠性低，一旦代码某个环节崩溃，整个系统都崩溃。</li>
</ol>
</li>
<li><ol start="4">
<li>开源组件库质量参差不齐，更新快，向下不兼容。</li>
</ol>
</li>
<li><ol start="5">
<li>Debbug不方便，错误没有stack trace。</li>
</ol>
</li>
</ul>
</li>
<li><p>事件循环eventloop</p>
<ul>
<li>　1）所有同步任务都在主线程上执行，形成一个执行栈</li>
<li>　2）当主线程中的执行栈为空时，检查事件队列是否为空，如果为空，则继续检查；如不为空，则执行3</li>
<li>　3）取出任务队列的首部，加入执行栈</li>
<li>　4）执行任务</li>
<li>　5）检查执行栈，如果执行栈为空，则跳回第 2 步；如不为空，则继续检查</li>
</ul>
</li>
<li><p>node怎么跟MongoDB建立连接</p>
<ul>
<li>1）引入mongoose</li>
<li>2）使用mongoose.connect()方法连接到MongoDB数据库</li>
<li>3）监听连接是否成功</li>
<li>4）然后通过node，书写接口，对数据库进行增删改查</li>
</ul>
</li>
</ul>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><ul>
<li><p>增</p>
<ul>
<li>arr.unshift('字符')：向数组开头添加一个或多个元素，并返回新的长度。</li>
<li>arr.concat(arr1,arr2,...)：连接两个或更多的数组，并返回结果</li>
<li>arr.push('字符')：向数组的末尾添加一个或多个元素，并返回新的长度。</li>
<li>arr.splice(index,howmany,item1,item2,...itemX)：向数组添加或删除元素。</li>
</ul>
</li>
<li><p>删</p>
<ul>
<li>arr.pop()：删除数组中最后一个元素并返回删除的元素。</li>
<li>arr.shift()：删除数组中的第一个元素。</li>
</ul>
</li>
<li><p>改</p>
<ul>
<li>arr.sort(fn)：对数组元素进行排序。</li>
<li>arr.reverse()：翻转数组的元素的顺序。</li>
<li>arr.map(fn)：通过指定函数处理的每个数组，并返回处理后的数组。</li>
<li>arr.join('连字符')：把数组中元素放入一个字符串中。</li>
<li>arr.toString()：把数组转为字符串，并返回结果。</li>
</ul>
</li>
<li><p>查</p>
<ul>
<li><p>filter()：检测数组元素，并返回符合条件所有元素的数组。</p>
</li>
<li><p>arr.every(fn)：检测数组元素是否都符合条件，返回布尔值。</p>
</li>
<li><p>arr.slice(n1,n2)：返回n1到n2之间的数组元素，不包括n2上的元素。</p>
</li>
<li><p>arr.lastIndexOf('字符')：返回指定字符最后出现的位置的下标。</p>
</li>
<li><p>arr.indexOf(‘字符’)：搜索数组中元素，并返回它首次出现的下标。</p>
</li>
<li><p>arr.some(fn)：检测数组元素中是否有元素符合指定条件。</p>
</li>
<li><p>遍历元素</p>
<ul>
<li>array.forEach(function(currentValue, index, arr), thisValue)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul>
<li>length：字符串的长度</li>
<li>str.charAt(num)：返回在指定位置的字符。</li>
<li>str.charCodeAt(num)：返回在指定位置的Unicode编码。</li>
<li>str.concat(str1,str2)：连接两个或多个字符串，并返回新的字符串。</li>
<li>String.fromCharCode(num)：将Unicode编码转为字符。</li>
<li>str.indexOf('字符串')：返回指定字符串值在字符串中首次出现的位置的下标。</li>
<li>str.lastIndexOf('字符串')：从后向前搜索字符串</li>
<li>str.match(/ain/g)：在字符串中检索指定的值，查找一或多个正则表达式的匹配。返回包含所有结果的数组。</li>
<li>str.replace(searchValue,newValue)：在字符串中用一些字符替换另一些字符。</li>
<li>str.search('字符或正则表达式')：检索字符串中指定子字符串。返回下标值。</li>
<li>str.slice(start,end)：提取字符串的某个部分，并以新的字符串返回被提取的部分</li>
<li>str.split()：将字符串分割成字符串数组。</li>
<li>str.substr(start,length)：从start开始截length个字符，返回截取的字符串。</li>
<li>str.substring(n1,n2)：返回n1到n2的字符串，不包括n2.</li>
<li>str.toLowerCase()<br>str.toUpperCase()</li>
<li>str.trim():去掉字符串两边空白。</li>
</ul>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><ul>
<li><p>变量声明</p>
<ul>
<li><p>let</p>
<ul>
<li>暂时性死区</li>
<li>变量不提升</li>
<li>不可重复声明</li>
</ul>
</li>
<li><p>const</p>
<ul>
<li>let的所有特性</li>
<li>值不可变</li>
<li>本质：const保证的不是变量的值不可改变，而是变量指向的那个内存地址不可改变。对于简单数据，值就保存在变量指向的那个内存地址，因此等同于常量。</li>
</ul>
</li>
<li><p>var</p>
</li>
<li><p>function</p>
</li>
<li><p>class</p>
<ul>
<li>ES6的class可以看作是一个语法糖，它的绝大部分功能ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法</li>
</ul>
</li>
<li><p>import</p>
</li>
</ul>
</li>
<li><p>解构赋值（模式匹配）</p>
<ul>
<li><p>规则：只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构，都会报错。let { prop: x } = undefined或null;  //TypeError</p>
</li>
<li><p>允许指定默认值，但如果一个数组成员不严格等于undefined，默认值无效。</p>
<ul>
<li>默认值是表达式，，那这个表达式是惰性求值，只在用到时才求值。</li>
</ul>
</li>
<li><p>本质：只要数据结构具有Iterator接口，都可以采用数组形式的解构赋值。let [a,b,c] = [1,2,3]</p>
</li>
<li><p>字符串</p>
<ul>
<li>字符串被转换成一个类似数组的对象。</li>
</ul>
</li>
<li><p>对象</p>
<ul>
<li>解构失败，变量的值为undefined。let {foo} = {bar: 'baz'};  foo  //undefined</li>
<li>对象解构赋值可以很方便将现有对象的方法赋值到某个变量中。let { log, sin, cos } = Math;</li>
<li>对象解构赋值的内部机制是先找到同名属性，然后再赋给对应的变量，真正被赋值的是后者，而非前者。let {foo:baz} = {foo: 123};    //baz为123，foo会报错，foo is not defined</li>
<li>数组解构的元素是按次序排列的，变量的取值由他的位置决定；而对象的属性没有次序，变量必须与属性同名才能取到正确的值。</li>
</ul>
</li>
<li><p>数值和布尔值</p>
<ul>
<li>解构赋值时会先转为对象。</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li>function add([x,y]){}<br>函数的参数表面上是一个数组，但在传入参数时，数组参数就被解构成变量x和y。</li>
</ul>
</li>
<li><p>用途</p>
<ul>
<li><p>交换变量的值 [x,y] = [y,x]</p>
</li>
<li><p>函数返回多个值</p>
<ul>
<li>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象返回。有了解构赋值便可轻松取出这些值。function example(){return [1,2,3];}  let [a,b,c] = example();</li>
</ul>
</li>
<li><p>函数参数的定义</p>
<ul>
<li>但参数无序时，可将参数与变量名对应起来。<br>function f({x,y,z}){}  f({z: 3, y: 2, x: 1});</li>
</ul>
</li>
<li><p>提取JSON数据</p>
</li>
<li><p>函数参数的默认值</p>
</li>
<li><p>遍历Map结构</p>
<ul>
<li>任何部署了Iterator接口的对象都可以用for...of循环遍历。</li>
<li>const map = new Map();<br>map.set('first','hello');<br>map.set('last','world');<br>for(let [key,value] of map){}</li>
</ul>
</li>
<li><p>输入模块的指定方法</p>
<ul>
<li>加载模块时，指定输入哪些方法</li>
<li>const { SourceMapConsumer, SourceNode } = require("source-map");</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>babel命令行转码</p>
<ul>
<li>将es6语法转为es5</li>
</ul>
</li>
<li><p>数组</p>
<ul>
<li><p>复制</p>
<ul>
<li>[].concat(...arr)</li>
</ul>
</li>
<li><p>array.forEach((item,index,arr) =>{})</p>
</li>
<li><p>扩展运算符</p>
<ul>
<li><p>三点(...)将数组转为用逗号分隔的参数序列</p>
<ul>
<li><p>替代数组的apply方法</p>
<ul>
<li>获取数组最大值:Math.max(...arr)</li>
</ul>
</li>
</ul>
</li>
<li><p>子主题 2</p>
</li>
</ul>
</li>
<li><p>Array上的</p>
<ul>
<li><p>Array.from(likeArr,fn)</p>
<ul>
<li>用于将类数组转为数组</li>
<li>参数一：类数组<br>二：类似于map方法，对每个元素遍历处理</li>
<li>如果map函数使用了this关键值，Array.from的第三个参数用于绑定this。</li>
</ul>
</li>
<li><p>Array.of()</p>
<ul>
<li>用于将一组值转为数组</li>
</ul>
</li>
</ul>
</li>
<li><p>数组实例</p>
<ul>
<li><p>copyWithin(target，start，end)</p>
<ul>
<li>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原来成员），然后返回当前数组。（会改变原数组）</li>
<li>target（必需）：从该位置开始替换数据）。<br>start（可选）：从该位置开始读取数据，默认为0。若为0，表示负数。<br>end（可选）：到该位置停止读取数据，默认等于数组长度，若为负值，表示倒数。<br>参数都是数值，若不是，先转为数值。</li>
</ul>
</li>
<li><p>find((value,index,arr) => {})</p>
<ul>
<li>遍历数组，找出第一个为true的成员，返回该成员，若无，返回undefined</li>
<li>可接受第二个参数，用于绑定回调函数的this对象</li>
</ul>
</li>
<li><p>findIndex((value,index,arr) => {})</p>
<ul>
<li>与find相同，但返回的是下标值，无返回-1</li>
<li>可发现NaN，弥补indexOf的不足</li>
</ul>
</li>
<li><p>fill(value,start,end)</p>
<ul>
<li>用value值填充或覆盖数组成员</li>
</ul>
</li>
<li><p>entries(),keys(),values()</p>
<ul>
<li><p>for(let index of ['a',b'].keys(){}<br>for(let [index,elem]  of  ['a','b'].entries(){}</p>
</li>
<li><p>遍历数组，keys对键名的遍历，values（）对键值遍历，entries（）对键值对的遍历</p>
</li>
<li><p>如果不使用 for...of 循环，可以手动调用遍历器对象的 next 方法，进行遍历。</p>
<ul>
<li>let letter = ['a', 'b', 'c'];</li>
<li>let entries = letter.entries();</li>
<li>console.log(entries.next().value); // [0, 'a']</li>
<li>console.log(entries.next().value); // [1, 'b']</li>
<li>console.log(entries.next().value); // [2, 'c']</li>
</ul>
</li>
</ul>
</li>
<li><p>includes(value，start)</p>
<ul>
<li>返回boolean值，表示数组中是否包含value值</li>
<li>start为负值，从倒数开始，大于数组长度，重置为0</li>
</ul>
</li>
<li><p>空位</p>
<ul>
<li><p>ES5中的空位</p>
<ul>
<li><p>空位不是 undefined ，一个位置的值等于 undefined ，依然是有值的。空位是没有任何值， in 运算符可以说明这一点。</p>
<ul>
<li>0 in [undefined, undefined, undefined] // true</li>
<li>0 in [, , ,] // false</li>
<li>forEach() , filter() , every() 和 some() 都会跳过空位。</li>
<li>map() 会跳过空位，但会保留这个值</li>
<li>join() 和 toString() 会将空位视为 undefined ，而 undefined 和 null 会被处理成空字符串。</li>
</ul>
</li>
</ul>
</li>
<li><p>ES6不会忽略空位，会将空位转为undefined</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串</p>
<ul>
<li><p>字符Unicode表示法</p>
<ul>
<li><p>js提供的\uxxxx形式表示一个字符，超出\uffff的字符，必须用两个双字节表示。“\uD842\uDFB7"    "吉"</p>
</li>
<li><p>ES6只需将码点放入大括号即可正确解读该字符串。“\u{20BB7}"   "吉”</p>
</li>
<li><p>at()方法</p>
<ul>
<li>ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。‘abc'.charAt(0)  //'a'     '吉'.charAt(0)   //’\uD842'</li>
<li>at()可识别码点大于0xFFFF的字符。<br>‘abc'.at(0)     //"a"<br>'吉'.at(0)    //“吉”</li>
</ul>
</li>
</ul>
</li>
<li><p>有遍历器接口，可用for...of遍历</p>
</li>
<li><p>字符查找</p>
<ul>
<li><p>ES5(返回-1）</p>
<ul>
<li>indexOf()</li>
</ul>
</li>
<li><p>ES6（返回布尔值，第二个参数表示开始搜素位置））</p>
<ul>
<li>includes(’字符‘，num)</li>
<li>startsWith(’字符‘，num)</li>
<li>endWith(’字符‘，num)</li>
</ul>
</li>
</ul>
</li>
<li><p>增加</p>
<ul>
<li><p>repeat（）</p>
<ul>
<li><p>返回新字符串，表示将原字符串重复n次<br>'x'.repeat(3)   //"xxx"</p>
</li>
<li><p>参数</p>
<ul>
<li>参数是小数时取整。<br>参数是负数或Infinity会报错。<br>参数是0到-1之间的小数，则等同于0。‘na'.repeat(-0.9)  //""<br>参数NaN等同于0    'na'.repeat(NaN)   //""<br>参数是字符串，则先转为数字。</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串补全长度</p>
<ul>
<li><p>头部补全padStart()，<br>尾部补全padEnd()     ’xxx'.padEnd(5,'ab')   //xxxab </p>
</li>
<li><p>参数</p>
<ul>
<li><p>第一个参数用来指定字符串的最小长度（如果原字符串的长度大于或等于指定最小长度，返回原字符串），'xxx'.padStart(2,'ab')     //'xxx'</p>
<ul>
<li>补全的 + 原字符串 》 指定的最小长度，截去超出位数的补全字符串。</li>
</ul>
</li>
<li><p>第二个参数是用来补全的字符串，省略就使用空格补全长度</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>模板字符串(反引号``）标识</p>
<ul>
<li><p>变量名写在${}中</p>
</li>
<li><p>调用函数 function fn(){ return 'hello world";}<br><code>foo ${ fn() } bar</code> //foo Hello World bar</p>
</li>
<li><p>不做处理raw()方法</p>
<ul>
<li>String.raw()方法往往用来充当模板字符串的处理函数，返回一个斜杆都被转义的字符串，对应于替换变量后的模板字符串。  String.raw<code>Hi\n${2+3}!</code>;    //"Hi\n5!"</li>
<li>若斜杠已转义则不做处理<br>String.raw<code>Hi\\n${2+3}!</code>;    //"Hi\n5!"</li>
</ul>
</li>
<li><p>标签模板<br>alert `123'  =><br>alert(123)</p>
<ul>
<li>标签指的是函数，紧跟其后的模板字符串就是它的参数。该参数实际是一个数组，该数组有一个raw属性，保存的是转义后的原字符串。<br>console.lof'123'     //   ["123", raw: Array[1]];</li>
<li>应用：过滤HTML字符串，防止用户输入恶意内容。</li>
</ul>
</li>
<li><p>限制：因默认会将字符串转义，故无法嵌入其他语言。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>正则</p>
<ul>
<li><p>ES5</p>
<ul>
<li>var regex = new RegExp('xyz','i');<br>等价于 var regex = /xyz/i;<br>等价于 var  regex = new RegExp(/xyz/i);<br> //不允许使用第二个参数添加修饰符，否则报错。<br>var regex = new RegExp(/xyz/,'i');  报错</li>
</ul>
</li>
<li><p>ES6</p>
<ul>
<li><p>若RegExp构造函数第一个参数是正则对象，第二个参数指定修饰符，且返回的修饰符会覆盖原来的修饰符。<br>new RegExp(/abc/ig,'i').flags    //“i”</p>
</li>
<li><p>字符串的正则方法,做到所有与正则相关的方法，全部定义在RegExp对象上。</p>
<ul>
<li>String.prototype.match调用RegExp.prototype[Symbol.match]</li>
<li>String.prototype.replace调用RegExp.prototype[Symbol.replace]</li>
<li>String.prototype.search调用RegExp.prototype[Symbol.search]</li>
<li>String.prototype.split调用RegExp.prototype[Symbol.split]</li>
</ul>
</li>
<li><p>修饰符</p>
<ul>
<li>i：忽略大小写</li>
<li>u:用来处理大于\uFFFF的Unicode字符</li>
<li>y： 全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配即可，而y修饰符确保匹配必须从剩余的第一个位置开始。</li>
</ul>
</li>
<li><p>具名组匹配</p>
<ul>
<li><p>const  RE_DATE=  /(?<year>\d{4}-(?<month>\d{2}-(?<day>\d{2})/;<br>const matchObj = RE_DTAE.exec('1999-12-31');<br>const year = matchObj.groups.yeat;   //1999<br>const  month = matchObj.groups.month;   //12<br>const   day = matchObj.groups.day;    //31</p>
<ul>
<li>"具名组匹配“在圆括号内部，模式的头部添加”问号+尖括号+组名“（？<year>),然后就可以在exec方法返回结果的groups属性上引用该组名。若具名组as没找到匹配，则matchObj.groups.as属性值就是undefined，并且as这个键名在groups始终存在。</li>
</ul>
</li>
<li><p>字符串替换时，使用$<组名>引用具名组</p>
<ul>
<li>let re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/u;<br>'2015-01-02'.replace(re,'$<day>/$<month>/$<year>')<br>//'02/01/2015'</li>
</ul>
</li>
<li><p>正则表达式内部引用某个”具名组匹配“，可使用\k<组名>。数字引用（\1）依然有效。</p>
<ul>
<li>const  RE_TWICE = /^(?<word>[a-z]+!\k<word>$/;<br>RE_TWICE.test('abc!abc')      //true<br>RE_TWICE.test('abc!ab')    //false</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数值扩展</p>
<ul>
<li><p>Number</p>
<ul>
<li><p>Number.isFinite()</p>
<ul>
<li>只对数值有效，非数值一律返回false，它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值转为数值再进行判断。</li>
</ul>
</li>
<li><p>Number.isNaN()</p>
</li>
<li><p>将全局parseInt()和parseFloat()转移到Number上面，使语言逐渐模块化。</p>
</li>
<li><p>Number.isInteger():判断一个值是否为整数（js中浮点数与整数相同存储方式）。</p>
</li>
<li><p>Number.EPSILON：表示极小的常量</p>
</li>
</ul>
</li>
<li><p>Math</p>
<ul>
<li><p>Math.trunc():去除一个数的小数部分，<br>非数值的话会先将其转为数值，<br>控制和无法截取整数的值，返回NaN</p>
</li>
<li><p>Math.sign():判断一个数是正数，负数还是0.非数值的先转为数值。</p>
<ul>
<li>参数为正数，返回+1</li>
<li>负数，返回-1</li>
<li>0，返回0</li>
<li>-0，返回-0</li>
<li>其他值，返回NaN</li>
</ul>
</li>
<li><p>Math.cbrt():计算一个数的立方根，非数值先转为数值</p>
</li>
<li><p>Math.fround()：返回一个数的单精度浮点数形式。</p>
</li>
<li><p>Math.hypot():返回所有参数的平方和的平方根<br>Math.hypot(3,4);      //5</p>
</li>
<li><p>对数方法</p>
<ul>
<li>Math.expm1():返回e的x次方减1</li>
<li>Math.log1p(x):返回 1+x 的自然对数，即Math.log(1+x)</li>
<li>Math.log10(x):返回以10为底的x的对数，若x<0,返回NaN。</li>
<li>Math.log2(x):返回以2为底的x的对数。</li>
</ul>
</li>
<li><p>双曲函数</p>
<ul>
<li>Math.sinh(x)<br>Math.cosh(x)<br>Math.tanh(x)<br>Math.asinh(x)<br>Math.acosh(x)<br>Math.atanh(x)</li>
</ul>
</li>
<li><p>Math.signbit():判断数的正负</p>
<ul>
<li>参数是NaN,返回false，<br>-0，返回true<br>负数，返回true<br>其他情况，返回false</li>
</ul>
</li>
<li><p>指数运算符（**）</p>
<ul>
<li>2 ** 2   //4<br>a  **= 2;<br>//等价于a = a * a</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>函数扩展</p>
<ul>
<li><p>函数参数的默认值</p>
<ul>
<li>function   m1({x=0,y=0}={}){return [x,y];}<br>function   m2({x,y} = { x : 0, y: 0}){return  [x,y];}</li>
<li>位置：必须是函数的尾参数，非尾参数不可设置默认值。</li>
<li>函数的length属性，将返回没有指定默认值的参数个数。（length指该函数预期传入的参数个数，指定默认值后，预期传入的参数个数就不包括这个参数了。同理，rest参数也不会计入length属性中。）</li>
<li>作用域：一旦参数设置了默认值，函数进行生命初始化时，参数会形成一个单独的作用域，等初始化结束，这个作用域就会消失。这种语法行为在不设置参数默认值时是不会出现的。</li>
</ul>
</li>
<li><p>rest函数</p>
<ul>
<li>function  add(...values){}</li>
<li>引入rest参数，用于获取函数的多于参数，这样就不用arguments对象了。且是一个数组对象。</li>
</ul>
</li>
<li><p>严格模式</p>
<ul>
<li>ES5开始，函数内部可设定为严格模式。<br>ES6规定，只要函数参数使用默认值，解构赋值或扩展运算符，那函数内部就不能显式设定为严格模式。</li>
</ul>
</li>
<li><p>name属性</p>
<ul>
<li>返回该函数的函数名，若将一个匿名函数赋值给一个变量，ES5的name属性会返回空字符串，而ES6则返回实际的函数名。</li>
<li>Function构造函数返回的函数实例，name属性值为anonymous。<br>(new  Function).name     //"anonymous"</li>
<li>bind返回的函数，name属性值加上bound前缀。<br>（function(){}).bind({}).name   //"bound   "</li>
</ul>
</li>
<li><p>箭头函数</p>
<ul>
<li><p>注意点</p>
<ul>
<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>不可使用arguments对象，该对象在函数体内不存在。要用时可用rest替代。</li>
<li>不可用yield命令，因此箭头函数不能用作Generator函数。</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><p>无参数或多个参数，用圆括号代替参数部分</p>
</li>
<li><p>返回一个对象，必须在对象外面加上括号，否则报错。</p>
</li>
<li><p>与变量解构结合使用</p>
<ul>
<li>const full = ({first,last}) => first + last;</li>
</ul>
</li>
<li><p>与rest参数结合</p>
<ul>
<li>const  h = (head,...tail) => [head,tail];<br>h(1,2,3,4,5);<br>//[1,[2,3,4,5]]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>双冒号运算符</p>
</li>
<li><p>尾调用优化</p>
</li>
<li><p>函数参数的尾逗号</p>
</li>
<li><p>catch语句的参数</p>
</li>
</ul>
</li>
<li><p>对象的扩展</p>
<ul>
<li>属性的简写。ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。</li>
<li>方法的简写。省略冒号与function关键字。</li>
<li>Object.keys()方法，获取对象的所有属性名或方法名（不包括原形的内容），返回一个数组。</li>
<li>Object.assign ()，assign方法将多个原对象的属性和方法都合并到了目标对象上面。可以接收多个参数，第一个参数是目标对象，后面的都是源对象。</li>
</ul>
</li>
<li><p>for...of  循环</p>
</li>
<li><p>import和export</p>
<ul>
<li>import和export命令只能在模块的顶部，不能在代码块之中。</li>
</ul>
</li>
<li><p>新增数据结构</p>
<ul>
<li><p>map（数据存储）</p>
<ul>
<li>本质上是健值对的集合，类似集合</li>
<li>可以遍历，可以跟各种数据格式转换</li>
</ul>
</li>
<li><p>set（数据重组）</p>
<ul>
<li>Set数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数。</li>
<li>属性和方法：<br>size 数据的长度<br>add() 添加某个值，返回 Set 结构本身。<br>delete() 删除某个值，返回一个布尔值，表示删除是否成功。<br>has() 查找某条数据，返回一个布尔值。<br>clear() 清除所有成员，没有返回值。<br>应用：数组去重。</li>
</ul>
</li>
</ul>
</li>
<li><p>promise</p>
<ul>
<li><p>它有三种状态，分别是pending-进行中、resolved-已完成、rejected-已失败。</p>
</li>
<li><p>三个状态：</p>
<ul>
<li>pending</li>
<li>fulfilled</li>
<li>reject</li>
</ul>
</li>
<li><p>两个过程：</p>
<ul>
<li>pending -> fulfilled</li>
<li>pending -> rejectd</li>
</ul>
</li>
<li><p>当pending为rejectd时，promise会进入catch</p>
</li>
<li><p>Promise是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p>
</li>
<li><p>Promise 构造函数包含一个参数和一个带有 resolve（解析）和 reject（拒绝）两个参数的回调。在回调中执行一些操作（例如异步），如果一切都正常，则调用 resolve，否则调用 reject。对于已经实例化过的 promise 对象可以调用 promise.then() 方法，传递 resolve 和 reject 方法作为回调。then()方法接收两个参数：onResolve和onReject，分别代表当前 promise 对象在成功或失败时。</p>
</li>
<li><p>promise构造函数是同步执行的，then方法是异步执行的</p>
</li>
</ul>
</li>
<li><p>Symbol</p>
<ul>
<li>Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的</li>
</ul>
</li>
<li><p>proxy代理</p>
<ul>
<li>Proxy代理使用代理（Proxy）监听对象的操作，然后可以做一些相应事情</li>
</ul>
</li>
</ul>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h3 id="优化前端性能"><a href="#优化前端性能" class="headerlink" title="优化前端性能"></a>优化前端性能</h3><ul>
<li>用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。</li>
<li><ul>
<li>压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css</li>
</ul>
</li>
<li><ul>
<li>利用<a href="https://cloud.tencent.com/product/cdn?from=10680">CDN</a>加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径</li>
</ul>
</li>
<li><ul>
<li>删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现</li>
</ul>
</li>
<li><ul>
<li>提取公共代码。</li>
</ul>
</li>
</ul>
<h3 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h3><ul>
<li>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</li>
<li><ol>
<li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li>
</ol>
</li>
<li><ol start="2">
<li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li>
</ol>
</li>
<li><ol start="3">
<li>确定入口：根据配置中的 entry 找出所有的入口文件；</li>
</ol>
</li>
<li><ol start="4">
<li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li>
</ol>
</li>
<li><ol start="5">
<li>完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li>
</ol>
</li>
<li><ol start="6">
<li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li>
</ol>
</li>
<li><ol start="7">
<li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li>
</ol>
</li>
<li>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</li>
</ul>
<h3 id="webpack-config-js配置文件"><a href="#webpack-config-js配置文件" class="headerlink" title="webpack.config.js配置文件"></a>webpack.config.js配置文件</h3><ul>
<li><p>webpack-dev-server：webpack实时打包构建</p>
</li>
<li><p>html-webpack-plugin插件配置启动页面</p>
</li>
<li><p>热更新</p>
<ul>
<li>“dev":"webpack-dev-server  --hot  --port  端口号   --open"</li>
</ul>
</li>
<li><p>打包css，less，scss文件</p>
</li>
<li><p>使用url-loader和file-loader处理css中的路径</p>
</li>
<li><p>使用babel处理高级JS语法</p>
</li>
<li><p>配置vue组件页面的解析。</p>
</li>
</ul>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="对MVVM理解"><a href="#对MVVM理解" class="headerlink" title="对MVVM理解"></a>对MVVM理解</h3><ul>
<li><p>MVVM 是 Model-View-ViewModel 的缩写。</p>
</li>
<li><p><strong>Model</strong>代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。</p>
</li>
<li><p><strong>View</strong> 代表UI 组件，它负责将数据模型转化成UI 展现出来。</p>
</li>
<li><p><strong>ViewModel</strong> 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。</p>
</li>
<li><p>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p>
</li>
<li><p><strong>ViewModel</strong> 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
</li>
<li><p>与MVC区别</p>
<ul>
<li>mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 viewModel。mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 Model 频繁发生变化，开发者需要主动更新到 View 。</li>
</ul>
</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li>Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。</li>
<li><strong>beforeCreate</strong>（创建前） 在数据观测和初始化事件还未开始</li>
<li><strong>created</strong>（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来</li>
<li><strong>beforeMount</strong>（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。</li>
<li><strong>mounted</strong>（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。</li>
<li><strong>beforeUpdate</strong>（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</li>
<li><strong>updated</strong>（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li>
<li><strong>beforeDestroy</strong>（销毁前） 在实例销毁之前调用。实例仍然完全可用。</li>
<li><strong>destroyed</strong>（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</li>
</ul>
<h3 id="数据绑定原理"><a href="#数据绑定原理" class="headerlink" title="数据绑定原理"></a>数据绑定原理</h3><ul>
<li>vue实现数据双向绑定主要是：采<strong>用数据劫持结合发布者-订阅者模式</strong>的方式，通过<strong>Object.defineProperty（）</strong>来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</li>
<li>vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 ），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —>视图更新；视图交互变化（input）—>数据model变更双向绑定效果。</li>
</ul>
<h3 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h3><ul>
<li><p>父组件与子组件传值</p>
<ul>
<li>父组件传给子组件：子组件通过props方法接受数据;</li>
<li>子组件传给父组件：$emit方法传递参数</li>
</ul>
</li>
<li><p>非父子组件间的数据传递，兄弟组件传值</p>
<ul>
<li>使用vuex。</li>
</ul>
</li>
</ul>
<h3 id="路由实现"><a href="#路由实现" class="headerlink" title="路由实现"></a>路由实现</h3><ul>
<li><p>模式</p>
<ul>
<li><p>history模式</p>
<ul>
<li><strong>history模式：</strong>history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。</li>
</ul>
</li>
<li><p>hash模式</p>
<ul>
<li><strong>hash模式：</strong>在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；</li>
<li>特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。</li>
<li>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。</li>
</ul>
</li>
</ul>
</li>
<li><p>vue-router</p>
<ul>
<li><p>路由嵌套</p>
<ul>
<li>在 VueRouter 的参数中使用 children 配置，这样就可以很好的实现路由嵌套。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><ul>
<li>低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的"View"上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</li>
</ul>
</li>
<li><ul>
<li>可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。</li>
</ul>
</li>
<li><ul>
<li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用 Expression Blend 可以很容易设计界面并生成 xml 代码。</li>
</ul>
</li>
<li><ul>
<li>可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li>
</ul>
</li>
</ul>
<h3 id="vue中的data必须是函数"><a href="#vue中的data必须是函数" class="headerlink" title="vue中的data必须是函数"></a>vue中的data必须是函数</h3><ul>
<li>对象为引用类型，当重用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。</li>
</ul>
<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><ul>
<li><p>vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车<br>有 5 种属性，分别是 state、getter、mutation、action、module</p>
</li>
<li><p>store 特性</p>
<ul>
<li><p>vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 datastate 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</p>
</li>
<li><p>使用 Vuex 只需执行 Vue.use(Vuex)，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？</p>
<ul>
<li>Vue.use(Vuex) 方法执行的是 install 方法，它实现了 Vue 实例对象的 init 方法封装和注入，使传入的 store 对象被设置到 Vue 上下文环境的store中。因此在VueComponent任意地方都能够通过this.store 访问到该 store。</li>
</ul>
</li>
</ul>
</li>
<li><p>getter特性</p>
<ul>
<li>getter 可以对 state 进行计算操作，它就是 store 的计算属性虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用如果一个状态只在一个组件内使用，是可以不用 getters</li>
</ul>
</li>
<li><p>mutation特性</p>
<ul>
<li>action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态action 可以包含任意异步操作</li>
</ul>
</li>
<li><p>原理</p>
<ul>
<li>vuex 仅仅是作为 vue 的一个插件而存在，不像 Redux,MobX 等库可以应用于所有框架，vuex 只能使用在 vue 上，很大的程度是因为其高度依赖于 vue 的 computed 依赖检测系统以及其插件系统，vuex 整体思想诞生于 flux,可其的实现方式完完全全的使用了 vue 自身的响应式设计，依赖监听、依赖收集都属于 vue 对对象 Property set get 方法的代理劫持。</li>
<li>最后一句话结束 vuex 工作原理，vuex 中的 store 本质就是没有 template 的隐藏着的 vue 组件；</li>
</ul>
</li>
</ul>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li><p>vue指令</p>
<ul>
<li><p>v-cloak</p>
<ul>
<li><p v-cloak></p>
</li>
<li><p>解决插值表达式闪烁问题（即网速慢时，只显示）</p>
</li>
</ul>
</li>
<li><p>v-text</p>
<ul>
<li><p><code>&lt;h2 v-text=&quot;msg&quot;&gt;*****&lt;/h2&gt;</code></p>
</li>
<li><p>会覆盖掉****，无闪烁问题</p>
</li>
</ul>
</li>
<li><p>v-html</p>
<ul>
<li><p><code>&lt;p  v-html=&quot;msg&quot;&gt;&lt;/p&gt;</code></p>
</li>
<li><p>会解析html格式的代码</p>
</li>
</ul>
</li>
<li><p>v-bind（  :  )</p>
<ul>
<li>绑定属性</li>
</ul>
</li>
<li><p>v-on (  @  )</p>
<ul>
<li>绑定事件</li>
</ul>
</li>
<li><p>v-model</p>
<ul>
<li>双向数据绑定</li>
</ul>
</li>
<li><p>v-for：遍历属性</p>
<ul>
<li>组件中使用v-for时，key是必须的。</li>
</ul>
</li>
<li><p>v-if</p>
<ul>
<li>高切换消耗。</li>
</ul>
</li>
<li><p>v-show</p>
<ul>
<li>高初始渲染消耗。</li>
</ul>
</li>
</ul>
</li>
<li><p>事件修饰符</p>
<ul>
<li><p>.stop</p>
<ul>
<li>阻止冒泡</li>
</ul>
</li>
<li><p>.prevent</p>
<ul>
<li>阻止默认事件</li>
</ul>
</li>
<li><p>.capture</p>
<ul>
<li>阻止事件捕获</li>
</ul>
</li>
<li><p>.self</p>
<ul>
<li>只阻止该元素自身事件</li>
</ul>
</li>
<li><p>.once</p>
<ul>
<li>事件只触发一次</li>
</ul>
</li>
</ul>
</li>
<li><p>过滤器</p>
<ul>
<li><p>只能用于mustach插值和v-bind表达式</p>
</li>
<li><p>私有过滤器</p>
<ul>
<li>filters: {dataFormat(data){}}</li>
</ul>
</li>
<li><p>全局过滤器</p>
<ul>
<li>Vue.filter('dataFormat',function(data){})</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义键盘修饰符</p>
<ul>
<li>Vue.config.keyCodes.名称 = 按键值</li>
</ul>
</li>
<li><p>自定义指令</p>
<ul>
<li><p>Vue.directive('focus',{<br>bind:function(el,binding){}<br>inserted:function(el){}<br>update:function(el){}})</p>
<ul>
<li><p>注意：在每个函数中，第一个参数永远是el，表示被绑定了指令的那个元素，这个el参数是一个原生的JS对象。</p>
</li>
<li><p>bind:每当指令绑定到元素上时会立即执行这个bind函数，只执行一次。</p>
<ul>
<li>和样式相关的操作一般放在bind函数中。</li>
<li>bind函数中有binding对象（包括name，value。。。属性）</li>
<li>子主题 3</li>
</ul>
</li>
<li><p>inserted表示元素插入到DOM中的时候会执行inserted函数，只触发一次。</p>
<ul>
<li>和JS行为有关的操作最好在inserted中执行放置。</li>
</ul>
</li>
<li><p>update:当VNode更新时会执行updates，可能会触发多次。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>请求地址</p>
<ul>
<li><p>vue-resource</p>
<ul>
<li><p>实现get,post,jsonp请求</p>
</li>
<li><p>在this.$http.get/post/jsonp().then()</p>
</li>
<li><p>form表单发起post请求，默认使用application/x-www-form-urlencoded表单格式。而vue-resource则是手动发起的post请求，默认没有表单格式，所以，有的服务器处理不了。</p>
</li>
<li><p>this.$http.post()中接受三个参数：</p>
<ul>
<li>第一个参数是要请求的URL地址。</li>
<li>第二个是要提交给服务器的数据，要以对象形式提交给服务器</li>
<li>第三个是一个配置对象，要以哪种表单数据类型提交过去。{emulateJSON: true},以普通表单格式将数据提交给服务器。</li>
</ul>
</li>
<li><p>指定数据接口根域名</p>
<ul>
<li>Vue.http.options.root = 'http://***/'<br>this.$http.get('add').then()</li>
<li>如果我们通过全局配置了请求的数据接口的根域名，则在每次单独发起http请求的时候，请求的 url 路径，必须以相对路径开头，前面不能带  / ，否则不会启用根路径做拼接。</li>
</ul>
</li>
<li><p>全局启用emulateJSON选项</p>
<ul>
<li>Vue.http.options.emulateJSON = true;<br>this.$http.post(url,参数）</li>
</ul>
</li>
</ul>
</li>
<li><p>JSONP的实现原理</p>
<ul>
<li><p>由于浏览器的安全限制，不允许AJAX访问跨域请求的数据接口，浏览器认为这种访问不安全。</p>
</li>
<li><p>可以通过动态创建script标签的形式，把script标签的src属性指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式称为JSONP（注意：根据JSONP的实现原理知晓，JSONP只支持GET请求。</p>
</li>
<li><p>具体实现过程</p>
<ul>
<li>先在客户端定义一个回调方法，预定义对数据的操作；</li>
<li>再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口。</li>
<li>服务端数据接口组织好要发送给客户端的数据，再拿着客户端传过来的回调方法名称，拼接出一个回调这个方法的字符串发送给客户端去解析执行。</li>
<li>客户端拿到服务器返回的字符串后，当作script脚本去解析执行，这样就能够拿到JSONP的数据了。</li>
</ul>
</li>
</ul>
</li>
<li><p>请求方法axios</p>
<ul>
<li><p>ajax</p>
<ul>
<li>【优点：局部更新；原生支持】</li>
<li>【缺点：可能破坏浏览器后退功能；嵌套回调】</li>
</ul>
</li>
<li><p>jqueryAjax：</p>
<ul>
<li>【在原生的ajax的基础上进行了封装；支持jsonp】</li>
</ul>
</li>
<li><p>fetch：</p>
<ul>
<li>【优点：解决回调地狱】</li>
<li>【缺点：API 偏底层，需要封装;默认不带Cookie，需要手动添加; 浏览器支持情况不是很友好，需要第三方的ployfill】</li>
</ul>
</li>
<li><p>axios</p>
<ul>
<li>支持浏览器和node.js</li>
<li>支持promise</li>
<li>能拦截请求和响应</li>
<li>能转换请求和响应数据</li>
<li>能取消请求</li>
<li>自动转换JSON数据</li>
<li>浏览器端支持防止CSRF(跨站请求伪造)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用<transition name="***"  mode="out-in">包裹</p>
<ul>
<li><p>name属性指定使用对象；<br>mode属性指定模式</p>
</li>
<li><p>有v-enter-active，v-leave-active和v-enter，v-leave的样式类名。</p>
</li>
<li><p>引入animate.css动画类库</p>
<ul>
<li>注意每个类中都得加animated这个基本类，效果才会出现。</li>
</ul>
</li>
<li><p>动画钩子函数</p>
<ul>
<li><p>第一个参数都是el，表示要执行动画的那个DOM元素，是个原生的JS DOM对象，大家可以认为el是通过document.getElementById获得的。</p>
</li>
<li><p>beforeEnter(el){}</p>
<ul>
<li>表示动画入场之前，此时动画尚未开始，可在函数中设置动画起始样式。</li>
</ul>
</li>
<li><p>enter(el，done){<br>el.offsetWidth<br>el.style.transform = ''<br>done()<br>}</p>
<ul>
<li>enter表示动画开始之后的样式，这里可以设置动画完成之后的结束状态。</li>
<li>el.offsetWidth这句话没实际作用，但是不写，出不来动画效果，可认为el.offsetWidth会强制动画刷新。</li>
<li>done():done是afterEnter()函数的引用，写上即可解决需要等一下才会出现afterEnter中设置的样式。因为它被同步调用。</li>
</ul>
</li>
<li><p>afterEnetr(el){}</p>
</li>
</ul>
</li>
<li><p>transition-group</p>
<ul>
<li>要使元素都很平滑过渡，使用固定模式：<br>.v-move{ transition: all  0.6s  ease; }<br>.v-leave-active{  position: absolute;  }<br>它会在元素的改变定位过程中应用。</li>
<li>在实现列表过渡的时候，如果需要过渡的元素是通过v-for循环创建的元素不能使用transition包裹，而应该使用transition-group，其中每个v-for出来的元素需要加上：key属性。</li>
<li>给transition-group添加appear属性，实现页面刚渲染出来时有入场的效果。</li>
<li>设置tag属性指定transition-group渲染为指定为元素，如不指定，默认为span标签。</li>
</ul>
</li>
</ul>
</li>
<li><p>数据监听</p>
<ul>
<li>watch属性监听data中属性/路由对象的改变</li>
<li>computed计算属性</li>
</ul>
</li>
</ul>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ul>
<li><p>cookie</p>
<ul>
<li><p>优点：</p>
<ul>
<li><ol>
<li>通过良好的编程习惯，控制保存在cookie中的session对象的大小。</li>
</ol>
</li>
<li><ol start="2">
<li>通过加密和安全传输技术，减少cookie被破解的可能性。</li>
</ol>
</li>
<li><ol start="3">
<li>只在cookie中存放不敏感数据，即使被盗也不会有重大损失。</li>
</ol>
</li>
<li><ol start="4">
<li>控制cookie的生命周期，使之不会永远有效。偷盗者可能拿到一个过期的cookie。</li>
</ol>
</li>
<li>5.解决无状态问题。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><ol>
<li>cookie数量和长度的限制。每个域名最多有20条cookie，每个cookie长度不超过4KB，否则会被截掉。</li>
</ol>
</li>
<li><ol start="2">
<li>安全性问题。如果cookie被人拦截，那人就可以获取session信息。即使加密也于事无补，因为拦截者并不需要知道cookie的信息，他只要原样转发cookie就可达到目的。</li>
</ol>
</li>
<li><ol start="3">
<li>有些状态不可能保存在客户端。如，为了防止重复提交表单，我们需要在服务器保存一个计数器。如果我们把这个计数器保存在客户端就起不到任何作用。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>浏览器本地存储</p>
<ul>
<li><ul>
<li>在较高版本的浏览器中，js提供sessionStorage和globalStorage。而HTML5使用localStorage代替globalStorage。</li>
</ul>
</li>
<li><ul>
<li>seesionStorage用于存储一个会话（session）中的数据，这些数据只在同一个会话中的页面才能访问并当会话结束后数据也随之销毁。因此，sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。</li>
</ul>
</li>
<li><ul>
<li>而localStorage用于持久化的本地存储，除非用户主动删除，否则数据永远不会过期。</li>
</ul>
</li>
</ul>
</li>
<li><p>web storage与cookie的区别</p>
<ul>
<li><ul>
<li>webStorage的概念与cookie相似，区别是他是为了更大存储设计的。cookie的大小是受限的，并且每次你请求一个新的页面时cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需指定作用域，不可跨域调用。</li>
</ul>
</li>
<li><ul>
<li>除此以外，Web Storage拥有setitem，getitem，removeitem，clear等方法，不像cookie需要前端开发者自己封装setCookie和getCookie。</li>
</ul>
</li>
<li><ul>
<li>但Cookie却是不可或缺的，cookie的作用是与服务器交互，作为http规范的一部分存在，而Web Storage仅仅是为了在本地存储数据而生。</li>
</ul>
</li>
</ul>
</li>
<li><p>cookie与session区别</p>
<ul>
<li><ol>
<li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>
</ol>
</li>
<li><ol start="2">
<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。考虑到安全应当使用session。</li>
</ol>
</li>
<li><ol start="3">
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</li>
</ol>
</li>
<li>考虑到减轻服务器性能方面，应当使用COOKIE。</li>
<li><ol start="4">
<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul>
<li><p>同步加载</p>
<ul>
<li>请求提交 -> 等待服务器处理 -> 处理完毕返回，这个期间客户端浏览器不能干任何事</li>
<li>又称阻塞模式，会阻塞到未加载的css，html的加载和渲染。</li>
<li>流览器之所以会采用同步模式，是因为加载的js文件中有对dom的操作，重定向，输出document等默认行为，所以同步才是最安全的。通常会把要加载的js放到body结束标签之前，使得js可在页面最后加载，尽量减少阻塞页面的渲染。这样可以先让页面显示出来</li>
</ul>
</li>
<li><p>异步加载</p>
<ul>
<li>请求通过事件触发 -> 服务器·处理（这时浏览器可以做其他事） -> 处理完毕</li>
<li><ol>
<li>也叫非阻塞模式加载，浏览器在下载js的同时，同时还会执行后续的页面处理。</li>
</ol>
</li>
<li><ol start="2">
<li>异步加载的方案有：动态插入js标签；通过ajax去获取js代码，通过eval执行；添加defer或async属性；创建并插入ifram，让它异步执行js。</li>
</ol>
</li>
</ul>
</li>
<li><p>延迟加载（懒加载）</p>
<ul>
<li><ol>
<li>有些js代码并不是页面初始化时就立刻需要，而稍后才需要。</li>
</ol>
</li>
<li><ol start="2">
<li>延迟加载就是一开始并不加载这些暂时不用的js，而是在需要的时候或稍后再通过js 的控制来异步加载。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul>
<li><p>同源策略及其限制</p>
<ul>
<li>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。它的存在可以保护用户隐私信息，防止身份伪造等(读取Cookie)。</li>
<li>同源策略限制内容有：Cookie、LocalStorage、IndexedDB 等存储性内容</li>
<li>img，link，script这三个标签允许跨域</li>
</ul>
</li>
<li><p>处理跨域方法</p>
<ul>
<li><p>JSONP</p>
<ul>
<li>原理：利用script元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</li>
<li>JSONP优点：是兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性。</li>
<li>JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。</li>
<li>流程：<br>1.声明一个回调函数，其函数名(如fn)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据。<br>2.服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串。<br>3.最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（fn），对返回的数据进行操作。</li>
</ul>
</li>
<li><p>CORS</p>
<ul>
<li>原理：整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</li>
<li>优点在于功能更加强大支持各种HTTP Method，缺点是兼容性不如JSONP。</li>
</ul>
</li>
<li><p>WebSocket</p>
<ul>
<li>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</li>
<li>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</li>
</ul>
</li>
<li><p>PostMessage</p>
<ul>
<li>如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即"协议 + 域名 + 端口"。也可以设为*，表示不限制域名，向所有窗口发送。</li>
</ul>
</li>
<li><p>服务器上设置代理页面</p>
</li>
</ul>
</li>
</ul>
<h3 id="输入url。。。"><a href="#输入url。。。" class="headerlink" title="输入url。。。"></a>输入url。。。</h3><ul>
<li>输入url后，首先需要找到这个url域名的服务器ip,为了寻找这个ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存-》路由器缓存，缓存中没有则查找系统的hosts文件中是否有记录，如果没有则查询DNS服务器，得到服务器的ip地址后，浏览器根据这个ip以及相应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个http请求封装在一个tcp包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的html给浏览器，因为html是一个树形结构，浏览器根据这个html来构建DOM树，在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐JS代码应该放在html代码的后面，之后根据外部央视，内部央视，内联样式构建一个CSS对象模型树CSS树，构建完成后和DOM树合并为渲染树，这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为html文件中会含有图片，视频，音频等资源，在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。 Cache-Control和Expires的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用Cache-Control，在请求这些有设置了缓存的数据时，会先 查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了ETag值会在这次请求的时候作为If-None-Match的值交给服务器校验，如果一致，继续校验 Last-Modified，没有设置ETag则直接验证Last-Modified，再决定是否返回304。</li>
</ul>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul>
<li><ol>
<li>减少http请求次数：CSS Sprites，JS、CSS源码压缩，图片大小控制合适；网页Gzip，CDN托管，data缓存，图片服务器。</li>
</ol>
</li>
<li><ol start="2">
<li>前端模板JS + 数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数。</li>
</ol>
</li>
<li><ol start="3">
<li>用innerHTML代替DOM操作，减少DOM操作的次数，优化js性能。</li>
</ol>
</li>
<li><ol start="4">
<li>当需要设置的样式很多时设置className而不是直接操作style。</li>
</ol>
</li>
<li><ol start="5">
<li>少用全局变量，缓存DOM节点查找的结果。减少IO读取操作。</li>
</ol>
</li>
<li><ol start="6">
<li>避免使用动态属性。</li>
</ol>
</li>
<li><ol start="7">
<li>图片预加载，将样式表放在顶部，将脚本放在底部，加上时间戳。</li>
</ol>
</li>
<li>8.利用webpack优化</li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul>
<li><p>XSS</p>
<ul>
<li>XSS跨站脚本攻击指恶意攻击者往web页面插入恶意代码，当用户浏览该页时，嵌入其中的html代码会被执行，从而达到恶意用户的目的。</li>
<li>防范：XSS攻击的核心是利用脚本注入。因此我们解决方法很简单，不信任用户的输入，对特殊字符进行如 “<”，“>" 转义。</li>
</ul>
</li>
<li><p>CSRF</p>
<ul>
<li><p>CSRF跨站请求伪造核心是请求伪造，通过伪造身份提交POST和GET请求来进行跨域的攻击。常见操作如转账。</p>
</li>
<li><p>完成跨站请求伪造需要两个步骤：</p>
<ul>
<li><ol>
<li>登陆受信任的网站A，在本地生成cookie。</li>
</ol>
</li>
<li><ol start="2">
<li>在不登出网站A或cookie未过期时，访问危险网站B。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SQL注入</p>
<ul>
<li><p>SQL注入攻击指应用程序在向后台数据库传递数据时，攻击者将SQL语句插入到表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意代码的SQL命令。</p>
</li>
<li><p>防范：</p>
<ul>
<li>1、增加黑名单或者白名单验证<br>白名单验证一般指，检查用户输入是否是符合预期的类型、长度、数值范围或者其他格式标准。黑名单验证是指，若在用户输入中，包含明显的恶意内容则拒绝该条用户请求。在使用白名单验证时，一般会配合黑名单验证。</li>
<li>2、安全检测<br>在项目完成的时候，始终坚持安全检测</li>
<li>3、防止系统敏感信息泄露<br>对数据表的访问权限进行严格控制，尽量限制用户不必要的访问权限。</li>
</ul>
</li>
</ul>
</li>
<li><p>文件上传漏洞</p>
<ul>
<li><p>原理：由于文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，导致允许攻击者向某个可通过 Web 访问的目录上传任意后台文件，并能够将这些文件传递给解释器，就可以在远程服务器上执行任意后台脚本。</p>
</li>
<li><p>防范：</p>
<ul>
<li>1、检查服务器是否判断了上传文件类型及后缀。</li>
<li>2、定义上传文件类型白名单，即只允许白名单里面类型的文件上传。</li>
<li>3、文件上传目录禁止执行脚本解析，避免攻击者进行二次攻击。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><ul>
<li><p>状态码</p>
<ul>
<li>1   --   继续，一般在发送post请求，已发送了http header之后，服务器将返回此信息，表示确认，之后发送具体参数信息。</li>
<li>2   --      请求成功。</li>
<li>3   --    重定向</li>
<li>4   --    客户端错误。</li>
<li>5   --    服务端错误。</li>
</ul>
</li>
<li><p>http与https区别</p>
<ul>
<li>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。</li>
<li>主要的区别如下：</li>
<li>Https协议需要ca证书，费用较高。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
<li>在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层</li>
</ul>
</li>
<li><p>https</p>
<ul>
<li><p>工作原理</p>
<ul>
<li>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</li>
<li>客户使用https url访问服务器，则要求web 服务器建立ssl链接。</li>
<li>web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。</li>
<li>客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。</li>
<li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>
<li>web服务器通过自己的私钥解密出会话密钥。</li>
<li>web服务器通过会话密钥加密与客户端之间的通信。</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>
<li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。</li>
<li>https缓存不如http高效，会增加数据开销。</li>
<li>SSL证书也需要钱，功能越强大的证书费用越高。</li>
<li>SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。</li>
</ul>
</li>
</ul>
</li>
<li><p>http2.0</p>
<ul>
<li><ol>
<li>提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比http1.0）</li>
</ol>
</li>
<li><ol start="2">
<li>允许多路复用：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了：在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。</li>
</ol>
</li>
<li><ol start="3">
<li>二进制分帧：HTTP2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码</li>
</ol>
</li>
<li><ol start="4">
<li>首部压缩</li>
</ol>
</li>
<li><ol start="5">
<li>服务器端推送</li>
</ol>
</li>
</ul>
</li>
<li><p>http协议无状态协议</p>
<ul>
<li><p>无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，需要重传，这样可能导致每次连接传送的数据量增大。</p>
<ul>
<li>HTTP无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持HTTP连接状态的技术就应运而生了，一个是Cookie，而另一个则是Session。HTTP本身是一个无状态的连接协议，为了支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是Cookie和Session了。</li>
<li>也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。</li>
</ul>
</li>
<li><p>可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。</p>
</li>
</ul>
</li>
</ul>
<h3 id="对前端的认识和看法"><a href="#对前端的认识和看法" class="headerlink" title="对前端的认识和看法"></a>对前端的认识和看法</h3><ul>
<li><ol>
<li>前端他是一个工作，他的工作领域是浏览器，它既要与美工，设计打交道又要懂点后台代码，知道ajax怎么从后台拿数据，接口怎么调用，最主要的是把美工的图合成完成的网页呈现给用户，需要实现网页的交互效果。</li>
</ol>
</li>
<li><ol start="2">
<li>前端处于设计和后台的中间领域，起到承上启下的作用，这就要求前端工程师的知识面在横向上必须要广。服务器技术要懂，产品与交互也要懂</li>
</ol>
</li>
<li><ol start="3">
<li>它需要掌握三个基本的技能：HTML，CSS， javascript。另外还需要懂点PHP或者其他应用在Web上的编程语言。</li>
</ol>
</li>
<li>前端的未来则是：有越来越多的软件开始在浏览器里运行，随着google和火狐的webos的发展，甚至在不久的将来，浏览器的api，会替代操作系统的sdk成为软件开发的标准。随着html5的发展，浏览器里运行的早已不是简单的页面，而是复杂的web应用。前端工程师也早已不是页面制作，而是web应用工程师。而未来究竟是web时代还是app时代仍是一个难以回答的问题。</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>逻辑结构</p>
<ul>
<li><p>集合结构</p>
</li>
<li><p>线性结构</p>
<ul>
<li>栈</li>
<li>队列</li>
<li>链表</li>
</ul>
</li>
<li><p>树形结构</p>
</li>
<li><p>图形结构</p>
</li>
</ul>
</li>
<li><p>物理结构</p>
<ul>
<li>顺序存储结构</li>
<li>链式存储结构</li>
</ul>
</li>
</ul>
<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>底部导航条采用uni-app自带的的tabbar，可在pages.json配置。因为顶部导航条的样式不想采用默认样式，所以取消顶部导航栏的默认样式，使用自己写的导航条，并使用固定定位display为flexed将导航条固定在顶部，设置z-index为99，使所有内容都处于导航条下面。</p>
<h3 id="尽量使用字体图标代替图片"><a href="#尽量使用字体图标代替图片" class="headerlink" title="尽量使用字体图标代替图片"></a>尽量使用字体图标代替图片</h3><ul>
<li><ol>
<li>轻量级：一个字体图标要比一系列的图像小，一旦字体加载了，图标就会马上渲染出来，不需要下载一个个图像，这样可减少HTTP请求，而且和HTML5的离线存储配合，可以对性能做出优化。</li>
</ol>
</li>
<li><ol start="2">
<li>灵活性：不调字体可以像页面中的文字一样通过font-size属性来对其进行大小的设置，且可添加各种文字效果，如color、hover、filter、text-shadow、transform等效果。灵活的很。</li>
</ol>
</li>
<li><ol start="3">
<li>兼容性：图标字体支持现代浏览器甚至低版本的IE浏览器，可放心使用。</li>
</ol>
</li>
<li><ol start="4">
<li>相对于位图放大图片会失真，缩小会浪费像素点，图标字体不会出现这种情况。</li>
</ol>
</li>
</ul>
<p>另外，点击导航栏进行页面切换部分采用uni-app官方为我们提供的scroll-view来实现横向或竖向的滚动。其特点是可以无缝滚动，且不会出现滚动条，当想使用滚动动画时可使用scroll-with-animation，感觉比较方便。</p>
<p>图片轮播图中出现在开发者工具显示正常，在手机上右半部分出现一部分空白，只需加上一个div将其包裹起来，最后一张图片切换到第一张时给人感觉不正常，只需将两套一样的图片拼接在一起即可。还有就是</p>
<p>页面整体采用flex布局，把重复的地方抽离出来并以组件形式呈现，把字体文件和公共样式文件单独存放。</p>
<h3 id="使用swiper组件"><a href="#使用swiper组件" class="headerlink" title="使用swiper组件"></a>使用swiper组件</h3><ul>
<li><ul>
<li>决定轮播图真正的高度是swiper，在其上设置高度才有效。swiper-item宽高自动是100%；</li>
</ul>
</li>
<li><ul>
<li>最好在swiper组件外面用view包裹，不然在手机端看时，图片无法全部铺满屏宽，右边有留白。</li>
</ul>
</li>
</ul>
</script></li></ol></li></ul></li></ul>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2020/04/07/前端面试/">前端面试</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">陈楚吟</a></p>
        <p><span>发布时间:</span>2020-04-07, 22:26:30</p>
        <p><span>最后更新:</span>2020-04-29, 14:26:08</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2020/04/07/前端面试/" title="前端面试">http://yoursite.com/2020/04/07/前端面试/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2020/04/07/前端面试/　　作者: 陈楚吟" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2020/04/27/数据结构与算法/">
                    数据结构与算法
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2020/04/06/http的学习/">
                    http的学习
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#面试"><span class="toc-number">1.</span> <span class="toc-text">面试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML5"><span class="toc-number">1.1.</span> <span class="toc-text">HTML5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#what"><span class="toc-number">1.1.1.</span> <span class="toc-text">what</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优"><span class="toc-number">1.1.2.</span> <span class="toc-text">优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺"><span class="toc-number">1.1.3.</span> <span class="toc-text">缺</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Doctype作用"><span class="toc-number">1.1.4.</span> <span class="toc-text">Doctype作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#语义化"><span class="toc-number">1.1.5.</span> <span class="toc-text">语义化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS3"><span class="toc-number">1.2.</span> <span class="toc-text">CSS3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#响应式布局"><span class="toc-number">1.2.1.</span> <span class="toc-text">响应式布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#出现css阻塞地方"><span class="toc-number">1.2.2.</span> <span class="toc-text">出现css阻塞地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化css性能"><span class="toc-number">1.2.3.</span> <span class="toc-text">优化css性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#css预处理"><span class="toc-number">1.2.4.</span> <span class="toc-text">css预处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浮动的原理和工作方式"><span class="toc-number">1.2.5.</span> <span class="toc-text">浮动的原理和工作方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#link与-import区别"><span class="toc-number">1.2.6.</span> <span class="toc-text">link与@import区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#absolute与fixed区别"><span class="toc-number">1.2.7.</span> <span class="toc-text">absolute与fixed区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#src与href区别"><span class="toc-number">1.2.8.</span> <span class="toc-text">src与href区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bootstrap"><span class="toc-number">1.2.9.</span> <span class="toc-text">bootstrap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS"><span class="toc-number">1.3.</span> <span class="toc-text">JS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#js继承及对象共享"><span class="toc-number">1.3.1.</span> <span class="toc-text">js继承及对象共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js阻塞"><span class="toc-number">1.3.2.</span> <span class="toc-text">js阻塞</span></a></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"前端面试　| Nikita　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2020/04/27/数据结构与算法/" title="上一篇: 数据结构与算法">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2020/04/06/http的学习/" title="下一篇: http的学习">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/ES6的学习/">ES6的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/vue学习中的问题/">vue学习中的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/27/计算机网络/">计算机网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/27/数据结构与算法/">数据结构与算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/07/前端面试/">前端面试</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/06/http的学习/">http的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/课程表制作/">课程表制作</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/CSS3/">CSS3</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/Grid布局/">Grid布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/CSS3高阶/">CSS3高阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/HTML5基础下-陈楚吟/">HTML5基础下--陈楚吟</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/HTML5基础上-陈楚吟/">HTML5基础上-陈楚吟</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/深入理解css/">深入理解css</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/选择器/">选择器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/vue学习三/">vue学习三</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/vue学习二/">vue学习二</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/vue学习一/">vue学习一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/浅谈canvas和相关实战/">浅谈canvas和相关实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/setTimeout与setInterval区别/">setTimeout与setInterval区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/js中callee和caller/">js中callee和caller</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/行内元素存在间距问题/">行内元素存在间距问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/09/canvas绘制碰撞球动画/">canvas绘制碰撞球动画</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/27/用JavaScript封装栈/">用JavaScript封装栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/26/伪类与伪元素的区区别/">伪类与伪元素的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/17/深入理解包与NPM和package-json深入解读/">深入理解包与NPMM,package.json深入解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/15/JS中外部文件的优势-1/">JS中外部文件的优势</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/15/node模块编译/">node模块编译</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/03/vue进阶/">vue进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/27/webpack学习/">webpack学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/15/攻克object对象/">攻克object对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/15/qq小程序天坑之旅/">qq小程序天坑之旅</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/27/proto/">proto</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/26/项目开发流程/">项目开发流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/25/事件机制/">事件机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/15/js执行上下文/">js执行上下文</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/15/js中的立即执行函数/">js中的立即执行函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/14/了解浏览器/">了解浏览器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/13/我认识的js原型及原型链/">我认识的js原型及原型链</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/12/深入理解js中的this/">深入理解js中的this</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/12/相对全面的数组去重/">相对全面的数组去重</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/11/css盒模型集锦/">css盒模型集锦</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 陈楚吟
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="陈楚吟">



<meta name="description" content="ES6变量声明let命令 声明变量，只在所在的代码块有效，处于暂时性死区 for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 变量不提升，不允许重复声明 允许在块级作用域内声明函数，函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。">
<meta name="keywords" content="write myBlog">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6的学习">
<meta property="og:url" content="http://yoursite.com/2020/04/28/ES6的学习/index.html">
<meta property="og:site_name" content="Nikita">
<meta property="og:description" content="ES6变量声明let命令 声明变量，只在所在的代码块有效，处于暂时性死区 for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 变量不提升，不允许重复声明 允许在块级作用域内声明函数，函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-06-17T07:18:53.704Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6的学习">
<meta name="twitter:description" content="ES6变量声明let命令 声明变量，只在所在的代码块有效，处于暂时性死区 for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 变量不提升，不允许重复声明 允许在块级作用域内声明函数，函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Nikita" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>ES6的学习 | Nikita</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">陈楚吟</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不负韶华</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">陈楚吟</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">陈楚吟</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不负韶华</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-ES6的学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/28/ES6的学习/" class="article-date">
      <time datetime="2020-04-28T06:51:11.000Z" itemprop="datePublished">2020-04-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ES6的学习
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="ES6变量声明"><a href="#ES6变量声明" class="headerlink" title="ES6变量声明"></a>ES6变量声明</h4><h6 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h6><ul>
<li>声明变量，只在所在的代码块有效，处于暂时性死区</li>
<li><code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</li>
<li>变量不提升，不允许重复声明</li>
<li>允许在块级作用域内声明函数，函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</li>
</ul>
<h6 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h6><ul>
<li><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。且必须立即初始化，不能留到以后赋值。只声明不赋值，就会报错。</li>
<li><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</li>
</ul>
<h6 id="将对象彻底冻结"><a href="#将对象彻底冻结" class="headerlink" title="将对象彻底冻结"></a>将对象彻底冻结</h6><ul>
<li><p>简单冻结 ：const   foo = Object.freeze({});</p>
</li>
<li><p>对象及属性都冻结：</p>
<p>var  constantize = (obj) =&gt; {</p>
<p>Object.freeze(obj);</p>
<p>Object.keys(obj).forEach((key,i) =&gt;{</p>
<p>if( typeof  obj[key] === ‘object’) {</p>
<p>constantize(obj[key]);}</p>
<p>});};</p>
</li>
</ul>
<h6 id="import命令"><a href="#import命令" class="headerlink" title="import命令"></a>import命令</h6><h6 id="class命令"><a href="#class命令" class="headerlink" title="class命令"></a>class命令</h6><h6 id="顶层对象"><a href="#顶层对象" class="headerlink" title="顶层对象"></a>顶层对象</h6><ul>
<li>浏览器环境中的顶层对象指window对象，node指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。<ul>
<li>浏览器里面，顶层对象是<code>window</code>，但 Node 和 Web Worker 没有<code>window</code>。</li>
<li>浏览器和 Web Worker 里面，<code>self</code>也指向顶层对象，但是 Node 没有<code>self</code>。</li>
<li>Node 里面，顶层对象是<code>global</code>，但其他环境都不支持。</li>
</ul>
</li>
<li>一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。</li>
<li>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用<code>this</code>变量，但是有局限性。<ul>
<li>全局环境中，<code>this</code>会返回顶层对象。但是，Node 模块和 ES6 模块中，<code>this</code>返回的是当前模块。</li>
<li>函数里面的<code>this</code>，如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这时<code>this</code>会返回<code>undefined</code>。</li>
<li>不管是严格模式，还是普通模式，<code>new Function(&#39;return this&#39;)()</code>，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么<code>eval</code>、<code>new Function</code>这些方法都可能无法使用。</li>
</ul>
</li>
</ul>
<h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><ul>
<li>只需模式匹配即可用数组方式为各种数据类型赋值</li>
<li>解构赋值允许指定默认值。只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。</li>
</ul>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ul>
<li>全局环境中，this会返回顶层对象（浏览器是window，Node是global）。但是，Node模块和ES6模块中，this返回当前块</li>
<li>函数里面的this，如果函数不是作为对象的方法执行，而是单纯作为函数运行，this会指向顶层对象。但是在严格模式下，这时的this会返回undefined</li>
<li>不管是严格模式还是普通模式，new   Function（‘return  this’）（），总是返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全策略），那么eval，new  Function这些方法都可能不能使用。</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul>
<li><p>字符串的遍历器接口</p>
<ul>
<li><p>for（let   变量名   of  ‘遍历对象’）{}使得字符串如字符串数组般被遍历。</p>
</li>
<li><p>除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点</p>
<blockquote>
<p>let  text = String.fromCodePoint(0x20BB7);</p>
<p>for(let i = 0;i &lt; text.length; i++){</p>
<p>​    console.log(text[i]);  </p>
<p>}</p>
<p>//“ “</p>
<p>// ” “</p>
<p>//for循环认为其包含两个字符</p>
<p>for（let i  of  text）{</p>
<p>​    console.log(text[i]);  </p>
<p>}</p>
<p>//”吉“</p>
<p>//for…of循环会正确识别出这一个字符</p>
</blockquote>
</li>
</ul>
</li>
<li><p>为了确保返回的是合法的 UTF-8 字符，<a href="https://github.com/tc39/proposal-well-formed-stringify" target="_blank" rel="noopener">ES2019</a> 改变了<code>JSON.stringify()</code>的行为。如果遇到<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(&apos;\u&#123;D834&#125;&apos;) // &quot;&quot;\\uD834&quot;&quot;</span><br><span class="line">JSON.stringify(&apos;\uDF06\uD834&apos;) // &quot;&quot;\\udf06\\ud834&quot;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板字符串</p>
<ul>
<li><p>模板字符串（template string）是增强版的字符串，用反引号（~）标识。他可以当作普通字符串使用，也可以用来定义多行字符串，或在字符串中嵌入变量。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; $(<span class="string">'#result'</span>).append(</span><br><span class="line">&gt; <span class="string">'There are &lt;b&gt;'</span> + basket.count + <span class="string">'&lt;/b&gt; '</span> +</span><br><span class="line">&gt; <span class="string">'items in your basket, '</span> +</span><br><span class="line">&gt; <span class="string">'&lt;em&gt;'</span> + basket.onSale +</span><br><span class="line">&gt; <span class="string">'&lt;/em&gt; are on sale!'</span></span><br><span class="line">&gt; );</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// 普通字符串</span></span><br><span class="line">&gt; <span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// 多行字符串</span></span><br><span class="line">&gt; <span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string">&gt; not legal.`</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">&gt; string text line 2`</span>);</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// 字符串中嵌入变量</span></span><br><span class="line">&gt; <span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line">&gt; <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>上面的代码都是用反引号表示，如果在模板字符串中需要使用反引号，则前面要用反斜杠转义</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> greeting = <span class="string">`\`Yo\` World!`</span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>如果使用模板字符串表示多行字符串，所有空格和缩进都会被保留在输出之中。如不想这个换行，可使用trim方法消除他。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; $(<span class="string">'#list'</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&gt; &lt;ul&gt;</span></span><br><span class="line"><span class="string">&gt; &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">&gt; &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&gt; &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&gt; `</span>.trim());</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>模板字符串嵌入变量，需要将变量名写在${}之中。还可以调用函数大括号内部可以放入任意的js表达式，可进行运算，以及引用对象属性。</p>
</li>
<li><p>如果大括号内的值不是字符串，将按照一般规则转为字符串。若是字符串则会调用对象的toString方法。若模板字符串的变量没有声明，将会报错。</p>
</li>
</ul>
</li>
<li><p>标签模板</p>
<ul>
<li><p>它可紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert `123`</span><br><span class="line">//等价于</span><br><span class="line">alert(123);</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板字符串里面如果有变量，就不是简单调用，而是将模板字符串先处理成多个参数，在调用函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = 5;</span><br><span class="line">let b = 10;</span><br><span class="line"></span><br><span class="line">tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;</span><br><span class="line">// 等同于</span><br><span class="line">tag([&apos;Hello &apos;, &apos; world &apos;, &apos;&apos;], 15, 50);</span><br><span class="line">function tag(stringArr, ...values)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="字符串新增方法"><a href="#字符串新增方法" class="headerlink" title="字符串新增方法"></a>字符串新增方法</h4><ul>
<li><p>String.fromCodePoint()</p>
<ul>
<li>可以识别大于<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode()</code>方法的不足。</li>
</ul>
</li>
<li><p>String.raw()</p>
<ul>
<li>该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</li>
</ul>
</li>
<li><p>codePointAt()</p>
</li>
<li><p>normalize()</p>
<ul>
<li>用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</li>
</ul>
</li>
</ul>
<h6 id="确定一个字符串是否包含在另一个字符串中"><a href="#确定一个字符串是否包含在另一个字符串中" class="headerlink" title="确定一个字符串是否包含在另一个字符串中"></a>确定一个字符串是否包含在另一个字符串中</h6><ul>
<li><p><strong>indexof（）</strong></p>
</li>
<li><p><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</p>
</li>
<li><p><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的头部。</p>
</li>
<li><p><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的尾部。</p>
</li>
<li><h6 id="repeat-：返回一个新字符串，表示将原字符串重复n次。"><a href="#repeat-：返回一个新字符串，表示将原字符串重复n次。" class="headerlink" title="repeat()：返回一个新字符串，表示将原字符串重复n次。"></a>repeat()：返回一个新字符串，表示将原字符串重复<code>n</code>次。</h6><ul>
<li>其参数会先进行往0方向取整再代值，如是负数或Infinity会报错。参数<code>NaN</code>等同于 0</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>) <span class="comment">// "xxx"</span></span><br><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">0</span>) <span class="comment">// ""</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。如果某个字符串不够指定长度，会在头部或尾部补全。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>trimStart()</code>和<code>trimEnd()</code>这两个方法。它们的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</li>
<li><code>matchAll()</code>方法返回一个正则表达式在当前字符串的所有匹配</li>
</ul>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><ul>
<li><p>如果正则构造函数的第一个参数是一个正则对象，那么就可以使用第二个参数指定修饰符。且返回的正则表达式会忽略原有的正则表达式修饰符，只使用新指定的修饰符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new RegExp(/abc/ig,&apos;i&apos;).flags</span><br><span class="line">//&quot;i&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串对象共有 4 个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p>
<p>ES6 将这 4 个方法，在语言内部全部调用<code>RegExp</code>的实例方法，从而做到所有与正则相关的方法，全都定义在<code>RegExp</code>对象上。</p>
<ul>
<li><code>String.prototype.match</code> 调用 <code>RegExp.prototype[Symbol.match]</code></li>
<li><code>String.prototype.replace</code> 调用 <code>RegExp.prototype[Symbol.replace]</code></li>
<li><code>String.prototype.search</code> 调用 <code>RegExp.prototype[Symbol.search]</code></li>
<li><code>String.prototype.split</code> 调用 <code>RegExp.prototype[Symbol.split]</code></li>
</ul>
</li>
</ul>
<h6 id="具名组匹配"><a href="#具名组匹配" class="headerlink" title="具名组匹配"></a>具名组匹配</h6><blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> RE_DATE = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line">&gt; <span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line">&gt; <span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line">&gt; <span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>允许为每一个组匹配指定一个名字。模式的头部添加“问号 + 尖括号 + 组名”，然后就可以在<code>exec</code>方法返回结果的<code>groups</code>属性上引用该组名。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> RE_DATE = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line">&gt; <span class="keyword">const</span> year = matchObj.groups.year; <span class="comment">// 1999</span></span><br><span class="line">&gt; <span class="keyword">const</span> month = matchObj.groups.month; <span class="comment">// 12</span></span><br><span class="line">&gt; <span class="keyword">const</span> day = matchObj.groups.day; <span class="comment">// 31</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>RegExp.prototype.flags 属性返回正则表达式的修饰符。</p>
</li>
</ul>
<h6 id="先行断言"><a href="#先行断言" class="headerlink" title="先行断言"></a>先行断言</h6><p>“先行断言”指的是，<code>x</code>只有在<code>y</code>前面才匹配，必须写成<code>/x(?=y)/</code>。比如，只匹配百分号之前的数字，要写成<code>/\d+(?=%)/</code>。“先行否定断言”指的是，<code>x</code>只有不在<code>y</code>前面才匹配，必须写成<code>/x(?!y)/</code>。比如，只匹配不在百分号之前的数字，要写成<code>/\d+(?!%)/</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\d+(?=%)/.exec(&apos;100% of US presidents have been male&apos;)  // [&quot;100&quot;]</span><br><span class="line">/\d+(?!%)/.exec(&apos;that’s all 44 of them&apos;)                 // [&quot;44&quot;]</span><br></pre></td></tr></table></figure>

<h6 id="后行断言"><a href="#后行断言" class="headerlink" title="后行断言"></a>后行断言</h6><p>“后行断言”正好与“先行断言”相反，<code>x</code>只有在<code>y</code>后面才匹配，必须写成<code>/(?&lt;=y)x/</code>。比如，只匹配美元符号之后的数字，要写成<code>/(?&lt;=\$)\d+/</code>。“后行否定断言”则与“先行否定断言”相反，<code>x</code>只有不在<code>y</code>后面才匹配，必须写成<code>/(?&lt;!y)x/</code>。比如，只匹配不在美元符号后面的数字，要写成<code>/(?&lt;!\$)\d+/</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=\$)\d+/.exec(&apos;Benjamin Franklin is on the $100 bill&apos;)  // [&quot;100&quot;]</span><br><span class="line">/(?&lt;!\$)\d+/.exec(&apos;it’s is worth about €90&apos;)                // [&quot;90&quot;]</span><br></pre></td></tr></table></figure>

<h6 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h6><ul>
<li>RegExp.prototype.unicode属性表示是否设置了u修饰符。</li>
<li>y修饰符隐含了头部匹配的标志^</li>
</ul>
<h4 id="函数的拓展"><a href="#函数的拓展" class="headerlink" title="函数的拓展"></a>函数的拓展</h4><ul>
<li><p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面</p>
<blockquote>
<p>function  log(x,y=’world’){</p>
<p>​    console.log(x,y);</p>
<p>}</p>
</blockquote>
<ul>
<li><p>好处：阅读代码的人可立即意识到哪些参数可以省略，不用查看函数体或文档。其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数也不会导致以前的代码无法运行</p>
</li>
<li><p>参数变量是默认声明的，故不能用let和const再次声明。否则会报错</p>
</li>
<li><p>使用参数默认值时，函数不能有同名参数</p>
</li>
<li><p>参数默认值不是传值的，而是每次都重新计算默认值表达式的值，即参数默认值是惰性求值的。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">&gt; <span class="built_in">console</span>.log(p);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; foo() <span class="comment">// 100</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; x = <span class="number">100</span>;</span><br><span class="line">&gt; foo() <span class="comment">// 101</span></span><br><span class="line">&gt; <span class="comment">//参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>函数与解构默认值结合使用</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">&gt; <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; foo(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">&gt; foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line">&gt; foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line">&gt; foo() <span class="comment">// TypeError: Cannot read property 'x' of undefined</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值就可避免这种情况。</p>
<blockquote>
<p>function   foo({x,y=5} = {}){</p>
<p>​    console.log(x,y);</p>
<p>}</p>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// 函数没有参数的情况</span></span><br><span class="line">&gt; m1() <span class="comment">// [0, 0]</span></span><br><span class="line">&gt; m2() <span class="comment">// [0, 0]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// x 和 y 都有值的情况</span></span><br><span class="line">&gt; m1(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line">&gt; m2(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// x 有值，y 无值的情况</span></span><br><span class="line">&gt; m1(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, 0]</span></span><br><span class="line">&gt; m2(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, undefined]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// x 和 y 都无值的情况</span></span><br><span class="line">&gt; m1(&#123;&#125;) <span class="comment">// [0, 0];</span></span><br><span class="line">&gt; m2(&#123;&#125;) <span class="comment">// [undefined, undefined]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; m1(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [0, 0]</span></span><br><span class="line">&gt; m2(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [undefined, undefined]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>参数默认值一般是尾参数。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">5</span>, z</span>) </span>&#123;</span><br><span class="line">&gt; <span class="keyword">return</span> [x, y, z];</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; f() <span class="comment">// [undefined, 5, undefined]</span></span><br><span class="line">&gt; f(<span class="number">1</span>) <span class="comment">// [1, 5, undefined]</span></span><br><span class="line">&gt; f(<span class="number">1</span>, ,<span class="number">2</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt; f(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>) <span class="comment">// [1, 5, 2]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>函数的length属性</p>
<ul>
<li><p>指定了默认值后，函数的length属性将返回没有指定默认值的参数个数。也就是说指定了默认值后，length属性将失真。</p>
</li>
<li><p>length属性的含义是该函数预期传入的参数个数，某个指定了默认之后，预期传入的参数个数就不包括这个参数了。</p>
</li>
<li><p>如果设置默认值的参数不是尾参数，那么length属性将不再计入后面的参数了。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;&#125;).length  <span class="comment">//1</span></span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">a=<span class="number">5</span></span>)</span>&#123;&#125;).length  <span class="comment">//0</span></span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c=<span class="number">9</span></span>)</span>&#123;&#125;).length  <span class="comment">//2</span></span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;&#125;).length   <span class="comment">//0</span></span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">a=<span class="number">0</span>,b,c</span>)</span>&#123;&#125;).length   <span class="comment">//0</span></span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params">a,b=<span class="number">2</span>,c</span>)</span>&#123;&#125;).length  <span class="comment">//1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>作用域</p>
<ul>
<li><p>一旦设置了参数默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用于就会消失。这种情况在没有默认参数值是不会出现的。</p>
<blockquote>
<p>var  x = 1;</p>
<p>function   f(x, y = x){</p>
<p>​    console.log(y);</p>
<p>}</p>
<p>f(2)  //2</p>
<p>//上面代码中，参数y的默认值等于变量x。调用函数时，参数会形成一个单独的作用域。在这个作用域里，默认变量x指向第一个参数x，而不是全局变量x，所以输出的是2</p>
</blockquote>
<blockquote>
<p>let  x = 1;</p>
<p>function  f(y=x){</p>
<p>​    let x = 2;</p>
<p>​    console.log(y);</p>
<p>}</p>
<p>f()   //1</p>
<p>//函数<code>f</code>调用时，参数<code>y = x</code>形成一个单独的作用域。这个作用域里面，变量<code>x</code>本身没有定义，所以指向外层的全局变量<code>x</code>。函数调用时，函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code>。若全局变量<code>x</code>不存在，就会报错。</p>
</blockquote>
</li>
<li><p>参数<code>x = x</code>形成一个单独作用域。实际执行的是<code>let x = x</code>，由于暂时性死区的原因，这行代码会报错”x 未定义“。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = x</span>) </span>&#123;</span><br><span class="line">&gt; <span class="comment">// ...</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; foo() <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>函数的参数默认值是一个匿名函数，当函数参数形成的单独作用域里面并没有定义该变量时，该变量就会指向外层的全局变量。若函数外层并无该变量，则会报错。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>) </span>&#123; x = <span class="number">2</span>; &#125;) &#123;</span><br><span class="line">&gt; <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">&gt; y();</span><br><span class="line">&gt; <span class="built_in">console</span>.log(x);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; foo() <span class="comment">// 3</span></span><br><span class="line">&gt; x <span class="comment">// 1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>rest参数</p>
<p>​    function   函数名(…变量名){}</p>
<ul>
<li>rest参数搭配的变量是一个数组，该变量会将多余的参数放入数组中。</li>
<li>与arguments对象不同，arguments对象是一个类数组。</li>
<li>rest参数之后不能有其他参数（及只能是是最后一个参数），否则会报错。当然，函数的length属性也不包括rest参数。</li>
</ul>
</li>
<li><p>严格模式下函数参数不能使用默认值，解构赋值或拓展运算符。两种解决方法：</p>
<ul>
<li><p>设定全局式的严格模式。</p>
<blockquote>
<p>‘use strict’;</p>
<p>function (a,b=a){</p>
<p>//code</p>
<p>}</p>
</blockquote>
</li>
<li><p>把函数包在一个无参数的立即执行函数中。</p>
<blockquote>
<p>const doSomething = (function(){</p>
<p>‘use strict’;</p>
<p>return function(value = 42){</p>
<p>​    return value;</p>
<p>};</p>
<p>}())；</p>
</blockquote>
</li>
</ul>
</li>
<li><p>name属性返回函数的函数名</p>
<ul>
<li><p>如果将一个匿名函数赋值给一个变量，Es5的name属性会返回空字符串，ES6返回实际函数名。</p>
</li>
<li><p>如果将一个具名函数赋值给一个变量，两者都返回这个具名函数原本的名字。</p>
<blockquote>
<p>const  bar = function baz(){};</p>
<p>//ES5</p>
<p>bar.name        //“baz”</p>
<p>//ES6</p>
<p>bar.name     //“baz”</p>
</blockquote>
</li>
<li><p>Function构造函数返回的函数实例，name属性的值为anonymous</p>
<blockquote>
<p>(new Function).name    //“anonymous”</p>
</blockquote>
</li>
<li><p>bind返回的函数，name属性值会加上bound前缀</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&gt; foo.bind(&#123;&#125;).name <span class="comment">// "bound foo"</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name <span class="comment">// "bound "</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
</ul>
<h6 id="箭头函数（-gt-）"><a href="#箭头函数（-gt-）" class="headerlink" title="箭头函数（=&gt;）"></a>箭头函数（=&gt;）</h6><blockquote>
<p>var  f= v =&gt; v;</p>
<p>//等同于</p>
<p>var   f = function(v){</p>
<p>return   v;</p>
<p>};</p>
</blockquote>
<ul>
<li><p>由于大括号被解释为代码块，故如果箭头函数直接返回一个对象会报错，必须在对象外面加上括号；</p>
<blockquote>
<p>//报错</p>
<p>let  gettempItem = id =&gt; { id: id, name: “temp” };</p>
<p>//不报错</p>
<p>let  gettempItem = id =&gt; ({ id: id, name: “temp”})</p>
</blockquote>
</li>
<li><p>使用箭头函数注意点</p>
<ul>
<li>函数体内的this对象，也就是定义时所在的对象，而不是使用是所在的对象。this对象的指向在js中是可变的。但在箭头函数中则是固定的。</li>
<li>不可以当作构造函数，即不可使用new命令，否则会抛出一个错误。</li>
<li>不可使用arguments对象，该对象在函数体内不存在。如果要用，可用rest参数替换。也没有super，new.target</li>
<li>不可使用yield命令，因此箭头函数不能用作Generator函数。</li>
</ul>
</li>
<li><p>this指向的固定化，并不是因为内部有绑定this机制，实际原因是箭头函数没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</p>
</li>
<li><p>箭头函数不适用场景</p>
<ul>
<li><p>定义对象的方法，且该方法内部包含this。调用<code>cat.jumps()</code>时，如果是普通函数，该方法内部的<code>this</code>指向<code>cat</code>；如果写成上面那样的箭头函数，使得<code>this</code>指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致<code>jumps</code>箭头函数定义时的作用域就是全局作用域。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> cat = &#123;</span><br><span class="line">&gt; lives: <span class="number">9</span>,</span><br><span class="line">&gt; jumps: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">&gt;  <span class="keyword">this</span>.lives--;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="comment">//上面的this指向的是全局作用域，不是cat</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>需要动态this时也不应使用箭头函数。下面代码运行时，点击按钮会报错，因为<code>button</code>的监听函数是一个箭头函数，导致里面的<code>this</code>就是全局对象。如果改成普通函数，<code>this</code>就会动态指向被点击的按钮对象。</p>
<blockquote>
<p>var button = document.getElementById(‘press’);</p>
<p>button.addEventListener(‘click’,()=&gt;{</p>
<p>​    this.classList.toggle(‘on’);</p>
<p>});</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h6 id="尾调用（Tail-Call）"><a href="#尾调用（Tail-Call）" class="headerlink" title="尾调用（Tail Call）"></a>尾调用（Tail Call）</h6><ul>
<li><p>尾调用优化只在严格模式下开启，正常模式是无效的，因为正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>
<ul>
<li><p>func.arguments:返回调用时函数的那个参数。</p>
</li>
<li><p>func.caller:返回调用函数当前函数的那个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restricted</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  restricted.caller;    <span class="comment">// 报错</span></span><br><span class="line">  restricted.arguments; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line">restricted();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>尾调用是函数式编程的一个重要概念。指某个函数的最后一步是调用另一个函数。</p>
</li>
<li><p>尾调用之所以与其他调用不同就在于其调用位置。我们知道，函数调用会在内存中形成一个”调用记录“，又称“调用帧”，保存调用的位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方还会形成B的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>
</li>
<li><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
</li>
<li><p>尾调用优化，即只保留内层函数的调用帧。如果所有函数都是尾调用，就可以完全做到每次执行一次时，调用帧只有一项，这将大大节省内存。注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>
</li>
</ul>
<h6 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h6><ul>
<li><p>尾部调用自身即为尾递归。</p>
</li>
<li><p>递归是非常耗内存的，因为需要同时保存成千上万个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<blockquote>
<p>function  factorial(n,total){</p>
<p>​    if(n === 1)    return  total;</p>
<p>​    return factorial(n-1,n*total);</p>
<p>}</p>
</blockquote>
</li>
<li><p>尾调用优化的Fibonacci数列</p>
<blockquote>
<p>function  Fibonacci2(n,ac1 = 1, ac2 = 1){</p>
<p>​    if(n&lt;=1) {return   ac2};</p>
<p>​    return  Fibonacci2(n-1,ac2,ac1+ac2);</p>
<p>}</p>
</blockquote>
</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><p>Array.from()将两类对象（类数组和可便利的对象）转为真正的数组。</p>
<ul>
<li>只要是部署了Iterator接口的数据结构，Array.from就都可以将其转为真正的数组。</li>
<li>扩展运算符背后调用的是遍历器接口（Symbol.iterator),如果一个对象没有部署这个对象就无法转换。</li>
<li>类数组对象本质是有length属性，即只要有length属性的对象都可以通过Array.from方法转为数组。</li>
</ul>
<blockquote>
<p>//es5</p>
<p>var arr1 = [].slice.call(arrayLike);</p>
<p>//es6</p>
<p>let  arr2 = Array.from(arrayLike);</p>
<p>//NodeList对象</p>
<p>let  ps = document.querySelectorAll(‘p’);</p>
<p>Array.from(ps).filter(p =&gt; {</p>
<p>​    return p.textContent.length.length &gt;100;</p>
<p>});</p>
<p>//arguments对象</p>
<p>function  foo(){</p>
<p>var  args = Array.from(arguments);</p>
<p>}</p>
</blockquote>
<ul>
<li><p>对于没有部署该方法的浏览器可使用Array.prototype.slice方法替换。</p>
<blockquote>
<p>const  toArray = ( () =&gt;</p>
<p>​    Array.from ? Array.from : obj =&gt; [].slice.call(obj);</p>
<p>)( );</p>
</blockquote>
</li>
<li><p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<blockquote>
<p>Array.from(arrayLike,x =&gt; x * x);</p>
<p>Array.from(arrayLike).map( x=&gt; x*x);</p>
<p>//两者等价</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Array.of()用于将一组值转换为数组。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line">&gt; <span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line">&gt; <span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>下面代码中，<code>Array</code>方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line">&gt; <span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line">&gt; <span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>Array.prototype.copyWithin(target,stsart=0,end=this.length)</p>
<ul>
<li>数组实例的<code>copyWithin()</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</li>
</ul>
</li>
<li><p>查找</p>
<ul>
<li><p>find（）：用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找到第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。回调函数可接受三个参数，依次为当前的值，当前的位置和原数组。</p>
<blockquote>
<p>[1,2,3,10,15].find(function(value,index,arr){</p>
<p>​    return value &gt; 9;</p>
<p>})    //10</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>findIndex():返回第一个符合条件的数组成员的位置，如果都不符合则返回-1；</p>
</li>
<li><p>这两个方法都可以接受第二个参数，<strong>用于绑定回调函数的this对象。</strong></p>
<blockquote>
<p>function  f(v){</p>
<p>​    return  v &gt; this.age;</p>
<p>}</p>
<p>let  person = {name:’john’,age:20};</p>
<p>[12,15,26,42].find(f,person);     //26</p>
</blockquote>
</li>
<li><p>都可发现NaN，弥补数组中indexOf方法的不足。<code>indexOf</code>方法无法识别数组的<code>NaN</code>成员，但是<code>findIndex</code>方法可以借助<code>Object.is</code>方法做到。</p>
<blockquote>
<p>[NaN].indexOf(NaN)</p>
<p>//-1</p>
<p>[NaN].findIndex(y =&gt; Object.is(NaN,y))</p>
<p>//0</p>
</blockquote>
</li>
</ul>
</li>
<li><p>fill()使用给定值进行数组填充</p>
<ul>
<li>如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</li>
<li>fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</li>
<li>fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</li>
</ul>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>)</span><br><span class="line">&gt; <span class="comment">// [7, 7, 7]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)</span><br><span class="line">&gt; <span class="comment">// [7, 7, 7]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&gt; <span class="comment">// ['a', 7, 'c']</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>遍历数组</p>
<ul>
<li><p><code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对像，可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>
</li>
<li><p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">&gt; <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="comment">// 0 "a"</span></span><br><span class="line">&gt; <span class="comment">// 1 "b"</span></span><br><span class="line">&gt; <span class="keyword">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">&gt; <span class="keyword">let</span> entries = letter.entries();</span><br><span class="line">&gt; <span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, 'a']</span></span><br><span class="line">&gt; <span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, 'b']</span></span><br><span class="line">&gt; <span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, 'c']</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>includes()</p>
<ul>
<li><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似</p>
</li>
<li><p>该方法的第二个参数表示搜索的起始位置，默认为<code>0</code>。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为<code>-4</code>，但数组长度为<code>3</code>），则会重置为从<code>0</code>开始。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>);  <span class="comment">// false</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">-1</span>); <span class="comment">// true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>没有该方法之前，我们通常使用数组的<code>indexOf</code>方法，检查是否包含某个值.</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span> (arr.indexOf(el) !== <span class="number">-1</span>) &#123;</span><br><span class="line">&gt; <span class="comment">// ...</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; [<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line">&gt; <span class="comment">// -1</span></span><br><span class="line">&gt; [<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>)</span><br><span class="line">&gt; <span class="comment">// true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>indexOf</code>方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于<code>-1</code>，表达起来不够直观。二是，它内部使用严格相等运算符（<code>===</code>）进行判断，这会导致对<code>NaN</code>的误判。</li>
</ul>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> contains = <span class="function">(<span class="params">(</span>) =&gt;</span></span><br><span class="line">&gt; <span class="built_in">Array</span>.prototype.includes</span><br><span class="line">&gt;  ? <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.includes(value)</span><br><span class="line">&gt;  : <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.some(<span class="function"><span class="params">el</span> =&gt;</span> el === value)</span><br><span class="line">&gt; )();</span><br><span class="line">&gt; contains([<span class="string">'foo'</span>, <span class="string">'bar'</span>], <span class="string">'baz'</span>); <span class="comment">// =&gt; false</span></span><br><span class="line">&gt; <span class="comment">//简易的替代版本。</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>另外，Map 和 Set 数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p>
<ul>
<li>Map 结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li>
<li>Set 结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>flat()和flatMap（）</p>
<ul>
<li><p>数组的成员有时还是数组，<code>Array.prototype.flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p>
</li>
<li><p><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为</p>
</li>
<li><p>可以用<code>Infinity</code>关键字作为参数。</p>
</li>
<li><p>如果原数组有空位，<code>flat()</code>方法会跳过空位。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].flat()</span><br><span class="line">&gt; <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>)</span><br><span class="line">&gt; <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">&gt; [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="literal">Infinity</span>)</span><br><span class="line">&gt; <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>].flat()</span><br><span class="line">&gt; <span class="comment">// [1, 2, 4, 5]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>flatMap()</code>方法对原数组的每个成员执行一个函数（相当于执行<code>Array.prototype.map()</code>），然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组。<code>flatMap()</code>只能展开一层数组。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">&gt; [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line">&gt; <span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br><span class="line">&gt; <span class="comment">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span></span><br><span class="line">&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]])</span><br><span class="line">&gt; <span class="comment">// [[2], [4], [6], [8]]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>flatMap()</code>方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。<code>flatMap()</code>方法还可以有第二个参数，用来绑定遍历函数里面的<code>this</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; arr.flatMap(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>) </span>&#123;</span><br><span class="line">&gt; <span class="comment">// ...</span></span><br><span class="line">&gt; &#125;[, thisArg])</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>数组中的空位</p>
<ul>
<li><p>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p>
</li>
<li><blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>] <span class="comment">// true</span></span><br><span class="line">&gt; <span class="number">0</span> <span class="keyword">in</span> [, , ,] <span class="comment">// false</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位.</p>
<ul>
<li><code>forEach()</code>, <code>filter()</code>, <code>reduce()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位。</li>
<li><code>map()</code>会跳过空位，但会保留这个值</li>
<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li>
</ul>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// forEach方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].forEach(<span class="function">(<span class="params">x,i</span>) =&gt;</span> <span class="built_in">console</span>.log(i)); <span class="comment">// 1</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// filter方法</span></span><br><span class="line">&gt; [<span class="string">'a'</span>,,<span class="string">'b'</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// ['a','b']</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// every方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x===<span class="string">'a'</span>) <span class="comment">// true</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// reduce方法</span></span><br><span class="line">&gt; [<span class="number">1</span>,,<span class="number">2</span>].reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y) <span class="comment">// 3</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// some方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].some(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">'a'</span>) <span class="comment">// false</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// map方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [,1]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// join方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].join(<span class="string">'#'</span>) <span class="comment">// "#a##"</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// toString方法</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].toString() <span class="comment">// ",a,,"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p>
</li>
<li><p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p>
</li>
<li><p><code>copyWithin()</code>会连空位一起拷贝。</p>
</li>
<li><p><code>fill()</code>会将空位视为正常的数组位置。</p>
</li>
<li><p><code>for...of</code>循环也会遍历空位.</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Array</span>.from([<span class="string">'a'</span>,,<span class="string">'b'</span>])</span><br><span class="line">&gt; <span class="comment">// [ "a", undefined, "b" ]</span></span><br><span class="line">&gt; [...[<span class="string">'a'</span>,,<span class="string">'b'</span>]]</span><br><span class="line">&gt; <span class="comment">// [ "a", undefined, "b" ]</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>,<span class="string">'b'</span>,,].copyWithin(<span class="number">2</span>,<span class="number">0</span>) <span class="comment">// [,"a",,"a"]</span></span><br><span class="line">&gt; <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">'a'</span>) <span class="comment">// ["a","a","a"]</span></span><br><span class="line">&gt; <span class="keyword">let</span> arr = [, ,];</span><br><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">&gt; <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="comment">// 1</span></span><br><span class="line">&gt; <span class="comment">// 1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// entries()</span></span><br><span class="line">&gt; [...[,<span class="string">'a'</span>].entries()] <span class="comment">// [[0,undefined], [1,"a"]]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// keys()</span></span><br><span class="line">&gt; [...[,<span class="string">'a'</span>].keys()] <span class="comment">// [0,1]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// values()</span></span><br><span class="line">&gt; [...[,<span class="string">'a'</span>].values()] <span class="comment">// [undefined,"a"]</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// find()</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].find(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// undefined</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">// findIndex()</span></span><br><span class="line">&gt; [,<span class="string">'a'</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// 0</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h4><h6 id="属性遍历"><a href="#属性遍历" class="headerlink" title="属性遍历"></a>属性遍历</h6><ul>
<li><p><strong>for…in</strong>:遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
</li>
<li><p><strong>Object.keys(obj)</strong>：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
</li>
<li><p><strong>Object.getOwnPropertyNames(obj)</strong>：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
</li>
<li><p><strong>Object.getOwnPropertySymbols(obj)</strong>：返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
</li>
<li><p><strong>Reflect.ownKeys(obj)</strong>：返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
</li>
<li><p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>
</ul>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Reflect</span>.ownKeys(&#123; [<span class="built_in">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span> &#125;)</span><br><span class="line">&gt; <span class="comment">// ['2', '10', 'b', 'a', Symbol()]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h6 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h6><ul>
<li><p>this关键字总是指向函数所在的当前对象，关键字super则是指向当前对象的原型对象，super只能用在对象的方法中，用在其他地方会报错。</p>
</li>
<li><p>JavaScript 引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。</p>
<blockquote>
<p>const  proto ={foo:’hello’};</p>
<p>const obj = {</p>
<p>​    foo:’world’,</p>
<p>​    find(){</p>
<p>​    return super.foo;</p>
<p>​    }</p>
<p>}</p>
<p>Object.setPrototypeOf(obj,proto);</p>
<p>obj.find();    //“hello”</p>
<p>//报错</p>
<p>const  obj = {foo:super.foo;    //对象的属性}</p>
<p>//只有对象方法的简写式才可以被js引擎确认定义的是对象的方法。</p>
<p>//以下两种都报错报错</p>
<p>const   obj = {</p>
<p>​    foo:() =&gt; super.foo</p>
<p>}</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> obj = &#123;</span><br><span class="line">&gt; foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;  <span class="keyword">return</span> <span class="keyword">super</span>.foo</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  x: <span class="string">'hello'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  x: <span class="string">'world'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// "world"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code>。</p>
<h6 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h6><ul>
<li>扩展运算符的解构赋值，不能复制继承自原型对象的属性。</li>
</ul>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">&gt; <span class="keyword">let</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&gt; o2.__proto__ = o1;</span><br><span class="line">&gt; <span class="keyword">let</span> &#123; ...o3 &#125; = o2;</span><br><span class="line">&gt; o3 <span class="comment">// &#123; b: 2 &#125;</span></span><br><span class="line">&gt; o3.a <span class="comment">// undefined</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="对象新增方法"><a href="#对象新增方法" class="headerlink" title="对象新增方法"></a>对象新增方法</h4><ul>
<li><p>Object.is():在所有环境中，只要两个值是一样的，他们就相等</p>
<ul>
<li><p>与严格相等（===）功能差不多，但是弥补了NaN不等于自身的缺陷。</p>
</li>
<li><p>+0不等于-0</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Object</span>.is(<span class="string">'foo'</span>, <span class="string">'foo'</span>)</span><br><span class="line">&gt; <span class="comment">// true</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)</span><br><span class="line">&gt; <span class="comment">// false</span></span><br><span class="line">&gt; +<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></span><br><span class="line">&gt; <span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
<li><p>Object.assign()用于对象的合并，将源对象的所有可枚举属性，复制到目标对象。</p>
<ul>
<li><p><code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p>
</li>
<li><p>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
</li>
<li><p>如果只有一个参数，<code>Object.assign</code>会直接返回该参数。</p>
</li>
<li><p>如果该参数不是对象，则会先转成对象，然后返回。由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。</p>
</li>
<li><blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&gt; <span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">&gt; target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(obj) === obj <span class="comment">// true</span></span><br><span class="line">&gt; <span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">2</span>) <span class="comment">// "object"</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(<span class="literal">undefined</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(<span class="literal">null</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。因为只有字符串的包装对象，会产生可枚举属性。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(obj, <span class="literal">undefined</span>) === obj <span class="comment">// true</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.assign(obj, <span class="literal">null</span>) === obj <span class="comment">// true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> v1 = <span class="string">'abc'</span>;</span><br><span class="line">&gt; <span class="keyword">const</span> v2 = <span class="literal">true</span>;</span><br><span class="line">&gt; <span class="keyword">const</span> v3 = <span class="number">10</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">const</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, v2, v3);</span><br><span class="line">&gt; <span class="built_in">console</span>.log(obj); <span class="comment">// &#123; "0": "a", "1": "b", "2": "c" &#125;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="数组中的遍历"><a href="#数组中的遍历" class="headerlink" title="数组中的遍历"></a>数组中的遍历</h4><ul>
<li><p>reduce求和,求平均值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce((tmp,item,index) =&gt; &#123; </span><br><span class="line">	//tmp是一个前一次的总和</span><br><span class="line">	//item是第几个数的值</span><br><span class="line">	//index是下标值，因第一个tmp是第一个arr[0],所以index是从1开始</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>map  映射</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.map((item) =&gt; &#123;</span><br><span class="line">	//item是第几个数的值</span><br><span class="line">	return item*2;</span><br><span class="line">&#125;);</span><br><span class="line">arr.map(item =&gt; item*2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>filter过滤器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr.filter(item =&gt; &#123;</span><br><span class="line">	//返回true者留下，返回false消失</span><br><span class="line">	if(item % 3 == 0)&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">//相当于</span><br><span class="line">arr.filter(item =&gt; item%3 == 0);</span><br></pre></td></tr></table></figure>
</li>
<li><p>forEach   循环迭代</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach( (item,index) =&gt; &#123;</span><br><span class="line">	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="字符串新增方法-1"><a href="#字符串新增方法-1" class="headerlink" title="字符串新增方法"></a>字符串新增方法</h4><ul>
<li>startsWith:检测str是否以某些字符的开头</li>
<li>endsWith：检测str是否以某个字符的结尾</li>
<li>字符串模板 ：${变量}</li>
</ul>
<h4 id="面向对象class类"><a href="#面向对象class类" class="headerlink" title="面向对象class类"></a>面向对象class类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class User&#123;</span><br><span class="line">	constructor(name,pass)&#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.pass = pass;</span><br><span class="line">	&#125;</span><br><span class="line">	showName()&#123;</span><br><span class="line">		alert(this.name);//不可以使用function，不用加逗号，表示属性，而非方法</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>class关键字，构造器和类分开</p>
</li>
<li><p>class里面直接加方法</p>
</li>
</ol>
<h6 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h6><p>老版写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function User(name,pass)&#123;</span><br><span class="line">           this.name = name;</span><br><span class="line">           this.pass = pass;</span><br><span class="line">       &#125; </span><br><span class="line">       User.prototype.showName = function()&#123;</span><br><span class="line">           alert(this.name);</span><br><span class="line">       &#125;</span><br><span class="line">       User.prototype.showPass = function()&#123;</span><br><span class="line">           alert(this.pass);</span><br><span class="line">       &#125;</span><br><span class="line">       function vipUser(name,pass,level)&#123;</span><br><span class="line">           User.call(this,name,pass);</span><br><span class="line">           this.level = level;</span><br><span class="line">       &#125;</span><br><span class="line">      vipUser.prototype = new User();</span><br><span class="line">      vipUser.prototype.constructor = vipUser;</span><br><span class="line">       vipUser.prototype.showlevel = function()&#123;</span><br><span class="line">           alert(this.level);</span><br><span class="line">       &#125;;</span><br><span class="line">       var v1 = new vipUser(&apos;blue&apos;,&apos;12345&apos;,10);</span><br><span class="line">       v1.showName();</span><br><span class="line">       v1.showlevel();</span><br></pre></td></tr></table></figure>

<p>super——超类，就相当于父类</p>
<p>extends——继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class User&#123;</span><br><span class="line">     constructor(name,pass)&#123;</span><br><span class="line">         this.name = name;</span><br><span class="line">         this.pass = pass;</span><br><span class="line">     &#125;</span><br><span class="line">     showName()&#123;</span><br><span class="line">         alert(this.name);</span><br><span class="line">     &#125;</span><br><span class="line">     showPass()&#123;</span><br><span class="line">         alert(this.pass);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> class VipUser extends User&#123;</span><br><span class="line">     constructor(name,pass,level)&#123;</span><br><span class="line">         super(name,pass);</span><br><span class="line">         this.level = level;</span><br><span class="line">     &#125;</span><br><span class="line">     showLevel()&#123;</span><br><span class="line">         alert(this.level);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> var v1 = new VipUser(&apos;nikita&apos;,&apos;15243&apos;,10);</span><br><span class="line"> v1.showName();</span><br><span class="line"> v1.showLevel();</span><br></pre></td></tr></table></figure>

<h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><h6 id="标准写法："><a href="#标准写法：" class="headerlink" title="标准写法："></a>标准写法：</h6><ul>
<li>只能用双引号。</li>
<li>所有名字都必须用引号包起来。</li>
</ul>
<h6 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h6><ul>
<li><p>字符串化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(&#123;&quot;a&quot;:12,&quot;name&quot;:&quot;nikita&quot;&#125;);</span><br><span class="line">//&quot;&#123;&quot;a&quot;:12,&quot;name&quot;:&quot;nikita&quot;&#125;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解析为一个json对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(&#123;&quot;a&quot;:12,&quot;name&quot;:&quot;nikita&quot;&#125;)；</span><br><span class="line">//&#123;name: &quot;nikita&quot;, age: 12&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Promise（消除异步操作）"><a href="#Promise（消除异步操作）" class="headerlink" title="Promise（消除异步操作）"></a>Promise（消除异步操作）</h4><ul>
<li><p>Promise对象只有三种状态：peding(进行中)，fulfilled（已成功），rejected（已失败）。</p>
</li>
<li><p>Promise实例具有then方法，then返回一个新的Promise实例。Promise对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch</code>方法指定的回调函数，处理这个错误。另外，<code>then</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch</code>方法捕获。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))</span><br><span class="line">  .catch((err) =&gt; console.log(&apos;rejected&apos;, err));</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))</span><br><span class="line">  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));</span><br></pre></td></tr></table></figure>
</li>
<li><p>用同步一样的方式来书写异步代码。接收一个含resolve和reject的函数参数。</p>
</li>
<li><p>resolve——解决，即成功    reject——拒绝，即失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise(function(resolve,reject)&#123;</span><br><span class="line">	//异步代码</span><br><span class="line">	$.ajax(&#123;</span><br><span class="line">		url:&apos;arr.txt&apos;,</span><br><span class="line">		dataType:&apos;json&apos;,</span><br><span class="line">		success(arr)&#123;</span><br><span class="line">			resolve(arr);</span><br><span class="line">		&#125;,</span><br><span class="line">		error(err)&#123;</span><br><span class="line">			reject(err);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;);</span><br><span class="line">//then函数有两个参数，一个是成功的回调函数，一个是失败的回调函数</span><br><span class="line">p.then(function()&#123;</span><br><span class="line">	alert(&apos;成功了&apos;);</span><br><span class="line">&#125;,function()&#123;</span><br><span class="line">	alert(&apos;失败了&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//若有两个Promise对象，可使用Promise.all进行全部处理</span><br><span class="line">//其中的arr是p1和p2中的数据</span><br><span class="line">function createPromise(url)&#123;</span><br><span class="line">	return new Promise(function(resolve,reject)&#123;</span><br><span class="line">		$.ajax(&#123;</span><br><span class="line">		url,</span><br><span class="line">		dataType:&apos;json&apos;,</span><br><span class="line">		 success(arr)&#123;</span><br><span class="line">			resolve(arr);</span><br><span class="line">		 &#125;,</span><br><span class="line">		 error(err)&#123;</span><br><span class="line">		 	reject(err);</span><br><span class="line">		 &#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">Promise.all([</span><br><span class="line">	createPromise(&apos;data/arr.txt&apos;),</span><br><span class="line">	createPromise(&apos;data/json.txt&apos;)</span><br><span class="line">]).then(function(arr)&#123;</span><br><span class="line">	//解构赋值</span><br><span class="line">	let [res1,res2] = arr;</span><br><span class="line">	alert(&apos;全部成功&apos;)</span><br><span class="line">&#125;,function()&#123;</span><br><span class="line">	alert(&apos;至少有一个失败&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>高版本jquery也封装了promise对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([</span><br><span class="line">	$.ajax(&#123;url:&apos;data/arr.txt&apos;,dataType:&apos;json&apos;&#125;),</span><br><span class="line">	$.ajax(&#123;url:&apos;data/json.txt&apos;,dataType:&apos;json&apos;&#125;)</span><br><span class="line">]).then(function(results)&#123;</span><br><span class="line">	let [arr,json] = results;</span><br><span class="line">	alert(&apos;成功了&apos;);</span><br><span class="line">&#125;,function(err)&#123;</span><br><span class="line">	alert(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise.race        竞速，即先到先执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Promise.race([</span><br><span class="line">	$.ajax(&#123;url:&apos;http://a2.taobai.com/data/users&apos;&#125;)</span><br><span class="line">	$.ajax(&#123;ur4:&apos;http://a2.taobai.com/data/users&apos;&#125;)</span><br><span class="line">	$.ajax(&#123;ur7:&apos;http://a2.taobai.com/data/users&apos;&#125;)</span><br><span class="line">	$.ajax(&#123;ur2:&apos;http://a2.taobai.com/data/users&apos;&#125;)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h6><ul>
<li>该方法为不管Promise对象最后如何，都会执行的代码。</li>
</ul>
<p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.listen(port)</span><br><span class="line">  .then(function () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure>

<h6 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h6><ul>
<li><p>用于将多个Promise实力包装为一个新的Promise实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>

<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>
<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>
<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 生成一个Promise对象的数组</span><br><span class="line">const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123;</span><br><span class="line">  return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all(promises).then(function (posts) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;).catch(function(reason)&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="Fetch-API是js接口"><a href="#Fetch-API是js接口" class="headerlink" title="Fetch API是js接口"></a>Fetch API是js接口</h6><ul>
<li>用于访问和操作HTTP管道的部分，例如请求和响应。</li>
</ul>
<h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><ul>
<li><p>是ES6提供的一种异步编程解决方案，是一个状态机，封装了很多内部状态。执行Generator函数会返回一个遍历器对象，说明Generator函数同时还是一个遍历器对象生成函数，返回的遍历器对象可以一次遍历每个状态。</p>
</li>
<li><p>特征           *             yield</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function* test(value1)&#123;</span><br><span class="line">	let value2 = yield value1;   </span><br><span class="line">	let value3 = yield value2;</span><br><span class="line">	return value3;</span><br><span class="line">&#125;</span><br><span class="line">//第一个yield后的值是传入的参数，第二个是第二个next方法传入的...</span><br><span class="line">var hw = test(1);</span><br><span class="line">hw.next(5);</span><br><span class="line">//第一个next传入的参数无效，不管test有无传参</span><br><span class="line">//&#123;value:1,done:false&#125;</span><br><span class="line">hw.next(7)</span><br><span class="line">//&#123;value:7,done:false&#125;</span><br><span class="line">hw.next(9)</span><br><span class="line">//&#123;value:9,done:true&#125;</span><br></pre></td></tr></table></figure>

<p>调用test函数时，该函数并未执行，而是返回一个指向内部状态的指针对象。而调用该函数的next方法则是将指针移向下一个状态，next有位置记忆功能，故每次调用next方法时，都从上一次停下来的地方执行，直到下一个yield或return为止。return与yield功能相似，但return无位置记忆功能，且每个函数只能有一个return语句。且将return语句后面的表达式作为对象的value属性值，若无return，则返回undefined</p>
<p>当Generator函数运行完毕，但还使用next方法时，返回{value:undefined,done:true},便是遍历已结束。</p>
</li>
<li><p>next的参数表示上一个yield表达式的返回值，所以第一个next传递参数是无效的。</p>
</li>
<li><p>yield表达式若用在另一表达式中，必须放在圆括号内。</p>
</li>
<li><p>yield若用作函数参数或放在赋值表达式的右边，可不加括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;hello&apos; + (yield 123));</span><br><span class="line">function* demo()&#123;</span><br><span class="line">foo(yield &apos;a&apos;,yield &apos;b&apos;);</span><br><span class="line">let input = yield;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="与Symbol-iterator的关系"><a href="#与Symbol-iterator的关系" class="headerlink" title="与Symbol.iterator的关系"></a>与Symbol.iterator的关系</h6><ul>
<li>任意一个对象的Symbol.iterator方法等同于该对象的遍历器生成函数。把Generator赋值给对象的Symbol.iterator属性，可使该对象具有Iterator接口。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var myIterable = &#123;&#125;;</span><br><span class="line">myIterable[Symbol.iterator] = function* ()&#123;</span><br><span class="line">	yield 1;</span><br><span class="line">	yield 2;</span><br><span class="line">&#125;</span><br><span class="line">[...myIterable]   //1,2</span><br></pre></td></tr></table></figure>

<ul>
<li>Generator函数执行后返回一个遍历器对象，该对象本身具有iterator接口，执行后返回自身。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function* gen()&#123;&#125;</span><br><span class="line">var g = gen();</span><br><span class="line">g[Symbol.iterator] === g</span><br><span class="line">//true</span><br></pre></td></tr></table></figure>

<h6 id="原生js对象添加Iterator接口的方法"><a href="#原生js对象添加Iterator接口的方法" class="headerlink" title="原生js对象添加Iterator接口的方法"></a>原生js对象添加Iterator接口的方法</h6><ul>
<li><p>除了<code>for...of</code>循环以外，扩展运算符（<code>...</code>）、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。</p>
</li>
<li><p>原生js对象没有遍历接口，无法使用for…of循环，可通过generator函数为其加上接口便可使用。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function* objectEntries(obj)&#123;</span><br><span class="line">	let propKeys = Reflect.ownKeys(obj);//将obj对象转为数组</span><br><span class="line">	for(let propKey of propKeys)&#123;</span><br><span class="line">		yield [propkey,obj[propKey]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let jane = &#123; first: &apos;Jane&apos;, last: &apos;Doe&apos; &#125;;</span><br><span class="line"></span><br><span class="line">for (let [key, value] of objectEntries(jane)) &#123;</span><br><span class="line">  console.log(`$&#123;key&#125;: $&#123;value&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">// first: Jane</span><br><span class="line">// last: Doe</span><br></pre></td></tr></table></figure>

<ul>
<li>将Generator函数加到对象的symbol.irerator属性上。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* objectEntries() &#123;</span><br><span class="line">  let propKeys = Object.keys(this);</span><br><span class="line"></span><br><span class="line">  for (let propKey of propKeys) &#123;</span><br><span class="line">    yield [propKey, this[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let jane = &#123; first: &apos;Jane&apos;, last: &apos;Doe&apos; &#125;;</span><br><span class="line"></span><br><span class="line">jane[Symbol.iterator] = objectEntries;</span><br><span class="line"></span><br><span class="line">for (let [key, value] of jane) &#123;</span><br><span class="line">  console.log(`$&#123;key&#125;: $&#123;value&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">// first: Jane</span><br><span class="line">// last: Doe</span><br></pre></td></tr></table></figure>

<h6 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw"></a>Generator.prototype.throw</h6><ul>
<li>Generator函数返回的遍历器对象都有一个throw方法，可在函数体外抛出错误，然后在Generator函数体内捕获。</li>
</ul>
<h6 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return"></a>Generator.prototype.return</h6><ul>
<li>Generator 函数返回的遍历器对象，还有一个<code>return</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。</li>
<li>如果 Generator 函数内部有<code>try...finally</code>代码块，且正在执行<code>try</code>代码块，那么<code>return</code>方法会导致立刻进入<code>finally</code>代码块，执行完以后，整个函数才会结束。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* numbers () &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  try &#123;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield 3;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    yield 4;</span><br><span class="line">    yield 5;</span><br><span class="line">  &#125;</span><br><span class="line">  yield 6;</span><br><span class="line">&#125;</span><br><span class="line">var g = numbers();</span><br><span class="line">g.next() // &#123; value: 1, done: false &#125;</span><br><span class="line">g.next() // &#123; value: 2, done: false &#125;</span><br><span class="line">g.return(7) // &#123; value: 4, done: false &#125;</span><br><span class="line">g.next() // &#123; value: 5, done: false &#125;</span><br><span class="line">g.next() // &#123; value: 7, done: true &#125;</span><br></pre></td></tr></table></figure>

<h6 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield*表达式"></a>yield*表达式</h6><ul>
<li><p>yield*表达式返回一个表遍历器对象。</p>
</li>
<li><p>如果Generator函数内部调用另一个Generator函数需要在前者函数体内，利用for..of手动完成遍历。若不想手动，则可利用yield*</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function* bar() &#123;</span><br><span class="line">  yield &apos;x&apos;;</span><br><span class="line">  yield* foo();</span><br><span class="line">  yield &apos;y&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function* bar() &#123;</span><br><span class="line">  yield &apos;x&apos;;</span><br><span class="line">  yield &apos;a&apos;;</span><br><span class="line">  yield &apos;b&apos;;</span><br><span class="line">  yield &apos;y&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function* bar() &#123;</span><br><span class="line">  yield &apos;x&apos;;</span><br><span class="line">  for (let v of foo()) &#123;</span><br><span class="line">    yield v;</span><br><span class="line">  &#125;</span><br><span class="line">  yield &apos;y&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let v of bar())&#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;x&quot;</span><br><span class="line">// &quot;a&quot;</span><br><span class="line">// &quot;b&quot;</span><br><span class="line">// &quot;y&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>yield和yield*都只能放在Generator函数中，不能放在普通函数里。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//遍历嵌套数组</span><br><span class="line">var arr = [1,[[2,3],4],[5,6]];</span><br><span class="line">var flag = function* (a)&#123;</span><br><span class="line">    var length = a.length;</span><br><span class="line">    for(let i = 0;i &lt; length;i++)&#123;</span><br><span class="line">        var item = a[i];</span><br><span class="line">        if(typeof item != &apos;number&apos;)&#123;</span><br><span class="line">            yield* flag(item);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            yield item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(var f of flag(arr))&#123;</span><br><span class="line">    console.log(f);</span><br><span class="line">&#125;</span><br><span class="line">// 1, 2, 3, 4, 5, 6</span><br></pre></td></tr></table></figure>

<h6 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h6><ul>
<li>传统的编程语言早就有异步编程的解决方案，即多任务的解决方案。其中一种就是协程，意思是多个线程相互协作，完成异步操作。<ul>
<li>第一步，协程<code>A</code>开始执行。</li>
<li>第二步，协程<code>A</code>执行到一半，进入暂停，执行权转移到协程<code>B</code>。</li>
<li>第三步，（一段时间后）协程<code>B</code>交还执行权。</li>
<li>第四步，协程<code>A</code>恢复执行。</li>
</ul>
</li>
<li>异步任务的封装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var fetch = require(&apos;node-fetch&apos;);</span><br><span class="line">function* gen()&#123;</span><br><span class="line">    var url = &apos;http://api.github.com/users/github&apos;;</span><br><span class="line">    var result = yield fetch(url);</span><br><span class="line">    console.log(result.bio);</span><br><span class="line">&#125;</span><br><span class="line">var g = gen();</span><br><span class="line">var result = g.next();</span><br><span class="line">result.value.then(function(data)&#123;</span><br><span class="line">  return data.json();</span><br><span class="line">&#125;).then(function(data)&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br><span class="line">//How people build software.</span><br></pre></td></tr></table></figure>

<h6 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h6><ul>
<li>Thunk函数时自动执行Generator函数的一种方法。</li>
<li>参数求值策略有“传值调用”和”传名调用”两种，Thunk函。编译器的“传名调用”实现，往往是将参数放到一个临时函数中，再将这个临时函数传入函数体中，这个函数体即为Thunk函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function f(m)&#123;return m*2;&#125;</span><br><span class="line">f(x+5);</span><br><span class="line">//等同于</span><br><span class="line">vat thunk = function()&#123; return x+5; &#125;</span><br><span class="line">function f(thunk)&#123; return thunk()*2; &#125;</span><br><span class="line"></span><br><span class="line">//Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</span><br><span class="line">// 正常版本的readFile（多参数版本）</span><br><span class="line">fs.readFile(fileName, callback);</span><br><span class="line"></span><br><span class="line">// Thunk版本的readFile（单参数版本）</span><br><span class="line">var Thunk = function (fileName) &#123;</span><br><span class="line">  return function (callback) &#123;</span><br><span class="line">    return fs.readFile(fileName, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var readFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br></pre></td></tr></table></figure>

<h6 id="Thunkify模块"><a href="#Thunkify模块" class="headerlink" title="Thunkify模块"></a>Thunkify模块</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const thunkify = require(&apos;thunkify&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">let read = thunkify(fs.readFile);</span><br><span class="line">read(&apos;package.json&apos;)(function(err,data)&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="co模块"><a href="#co模块" class="headerlink" title="co模块"></a>co模块</h6><ul>
<li><p>co模块让你不用编写Generator函数的执行器，Generator函数只要传入co函数即可执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var co = require(&apos;co&apos;);</span><br><span class="line">co(generator);//返回一个promise对象，故可用then方法添加回调函数</span><br><span class="line">co.then(function()&#123;&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>co模块的原理</strong></p>
<p>为什么 co 可以自动执行 Generator 函数？</p>
<p>前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>
<p>两种方法可以做到这一点。</p>
<p>（1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</p>
<p>（2）Promise 对象。将异步操作包装成 Promise 对象，用<code>then</code>方法交回执行权。</p>
<p>co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的<code>yield</code>命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co。</p>
<p><strong>基于Promise对象的自动执行</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">let readFile = function (fileName)&#123;</span><br><span class="line">    return new Promise(function (resolve,reject)&#123;</span><br><span class="line">        fs.readFile(fileName,function(err,data)&#123;</span><br><span class="line">            if(err) return reject(err);</span><br><span class="line">            return resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">var gen = function* ()&#123;</span><br><span class="line">    let f1 = yield readFile(&apos;1.txt&apos;);</span><br><span class="line">    let f2 = yield readFile(&apos;2.txt&apos;);</span><br><span class="line">    console.log(f1.toString());</span><br><span class="line">    console.log(f2.toString());</span><br><span class="line">&#125;</span><br><span class="line">function run(gen)&#123;</span><br><span class="line">    var g = gen();</span><br><span class="line">    function next(data)&#123;</span><br><span class="line">        var result = g.next(data);</span><br><span class="line">        if(result.done) return result.value;</span><br><span class="line">        result.value.then(function(data)&#123;</span><br><span class="line">            next(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>

<h4 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h4><ul>
<li>引入async函数，使异步操作更方便。跟Generator函数类似，只需将*改为ansyc，yield改为await。</li>
<li><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</li>
</ul>
<h6 id="ansyc较Generator函数的优点"><a href="#ansyc较Generator函数的优点" class="headerlink" title="ansyc较Generator函数的优点"></a>ansyc较Generator函数的优点</h6><ul>
<li>内置执行器。Generator函数的执行必须靠执行器，才co模块，而async函数自带执行器。即async函数的执行与普通函数一样，使用函数名调用即可。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">let readFile = function (fileName)&#123;</span><br><span class="line">    return new Promise(function (resolve,reject)&#123;</span><br><span class="line">        fs.readFile(fileName,function(err,data)&#123;</span><br><span class="line">            if(err) return reject(err);</span><br><span class="line">            return resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//generator函数需要再封装一个run函数自执行</span><br><span class="line">// var gen = function* ()&#123;</span><br><span class="line">//     let f1 = yield readFile(&apos;1.txt&apos;);</span><br><span class="line">//     let f2 = yield readFile(&apos;2.txt&apos;);</span><br><span class="line">//     console.log(f1.toString());</span><br><span class="line">//     console.log(f2.toString());</span><br><span class="line">// &#125;</span><br><span class="line">// function run(gen)&#123;</span><br><span class="line">//     var g = gen();</span><br><span class="line">//     function next(data)&#123;</span><br><span class="line">//         var result = g.next(data);</span><br><span class="line">//         if(result.done) return result.value;</span><br><span class="line">//         result.value.then(function(data)&#123;</span><br><span class="line">//             next(data);</span><br><span class="line">//         &#125;)</span><br><span class="line">//     &#125;</span><br><span class="line">//     next();</span><br><span class="line">// &#125;</span><br><span class="line">// run(gen)</span><br><span class="line"></span><br><span class="line">//async函数有内置执行器</span><br><span class="line">const asyncReadFile = async function()&#123;</span><br><span class="line">    const f1 = await readFile(&apos;1.txt&apos;);</span><br><span class="line">    const f2 = await readFile(&apos;2.txt&apos;);</span><br><span class="line">    console.log(f1.toString());</span><br><span class="line">    console.log(f2.toString());</span><br><span class="line">&#125;</span><br><span class="line">asyncReadFile()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>更好的语义    </p>
<ul>
<li>async：异步</li>
<li>await表示紧跟在后面的表达式需要等待结果</li>
</ul>
</li>
<li><p>更广的适应性。</p>
<ul>
<li>co模块约定，yield命令后面只能是Thunk函数或Promise’对象，而async函数的await命令后面可以是Promise对象和原始类型的值（number，string，boolean，但这时会转为立即resolved的promise对象）。</li>
</ul>
</li>
<li><p>返回值是 Promise。</p>
<p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>
<p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p>
</li>
</ul>
<h6 id="async使用形式"><a href="#async使用形式" class="headerlink" title="async使用形式"></a>async使用形式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">async function foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">const foo = async function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 对象的方法</span><br><span class="line">let obj = &#123; async foo() &#123;&#125; &#125;;</span><br><span class="line">obj.foo().then(...)</span><br><span class="line"></span><br><span class="line">// Class 的方法</span><br><span class="line">class Storage &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.cachePromise = caches.open(&apos;avatars&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async getAvatar(name) &#123;</span><br><span class="line">    const cache = await this.cachePromise;</span><br><span class="line">    return cache.match(`/avatars/$&#123;name&#125;.jpg`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const storage = new Storage();</span><br><span class="line">storage.getAvatar(&apos;jake&apos;).then(…);</span><br><span class="line"></span><br><span class="line">// 箭头函数</span><br><span class="line">const foo = async () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>async函数内部return语句返回的值会成为then方法回调函数的参数。</strong></p>
<p><strong>async函数抛出的错误会导致返回的Promise对象变为reject状态。抛出的错误会被catch方法回调函数接收到。</strong>‘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function f(flag)&#123;</span><br><span class="line">    if(flag) throw new Error(&apos;出错了&apos;);</span><br><span class="line">    return &apos;hello&apos;;</span><br><span class="line">&#125;</span><br><span class="line">f(false).then(</span><br><span class="line">    v =&gt; console.log(v),</span><br><span class="line">    e =&gt; console.log(e)</span><br><span class="line">)</span><br><span class="line">//hello</span><br><span class="line">//当flag为true时，返回’出错了‘</span><br></pre></td></tr></table></figure>

<ul>
<li>async函数返回的Promise对象必须等到内部所有await命令后面的Promise对象执行完毕才会发生状态改变，除非遇到return语句或抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</li>
</ul>
<h6 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h6><ul>
<li><p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p>
</li>
<li><p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p>
</li>
<li><p>任何一个await语句后面的Promise对象变为reject状态，那么整个async函数就都会中断执行。</p>
<ul>
<li>要想不中断，可将其放入try…catch结构中。</li>
<li>或者在await后面的Promise对象再跟一个catch方法，处理前面可能出现的错误。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">async function f()&#123;</span><br><span class="line">	try&#123;</span><br><span class="line">		await Promise.reject(&apos;出错了&apos;);</span><br><span class="line">	&#125;catch(e)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	return await Promise.resolve(&apos;hello&apos;);</span><br><span class="line">&#125;</span><br><span class="line">f().then(v =&gt; &#123; console.log(v)&#125;);//hello</span><br><span class="line"></span><br><span class="line">async function f()&#123;</span><br><span class="line">	await Promise.reject(&apos;出错了&apos;)</span><br><span class="line">	.catch(e =&gt; &#123;console.log(e);&#125;);</span><br><span class="line">	return await Promise.resolve(&apos;hello&apos;)</span><br><span class="line">&#125;</span><br><span class="line">f().then(v =&gt; &#123; console.log(v)&#125;);</span><br><span class="line">//出错了</span><br><span class="line">//hello</span><br><span class="line"></span><br><span class="line">async function f() &#123;</span><br><span class="line">  await new Promise(function (resolve, reject) &#123;</span><br><span class="line">    throw new Error(&apos;出错了&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(v =&gt; console.log(v))</span><br><span class="line">.catch(e =&gt; console.log(e))</span><br><span class="line">// Error：出错了</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h4><ul>
<li>生成实例对象的传统方法是通过构造函数，引入class类概念，利用constructor构造方法创建实例，类中方法不需要加function，毗邻方法间不许用逗号相隔，加了会报错。在类实例上调用方法其实就是调用原型上的方法。</li>
<li>prototype对象的constructor属性，直接指向类本身，与ES5相似。constructor是类的默认方法，无显式指定时会模认自动生成。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class B&#123;</span><br><span class="line">	constructor()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">let b = new B();</span><br><span class="line">b.constructor === B.prototype.constructor  //true</span><br><span class="line">B.prototype.constructor === B    //true</span><br></pre></td></tr></table></figure>

<ul>
<li>由于类的方法都定义在prototype对象上，故类的新方法可添加在prototype对象上。Object.assign可一次添加多个方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(Point.prototype,&#123;</span><br><span class="line">	toString()&#123;&#125;,</span><br><span class="line">	toValue()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>类内部定义的方法都不可枚举。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(Point.prototype)</span><br><span class="line">//Object.keys()返回可枚举的键名</span><br><span class="line">//[]  </span><br><span class="line">Object.getOwnPropertyNames(Point.prototype)</span><br><span class="line">//[&quot;constructor&quot;,&quot;toString&quot;]</span><br><span class="line">//返回自身全部属性方法名（包括不可枚举属性）</span><br></pre></td></tr></table></figure>

<ul>
<li>constructor方法默认返回实例对象（即this），可指定返回另外一个对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">	constructor()&#123; return Object.create(null); &#125;</span><br><span class="line">&#125;</span><br><span class="line">new Foo() instanceof Foo</span><br></pre></td></tr></table></figure>

<h6 id="类的几种表示法"><a href="#类的几种表示法" class="headerlink" title="类的几种表示法"></a>类的几种表示法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class B&#123;&#125;</span><br><span class="line">let b = new B();</span><br><span class="line"></span><br><span class="line">const MyClass = class Me&#123;&#125;; //Me可省略，只能在内部使用</span><br><span class="line">let inst = new MyClass();//外部使用类只能用MyClass</span><br><span class="line"> </span><br><span class="line">//立即执行的类</span><br><span class="line">let person = new class&#123;</span><br><span class="line">	constructor(name)&#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	sayName()&#123;</span><br><span class="line">		console.log(this.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;(&apos;张三&apos;)</span><br><span class="line">person.sayName(); //“张三”</span><br></pre></td></tr></table></figure>

<h6 id="noticePoint"><a href="#noticePoint" class="headerlink" title="noticePoint"></a>noticePoint</h6><ul>
<li><p>类和模块默认就是严格模式。</p>
</li>
<li><p>类不存在变量提升，类使用在前，定义在后会报错。</p>
</li>
<li><p>name属性。ES6的类只是ES5的构造函数的一层包装，故函数的许多特性都被Class继承，包括name属性，name属性总是返回紧跟在class关键字后面的类名。</p>
</li>
<li><p>如果类的Symbol.iterator方法前有一星号，就是Generator方法。该方法会返回类的默认遍历器，for…of循环自动调用这个遍历器。</p>
</li>
<li><p>类内部如果有this默认指向类的实例。<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是<code>undefined</code>），从而导致找不到<code>print</code>方法而报错。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">  printName(name = &apos;there&apos;) &#123;</span><br><span class="line">    this.print(`Hello $&#123;name&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print(text) &#123;</span><br><span class="line">    console.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const logger = new Logger();</span><br><span class="line">const &#123; printName &#125; = logger;</span><br><span class="line">printName(); // TypeError: Cannot read property &apos;print&apos; of undefined</span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//1.给构造函数绑定this</span><br><span class="line">class Logger&#123;</span><br><span class="line">	constructor()&#123;</span><br><span class="line">		this.printName = this.printName.bind(this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2.使用箭头函数</span><br><span class="line">class Obj&#123;</span><br><span class="line">	constructor()&#123;</span><br><span class="line">		this.getThis = () =&gt; this;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">const myObj = new Obj();</span><br><span class="line">myObj.getThis() === myobj  //true</span><br><span class="line"></span><br><span class="line">//3.使用Proxy，获取方法时自动绑定this</span><br><span class="line">function selfish(target)&#123;</span><br><span class="line">	const cache = new WeakMap();</span><br><span class="line">	const handler = &#123;</span><br><span class="line">		get(target,key)&#123;</span><br><span class="line">			const value = Reflect.get(target,key);</span><br><span class="line">			if(typeof value !== &apos;function&apos;)&#123;</span><br><span class="line">				return value;</span><br><span class="line">			&#125;</span><br><span class="line">			if(!cache.has(value))&#123;</span><br><span class="line">				cache.set(value,value.bind(target));</span><br><span class="line">			&#125;</span><br><span class="line">			return cache.get(value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	const proxy = new Proxy(target,handle);</span><br><span class="line">	return proxy;</span><br><span class="line">&#125;</span><br><span class="line">const logger = selfish(new Logger());</span><br></pre></td></tr></table></figure>

<ul>
<li>类中的方法前加上static关键字，该不会被实例继承，调用只能通过累来调用，称为静态方法。如果静态方法上包含this关键字，这个this指的是类，而不是实例。故静态方法可与非静态方法重名。</li>
<li>父类的静态方法可被子类继承，并可通过super对象屌用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">	static bar()&#123;this.baz();&#125;</span><br><span class="line">	static baz()&#123;console.log(&apos;helloBar&apos;);&#125;</span><br><span class="line">	static classMethod()&#123;return &apos;hello&apos;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.classMethod()  //‘hello&apos;</span><br><span class="line">Foo.bar()    //&apos;helloBar&apos;</span><br><span class="line">var foo = new Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line">//TypeError:foo.classMethod is not a function</span><br><span class="line"></span><br><span class="line">class Bar extends Foo&#123;</span><br><span class="line">	static sonMethod()&#123;</span><br><span class="line">		return super.classMethod() + &apos;,too&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Bar.classMethod()   //&apos;hello&apos;</span><br><span class="line">Bar.sonMethods()      //&apos;hello,too&apos;</span><br></pre></td></tr></table></figure>

<ul>
<li>实例属性<code>this._count</code>定义在<code>constructor()</code>方法里面，可将属性也可以定义在类的最顶层，其他都不变。实例属性<code>_count</code>与取值函数<code>value()</code>和<code>increment()</code>方法，处于同一个层级。这时，不需要在实例属性前面加上<code>this</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class IncreasingCounter &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this._count = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  get value() &#123;</span><br><span class="line">    console.log(&apos;Getting the current value!&apos;);</span><br><span class="line">    return this._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    this._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class IncreasingCounter &#123;</span><br><span class="line">  _count = 0;</span><br><span class="line">  get value() &#123;</span><br><span class="line">    console.log(&apos;Getting the current value!&apos;);</span><br><span class="line">    return this._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    this._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态属性即Class本身属性，必须在前面加上static关键字。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">calss Foo&#123;</span><br><span class="line">	static prop = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>子类继承父类，除了使用extends外，必须在子类的constructor上调用super对象，否则new实例时会报错。这是因为子类自己的this对象必须经过父类的构造函数完成塑造，得到与父类同样的实例属性和方法再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。如果在调用super之前使用this会报错。</p>
</li>
<li><p>Object.getPrototypeOf()用于在子类中获取父类，可用该方法判断一个类是否继承了另一个类。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(ColorPoint) === Point</span><br><span class="line">//true</span><br></pre></td></tr></table></figure>

<h6 id="super"><a href="#super" class="headerlink" title="super"></a>super</h6><ul>
<li>既可当函数调用，也可当对象使用。</li>
<li>super作为函数调用时，代表父类的构造函数。ES6规定，子类的constructor函数必须执行一次super()，且super()函数只能用在子类的构造函数内，用在其他地方会报错。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">	constructor()&#123;</span><br><span class="line">		console.log(new.target.name);//new.target指向当前正在执行的函数</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">	constructor()&#123;</span><br><span class="line">		super();   //等价于A.prototype.constructor.call(this)</span><br><span class="line">		//super内部的this指向子类的实例</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">new A() //A</span><br><span class="line">new B() //B</span><br></pre></td></tr></table></figure>

<ul>
<li>super作为对象时，在普通方法中，指向父类的原型对象；静态方法中，指向父类。这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.p = 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.x = 3;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  get m() &#123;</span><br><span class="line">    return super.p;</span><br><span class="line">  &#125;</span><br><span class="line">  get x()&#123;</span><br><span class="line">  	return super.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B();</span><br><span class="line">b.m // undefined</span><br><span class="line">b.x //3</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.x = 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x = 2;</span><br><span class="line">    super.x = 3;</span><br><span class="line">    console.log(super.x); // undefined</span><br><span class="line">    console.log(this.x); // 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p>
<ul>
<li>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</li>
<li>在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">  	this.x = &apos;实例的x&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  static print()&#123;</span><br><span class="line">  	console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">  static myMethod(msg) &#123;</span><br><span class="line">    console.log(&apos;static&apos;, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    console.log(&apos;instance&apos;, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">  static m()&#123;</span><br><span class="line">  	super.print();</span><br><span class="line">  &#125;</span><br><span class="line">  static myMethod(msg) &#123;</span><br><span class="line">    super.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    super.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.myMethod(1); // static 1</span><br><span class="line"></span><br><span class="line">var child = new Child();</span><br><span class="line">child.myMethod(2); // instance 2</span><br><span class="line"></span><br><span class="line">Child.x = &apos;这是类的x&apos;;</span><br><span class="line">Child.m() //&apos;这是类的x&apos;</span><br></pre></td></tr></table></figure>

<h6 id="类的prototype属性和-proto-属性"><a href="#类的prototype属性和-proto-属性" class="headerlink" title="类的prototype属性和__proto__属性"></a>类的prototype属性和<code>__proto__</code>属性</h6><ul>
<li>每个对象都有<code>__proto__</code>属性，指向对应的构造函数的prototype属性。</li>
<li><strong>子类的<code>__proto__</code>属性表示构造函数的继承，总是指向父类。</strong></li>
<li><strong>子类的prototype属性的<code>__proto__</code>属性表示方法的继承，总是指向父类的prototype属性。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">class B extends A&#123;&#125;</span><br><span class="line">B.__proto__ === A  //true</span><br><span class="line">B.prototype.__proto__  === A.prototype  //true</span><br><span class="line"></span><br><span class="line">//B的实例继承A的实例</span><br><span class="line">Object.setPrototypeOf(B.prototype,A.prototype);</span><br><span class="line">//B继承A的静态属性</span><br><span class="line">Object.setPrototypeOf(B,A);</span><br><span class="line"></span><br><span class="line">//Object.setPrototypeOf方法实现</span><br><span class="line">Object.setPrototypeOf = function(obj,proto)&#123;</span><br><span class="line">	obj.__proto__ = proto;</span><br><span class="line">	return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</p>
<p>上面代码的<code>A</code>，只要是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p>
<p>以下两种特殊情况</p>
<ul>
<li>子类继承Object类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A extends Object&#123;&#125;</span><br><span class="line">A.__proto__ === Object  //true</span><br><span class="line">A.prototype.__proto__ === Object.prototype  //true</span><br><span class="line">//A其实就是构造函数Object的复制，A的实例就是Object的实例</span><br></pre></td></tr></table></figure>

<ul>
<li>不存在任何继承</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">A.__proto__ === Function.prototype   //true</span><br><span class="line">A.prototype.__proto__ === Object.prototype   //true</span><br></pre></td></tr></table></figure>

<p>A作为一个基类，即不存在任何继承，就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象即object实例，所以<code>A.prototype.__proto__</code>指向构造函数Object的prototype属性。</p>
<h4 id="module模块"><a href="#module模块" class="headerlink" title="module模块"></a>module模块</h4><ul>
<li>ES6之前，社区制定了一些模块加载方案。主要是CommonJS——服务器，AMD——浏览器。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// CommonJS模块,运行时加载，无法做到“运行时加载”</span><br><span class="line">let &#123; stat, exists, readFile &#125; = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">let _fs = require(&apos;fs&apos;);</span><br><span class="line">let stat = _fs.stat;</span><br><span class="line">let exists = _fs.exists;</span><br><span class="line">let readfile = _fs.readfile;</span><br></pre></td></tr></table></figure>

<ul>
<li>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ES6模块</span><br><span class="line">import &#123; stat, exists, readFile &#125; from &apos;fs&apos;;</span><br></pre></td></tr></table></figure>

<p>上面代码的实质是从<code>fs</code>模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>
<p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p>
<ul>
<li>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li>
<li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li>
<li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li>
</ul>
<p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p>
<h6 id="严格模式主要有以下限制。"><a href="#严格模式主要有以下限制。" class="headerlink" title="严格模式主要有以下限制。"></a>严格模式主要有以下限制。</h6><ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用<code>with</code>语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀 0 表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li>
<li><code>eval</code>不会在它的外层作用域引入变量</li>
<li><code>eval</code>和<code>arguments</code>不能被重新赋值</li>
<li><code>arguments</code>不会自动反映函数参数的变化</li>
<li>不能使用<code>arguments.callee</code></li>
<li>不能使用<code>arguments.caller</code></li>
<li>禁止<code>this</code>指向全局对象</li>
<li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li>
<li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li>
</ul>
<p>其中，尤其需要注意<code>this</code>的限制。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code></p>
<h6 id="exprot与import"><a href="#exprot与import" class="headerlink" title="exprot与import"></a>exprot与import</h6><ul>
<li>export写法：必须提供对外的接口。实质是在接口名与模块内部变量之间建立一一对应的关系。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">export 1;</span><br><span class="line">// 报错</span><br><span class="line">var m = 1; </span><br><span class="line">export m;</span><br><span class="line"></span><br><span class="line">// 写法一</span><br><span class="line">export var m = 1;</span><br><span class="line">// 写法二</span><br><span class="line">var m = 1;</span><br><span class="line">export &#123;m&#125;;</span><br><span class="line">// 写法三</span><br><span class="line">var n = 1;</span><br><span class="line">export &#123;n as m&#125;;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">export f;</span><br><span class="line">// 正确</span><br><span class="line">export function f() &#123;&#125;;</span><br><span class="line">// 正确</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">export &#123;f&#125;;</span><br></pre></td></tr></table></figure>

<p><code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p>
<ul>
<li><code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。<code>import</code>命令是编译阶段执行的，在代码运行之前。</li>
<li>使用export  default 时，对应的import语句不需要使用大括号；使用export时，对应的import语句需要使用大括号。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default function crc32()&#123;&#125;</span><br><span class="line">import crc32 from &apos;crc32&apos;;</span><br><span class="line"></span><br><span class="line">export function crc32()&#123;&#125;</span><br><span class="line">import &#123;crc32&#125; from &apos;crc32&apos;;</span><br></pre></td></tr></table></figure>

<p>export  default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export  default命令只能使用一次。故import后面才不用加大括号，因为只可能唯一对应export  default命令。</p>
<p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// modules.js</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x * y;</span><br><span class="line">&#125;</span><br><span class="line">export &#123;add as default&#125;;</span><br><span class="line">// 等同于</span><br><span class="line">// export default add;</span><br><span class="line"></span><br><span class="line">// app.js</span><br><span class="line">import &#123; default as foo &#125; from &apos;modules&apos;;</span><br><span class="line">// 等同于</span><br><span class="line">// import foo from &apos;modules&apos;;</span><br></pre></td></tr></table></figure>

<h6 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h6><ul>
<li>浏览器异步加载js脚本的方法。<code>&lt;script&gt;</code>标签遇到defer或async属性，脚本就会异步加载，渲染引擎遇到这一命令就会开始下载外部脚本，但不会等他下载和执行，而是直接执行后面的命令。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;&quot;  defer&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;&quot;  async&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>defer与async的区别</strong></p>
<p>defer要等到整个页面在内存中正常渲染结束（DOM结构完全生成，以及脚本执行），才会执行。<strong>渲染完再执行</strong>，若有多个defer脚本，则按顺序加载。</p>
<p>async是<strong>下载后执行</strong>，即一旦下载完成，渲染引擎就会中断渲染执行这个脚本后再继续渲染。故不能保证加载顺序。</p>
<ul>
<li>加载ES6模块,对于带有<code>type=&quot;module&quot;</code>的脚本都是异步加载，相当于默认是defer属性，<strong>渲染完再加载</strong>，可设为async属性。</li>
</ul>
<p><code>&lt;script type=&quot;module&quot; src=&quot;&quot;&gt;&lt;/script&gt;</code></p>
<ul>
<li>外部脚本注意事项：<ul>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>
<li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li>
<li>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li>
<li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li>
<li>同一个模块如果加载多次，将只执行一次。</li>
</ul>
</li>
</ul>
<h6 id="ES6模块与CommonJS模块的差异"><a href="#ES6模块与CommonJS模块的差异" class="headerlink" title="ES6模块与CommonJS模块的差异"></a>ES6模块与CommonJS模块的差异</h6><ul>
<li>commonJS模块输出的是一个值的拷贝，且运行时加载。<ul>
<li>值拷贝表明一旦输出后，内部值的改变不影响这个值。</li>
</ul>
</li>
<li>ES6模块输出的是值的引用，编译时输出接口。<ul>
<li>JS引擎对脚本静态分析时，遇到模块加载命令import就会生成一个只读引用，等到脚本真正执行时再根据这个只读引用到被加载模块取值。</li>
</ul>
</li>
</ul>
<h6 id="CommonJS加载原理"><a href="#CommonJS加载原理" class="headerlink" title="CommonJS加载原理"></a>CommonJS加载原理</h6><ul>
<li>CommonJS（加载时执行）的一个模块就是一个脚本文件，require命令第一次加载该脚本就会执行整个脚本，然后在内存生成一个对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	//node内部加载模块完成后生成的对象</span><br><span class="line">	id:&apos;...&apos;,	//模块名</span><br><span class="line">	exports:&#123;...&#125;,	//模块输出的各个接口</span><br><span class="line">	loaded:true,	//该模块脚本是否执行完毕</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以后用到这个模块时就回到exports属性上取值，即使再执行require也不会再次执行该模块而是到缓存中取值，即CommonJS无论加载多少次都只在第一次加载时运行一次，以后再加载只会返回第一次加载的结果，除非手动清除缓存。</p>
<h6 id="ES6模块转码"><a href="#ES6模块转码" class="headerlink" title="ES6模块转码"></a>ES6模块转码</h6><ul>
<li>Babel</li>
<li>转码器：ES6 module transpiler（将es6转为CommonJS或AMD模块）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm i -g es6-module-transpiler</span><br><span class="line">//转码</span><br><span class="line">compile-modules convert file1.js file2.js</span><br><span class="line">//-o指定转码后的文件名</span><br><span class="line">compile-modules convert -o out.js file1.js</span><br></pre></td></tr></table></figure>

<ul>
<li>在网页中导入system.js文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;system.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	//使用System.import加载模块文件,返回Promise对象</span><br><span class="line">	System.import(&apos;./模块文件&apos;).then(function()&#123;&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h4><ul>
<li>注意区分Object与Map，只有模拟现实世界的实体对象时才使用Object。如果只是需要key：value的数据结构，使用Map结构，因其有内建的遍历机制。</li>
<li>总是用class代替prototype操作。使用extends实现继承，不会破环instanceof运算的危险。</li>
<li>模块默认输出一个函数，函数名首字母应该小写，默认输出对象时，对象名首字母大写。</li>
</ul>
<h4 id="异步遍历器"><a href="#异步遍历器" class="headerlink" title="异步遍历器"></a>异步遍历器</h4><ul>
<li>Iterator接口是一种数据遍历的协议，只要调用遍历器对象的next方法就会得到一个对象，表示当前遍历指针所在的那个位置的信息。next方法必须是同步的，返回value和done两个属性值。</li>
<li>若next方法是一个异步操作，可将异步操作包装成Thunk函数或Promise对象，即next方法的返回值的value属性是一个Thunk函数或Promise对象，等待以后返回真正的值，而done则还是同步操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function idMaker()&#123;</span><br><span class="line">	let index = 0;</span><br><span class="line">	return &#123;</span><br><span class="line">		next:function()&#123;</span><br><span class="line">			return&#123;</span><br><span class="line">				value:new Promise(resolve =&gt; setTimeOut(() =&gt; resolve(index++),1000)),</span><br><span class="line">				done:false</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">const it = idMaker();</span><br><span class="line">it.next().value.then(o =&gt; console.log(o))  //1</span><br><span class="line">it.next().value.then(o =&gt; console.log(o))  //2</span><br></pre></td></tr></table></figure>

<ul>
<li>一个对象的同步遍历器的接口部署在Symbol.iterator属性上。</li>
<li>for…of遍历同步的iterator接口，<code>for await...of</code>循环遍历异步的Iterator接口。createAsyncIterable()返回一个拥有一部遍历器接口的对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function f()&#123;</span><br><span class="line">	for await (const x of createAsyncIterable([&apos;a&apos;,&apos;b&apos;]))&#123;</span><br><span class="line">		console.log(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//a   b</span><br></pre></td></tr></table></figure>

<ul>
<li>异步Generator函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async function* map()&#123; yield &apos;hello&apos;; &#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2020/04/28/ES6的学习/">ES6的学习</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">陈楚吟</a></p>
        <p><span>发布时间:</span>2020-04-28, 14:51:11</p>
        <p><span>最后更新:</span>2020-06-17, 15:18:53</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2020/04/28/ES6的学习/" title="ES6的学习">http://yoursite.com/2020/04/28/ES6的学习/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2020/04/28/ES6的学习/　　作者: 陈楚吟" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2020/04/30/http进阶/">
                    http进阶
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2020/04/28/vue学习中的问题/">
                    vue学习中的问题
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#ES6变量声明"><span class="toc-number">1.</span> <span class="toc-text">ES6变量声明</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#let命令"><span class="toc-number">1.0.1.</span> <span class="toc-text">let命令</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#const命令"><span class="toc-number">1.0.2.</span> <span class="toc-text">const命令</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#将对象彻底冻结"><span class="toc-number">1.0.3.</span> <span class="toc-text">将对象彻底冻结</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#import命令"><span class="toc-number">1.0.4.</span> <span class="toc-text">import命令</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#class命令"><span class="toc-number">1.0.5.</span> <span class="toc-text">class命令</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#顶层对象"><span class="toc-number">1.0.6.</span> <span class="toc-text">顶层对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组解构"><span class="toc-number">2.</span> <span class="toc-text">数组解构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this"><span class="toc-number">3.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串"><span class="toc-number">4.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串新增方法"><span class="toc-number">5.</span> <span class="toc-text">字符串新增方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#确定一个字符串是否包含在另一个字符串中"><span class="toc-number">5.0.1.</span> <span class="toc-text">确定一个字符串是否包含在另一个字符串中</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#repeat-：返回一个新字符串，表示将原字符串重复n次。"><span class="toc-number">5.0.2.</span> <span class="toc-text">repeat()：返回一个新字符串，表示将原字符串重复n次。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#正则表达式"><span class="toc-number">6.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#具名组匹配"><span class="toc-number">6.0.1.</span> <span class="toc-text">具名组匹配</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#先行断言"><span class="toc-number">6.0.2.</span> <span class="toc-text">先行断言</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#后行断言"><span class="toc-number">6.0.3.</span> <span class="toc-text">后行断言</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#属性"><span class="toc-number">6.0.4.</span> <span class="toc-text">属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数的拓展"><span class="toc-number">7.</span> <span class="toc-text">函数的拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#箭头函数（-gt-）"><span class="toc-number">7.0.1.</span> <span class="toc-text">箭头函数（=&gt;）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#尾调用（Tail-Call）"><span class="toc-number">7.0.2.</span> <span class="toc-text">尾调用（Tail Call）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#尾递归"><span class="toc-number">7.0.3.</span> <span class="toc-text">尾递归</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组"><span class="toc-number">8.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象的扩展"><span class="toc-number">9.</span> <span class="toc-text">对象的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#属性遍历"><span class="toc-number">9.0.1.</span> <span class="toc-text">属性遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#super关键字"><span class="toc-number">9.0.2.</span> <span class="toc-text">super关键字</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#解构赋值"><span class="toc-number">9.0.3.</span> <span class="toc-text">解构赋值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象新增方法"><span class="toc-number">10.</span> <span class="toc-text">对象新增方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组中的遍历"><span class="toc-number">11.</span> <span class="toc-text">数组中的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串新增方法-1"><span class="toc-number">12.</span> <span class="toc-text">字符串新增方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面向对象class类"><span class="toc-number">13.</span> <span class="toc-text">面向对象class类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#继承"><span class="toc-number">13.0.1.</span> <span class="toc-text">继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#json"><span class="toc-number">14.</span> <span class="toc-text">json</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#标准写法："><span class="toc-number">14.0.1.</span> <span class="toc-text">标准写法：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#方法："><span class="toc-number">14.0.2.</span> <span class="toc-text">方法：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise（消除异步操作）"><span class="toc-number">15.</span> <span class="toc-text">Promise（消除异步操作）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Promise-prototype-finally"><span class="toc-number">15.0.1.</span> <span class="toc-text">Promise.prototype.finally()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Promise-all"><span class="toc-number">15.0.2.</span> <span class="toc-text">Promise.all()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Fetch-API是js接口"><span class="toc-number">15.0.3.</span> <span class="toc-text">Fetch API是js接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Generator函数"><span class="toc-number">16.</span> <span class="toc-text">Generator函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#与Symbol-iterator的关系"><span class="toc-number">16.0.1.</span> <span class="toc-text">与Symbol.iterator的关系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#原生js对象添加Iterator接口的方法"><span class="toc-number">16.0.2.</span> <span class="toc-text">原生js对象添加Iterator接口的方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Generator-prototype-throw"><span class="toc-number">16.0.3.</span> <span class="toc-text">Generator.prototype.throw</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Generator-prototype-return"><span class="toc-number">16.0.4.</span> <span class="toc-text">Generator.prototype.return</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#yield-表达式"><span class="toc-number">16.0.5.</span> <span class="toc-text">yield*表达式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#协程"><span class="toc-number">16.0.6.</span> <span class="toc-text">协程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Thunk函数"><span class="toc-number">16.0.7.</span> <span class="toc-text">Thunk函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Thunkify模块"><span class="toc-number">16.0.8.</span> <span class="toc-text">Thunkify模块</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#co模块"><span class="toc-number">16.0.9.</span> <span class="toc-text">co模块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#async函数"><span class="toc-number">17.</span> <span class="toc-text">async函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ansyc较Generator函数的优点"><span class="toc-number">17.0.1.</span> <span class="toc-text">ansyc较Generator函数的优点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#async使用形式"><span class="toc-number">17.0.2.</span> <span class="toc-text">async使用形式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#await-命令"><span class="toc-number">17.0.3.</span> <span class="toc-text">await 命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class类"><span class="toc-number">18.</span> <span class="toc-text">class类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#类的几种表示法"><span class="toc-number">18.0.1.</span> <span class="toc-text">类的几种表示法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#noticePoint"><span class="toc-number">18.0.2.</span> <span class="toc-text">noticePoint</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#super"><span class="toc-number">18.0.3.</span> <span class="toc-text">super</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#类的prototype属性和-proto-属性"><span class="toc-number">18.0.4.</span> <span class="toc-text">类的prototype属性和__proto__属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#module模块"><span class="toc-number">19.</span> <span class="toc-text">module模块</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#严格模式主要有以下限制。"><span class="toc-number">19.0.1.</span> <span class="toc-text">严格模式主要有以下限制。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#exprot与import"><span class="toc-number">19.0.2.</span> <span class="toc-text">exprot与import</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#异步加载"><span class="toc-number">19.0.3.</span> <span class="toc-text">异步加载</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ES6模块与CommonJS模块的差异"><span class="toc-number">19.0.4.</span> <span class="toc-text">ES6模块与CommonJS模块的差异</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CommonJS加载原理"><span class="toc-number">19.0.5.</span> <span class="toc-text">CommonJS加载原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ES6模块转码"><span class="toc-number">19.0.6.</span> <span class="toc-text">ES6模块转码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编程风格"><span class="toc-number">20.</span> <span class="toc-text">编程风格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步遍历器"><span class="toc-number">21.</span> <span class="toc-text">异步遍历器</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"ES6的学习　| Nikita　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2020/04/30/http进阶/" title="上一篇: http进阶">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2020/04/28/vue学习中的问题/" title="下一篇: vue学习中的问题">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/07/26/项目中的业务需求/">项目中的业务需求</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/26/js中的Blod对象/">js中的Blod对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/25/vue中的插槽slot/">vue中的插槽slot</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/19/vue-config-js配置文件详解/">vue.config.js配置文件详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/10/代理/">代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/09/浏览器发请求的几种方式/">浏览器发请求的几种方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/html技巧/">html技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/26/js技巧/">js技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/25/css技术技巧/">css技术技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/数组中的reduce/">数组中的reduce</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/‘力扣简单题’/">‘力扣简单题’</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/vue小技巧/">vue小技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/vue的面试/">vue的面试</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/18/学习vuex/">学习vuex</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/同源策略/">同源策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/typescript/">typescript</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/jquery/">jquery</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/js动画篇/">js动画篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/js精研/">js精研</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/js基础/">js基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/刷题笔记/">刷题笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/11/前端cookie解读/">前端cookie解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/04/前端经验/">前端经验</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/22/linux学习/">linux学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/10/pandas之excel/">pandas之excel</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/09/HTML5和CSS3/">HTML5和CSS3</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/08/爬虫/">爬虫</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/07/python的学习/">python的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/30/AJAX学习/">AJAX学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/30/node进阶/">node进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/30/http进阶/">http进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/ES6的学习/">ES6的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/vue学习中的问题/">vue学习中的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/27/计算机网络/">计算机网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/27/数据结构与算法/">数据结构与算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/07/前端面试/">前端面试</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/06/http的学习/">http的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/课程表制作/">课程表制作</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/CSS3/">CSS3</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/Grid布局/">Grid布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/CSS3高阶/">CSS3高阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/HTML5基础下-陈楚吟/">HTML5基础下--陈楚吟</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/HTML5基础上-陈楚吟/">HTML5基础上-陈楚吟</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/深入理解css/">深入理解css</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/选择器/">选择器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/vue学习三/">vue学习三</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/vue学习二/">vue学习二</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/vue学习一/">vue学习一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/浅谈canvas和相关实战/">浅谈canvas和相关实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/setTimeout与setInterval区别/">setTimeout与setInterval区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/js中callee和caller/">js中callee和caller</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/行内元素存在间距问题/">行内元素存在间距问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/09/canvas绘制碰撞球动画/">canvas绘制碰撞球动画</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/27/用JavaScript封装栈/">用JavaScript封装栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/26/伪类与伪元素的区区别/">伪类与伪元素的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/17/深入理解包与NPM和package-json深入解读/">深入理解包与NPMM,package.json深入解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/15/JS中外部文件的优势-1/">JS中外部文件的优势</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/03/vue进阶/">vue进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/27/webpack学习/">webpack学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/15/攻克object对象/">攻克object对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/15/qq小程序天坑之旅/">qq小程序天坑之旅</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/27/proto/">proto</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/26/项目开发流程/">项目开发流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/25/事件机制/">事件机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/17/MVVC模型架构/">MVVC模型架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/15/js执行上下文/">js执行上下文</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/15/js中的立即执行函数/">js中的立即执行函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/14/js中的闭包/">js中的闭包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/14/了解浏览器/">了解浏览器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/13/我认识的js原型及原型链/">我认识的js原型及原型链</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/12/深入理解js中的this/">深入理解js中的this</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/12/相对全面的数组/">相对全面的数组去重</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/11/css盒模型集锦/">css盒模型集锦</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 陈楚吟
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>
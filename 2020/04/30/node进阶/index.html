<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="陈楚吟">



<meta name="description" content="单线程的弱点 无法利用多核CPU。 错误会引起整个应用退出，应用的健壮性值得考虑。 大量计算占用CPU导致无法继续调用异步I/O。  像浏览器中JavaScript与UI共用一个线程一样，JavaScript长时间执行会导致UI渲染和响应被中断。在Node中，长时间的CPU占用也会导致后续异步I/O发不出调用，已完成的异步I/O的回调函数也会得不到及时执行。 Node采用了与Web Workers">
<meta name="keywords" content="write myBlog">
<meta property="og:type" content="article">
<meta property="og:title" content="node进阶">
<meta property="og:url" content="http://yoursite.com/2020/04/30/node进阶/index.html">
<meta property="og:site_name" content="Nikita">
<meta property="og:description" content="单线程的弱点 无法利用多核CPU。 错误会引起整个应用退出，应用的健壮性值得考虑。 大量计算占用CPU导致无法继续调用异步I/O。  像浏览器中JavaScript与UI共用一个线程一样，JavaScript长时间执行会导致UI渲染和响应被中断。在Node中，长时间的CPU占用也会导致后续异步I/O发不出调用，已完成的异步I/O的回调函数也会得不到及时执行。 Node采用了与Web Workers">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-06-17T07:58:43.983Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="node进阶">
<meta name="twitter:description" content="单线程的弱点 无法利用多核CPU。 错误会引起整个应用退出，应用的健壮性值得考虑。 大量计算占用CPU导致无法继续调用异步I/O。  像浏览器中JavaScript与UI共用一个线程一样，JavaScript长时间执行会导致UI渲染和响应被中断。在Node中，长时间的CPU占用也会导致后续异步I/O发不出调用，已完成的异步I/O的回调函数也会得不到及时执行。 Node采用了与Web Workers">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Nikita" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>node进阶 | Nikita</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">陈楚吟</a></h1>
        </hgroup>

        
        <p class="header-subtitle">不负韶华</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">陈楚吟</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">陈楚吟</a></h1>
            </hgroup>
            
            <p class="header-subtitle">不负韶华</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-node进阶" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/30/node进阶/" class="article-date">
      <time datetime="2020-04-30T02:30:22.000Z" itemprop="datePublished">2020-04-30</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      node进阶
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h4 id="单线程的弱点"><a href="#单线程的弱点" class="headerlink" title="单线程的弱点"></a>单线程的弱点</h4><ol>
<li>无法利用多核CPU。</li>
<li>错误会引起整个应用退出，应用的健壮性值得考虑。</li>
<li>大量计算占用CPU导致无法继续调用异步I/O。</li>
</ol>
<p>像浏览器中JavaScript与UI共用一个线程一样，JavaScript长时间执行会导致UI渲染和响应被中断。在Node中，长时间的CPU占用也会导致后续异步I/O发不出调用，已完成的异步I/O的回调函数也会得不到及时执行。</p>
<p>Node采用了与Web Workers相同的思路来解决单线程中大计算量的问题：child_process。</p>
<p>子进程的出现，意味着Node可以从容地应对单线程在健壮性和无法利用多核CPU方面的问题。通过计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好的保持应用模型的简单和地低依赖。通过Master-Worker的管理方式，也可以很好地管理各个工作进程，以达到更高的的健壮性。</p>
<h4 id="node简介"><a href="#node简介" class="headerlink" title="node简介"></a>node简介</h4><ul>
<li>Node.js是一个js运行环境，实际上它是对Google v8引擎的封装。V8引擎执行js的速度快，性能好。node.js对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境上运行的更好。</li>
<li>node.js是一个基于chrome javascript运行建立的平台，用于方便的搭建响应速度快，易于拓展的网络应用。node.js使用事件驱动，非阻塞I/O模型得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。</li>
<li>node采用一系列“非阻塞”库来支持事件循环的方式。本质上就是为文件系统，数据库之类的资源提供接口。向文件系统发送一个请求时，无需等待硬盘（寻址并检索文件），硬盘准备好的时候非阻塞接口会通知node。该模型以可拓展的方式简化了对慢资源的访问，直观易懂。</li>
<li>node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理——node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，因此，我们应该要充分的利用这一点——尽可能地避免阻塞操作</li>
</ul>
<h4 id="node-js组成部分"><a href="#node-js组成部分" class="headerlink" title="node.js组成部分"></a>node.js组成部分</h4><ul>
<li>引入required模块：我们可使用required指令载入node.js模块   var http = require(“http”);</li>
<li>创建服务器：服务器可监听客户端请求，类似于Apache，Nginx等http服务器 。使用http.createServer()方法创建服务器，并使用listen方法绑定端口。</li>
<li>接收请求和响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送http请求，服务器接收请求并返回响应数据。使用request和response参数来接收和响应数据。</li>
</ul>
<h4 id="npm包管理器"><a href="#npm包管理器" class="headerlink" title="npm包管理器"></a>npm包管理器</h4><ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用</li>
</ul>
<h4 id="NPM常用命令"><a href="#NPM常用命令" class="headerlink" title="NPM常用命令"></a>NPM常用命令</h4><p>NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。</p>
<ul>
<li><p>NPM提供了很多命令，例如<code>install</code>和<code>publish</code>，使用<code>npm help</code>可查看所有命令。</p>
</li>
<li><p>使用<code>npm help &lt;command&gt;</code>可查看某条命令的详细帮助，例如<code>npm help install</code>。</p>
</li>
<li><p>在<code>package.json</code>所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</p>
</li>
<li><p>使用<code>npm update &lt;package&gt;</code>可以把当前目录下<code>node_modules</code>子目录里边的对应模块更新至最新版本。</p>
</li>
<li><p>使用<code>npm update &lt;package&gt; -g</code>可以把全局安装的对应命令行程序更新至最新版。</p>
</li>
<li><p>使用<code>npm cache clear</code>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</p>
</li>
<li><p>使用<code>npm unpublish &lt;package&gt;@&lt;version&gt;</code>可以撤销发布自己发布过的某个版本代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm -v  						查看版本</span><br><span class="line">npm version  					查看所有模块的版本</span><br><span class="line">npm search 包名/部分包名			 搜索包</span><br><span class="line">npm init   						初始化package.json文件</span><br><span class="line">npm install/i 安装包     </span><br><span class="line">npm remove/r包名					删除包</span><br><span class="line">npm install/i 包名 --save 		安装包并添加到依赖中</span><br><span class="line">npm install 					根据package.json下载当前项目所依赖的包</span><br><span class="line">npm install 包名 -g				全局安装包，用于一些编译根据，比如：gulp，webpack</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>注意：如果想在页面中引入node_module中某个模块，优先从当前目录引入，如果没有，则从上一级目录中找，直到根目录。</li>
</ul>
<h4 id="REPL交互式解释器"><a href="#REPL交互式解释器" class="headerlink" title="REPL交互式解释器"></a>REPL交互式解释器</h4><ul>
<li>REPL(Read Eval Print Loop:交互式解释器)表示一个电脑的环境，类似于终端，可接受系统的响应。node自带了交互式解释器，可执行以下任务<ul>
<li>读取，读取用户输入，解析输入js数据结构并存储于内存中。</li>
<li>执行，执行输入的数据结构。</li>
<li>打印，输出结果。</li>
<li>循环，循环操作以上步骤直到用户两次按下ctrl+c按钮退出。</li>
</ul>
</li>
</ul>
<h4 id="node知识"><a href="#node知识" class="headerlink" title="node知识"></a>node知识</h4><h6 id="node-js与其它语言的区别"><a href="#node-js与其它语言的区别" class="headerlink" title="node.js与其它语言的区别"></a>node.js与其它语言的区别</h6><ul>
<li><p>node.js不是一门独立的语言。php，jsp即使语言，又是平台。node.js用js进行编程，运行平台是封装后的js引擎V8</p>
</li>
<li><p>轻量级架构</p>
<ul>
<li>java，php，net，需要运行在服务器上，apache，tomcat</li>
<li>node.js不用架设在任何服务器软件之上。</li>
<li>用最低的硬件成本，达到更高的开发，更优的处理函数。</li>
</ul>
</li>
<li><p>node.js没有web容器，就是安装配置完成之后，没有根目录（php的根目录是www）</p>
</li>
</ul>
<h6 id="node-js的特点（追求极致性能）"><a href="#node-js的特点（追求极致性能）" class="headerlink" title="node.js的特点（追求极致性能）"></a>node.js的特点（追求极致性能）</h6><ul>
<li>单线程<ul>
<li>优势：减少内存消耗（操作系统不再有创建线程，销毁线程的开销。<ul>
<li>在php，jsp等服务器语言中，会为每个用户创建一个线程，而每个线程大约需要2M内存，每创建一个线程就要占用内存空间。</li>
<li>当有客户链接时，就会触发一个内部事件，通过非阻塞I/O，事件驱动机制，让node.js宏观上是并发的。可同时处理4万用户的请求。即当张三连接着时，李四请求连接，引擎就会停止张三语法的执行，转而将李四加入到时间栈中。</li>
<li>node.js不为每个用户创建一个线程，仅仅使用同一个线程。</li>
</ul>
</li>
<li>劣势：<ul>
<li>如果线程遭遇I/O阻塞，整个线程便阻塞了。</li>
<li>如果有人将node.js搞崩溃了，则会全部奔溃。</li>
</ul>
</li>
</ul>
</li>
<li>非阻塞<ul>
<li>node.js采用非阻塞I/O机制，因此在执行完访问数据库操作后，会立即执行后面的代码（其他非阻塞事件不会，他们会等数据库操作完毕并返回结果才执行后面的代码），把数据库的处理代码放入回调函数中，从而提高效率。</li>
<li>当某个I/O执行完毕后，将以事件的形式通过执行I/O操作的线程，线程执行完这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断检查有没有未处理的事件，并依次予以处理。</li>
<li>阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远执行计算操作，这个线程的CPU核心利用率永远是100%；</li>
</ul>
</li>
<li>事件驱动<ul>
<li>不管用户的请求，还是老用户的I/O完成，都将以事件的形式加入事件环，等待调度。</li>
</ul>
</li>
<li>node.js的iI/O都是异步的，都是回调函数调回调函数</li>
</ul>
<h6 id="node事件触发"><a href="#node事件触发" class="headerlink" title="node事件触发"></a>node事件触发</h6><ul>
<li>继承EventEmitter，大多数情况下不会直接使用EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</li>
<li>原因：<ul>
<li>具有某个实体功能的对象实现时间符合语义，事件的监听和发射应该是一个对象的方法。</li>
<li>js对象是基于原型的，支持多重继承，继承EventEmitter不会打乱对象原有的继承关系。</li>
</ul>
</li>
</ul>
<h6 id="node-js应用方向"><a href="#node-js应用方向" class="headerlink" title="node.js应用方向"></a>node.js应用方向</h6><ol>
<li>特点<ul>
<li>善于I/O，不善于计算。<ul>
<li>因为node.js最擅长任务的调度，如果你的任务有很多CPU计算，实际上相当于这个计算阻塞了这个单线程，就不适合node开发。</li>
<li>当应用程序需要处理大量并发的I/O，而在向客户端发出响应后，应用程序内部并不需要进行复杂的处理时，node也非常适合与websocket配合，开发长连接的实时交互应用程序。</li>
</ul>
</li>
<li>天生异步<ul>
<li>callback，trunk（参数的求值策略），promise，generator（es6的生成器，用于计算），asynac函数</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="node模块化"><a href="#node模块化" class="headerlink" title="node模块化"></a>node模块化</h4><ul>
<li>CommonJS规范为JS能够在任何地方执行，这是一个愿景。</li>
<li>从文件角度看，每个JS文件就是一个个模块，从结构上看，多个JS文件之间可以相互require共同实现一个功能，这整体功能就是一个模块。</li>
<li>在node.js中，一个模块定义的变量只能在该文件中使用，当需要另一文件中的变量时，需使用exports进行暴漏，然后使用require引入。</li>
<li>引入模块时，如果是非核心模块，且在同级目录时，require需要加上<code>./</code>，核心模块则不需要，直接写名字即可</li>
</ul>
<h6 id="node核心模块"><a href="#node核心模块" class="headerlink" title="node核心模块"></a>node核心模块</h6><ul>
<li><p>全局变量是global。</p>
</li>
<li><p>每个node都在外面给我们套了一个函数。</p>
<p><code>function(exports,require,module,_filename,_dirname){//里面是你写的内容}</code></p>
<ul>
<li>exports：该对象用来将函数内部的局部函数暴漏到外部函数中。</li>
<li>require：用来引入外部模块。</li>
<li>module：代表当前模块本身，exports就是module的属性。我们可以使用exports或modile.exports导出。</li>
<li>_filename:当前模块的完整路径</li>
<li>_dirname:当前模块所在的文件的完整路径。</li>
</ul>
</li>
<li><p>exports与module.exports的区别</p>
</li>
<li><p>json文件不能加注释。</p>
</li>
</ul>
<h4 id="Buffer缓存区"><a href="#Buffer缓存区" class="headerlink" title="Buffer缓存区"></a>Buffer缓存区</h4><ul>
<li>可以理解为是一个存放二进制的容器，专门用于数据的存放。</li>
<li>node自带的，不需要引入就可使用。一个字节占8bit</li>
<li>8bit = 1B       1024B  = 1KB      1024KB = 1MKB      1GB=1024KB     1TB=1024GB</li>
<li>Buffer.from(str,编码格式);</li>
<li>Buffer.alloc(size[,fill[,encoding]])<ul>
<li>size:新建的Buffer期望的长度，不能动态改变，溢出的数据不做处理。int值</li>
<li>fill：用来预填充新建的Buffer的值，默认为0.     String   Buffer    int</li>
<li>encoding:如果fill为字符串，则该值就是它的字符编码，默认为“utf-8”</li>
</ul>
</li>
</ul>
<h4 id="fs文件处理"><a href="#fs文件处理" class="headerlink" title="fs文件处理"></a>fs文件处理</h4><ul>
<li><p>fs.open(path,flag[,mode],callback)打开文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//1.引入模块</span><br><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">//2.创建写入流，相当于在it666.txt与服务器之间建立一个通道，使数据可以源源不断从it666.txt中上传至服务器中</span><br><span class="line">let ws = fs.createWriteStream(&quot;it666.txt&quot;);</span><br><span class="line">//3.打开通道，监听打开事件，有on，once等方法，因只需监听一次，故用once</span><br><span class="line">stream.once(&apos;open&apos;,() =&gt; &#123;</span><br><span class="line">    console.log(&apos;通道已经打开&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">stream.once(&apos;close&apos;, ()=&gt; &#123;</span><br><span class="line">    console.log(&apos;通道已经关闭&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">//写入东西</span><br><span class="line">stream.write(&apos;dfsadc&apos;);</span><br><span class="line">stream.write(&apos;dfsadc&apos;);</span><br><span class="line">//关闭通道，当发现还有东西未写入时，不会关闭</span><br><span class="line">stream.end()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">let ws = fs.createWriteStream(&quot;it666.txt&quot;);</span><br><span class="line">let rs = fs.createReadStream(&quot;sp.mp4&quot;);</span><br><span class="line">//创建管道，该语句就会自动将数据存入sp.mp4中，同时监听打开关闭等事件</span><br><span class="line">rs.pipe(ws);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul>
<li>数据库就是按照一定的数据结构来组织，存储和管理数据的仓库。</li>
<li>我们写的程序都是在计算机上运行的，一旦计算机断电或程序运行完毕，程序数据就会全部丢失，所以我们需要将一些程序运行的数据持久性保存到硬盘中，以确保数据的安全性。</li>
<li>选择数据库的原因：<ul>
<li>数据库是有结构的，数据与数据之间可以建立各种关系，类似于网状拓扑图。</li>
<li>数据库提供各种接口，让各种操作（增删改查）变得快捷简单。</li>
<li>给个种语言（php，jsp，java）提供了完善的接口。</li>
</ul>
</li>
<li>数据库分类<ul>
<li>RDBMS(关系型数据库)：MySQL，SQL Server，ORACLE,DB2….</li>
<li>NoSQL（非关系型数据库 Not only SQL）:MongoDB,CouchDB,HBase,Redis…<ul>
<li>没有行列的概念，用JSON来存储数据，集合就相当于“表”，文档就相当于“行”。</li>
<li>非关系型数据库为非标准化的数据库。</li>
<li>特征：键值存储数据库，列存储数据库，文档存储数据库，图形数据库。</li>
</ul>
</li>
<li>两者区别：关系型数据库比较结构化，操作不是很灵活；非关系型数据库操作灵活，但不适合大型数据存储，比较适合微架构….两者相辅相成。</li>
</ul>
</li>
</ul>
<h6 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h6><ul>
<li>MongoDB是为快速开发互联网Web应用而设计的数据库系统。他的数据类型是面向文档的，类似于JSON的结构。</li>
<li>基本组成<ul>
<li>数据库（database）：数据库是一个仓库，在仓库中可以存放集合。</li>
<li>集合（collection）：集合类似于数组，在集合中可以存放文档。</li>
<li>文档（document）：文档数据库中的最小单位，我们存储和操作的内容都是文档。</li>
</ul>
</li>
<li>mongoDB的基本指令:<ul>
<li>show dbs    ：显示当前所有的数据库</li>
<li>use 数据库名        ：进入到指定的数据库中</li>
<li>db     ：显示当前数据库</li>
<li>show  collections        ：显示数据库中的所有集合</li>
</ul>
</li>
<li>命令进行CRUD<ul>
<li>插入：db.<collection>.insert(doc);      如：db.student.insert({id:001,name:’nikita’});</collection></li>
<li>查询：db.<collection>.find();</collection></li>
</ul>
</li>
</ul>
<h4 id="同步与异步，阻塞与非阻塞"><a href="#同步与异步，阻塞与非阻塞" class="headerlink" title="同步与异步，阻塞与非阻塞"></a>同步与异步，阻塞与非阻塞</h4><ul>
<li><p>同步，当发起一个调用时，在没有获取结果前，调用不会返回，直到获取结果。事一件一件做，做完一件在做一件。</p>
</li>
<li><p>异步：当发起一个调用时，在没有获取结果之前，调用就返回了，调用者并不会立即得到结果，而是被调用者通知调用调用者，通过回调函数处理结果。</p>
</li>
<li><p>阻塞，在等待结果时，不能干其他事，线程被挂起，直到结果返回。</p>
</li>
<li><p>非阻塞：在等待结果中，还能干其他事，线程不会被阻塞。</p>
</li>
</ul>
<h4 id="url相关操作"><a href="#url相关操作" class="headerlink" title="url相关操作"></a>url相关操作</h4><ul>
<li>将url解析为一个url对象：url.parse(urlString[,parseQueryString[,slashDenotHost]])</li>
<li>将一个url对象反解析为一个url地址：url.format(urlObject)</li>
<li>将部分url拼接为一个完整url地址url.resolve(from,to)</li>
<li>response对象有一个方法：write可以用来给客户端发送响应数据。write可以使用多次，但最后需要用end来结束响应，否则客户端会一直等待</li>
<li>req.url是地址栏中localhost后面的所有内容，除了hash的内容。</li>
<li>querystring.parse将字符串转为一个对象。</li>
</ul>
<h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><h6 id="使用第三方插件"><a href="#使用第三方插件" class="headerlink" title="使用第三方插件"></a>使用第三方插件</h6><p>需要先安装formidable包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let http = require(&apos;http&apos;);</span><br><span class="line">let url = require(&apos;url&apos;);</span><br><span class="line">let formidable = require(&apos;formidable&apos;);</span><br><span class="line">let util = require(&apos;util&apos;);//用于将object转为字符串</span><br><span class="line"> http.createServer((req,res) =&gt; &#123;</span><br><span class="line"> 	if(req.url === &apos;/postmsg&apos; &amp;&amp; req.methods.tolowerCase() === &quot;post&quot;)&#123;</span><br><span class="line"> 		//实例化对象</span><br><span class="line"> 		let form = new formidable.IncomingForm();</span><br><span class="line"> 		//设置上传文件路径</span><br><span class="line"> 		form.uploadDir = &apos;./uploads&apos;;</span><br><span class="line"> 		//获取表单内容</span><br><span class="line"> 		form.parse(req,(err,fileds,files) =&gt; &#123;</span><br><span class="line"> 			res.writeHead(200,&#123;&quot;content-Type&quot;:&quot;text/plain;charset=UTF-8&quot;&#125;);</span><br><span class="line"> 			res.end(util.inspect(&#123;fields:fields,files:files&#125;));</span><br><span class="line"> 		&#125;)</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;).listen(80,&apos;127.0.0.1&apos;);</span><br></pre></td></tr></table></figure>

<h4 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h4><p>在Node中，每个文件模块都是一个对象，它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Module(id, parent)&#123;</span><br><span class="line">	this.id = id;</span><br><span class="line">	this.exports = &#123;&#125;;</span><br><span class="line">	this.parent = parent;</span><br><span class="line">	if(parent &amp;&amp; parent.children)&#123;</span><br><span class="line">		parent.children.push(this);</span><br><span class="line">	&#125;</span><br><span class="line">	this.filename = null;</span><br><span class="line">	this.loaded = false;</span><br><span class="line">	this.children = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译和执行是引入文件模块的最后一个阶段。定位到具体文件后，Node会新建一个模块对象，然后通过路径载入并编译。对于不同的文件扩展名，其载入的方式也有所不同，具体如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.js文件。通过fs模块同步读取文件后编译执行。</span><br><span class="line"></span><br><span class="line">.node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后的编译生成的文件。</span><br><span class="line"></span><br><span class="line">.json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。</span><br><span class="line"></span><br><span class="line">其余扩展名文件。它们都被当作.js文件解析。(因为node只能解析js文件，其他文件最后都会被转化成js文件，故当其余扩展名文件出现时，node无法识别，故将其认为是默认扩展名进行解析，即.js)</span><br></pre></td></tr></table></figure>

<p>每一个编译成功的模块都会将文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。</p>
<p>根据不同文件扩展名，node会调用不同的读取方式，如：.json文件调用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Module._extensions[&apos;.json&apos;] = function(module,filename)&#123;</span><br><span class="line">	var content = NativeModule.require(&apos;fs&apos;).readFileSync(filename,&apos;utf8&apos;);</span><br><span class="line">	try&#123;</span><br><span class="line">		module.exports = JSON.parse(strinpBOM(cntent));</span><br><span class="line">	&#125;catch(err)&#123;</span><br><span class="line">		err.message = filename + &apos;:&apos; + err.message;</span><br><span class="line">		throw err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，Module._extensions会被赋值给 require() 的extensions属性，所以通过在代码中访问require.extensions可知道系统中已有的加载方式。编写代码测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//新建index.js文件</span><br><span class="line">console.log(require.extensions);</span><br><span class="line">//运行node index.js,输出</span><br><span class="line">//[Object: null prototype] &#123; &apos;.js&apos;: [Function], &apos;.json&apos;: [Function], &apos;.node&apos;: [Function] &#125;</span><br></pre></td></tr></table></figure>

<p>如果想对自定义的扩展名进行特殊的加载，可以通过类似require.extensions[‘.ext’]的方式实现。早期的CoffeeScript文件就是通过添加require.extensions[‘.coffee’]扩展方式来加载的。但是从v0.10.6版本开始，官方不鼓励通过这种方式进行自定义扩展名的加载，而是期望先将其它语言或文件先编译成js文件后再进行加载，这样做的好处是不将繁琐的编译加载等过程引入node的执行过程。</p>
<p>在确定文件的扩展名后，node将调用具体的编译方式来将文件执行后返回给调用者。</p>
<p>注：我们都知道CommonJS模块规范中，每个模块文件都存在<code>require、exports、module、_filename、_dirname</code>这5个变量却不知其从何而来。若是把直接定义模块的过程放在浏览器端，势必会存在污染全局变量的情况，故其不可能。</p>
<p>事实上，在编译过程中，node会对获取的js文件内容进行包装，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function(require、exports、module、_filename、_dirname)&#123;</span><br><span class="line">	var math = require(&apos;math&apos;);</span><br><span class="line">	exports.area = function(radius)&#123;</span><br><span class="line">		return Math.PI * radius * radius;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样每个模块文件之间都进行了作用于隔离。包装之后的代码会通过vm原生模块的runInThisContext() 方法执行，类似于eval，只是具有明确上下文，不污染全局，返回一个体的function对象。最后，将当前模块对象的exports属性，require()方法，module(模块对象本身)，以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。</p>
<p>这就是为什么这些变量并没有在每个模块声明却可以使用的原因。在执行后，模块的exports属性被返回给了调用方。exports属性上的任何方法都可以被外部调用到，但是模块中的其余变量和属性则不可直接被调用。</p>
<p>至此，require、exports、module的流程已经完整，这就是Node对CommonJS模块规范的实现。</p>
<p><strong>JSON文件的编译</strong></p>
<p>json文件的编译是三种编译方式中最简单的。Node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse（）方法得到对象，然后将它赋给模块对象的exports，以供外部调用。</p>
<p>JSON文件在用作项目的配置文件时比较有用。如果你定义了JSON文件作为配置，那就不用调用fs模块去异步读取和解析，直接调用require（）引入即可。此外，你还可以享受到模块缓存的便利，并且二次引入时也没有性能影响。</p>
<p>这里我们提到的模块编译都是指文件编译，即用户自己编写的模块。</p>
<h6 id="内建模块"><a href="#内建模块" class="headerlink" title="内建模块"></a>内建模块</h6><p>内建模块的优势在于：首先，他们本身由C/C++编写，性能上优于脚本语言；其次，其次，在进行文件编译时，他们会被编译进二进制文件。一旦node开始执行，他们会被直接加载进内存中，无需再次坐标识符定位、文件定位、编译等过程，直接就可执行。</p>
<p>Node在启动时，会生成一个全局变量process，并提供Binding()方法来协助加载内建模块。</p>
<p>在加载内建模块时，我们会先创建一个exports空对象，然后调用get_builtin_module（）方法取出内建模块对象，通过执行register_func()填充exports对象，最后将exports对象按模块名缓存，并返回给调用方完成导出。</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2020/04/30/node进阶/">node进阶</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">陈楚吟</a></p>
        <p><span>发布时间:</span>2020-04-30, 10:30:22</p>
        <p><span>最后更新:</span>2020-06-17, 15:58:43</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2020/04/30/node进阶/" title="node进阶">http://yoursite.com/2020/04/30/node进阶/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2020/04/30/node进阶/　　作者: 陈楚吟" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2020/04/30/AJAX学习/">
                    AJAX学习
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2020/04/30/http进阶/">
                    http进阶
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#单线程的弱点"><span class="toc-number">1.</span> <span class="toc-text">单线程的弱点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#node简介"><span class="toc-number">2.</span> <span class="toc-text">node简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#node-js组成部分"><span class="toc-number">3.</span> <span class="toc-text">node.js组成部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#npm包管理器"><span class="toc-number">4.</span> <span class="toc-text">npm包管理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NPM常用命令"><span class="toc-number">5.</span> <span class="toc-text">NPM常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#REPL交互式解释器"><span class="toc-number">6.</span> <span class="toc-text">REPL交互式解释器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#node知识"><span class="toc-number">7.</span> <span class="toc-text">node知识</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#node-js与其它语言的区别"><span class="toc-number">7.0.1.</span> <span class="toc-text">node.js与其它语言的区别</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#node-js的特点（追求极致性能）"><span class="toc-number">7.0.2.</span> <span class="toc-text">node.js的特点（追求极致性能）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#node事件触发"><span class="toc-number">7.0.3.</span> <span class="toc-text">node事件触发</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#node-js应用方向"><span class="toc-number">7.0.4.</span> <span class="toc-text">node.js应用方向</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#node模块化"><span class="toc-number">8.</span> <span class="toc-text">node模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#node核心模块"><span class="toc-number">8.0.1.</span> <span class="toc-text">node核心模块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer缓存区"><span class="toc-number">9.</span> <span class="toc-text">Buffer缓存区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fs文件处理"><span class="toc-number">10.</span> <span class="toc-text">fs文件处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库"><span class="toc-number">11.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#MongoDB"><span class="toc-number">11.0.1.</span> <span class="toc-text">MongoDB</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步与异步，阻塞与非阻塞"><span class="toc-number">12.</span> <span class="toc-text">同步与异步，阻塞与非阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#url相关操作"><span class="toc-number">13.</span> <span class="toc-text">url相关操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#上传文件"><span class="toc-number">14.</span> <span class="toc-text">上传文件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#使用第三方插件"><span class="toc-number">14.0.1.</span> <span class="toc-text">使用第三方插件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模块编译"><span class="toc-number">15.</span> <span class="toc-text">模块编译</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#内建模块"><span class="toc-number">15.0.1.</span> <span class="toc-text">内建模块</span></a></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"node进阶　| Nikita　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2020/04/30/AJAX学习/" title="上一篇: AJAX学习">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2020/04/30/http进阶/" title="下一篇: http进阶">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/数组中的reduce/">数组中的reduce</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/23/‘力扣简单题’/">‘力扣简单题’</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/vue小技巧/">vue小技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/vue的面试/">vue的面试</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/18/学习vuex/">学习vuex</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/同源策略/">同源策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/typescript/">typescript</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/jquery/">jquery</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/js动画篇/">js动画篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/js精研/">js精研</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/js基础/">js基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/13/刷题笔记/">刷题笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/11/前端cookie解读/">前端cookie解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/04/前端经验/">前端经验</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/22/linux学习/">linux学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/10/pandas之excel/">pandas之excel</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/09/HTML5和CSS3/">HTML5和CSS3</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/08/爬虫/">爬虫</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/07/python的学习/">python的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/30/AJAX学习/">AJAX学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/30/node进阶/">node进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/30/http进阶/">http进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/ES6的学习/">ES6的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/vue学习中的问题/">vue学习中的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/27/计算机网络/">计算机网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/27/数据结构与算法/">数据结构与算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/07/前端面试/">前端面试</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/06/http的学习/">http的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/课程表制作/">课程表制作</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/CSS3/">CSS3</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/Grid布局/">Grid布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/CSS3高阶/">CSS3高阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/HTML5基础下-陈楚吟/">HTML5基础下--陈楚吟</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/HTML5基础上-陈楚吟/">HTML5基础上-陈楚吟</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/深入理解css/">深入理解css</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/26/选择器/">选择器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/vue学习三/">vue学习三</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/vue学习二/">vue学习二</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/vue学习一/">vue学习一</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/浅谈canvas和相关实战/">浅谈canvas和相关实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/setTimeout与setInterval区别/">setTimeout与setInterval区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/js中callee和caller/">js中callee和caller</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/10/行内元素存在间距问题/">行内元素存在间距问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/09/canvas绘制碰撞球动画/">canvas绘制碰撞球动画</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/27/用JavaScript封装栈/">用JavaScript封装栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/26/伪类与伪元素的区区别/">伪类与伪元素的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/17/深入理解包与NPM和package-json深入解读/">深入理解包与NPMM,package.json深入解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/15/JS中外部文件的优势-1/">JS中外部文件的优势</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/03/vue进阶/">vue进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/27/webpack学习/">webpack学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/15/攻克object对象/">攻克object对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/15/qq小程序天坑之旅/">qq小程序天坑之旅</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/27/proto/">proto</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/26/项目开发流程/">项目开发流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/25/事件机制/">事件机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/17/MVVC模型架构/">MVVC模型架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/15/js执行上下文/">js执行上下文</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/15/js中的立即执行函数/">js中的立即执行函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/14/js中的闭包/">js中的闭包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/14/了解浏览器/">了解浏览器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/13/我认识的js原型及原型链/">我认识的js原型及原型链</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/12/深入理解js中的this/">深入理解js中的this</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/12/相对全面的数组/">相对全面的数组去重</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/11/css盒模型集锦/">css盒模型集锦</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2020 陈楚吟
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>